(*
	name: test
	descr: Libraries for strato machines (Macotec M-series machines)
	version: 0.5.0
	author: MG
	dependencies: Common.pll, defvar.pll, iomap.pll, messages.pll

	global-variables: 15
	functions: 2
	function blocks: 65
	programs: 5
	macros: 3
	structs: 1
	typedefs: 1
	enums: 2
*)



	(****************************)
	(*                          *)
	(*     GLOBAL VARIABLES     *)
	(*                          *)
	(****************************)


	VAR_GLOBAL
	{G:"Common"}
	Mach : fbMachine; { DE:"Machine status logic" }
	InitTask : fbInitTask; { DE:"Initialize machine" }
	MachSettings : fbMachSettings; { DE:"Load machine parameters" }
	ParDefaults : fbParDefaults; { DE:"Load user parameters default" }
	{G:"Calculations"}
	GuessSheetSize : fbGuessSheetSize; { DE:"Indovina dimensioni lastra da fotocellule" }
	GuessSheetPos : fbGuessSheetPos; { DE:"Indovina posizione lastra da fotocellule" }
	{G:"Strato"}
	Scu : fbSafety; { DE:"Safety unit" }
	CtrlBoard : fbCtrlBoard; { DE:"Pulpito di comando" }
	Hmi : fbHmi; { DE:"Interazione con interfaccia utente" }
	JobData : fbJobData; { DE:"Dati e argomenti della lavorazione" }
	StepSeq : fbStepSeq; { DE:"Sequenza del passo di lavorazione" }
	{G:"Shared_resources"}
	PowerSource : INT; { DE:"Alimentazione elettrica, evitare sovraccarichi" }
	UpperCutZone : INT; { DE:"Spazio sopra il piano nell'area di taglio (carr sup)" }
	LowerCutZone_Dtch : INT; { DE:"Spazio sotto il piano nell'area di taglio lato stacco (carr inf)" }
	LowerCutZone_Algn : INT; { DE:"Spazio sotto il piano nell'area di taglio lato risc (lamp)" }
	END_VAR



	(*********************)
	(*                   *)
	(*     FUNCTIONS     *)
	(*                   *)
	(*********************)



FUNCTION fnRotated90 : BOOL

	VAR_INPUT
	Rot : INT; { DE:"Rotation in multiple of [90 deg]" }
	END_VAR

	{ CODE:ST }(*   Tells if is rotated
    ----------------------------------------------

    OVERVIEW
    ----------------------------------------------
    Tells if this rotation in multiple of 90°
    involves an actual rotation or not.
    Rotations of k·180° doesn't involve an actual
    90° rotation.
*)
fnRotated90 := MOD(Rot,2)<>0;

END_FUNCTION




FUNCTION fnYg : LREAL

	VAR_INPUT
	a : LREAL; { DE:"Angle [rad]" }
	yo : LREAL; { DE:"Lower vertex ordinate [mm]" }
	d : LREAL; { DE:"Grab point to lower vertex distance [mm]" }
	END_VAR

	{ CODE:ST }(*   Returns a position in [mm]
    ----------------------------------------------

    OVERVIEW
    ----------------------------------------------
    Calculates the profile of the grab point
    ordinate respect the rotation angle.
    Returns a position in [mm].

    DETAILS
    ----------------------------------------------
    Il profilo dell'ordinata di presa:
    yg(a) = yo(a) + d·cosa
*)

fnYg := yo + d * COS(a);

END_FUNCTION




	(***************************)
	(*                         *)
	(*     FUNCTION BLOCKS     *)
	(*                         *)
	(***************************)



FUNCTION_BLOCK fbYo

{ DE:"Calcolo profilo ordinata vertice basso rotazione riscontro" }

	VAR_INPUT
	a : LREAL; { DE:"Current angle [rad]" }
	w1 : LREAL; { DE:"Angular frequency of first interval" }
	w2 : LREAL; { DE:"Angular frequency of second interval" }
	ai : LREAL; { DE:"Initial angle [rad]" }
	acr : LREAL; { DE:"Intermediate point angle [rad]" }
	af : LREAL; { DE:"Final angle [rad]" }
	yoi : LREAL; { DE:"Initial point [mm]" }
	yocr : LREAL; { DE:"Intermediate point [mm]" }
	yof : LREAL; { DE:"Final point [mm]" }
	END_VAR

	VAR_OUTPUT
	value : LREAL; { DE:"Calculated ordinate of lower vertex" }
	END_VAR

	{ CODE:ST }(*

    OVERVIEW
    ----------------------------------------------
    Definisce il profilo desiderato da imprimere
    all'ordinata del vertice basso nelle rotazioni
    lato riscontro.
    Il vertice basso è quello a rischio di collisione
    con le rotelle di riferimento basse.

    DETAILS
    ----------------------------------------------
    Date le ordinate iniziale e finale desiderate
    yoi, yof corridpondenti agli angoli ai e af,
    potrebbe essere lineare:
    yo(a) = (yof-yoi)·(a-ai)/(af-ai) + yoi
          = m·a + q , m=(yof-yoi)/(af-ai), q=yoi-m·ai
    Oppure armonico:
    yo(a) = (yof-yoi)·sin[π/2·(a-ai)/(af-ai)] + yoi
          = A·sin[w·(a-ai)] + C
    Dato un valore intermedio desiderato yocr
    corrispondente ad un'angolo ai<acr<af, potremmo
    definire il profilo armonico a tratti:
    yo(a) = (yocr-yoi)·sin[π/2·(a-ai)/(acr-ai)] + yoi, a≤acr
    yo(a) = (yocr-yof)·sin[π/2·(a-af)/(acr-af)] + yof, a>acr
    Che si riduce al profilo armonico originale ponendo
    acr=af, yocr=yof

    CONTRACT
    ----------------------------------------------
    Inizializzare: Yo.ai, Yo.acr, Yo.af, Yo.yoi, Yo.yocr, Yo.yof
    Calcolare: Yo.w1 := PI_2 / (acr-ai);
               Yo.w2 := PI_2 / (acr-af);
*)

IF a <= acr THEN
    value := (yocr-yoi) * SIN(w1*(a-ai)) + yoi;
ELSE
    value := (yocr-yof) * SIN(w2*(a-af)) + yof;
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbXp

{ DE:"Calcolo ascissa piedino ausiliario X per rotazioni riscontro" }

	VAR_INPUT
	a : LREAL; { DE:"Current angle [rad]" }
	yo : LREAL; { DE:"Lower vertex ordinate [mm]" }
	d : LREAL; { DE:"Grab point to lower vertex distance [mm]" }
	Yp : LREAL; { DE:"Fixed ordinate of the block [mm]" }
	Rp : LREAL; { DE:"Radius of the block [mm]" }
	END_VAR

	VAR_OUTPUT
	value : LREAL; { DE:"Ultimo valore calcolato [mm]" }
	END_VAR

	VAR CONSTANT
	amax : LREAL := 1.562; { DE:"Angolo massimo [rad]" }
	END_VAR

	{ CODE:ST }(*

    OVERVIEW
    ----------------------------------------------
    Calculates the profile of the auxiliary X
    block for alignment side rotations respect
    the rotation angle.
    Returns a position in [mm].

    DETAILS
    ----------------------------------------------
    Si riferisce all'ascissa del punto di intersez
    tra il bordo del vetro e la retta y=Yp.
    Tiene conto del punto di contatto effettivo
    considerando piedino circolare di raggio Rp.
    xp(a) = Xg + d·sina + [yo(a)-Yp]·tga + (1-1/cosa)·Rp
    Il lato di appoggio non potrà mai abbassarsi
    del tutto sotto l'ordinata del piedino Yp.
    Considero l'ascissa di presa Xg nulla.
    Non ha senso che la posizione del piedino
    superi il bordo lastra, che alla fine è in d.

    CONTRACT
    ----------------------------------------------
    Usato solo per rotazioni complete di lastre
    grosse lato riscontro, quindi (a = 0,...,π/2)
    Fallisce per a=(2k+1)π/2 !!
    Se Lp è la corsa, potrebbe essere:
        Amax := PI_2 - ATAN2( Rp, Lp );
*)
IF a<=amax AND value<d THEN
    value := (* Xg==0 + *) d * SIN(a) + (yo-Yp) * TAN(a) + (1.0 - 1.0/COS(a)) * Rp;
(* Mi serve un meccanismo per riarmare il valore saturato: *)
ELSIF a<0.01 THEN
    value := 0.0;
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbInitTask

{ DE:"Initialize machine" }

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	EraseArray : fbEraseArray; { DE:"Inizializzazione array globale" }
	vqSwVer : DINT; { DE:"Versione definizioni" }
	MachSettings : fbMachSettings; { DE:"Load machine parameters" }
	vbMachSettings : BOOL; { DE:"Lettura effettuata" }
	Watch : fbWatch; { DE:"Orologio di sistema" }
	vnPlcYear : INT; { DE:"Anno" }
	vnPlcMonth : INT; { DE:"Mese" }
	vnPlcDay : INT; { DE:"Giorno nel mese" }
	vnPlcHour : INT; { DE:"Ora" }
	vnPlcMinutes : INT; { DE:"Minuti" }
	vnPlcSeconds : INT; { DE:"Secondi" }
	vqBootsCount : DINT; { DE:"Contatore avvii macchina (see also 'vdBootDate')" }
	vdBootDate : LREAL; { DE:"Date of last boot" }
	vbExpired : BOOL; { DE:"Manutenzione programmata" }
	vdExpDate : LREAL; { DE:"Expiration date of scheduled maintenance" }
	vqExpBoots : DINT; { DE:"Boots for scheduled maintenance expiration (see also 'vdExpDate')" }
	vbRstSvcs : BOOL; { DE:"Reset subsystems commands/services" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vbSlantMode : BOOL; { DE:"Macchina in modalità taglio fuori squadra" }
	vbShapeMode : BOOL; { DE:"Macchina in modalità sagomato curvilineo" }
	ICM_TILTOUT_AUTO : BOOL; { DE:"Selettore modalità automatica ribaltina scarico pezzi" }
	vqWorkSettings : DINT; { DE:"Selettori ritentivi di lavorazione" }
	END_VAR

	{ CODE:ST }(*    fbInitTask (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Executed one at PLC start
      Typically called in PROGRAM Init

      NOTES
      ----------------------------------------------
      Il reboot software dell'M32 è piuttosto
      problematico, per questo è bene spostare
      le inizializzazioni più importanti nel
      task normale
*)

dlog( Txt:='_', Lvl:=0);
dlog( Txt:='-> PLC Init defvar ver.%d', Lvl:=0, Val1:=TO_DINT(SW_VER) );

(* Versione software *)
vqSwVer := TO_DINT(1000.0 * SW_VER);


(* -- Reset buffers I/O digitali -- *)
EraseArray( Type:=TYP_VB, Idx:=ivbDinBuffer, Size:=DIN_BUF_SIZE );
EraseArray( Type:=TYP_VB, Idx:=ivbDoutBuffer, Size:=DOUT_BUF_SIZE );
(* -Inizializzazione ingressi- *)
ICM_TILTOUT_AUTO := (vqWorkSettings & BIT_AUTOTILTOUT)<>0;


(* -- Reset buffer messaggi -- *)
EraseArray( Type:=TYP_VB, Idx:=ivbMsgs, Size:=MAX_MESSAGES );
EraseArray( Type:=TYP_VQ, Idx:=ivqMsgsPars, Size:=MAX_MESSAGES );
(* vqRequestActive := 0; *)
SET_MSG(MSG_BOOTING,'MSG_BOOTING',0);


(* -- Servizi vari -- *)
vbRstSvcs := TRUE;


(* -- Statistiche e controlli all'avvio --*)
(* Informazioni sull'avvio *)
vqBootsCount := vqBootsCount + 1; (* Contatore avvii *)
Watch( Act:=1 ); (* Read watch *)
vdBootDate := fnDateTime(Year:=vnPlcYear, Month:=vnPlcMonth, Day:=vnPlcDay, Hour:=vnPlcHour, Mins:=vnPlcMinutes, Secs:=vnPlcSeconds);
(* Detect scheduled maintenance *)
vbExpired := (vdExpDate>0.0 AND vdBootDate>=vdExpDate) OR (vqExpBoots>0 AND vqBootsCount>=vqExpBoots);


(* -- Inizializzazione stati -- *)
vbAutoMode := FALSE;
vbSlantMode := FALSE;
vbShapeMode := FALSE;


(* -- Richiedi subito il caricamento dei settaggi macchina --
   Aspetterò il completamento nel ciclo principale *)
vbMachSettings := FALSE; (* Meglio inizializzarlo, in caso di hot boot *)
MachSettings.Load := TRUE;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbRoomFit

{ DE:"Inserisci un corpo in una serie di rette" }

	VAR_IN_OUT
	y : DINT; { DE:"Initial/found coordinate [um]" }
	END_VAR

	VAR_INPUT
	dwn : BOOL; { DE:"Search direction" }
	rp : DINT; { DE:"Room sup for collision check [um]" }
	rm : DINT; { DE:"Room inf for collision check [um]" }
	iYb : INT; { DE:"Y coordinates array index" }
	N : INT; { DE:"Y coordinates number" }
	END_VAR

	VAR_OUTPUT
	ib : INT; { DE:"Colliding block index" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	END_VAR

	{ CODE:ST }(*

    OVERVIEW
    ----------------------------------------------
    Starting from a maximum (minimum) position (y)
    of a body of room rp-rm (centered in y) and
    given an ordinate array (Y₁,Y₂,... ), find the
    highest (lowest) y that fits the body in the
    ordinates array without colliding with them.
         ▴
       y │             _ _ _ _ _ y (initial)
         │            ■==== Y₃
         │   _ rp ↕╔═╗ _ _ _ _ _ y (found)
         │     rm ↕╚═╝
         │            ■==== Y₂
         │            ■==== Y₁
         ┼──────────────────────────────▸
*)
dlog( Txt:='fbRoomFit: y=%ld room=%ld|%ld dwn:%d', Lvl:=5, Val1:=y/1E3, Val2:=rm/1E3, Val3:=rp/1E3, Val4:=TO_DINT(dwn) );
(* Nota: l'ingombro del corpo è dato da (y+rm) e (y+rp) *)

IF dwn THEN
    (* Parto da y e cerco verso il basso *)
    ib := N; (* Trovo il primo piedino alto che collide *)
    WHILE ib > INT#0 DO
        IF vq[iYb+ib] < (y+rm) THEN
            (* Questo piedino è sotto, ci sto dentro *)
            dlog( Txt:='Ok y=%ld (%ld|%ld)', Lvl:=5, Val1:=y/1E3, Val2:=(y+rm)/1E3, Val3:=(y+rp)/1E3 );
            IF ib=N THEN ib := INT#0; END_IF; (* Se stavo considerando il primo, nessun piedino collide *)
            RETURN;
        ELSIF vq[iYb+ib] < (y+rp) THEN
            (* Questo piedino collide! *)
            dlog( Txt:='blk%d hits %ld|%ld, moving under %ld', Lvl:=5, Val1:=TO_DINT(ib), Val2:=(y+rm)/1E3, Val3:=(y+rp)/1E3, Val4:=vq[iYb+ib]/1E3 );
            (* Sposto il corpo sotto questo piedino *)
            y := vq[iYb+ib] - rp;
            (* Se non c'è un piedino sotto, accetto la posizione? * )
            IF ib=INT#1 THEN
                dlog( Txt:='Ok y=%ld (%ld|%ld) min', Lvl:=5, Val1:=y/1E3, Val2:=(y+rm)/1E3, Val3:=(y+rp)/1E3 );
                RETURN;
            END_IF; *)
            (* No, non accetto di stare sotto l'ultimo piedino *)
        (* ELSE (* Il piedino è sopra e non collide, procedo a controllare quello sotto *)
        END_IF;
        ib := ib - INT#1; (* Next down *)
    END_WHILE;
ELSE
    (* Parto da y e cerco verso l'alto *)
    ib := INT#1; (* Trovo il primo piedino basso che collide *)
    WHILE ib <= N DO
        IF vq[iYb+ib] > (y+rp) THEN
            (* Questo piedino è sopra, ci sto dentro *)
            dlog( Txt:='Ok y=%ld (%ld|%ld)', Lvl:=5, Val1:=y/1E3, Val2:=(y+rm)/1E3, Val3:=(y+rp)/1E3 );
            IF ib=INT#1 THEN ib := INT#0; END_IF; (* Se stavo considerando il primo, nessun piedino collide *)
            RETURN;
        ELSIF vq[iYb+ib] > (y+rm) THEN
            (* Questo piedino collide! *)
            dlog( Txt:='blk%d at %ld hits %ld|%ld', Lvl:=5, Val1:=TO_DINT(ib), Val2:=vq[iYb+ib]/1E3, Val3:=(y+rm)/1E3, Val4:=(y+rp)/1E3 );
            (* Sposto il corpo sopra questo piedino *)
            y := vq[iYb+ib] - rm;
            (* Se non c'è un piedino sopra, accetto la posizione *)
            IF ib=N THEN
                dlog( Txt:='Ok y=%ld (%ld|%ld) max', Lvl:=5, Val1:=y/1E3, Val2:=(y+rm)/1E3, Val3:=(y+rp)/1E3 );
                RETURN;
            END_IF;
        (* ELSE (* Il piedino è sotto e non collide, procedo a controllare quello sopra *)
        END_IF;
        ib := ib + INT#1; (* Next up *)
    END_WHILE;
END_IF;

(* Se sono qui i piedini sono finiti, il corpo è troppo grosso *)
dlog( Txt:='!! No fit found (y=%ld %ld|%ld, blk%d)', Lvl:=2, Val1:=y/1E3, Val2:=(y+rm)/1E3, Val3:=(y+rp)/1E3, Val4:=TO_DINT(ib) );
y := NO_POS_UM; (* Ordinata non trovata *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbCalcRotAlgn

{ DE:"Calcoli per rotazione lato riscontro con pinza" }

	VAR_INPUT
	What : INT; { DE:"Argomento rotazione (ROTARG_INCOMING, ...)" }
	END_VAR

	VAR_OUTPUT
	Ok : BOOL; { DE:"Rotazione fattibile" }
	Big : BOOL; { DE:"Vetro grosso, la presa va scelta per evitare collisioni" }
	Y2Coll : DINT; { DE:"Ordinata vertice alto in corrispondenza di collisione spalla [um]" }
	TgtYbtm : DINT; { DE:"Posizione Y desiderata del bordo sotto della lastra ruotata [um]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	vqGrab_GlassWidth : DINT; { DE:"Larghezza iniziale lastra da ruotare [um]" }
	vqGrab_GlassYbtm : DINT; { DE:"Ordinata bordo passo iniziale lastra da ruotare [um]" }
	vqGrab_GlassYtop : DINT; { DE:"Ordinata bordo alto iniziale lastra da ruotare [um]" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqGrab_Agrab : DINT; { DE:"Angolo di presa [mdeg]" }
	vqGrab_Arot : DINT; { DE:"Angolo relativo di rotazione [mdeg]" }
	vqGrab_Ygrab : DINT; { DE:"Quota di presa [um]" }
	vqGrab_Yc_pre : DINT; { DE:"Quota a cui portare la presa della lastra agguantata prima della rotazione [um]" }
	vqGrab_Yc_post : DINT; { DE:"Quota a cui portare la presa della lastra agguantata dopo la rotazione [um]" }
	vnSheetType : INT; { DE:"Tipologia materiale" }
	vbWillTiltOutPiece : BOOL; { DE:"Almeno un pezzo sarà mandato alla ribaltina" }
	vbGrab_RotWithBlock : BOOL; { DE:"Rotazione con aiuto piedino" }
	vqRot_Diag : DINT; { DE:"Diagonale lastra in rotazione [um]" }
	vqRot_Xmin : DINT; { DE:"Ingombro rotazione: X minimo [um]" }
	vqRot_Xmax : DINT; { DE:"Ingombro rotazione: X massimo [um]" }
	vqRot_Ymin : DINT; { DE:"Ingombro rotazione: Y minimo [um]" }
	vqRot_Ymax : DINT; { DE:"Ingombro rotazione: Y massimo [um]" }
	Yo : fbYo; { DE:"Profilo ordinata vertice basso per rotazioni" }
	Xp : fbXp; { DE:"Profilo ascissa piedino ausiliario X per rotazioni" }
	vnGrabber_Type : INT; { DE:"Tipo girapezzi (0:none 1:ventosa 2:pinza)" }
	vqGrab_MaxGlassThckn : DINT; { DE:"Spessore complessivo massimo agguantabile da pinza [um]" }
	vqGrab_MinFloatThckn : DINT; { DE:"Minimo spessore monolitico ruotabile automaticamente [um]" }
	vqRot_MaxLeanOut : DINT; { DE:"Massima sporgenza vetro fuori dal tavolo ammessa [um]" }
	vqRotProc_DiagMax : DINT; { DE:"Massima diagonale ruotabile [um]" }
	vqRotAlgn_WidthMax : DINT; { DE:"Massima larghezza ruotabile lato riscontro [um]" }
	vqRotAlgn_HeightMax : DINT; { DE:"Massima altezza ruotabile lato riscontro [um]" }
	vqRotNoBlk_MassMax : DINT; { DE:"Soglia massa ruotabile senza piedino [g]" }
	vqRotAlgn_WidthMin : DINT; { DE:"Larghezza minima da ruotare automaticamente lato riscontro [um]" }
	vqShift_GoodWidth : DINT; { DE:"Larghezza minima traslabile su riscontri senza avvicinam stacco [um]" }
	vqFallWidth : DINT; { DE:"Larghezza critica pericolo caduta vetro [um]" }
	vqFallBck0MinWidth : DINT; { DE:"Minima larghezza per riscontrare a zero il bordo indietro [um]" }
	vbFeat_AlgnHasBelts : BOOL; { DE:"Riscontri provvisti di cinghie (non i rulli)" }
	vqGrabber_Radius : DINT; { DE:"Raggio pinza girapezzi [um]" }
	vqGrab_YroomSafeMrg : DINT; { DE:"Margine di sicurezza su ingombro Y carrello inferiore per posizioni presa [um]" }
	vqGrab_YroomMSafeSpc : DINT; { DE:"Spazio aggiuntivo prevenzione collisioni con piedino riscontro sottostante [um]" }
	vqGrab_RotMargin : DINT; { DE:"Margine area rotazioni [um]" }
	vqGrab_MinRotTail : DINT; { DE:"Margine minimo alto del punto di presa (coda dopo rotazione) [um]" }
	vqVGrab_Ygrab : DINT; { DE:"Quota di presa assoluta della ventosa [um]" }
	vqGrabber_DX : DINT; { DE:"Ascissa dell'asse di rotazione del girapezzi [um]" }
	vqRotAlgn_UseBlockHmin : DINT; { DE:"Altezza minima per utilizzo piedino [um]" }
	vqRotAlgn_UseBlockWmin : DINT; { DE:"Larghezza minima per utilizzo piedino [um]" }
	vqGrabber_DY : DINT; { DE:"Offset Y centro girapezzi [um]" }
	vqECarrInf_Length : DINT; { DE:"Dimensione traino inferiore [um]" }
	vqCarrInf_DYroomP : DINT; { DE:"Ingombro Y (avanti) corpo carrello inferiore um]" }
	vqCarrInf_DYroomM : DINT; { DE:"Ingombro Y (indietro) corpo carrello inferiore [um]" }
	vqX_CollTopAlgn : DINT; { DE:"X punto collisione carpenteria in alto lato riscontri [um]" }
	vqY_CollTopAlgn : DINT; { DE:"Y punto collisione carpenteria in alto lato riscontri [um]" }
	vqX_CollTopDtch : DINT; { DE:"X punto collisione carpenteria in alto lato stacco [um]" }
	vqY_CollTopDtch : DINT; { DE:"Y punto collisione carpenteria in alto lato stacco [um]" }
	vqRotGrab_Xinf : DINT; { DE:"Area disponibile rotazione con pinza: X minimo [um]" }
	vqRotGrab_Xsup : DINT; { DE:"Area disponibile rotazione con pinza: X massimo [um]" }
	vqRotGrab_Yinf : DINT; { DE:"Area disponibile rotazione con pinza: Y minimo [um]" }
	vqRotGrab_Ysup : DINT; { DE:"Area disponibile rotazione con pinza: Y massimo [um]" }
	vbNextStep_Valid : BOOL; { DE:"Passo successivo valido" }
	vqNextStep_FirstAlgn : DINT; { DE:"Prossima quota riscontri (per rotazione o processazione) [um]" }
	CalcAlgnDelta : fbCalcAlgnDelta; { DE:"Calcola delta riscontro" }
	vqYo_SheetFeed : DINT; { DE:"Ordinata tipica della lastra in arrivo dal carico [um]" }
	vqYph_DtchLast : DINT; { DE:"Ordinata ultima fotocellula su stacco [um]" }
	ivqAlgnBlks_Y : INT; { DE:"Accesso alle ordinate dei piedini di riscontro" }
	vnAlgnBlk_AuxRot : INT; { DE:"Indice piedino per ausilio rotazioni lato riscontro" }
	vqAlgnBlkRot_R : DINT; { DE:"Raggio del primo piedino di riscontro (aiuto rotazione) [um]" }
	vqAlgnBlkRot_Dy : DINT; { DE:"Scostamento Y del piedino di aiuto rotazione [um]" }
	vqAlgnBlk_YMargin : DINT; { DE:"Margine per piedini di riscontro [um]" }
	vqAlgnBlks_R : DINT; { DE:"Raggio dei piedini di riscontro [um]" }
	vnAlgnBlks_N : INT; { DE:"Numero dei piedini di riscontro" }
	ivqTiltOutArms_Y : INT; { DE:"Accesso alle ordinate delle braccia ribaltina" }
	vnTiltOutArms_N : INT; { DE:"Numero delle braccia ribaltina" }
	END_VAR

	VAR
	YroomFit : fbRoomFit; { DE:"Posiziona un ingombro in Y tra i riscontri" }
	H : DINT; { DE:"Altezza lastra in posizione iniziale [um]" }
	M : DINT; { DE:"Temporaneo [g]" }
	END_VAR

	{ CODE:ST }(*    fbCalcRotAlgn (Strato M-series)
    ----------------------------------------------

    OVERVIEW
    ----------------------------------------------
    Calcoli relativi alla rotazione piena 0-90
    lato riscontro con pinza, relativamente alla
    quale si implementa:
      .Fattibilità rotazione
      .Calcolo dell'area di rotazione
      .Determinazione ottima del punto di presa 'vqGrab_Ygrab'
      .Scelta della posizione Y del pezzo ruotato
      .Calcolo dei profili delle camme della rotazione

    DETAILS
    ----------------------------------------------
    Questo blocco riguarda i calcoli relativi alle
    rotazioni del vetro con pinza.
    Le rotazioni si possono classificare in:
      .Rotazione generica
      .Rotazione lato riscontro (da 0° a 90°)
      .Rotazione lato stacco (da 180° a 90°)
    Il profilo delle camme è calcolato con i
    seguenti criteri:
      .Per rotazioni con pericolo di ingombro
       in corrispondenza dell'angolo critico
       (diagonale verticale) il vertice basso
       deve essere al limite inferiore dell'area
       consentita, la posizione finale deve
       essere compatibile col piedino di aiuto
       rotazione
      .Per rotazioni di pezzi più piccoli,
       la posizione finale deve essere tale
       da rendere il pezzo riscontrabile/
       ribaltabile
    I profili sono definiti con due tratti,
    in modo da controllare l'angolo corrispondente
    al minimo del vertice basso.
*)

Ok := FALSE; (* Default: non fattibile *)

(* Assumo valorizzati gli argomenti:
   vqGrab_GlassWidth, vqGrab_GlassYbtm, vqGrab_GlassYtop, vqGrab_Ygrab, vqGrab_Agrab, vqGrab_Arot *)

(* Calcolo la diagonale della lastra da ruotare *)
H := vqGrab_GlassYtop - vqGrab_GlassYbtm;
vqRot_Diag := fnLength_DINT(vqGrab_GlassWidth, H);

dlog( Txt:='fbCalcRotAlgn: %ldx%ld Ybtm=%ld What=%d', Lvl:=5, Val1:=vqGrab_GlassWidth/1E3, Val2:=H/1E3, Val3:=vqGrab_GlassYbtm/1E3, Val4:=TO_DINT(What) );

(* Primi controlli *)
(* La posizione Y della lastra deve essere nota *)
IF vqGrab_GlassYbtm>=vqGrab_GlassYtop OR vqGrab_GlassYbtm=NO_POS_UM OR vqGrab_GlassYtop=NO_POS_UM THEN
    dlog( Txt:='!! Unknown Y', Lvl:=2 );
    RETURN;
(* Lo spessore deve essere agguantabile dalla pinza *)
ELSIF vqGlass_Thckn>vqGrab_MaxGlassThckn THEN
    dlog( Txt:='!! Thick sheet %ld > %ld mm not grabbable', Lvl:=1, Val1:=vqGlass_Thckn/1E3, Val2:=vqGrab_MaxGlassThckn/1E3 );
    RETURN;
(* Se vetro monolitico lo spessore non deve essere troppo piccolo *)
ELSIF (vnSheetType & BIT_STRATO)=0 AND vqGlass_Thckn<vqGrab_MinFloatThckn THEN
    dlog( Txt:='!! Wont rotate float %ld < %ld mm', Lvl:=1, Val1:=vqGlass_Thckn/1E3, Val2:=vqGrab_MinFloatThckn/1E3 );
    RETURN;
(* Controllo dimensioni e diagonale massima *)
ELSIF vqRot_Diag > vqRotProc_DiagMax THEN
    dlog( Txt:='!! Rot limit diag=%ld > %ld mm', Lvl:=2, Val1:=vqRot_Diag/1E3, Val2:=vqRotProc_DiagMax/1E3 );
    RETURN;
ELSIF H > vqRotAlgn_HeightMax THEN
    dlog( Txt:='!! Rot limit H=%ld > %ld mm', Lvl:=2, Val1:=H/1E3, Val2:=vqRotAlgn_HeightMax/1E3 );
    RETURN;
ELSIF vqGrab_GlassWidth > vqRotAlgn_WidthMax THEN
    dlog( Txt:='!! Rot limit W=%ld > %ld mm', Lvl:=2, Val1:=vqGrab_GlassWidth/1E3, Val2:=vqRotAlgn_WidthMax/1E3 );
    RETURN;
(* Non ha senso ruotare lastre troppo strette: devono essere riscontrabili con bordo indietro a zero *)
ELSIF vqGrab_GlassWidth<vqFallBck0MinWidth THEN
    dlog( Txt:='!! Rot limit W=%ld < %ld mm', Lvl:=2, Val1:=vqGrab_GlassWidth/1E3, Val2:=vqFallBck0MinWidth/1E3 );
    RETURN;
(* Applico limite utente sulla larghezza minima *)
ELSIF vqGrab_GlassWidth<vqRotAlgn_WidthMin THEN
    dlog( Txt:='!! Rot user limit W=%ld < %ld mm', Lvl:=2, Val1:=vqGrab_GlassWidth/1E3, Val2:=vqRotAlgn_WidthMin/1E3 );
    RETURN;
(* Lastre troppo basse cadono in zona taglio quando apro la pinza *)
ELSIF H < vqFallWidth THEN
    (* Condizione di caduta dopo rotazione                    │
       Quando mollo con la pinza, il vetro è:            ███ ▒▒▒▒▓▓▓███
       lato rimanenza: vqGrab_GlassYtop - vqGrab_Ygrab   ███ ▒▒▒▒▓▓▓███
       lato prodotto:  vqGrab_Ygrab - vqGrab_GlassYbtm   ███ ╭│╮▒▓▓▓███
       Cade se una delle due è minore del buco,          ███ └│┘ ██████
       e il baricentro non è sul tavolo.
       Visto che però devo traslare, la condizione è semplicemente
       che la larghezza non possa mai cadere dall'area di taglio
       con stacco in parcheggio *)
    dlog( Txt:='!! Fall after rot w=%ld < %ld mm', Lvl:=2, Val1:=H/1E3, Val2:=vqFallWidth/1E3 );
    RETURN;
END_IF;

(* Determino la posizione Y ideale che deve avere la lastra dopo
   la rotazione: dipende da altezza lastra, che è 'vqGrab_GlassWidth'
   e dalle ordinate dei riscontri/cinghie/braccia ribaltina, le quali
   si distanziano progressivamente all'aumentare di Y.
   Questo valore 'TgtYbtm' è da interpretarsi come la posizione Y
   del bordo basso lastra dopo la rotazione; poichè in queste rotazioni
   l'angolo di arrivo pinza è 90°, esso coincide con l'Y della pinza,
   quindi il movimento sarà un riposizionamento relativo alla pinza.

   Lastre alte si portano all'ordinata tipica/ideale, per la quale la
   macchina è stata progettata.
   Le lastre basse le posizioniamo massimizzando anzitutto la
   riscontrabilità/agganciabilità per trascinamento a fine linea,
   poi la traslabilità con cinghie e infine la ribaltabilità *)
(* Nota: non differenzio per pezzi finiti solo da ribaltare, perché
         devono comunque essere agganciabili dai riscontri *)
(* ASSERT(vnAlgnBlks_N>=4, 'vnAlgnBlks_N<4') *)
IF vqGrab_GlassWidth < (vq[ivqAlgnBlks_Y+2] + vqAlgnBlk_YMargin) THEN
    (* Questa lastra è molto bassa: appoggiandola allo zero (rotelle),
       non supera il secondo piedino di almeno 'vqAlgnBlk_YMargin'.
       La cosa migliore è centrarla sui primi due piedini
       del riscontro:  Yo = Y₁ - [H - (Y₂-Y₁)] / 2 *)
    TgtYbtm := vq[ivqAlgnBlks_Y+1] - (vqGrab_GlassWidth - vq[ivqAlgnBlks_Y+2] + vq[ivqAlgnBlks_Y+1])/2;
    dlog( Txt:='TgtYbtm=%ld to align 2 (%ld|%ld)', Lvl:=5, Val1:=TgtYbtm/1E3, Val2:=vq[ivqAlgnBlks_Y+1]/1E3, Val3:=vq[ivqAlgnBlks_Y+2]/1E3 );

ELSIF vqGrab_GlassWidth < (vq[ivqAlgnBlks_Y+3] - vqYo_SheetFeed + vqAlgnBlk_YMargin) AND
      vqGrab_GlassWidth > (vq[ivqAlgnBlks_Y+3] - vq[ivqAlgnBlks_Y+1] + vqAlgnBlk_YMargin) THEN
    (* Questa lastra è riscontrabile col terzo piedino se opportunamente
       centrata: meglio fare così perché migliora molto il riscontro,
       la distanza tra i piedini 1-2 e 2-3 è simile e quindi il secondo
       spingerebbe quasi in mezzo alla lastra, situazione terribile *)
    TgtYbtm := vq[ivqAlgnBlks_Y+1] - (vqGrab_GlassWidth - vq[ivqAlgnBlks_Y+3] + vq[ivqAlgnBlks_Y+1])/2;
    dlog( Txt:='TgtYbtm=%ld to align 3 (%ld|%ld)', Lvl:=5, Val1:=TgtYbtm/1E3, Val2:=vq[ivqAlgnBlks_Y+1]/1E3, Val3:=vq[ivqAlgnBlks_Y+3]/1E3 );

ELSIF vqGrab_GlassWidth < (vq[ivqAlgnBlks_Y+4] - vqYo_SheetFeed + vqAlgnBlk_YMargin) AND
      vqGrab_GlassWidth > (vq[ivqAlgnBlks_Y+4] - vq[ivqAlgnBlks_Y+1] + vqAlgnBlk_YMargin) THEN
    (* Questa lastra è riscontrabile col quarto piedino se opportunamente
       centrata: meglio fare così perché migliora molto il riscontro *)
    TgtYbtm := vq[ivqAlgnBlks_Y+1] - (vqGrab_GlassWidth - vq[ivqAlgnBlks_Y+4] + vq[ivqAlgnBlks_Y+1])/2;
    dlog( Txt:='TgtYbtm=%ld to align 4 (%ld|%ld)', Lvl:=5, Val1:=TgtYbtm/1E3, Val2:=vq[ivqAlgnBlks_Y+1]/1E3, Val3:=vq[ivqAlgnBlks_Y+4]/1E3 );

(* Per i riscontri basta così assumo che i piedini successivi
   siano distanziati in modo tale da non dover più centrare *)

(* Oltre una certa altezza è sicuramente riscontrabile e traslabile,
   considero quindi solo la ribaltabilità.
   Quando non riesce a raggiungere l'ultimo braccio per un soffio
   c'è pericolo di caduta e carica molto il penultimo braccio, in
   tal caso meglio assicurare che appoggi all'ultimo braccio, chiaramente
   lo faccio solo se dopo la rotazione ho un pezzo finito da ribaltare *)
ELSIF (What=ROTARG_REOR OR vbWillTiltOutPiece) AND
      vqGrab_GlassWidth < (vq[ivqTiltOutArms_Y+vnTiltOutArms_N] - vqYo_SheetFeed) AND
      vqGrab_GlassWidth > (vq[ivqTiltOutArms_Y+vnTiltOutArms_N] - vq[ivqTiltOutArms_Y+2]) THEN
	(* Assicuro che appoggi all'ultimo braccio *)
    TgtYbtm := vq[ivqTiltOutArms_Y+vnTiltOutArms_N] + 10E3 - vqGrab_GlassWidth; (* [um] *)
    dlog( Txt:='TgtYbtm=%ld to tilt', Lvl:=4, Val1:=TgtYbtm/1E3 );
ELSE
    (* Pongo la lastra nella posizione tipica/ideale *)
    TgtYbtm := vqYo_SheetFeed; (* [um] *)
END_IF;

(* Voglio assicurarmi che possa essere letta dalla fotocellula stacco *)
IF TgtYbtm >= vqYph_DtchLast THEN
    dlog( Txt:='! Cannot place in Y=%ld > %ld mm (vqYph_DtchLast)', Lvl:=2, Val1:=TgtYbtm/1E3, Val2:=vqYph_DtchLast/1E3 );
    TgtYbtm := vqYo_SheetFeed; (* Default *)
END_IF;

(* Tengo conto dell'eccentricità dell'asse di rotazione pinza.
   la componente Y è già compensata con 'vqGrabber_DY'.
   L'effetto di una componente X positiva nelle rotazioni riscontro
   è far avanzare la X e abbassare la Y lastra rispetto la
   posizione teorica dopo la rotazione.
   A rigor di logica dovrei applicarlo nel calcolo delle camme e
   nel calcolo del punto di presa per compensare la traslazione X
   per semplicità per ora compenso solo l'Y finale *)
TgtYbtm := TgtYbtm + vqGrabber_DX;

(* Quote a cui portare la lastra agguantata prima e dopo la rotazione riscontri: *)
(* Niente movimenti prima della rotazione *)
vqGrab_Yc_pre := NO_POS_UM;
(* A fine rotazione la pinza va portata a 'TgtYbtm' *)
vqGrab_Yc_post := TgtYbtm;


(* TODO 5: Discriminare qui se rotazione generica o 90°? vqGrab_Agrab=90E3 *)

(* Determino se sono a rischio di collisione spalla *)
Big := vqRot_Diag >= vqRotAlgn_HeightMax OR
       (vqRot_Diag + vqRotGrab_Yinf + 2*vqGrab_RotMargin) >= vqY_CollTopAlgn;


(* Determino se voglio usare il piedino aiuto rotazione:
   a seconda delle preferenze oppure se sono a rischio di collisione *)
vbGrab_RotWithBlock := (Big AND H>vqRotAlgn_UseBlockHmin) OR (* In teoria dovrei controllare la quota di presa pinza minima con piedino vqGrab_MinYgrabWithBlock *)
                       (vqGrab_GlassYtop >= vqRotAlgn_UseBlockHmin AND
                        vqGrab_GlassWidth >= vqRotAlgn_UseBlockWmin);

(* Calcolo i profili delle camme per la rotazione prodotto (riscontro)
   da 0° a 90°.
   Il profilo del movimento Y della pinza è diviso in due tratti,
   separati in corrispondenza dell'angolo critico acr in cui si
   ha il minimo della posizione y del vertice basso della lastra:
    .Primo tratto: 0°-acr
    .Secondo tratto: acr-90°
   A seconda delle situazioni uno dei due tratti può collassare.

   Qui calcolo il profilo delle camme elettroniche della rotazione,
   ossia il movimento del carrello inferiore e dell'eventuale piedino
   di aiuto rotazione sincronizzati alla rotazione della pinza

    Yo (Ordinata vertice basso della lastra in rotazione)
      .ai   [rad] Angolo iniziale/di partenza
      .acr  [rad] Angolo critico
      .af   [rad] Angolo finale/di arrivo
      .yoi  [mm]  Ordinata iniziale/di partenza
      .yocr [mm]  Ordinata in corrispondenza di 'acr'
      .yof  [mm]  Ordinata finale/di arrivo
      .w1   Scalatura orizzontale del seno nel primo tratto
      .w2   Scalatura orizzontale del seno nel secondo tratto

    Xp (Ascissa piedino ausiliario X per rotazioni riscontro)
      .yo [mm] Ordinata vertice basso della lastra in rotazione
      .d  [mm] Distanza tra punto di presa e vertice basso
      .Yp [mm] Ordinata del piedino
      .Rp [mm] Raggio del piedino
*)

(* Angoli iniziali e finali *)
Yo.ai := MDEG2RAD * TO_LREAL(vqGrab_Agrab); (* [rad] *)
Yo.af := MDEG2RAD * TO_LREAL(vqGrab_Agrab+vqGrab_Arot); (* [rad] *)
(* Assumendo lastra allineata: *)
Yo.yoi := 1.0E-3 * TO_LREAL(vqGrab_GlassYbtm); (* [mm] Ordinata vertice basso iniziale *)

(* Dati fissi del piedino ausiliario rotazioni riscontro
   Nota: potrebbero essere calcolati una-tantum! *)
Xp.Yp := 1.0E-3 * TO_LREAL(vq[ivqAlgnBlks_Y+vnAlgnBlk_AuxRot] + vqAlgnBlkRot_Dy); (* Ordinata fissa piedino X ausiliario rot risc *)
Xp.Rp := 1.0E-3 * TO_LREAL(vqAlgnBlkRot_R); (* Raggio piedino X ausiliario rot risc *)


(* Forzature in caso di sistema ventosa (StratoS) *)
IF vnGrabber_Type=1 THEN
    (* In caso di ventosa...*)
    (* ...Bisogna usare il piedino (la ventosa è passiva) *)
    vbGrab_RotWithBlock := TRUE;
    (* ...Il punto presa è rigido *)
    vqGrab_Ygrab := vqVGrab_Ygrab;
END_IF;


IF vbGrab_RotWithBlock THEN
    (* Rotazioni di lastre grosse
        .Rotazioni rischio ingombro - cerco di sfruttare al massimo
         l'area disponibile alla rotazione (movim. verso il basso)
        .Rotazioni lastre pesanti - è necessario l'ausilio del piedino,
         la posizione y ha dei vincoli per sfruttare il piedino,
         il punto di presa è tale da non collidere con i riscontri *)
    dlog( Txt:='With block', Lvl:=5 );

    (* Determinazione del punto di presa (con piedino) *)
    IF vqGrab_Ygrab=NO_POS_UM THEN
        (* I criteri per la scelta del punto di presa:
           ●Non prendere troppo in basso per:
              ▸Massimizzare la leva del piedino (è più importante questo della minimizzazione di J)
              ▸Tenere il vertice alto ben lontano dalla spalla (nell'intorno dell'angolo critico)
           ●Non prendere troppo in alto per:
              ▸Minimizzare il momento di inerzia
              ▸Bilanciare il vetro nell'operazione di riposizionamento Y
               (infatti col piedino l'Y di arrivo è fissata e poi in genere bisogna
                riposizionare, se ho più vetro da una parte si potrebbe stortare)
              ▸Assicurare grip con cinghie stacco, perché sicuramente dopo la rotazione
               la lastra dovrà essere traslata perché non stiamo agguantando sul taglio,
               quindi ci deve essere abbastanza vetro sullo stacco
           ●Cercare di evitare di prendere in corrispondenza dei piedini di riscontro
              ▸Se si vuole agganciare il vetro all'inzio della rotazione col
               piedino ausiliario, dobbiamo poter far entrare i piedini di riscontro
               in zona taglio senza che collidano con la pinza

           Se la lastra può potenzialmente collidere con la spalla,
           il punto di presa deve essere più in alto posssibile
              IF (vqRot_Diag + vqRotGrab_Yinf + vqGrab_RotMargin) >= vqY_CollTopAlgn THEN ... END_IF;

           Visto che i criteri sono discordanti, diamo la possibilità al
           collaudatore di limitare l'ordinata di presa per evitare problemi
           sul successivo arretramento mediante un parametro per definire il
           punto di presa preferito per lastre alte: 'vqGrab_MinRotTail',
           correlato con quanto vetro vogliamo sulle cinghie stacco

           La scelta del punto di presa (si ragiona rispetto la poszione pinza)
           è svolta da 'YroomFit', il quale controlla la collisione coi
           piedini di riscontro: se non è prendibile nel punto indicato,
           sceglie una ordinata via via minore (mai maggiore) *)

        (* Una nota sugli ingombri carrello inferiore + pinza:
           Nei calcoli seguenti bisogna considerare l'ingombro che
           avrò durante la rotazione; se è presente un traino inferiore,
           assumo che la pinza sia su di esso. *)

        (* A seconda del rischio di collisione spalla *)
        IF Big THEN
            (* Se sono a rischio di collisione spalla cerco di pinzare più
               in alto possibile per minimizzare il rischio di collidere,
               parto da una quota massima e cerco verso il basso *)
            dlog( Txt:='Diagonal %ld mm may collide', Lvl:=4, Val1:=vqRot_Diag/1E3 );
            YroomFit( y:=vqGrab_GlassYtop - vqGrab_MinRotTail - vqGrabber_DY,
                      dwn:=TRUE,
                      rp:=vqCarrInf_DYroomP+MAX(vqECarrInf_Length,0) + vqAlgnBlks_R + vqGrab_YroomSafeMrg,
                      rm:=vqCarrInf_DYroomM+MIN(vqECarrInf_Length,0) - vqAlgnBlks_R - vqGrab_YroomSafeMrg - vqGrab_YroomMSafeSpc,
                      iYb:=ivqAlgnBlks_Y,
                      N:=vnAlgnBlks_N );
        ELSE
            (* Se non sono a rischio collisione spalla preferisco cercare
               di bilanciare il vetro in modo che non si storti quando
               riposiziono in Y, parto da una quota minima, idealmente a
               metà lastra, e cerco verso l'alto *)
            YroomFit( y:=vqGrab_GlassYbtm + H/2 - vqGrabber_DY,
                      dwn:=FALSE,
                      rp:=vqCarrInf_DYroomP+MAX(vqECarrInf_Length,0) + vqAlgnBlks_R + vqGrab_YroomSafeMrg,
                      rm:=vqCarrInf_DYroomM+MIN(vqECarrInf_Length,0) - vqAlgnBlks_R - vqGrab_YroomSafeMrg - vqGrab_YroomMSafeSpc,
                      iYb:=ivqAlgnBlks_Y,
                      N:=vnAlgnBlks_N );
        END_IF;
        (* Un po' di feedback sul risultato *)
        IF YroomFit.y<>NO_POS_UM THEN
            vqGrab_Ygrab := YroomFit.y + vqGrabber_DY; (* Posizione pinza *)
            dlog( Txt:='CarrInf grabs at %ld|%ld (blk%d)', Lvl:=4, Val1:=(YroomFit.y+vqCarrInf_DYroomM+MIN(vqECarrInf_Length,0))/1E3, Val2:=(YroomFit.y+vqCarrInf_DYroomP+MAX(vqECarrInf_Length,0))/1E3, Val3:=TO_DINT(YroomFit.ib) );
        ELSE
            dlog( Txt:='!! Cannot find a grab point for Y=%ld|%ld', Lvl:=2, Val1:=vqGrab_GlassYbtm/1E3, Val2:=vqGrab_GlassYtop/1E3 );
            (* TODO 4: Fallback senza piedino? Pericoloso per gli ingombri *)
            RETURN;
        END_IF;
    END_IF; (* Calcolo punto di presa per lastre grosse *)

    (* Check: Il punto di presa deve essere interno al vetro *)
    IF vqGrab_Ygrab>vqGrab_GlassYtop OR vqGrab_Ygrab<vqGrab_GlassYbtm THEN
        dlog( Txt:='!! Grab at %ld mm outside (%ld|%ld)', Lvl:=1, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_GlassYbtm/1E3, Val3:=vqGrab_GlassYtop/1E3 );
        RETURN;
    END_IF;

    (* Il piedino è efficace solo se può agganciare subito il vetro *)
    IF vqGrab_GlassYbtm > TO_DINT(1.0E3 * Xp.Yp) THEN
        dlog( Txt:='!! Ybtm=%ld mm cannot be hooked', Lvl:=2, Val1:=vqGrab_GlassYbtm/1E3 );
        (* Il vetro tenderà a stare più indietro perché la pinza farà
           fatica, per l'aggancio al volo servirebbe stare più indietro!
           Xp( a:=Yo.a - A_DELTA, yo:=Yo.value ); *)
        RETURN;
    END_IF;

    (* Poichè uso il piedino l'ordinata finale è per forza: *)
    Yo.yof := Xp.Yp + Xp.Rp; (* [mm] Ordinata vertice basso finale: sopra il piedino *)

    (* Angolo critico in cui la diagonale è verticale *)
    (* Yo.acr := ATAN2( TO_LREAL(vqGrab_GlassWidth), TO_LREAL(H) ); *)
    Yo.acr := ATAN( TO_LREAL(vqGrab_GlassWidth) / TO_LREAL(H) ); (* DANGER_DIVISION_BY_ZERO *)

    (* In corrispondenza di questo angolo voglio che il vertice basso sia più giù possibile *)
    (* Se il punto intermedio è troppo vicino agli estremi (0.2rad ≈ 10°)
       lo ignoro, e uno dei tratti che definiscono la camma collassa *)
    IF (Yo.acr-Yo.ai)<0.2 THEN
        (* É troppo vicino all'inizio, il primo tratto collassa, rinuncio ad abbassarmi *)
        dlog( Txt:='yo: il primo tratto collassa', Lvl:=6 );
        Yo.acr := Yo.ai;
        Yo.yocr := Yo.yoi;
        (* C'è solo il secondo tratto *)
        Yo.w1 := 0.0;
        Yo.w2 := PI_2 / (Yo.acr - Yo.af); (* π/2 / ∆α *)
    ELSIF (Yo.af-Yo.acr)<0.2 THEN
        (* É troppo vicino alla fine, il secondo tratto collassa, rinuncio ad abbassarmi *)
        dlog( Txt:='yo: il secondo tratto collassa', Lvl:=6 );
        Yo.acr := Yo.af;
        Yo.yocr := Yo.yof;
        (* C'è solo il primo tratto *)
        Yo.w1 := PI_2 / (Yo.acr - Yo.ai); (* π/2 / ∆α *)
        Yo.w2 := 0.0;
    ELSE
        (* Il punto intermedio è fattibile *)
        dlog( Txt:='yo: min in a=%ld deg', Lvl:=4, Val1:=TO_DINT(RAD2DEG*Yo.acr) );
        Yo.yocr := 1.0E-3 * TO_LREAL(vqRotGrab_Yinf + vqGrab_RotMargin); (* [mm] In acr vai più in basso possibile *)
        (* Il primo tratto *)
        Yo.w1 := PI_2 / (Yo.acr - Yo.ai); (* π/2 / ∆α *)
        (* Il secondo tratto *)
        Yo.w2 := PI_2 / (Yo.acr - Yo.af); (* π/2 / ∆α *)
    END_IF;
ELSE
    (* Rotazioni lastre senza piedino e problemi ingombro:
       posso spostarla a piacere nelle posizione finale più opportuna *)
    (* dlog( Txt:='No Block', Lvl:=5); *)

    (* Non deve essere troppo pesante *)
    M := fnGlassMass_g(vqGrab_GlassWidth,H,vqGlass_Thckn);
    IF M > vqRotNoBlk_MassMax THEN
        dlog( Txt:='!! Too heavy %ld > %ld Kg', Lvl:=2, Val1:=M/1E3, Val2:=vqRotNoBlk_MassMax/1E3 );
        RETURN;
    END_IF;

    (* Determinazione del punto di presa (senza piedino) *)
    IF vqGrab_Ygrab=NO_POS_UM THEN
        (* Non ho vincoli sul punto di presa, posso sceglierlo per:
           .Posizionare in modo da procedere subito al riscontro
            del passo dopo, se c'è un taglio da fare
           .Minimizzare il momento d'inerzia *)
        (* Ottimizzo per riscontro passo corrente (rotazione lastra in arrivo) *)
        (* IF What=ROTARG_INCOMING THEN
            vqGrab_Ygrab := vqGrab_GlassYbtm + vqProc_Algn + vqProc_AlgnDelta; *)
        (* Ottimizzo per riscontro passo successivo *)
        IF vbNextStep_Valid AND What=ROTARG_PROD AND H<2000E3 THEN
            (* Sbircio quale sarà il delta del riscontro successivo
               Assumo che se ruoto, lo step successivo avrà il riscontro (vbMustAlign=TRUE) *)
            CalcAlgnDelta( Width:=H, Height:=vqGrab_GlassWidth, Align:=vqNextStep_FirstAlgn );
            vqGrab_Ygrab := vqGrab_GlassYbtm + vqNextStep_FirstAlgn + CalcAlgnDelta.Delta;
            dlog( Txt:='Grab in %ld (-%ld) to align %ld+%ld mm', Lvl:=5, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_GlassYbtm/1E3, Val3:=vqNextStep_FirstAlgn/1E3, Val4:=CalcAlgnDelta.Delta/1E3 );

            (* Se il punto presa è troppo vicino al bordo lo correggo *)
            IF vqGrab_Ygrab < (vqGrab_GlassYbtm + vqGrabber_Radius) THEN
                (* Troppo vicino al bordo basso, è un rifilo di testa.
                   Per usare tutta la pinza devo agguantare un po' più in alto,
                   la lastra dovrà indietreggiare un po' prima del riscontro,
                   non c'è problema, tanto è tutta lato stacco *)
                vqGrab_Ygrab := vqGrab_GlassYbtm + vqGrabber_Radius;
                dlog( Txt:='! Low grab %ld=%ld+%ld mm', Lvl:=2, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_GlassYbtm/1E3, Val3:=vqGrabber_Radius/1E3 );
            ELSIF vqGrab_Ygrab > (vqGrab_GlassYtop - vqGrabber_Radius) THEN
                (* Troppo vicino al bordo alto, è un rifilo.
                   Per usare tutta la pinza devo agguantare più in basso,
                   la lastra dovrà avanzare un po' prima del riscontro *)
                IF vbFeat_AlgnHasBelts THEN
                    (* Con le cinghie su riscontro non ho problemi di avanzamento *)
                    vqGrab_Ygrab := vqGrab_GlassYtop - vqGrabber_Radius;
                    dlog( Txt:='! High grab %ld=%ld-%ld mm', Lvl:=2, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_GlassYtop/1E3, Val3:=vqGrabber_Radius/1E3 );
                ELSE
                    (* I soli rulli non bastano a far avanzare la lastra, quindi
                       devo assicurare un certo appoggio sulle cinghie stacco *)
                    vqGrab_Ygrab := vqGrab_GlassYtop - MIN( vqGrab_MinRotTail, H/2 );
                    (* La posizione del bordo indietro per assicurare grip sulle cinghie: Xbck <= vqX_RemnBeltsEnd - vqBelts_MinGripDX
                       però tieni conto che ci sono i rulli riscontro che aiutano *)
                    dlog( Txt:='! Grab in %ld to ensure trim grip', Lvl:=2, Val1:=vqGrab_Ygrab/1E3 );
                END_IF;
            END_IF;
        ELSE
            (* Non ho un riscontro da ottimizzare.
               Se lastra stretta pinzo in basso in modo da portarla sullo stacco,
               altrimenti pinzo a metà per ottimizzare il momento d'inerzia *)
            IF H<vqShift_GoodWidth THEN
                vqGrab_Ygrab := vqGrab_GlassYbtm + vqGrabber_Radius;
                dlog( Txt:='Grab btm (%ld)', Lvl:=3, Val1:=vqGrab_Ygrab/1E3 );
            ELSE
                vqGrab_Ygrab := vqGrab_GlassYbtm + H/2;
                dlog( Txt:='Grab mid (%ld)', Lvl:=3, Val1:=vqGrab_Ygrab/1E3 );
            END_IF;
        END_IF;

    END_IF; (* Calcolo punto di presa per lastre piccole *)

    (* Check: il punto di presa deve essere interno al vetro *)
    IF vqGrab_Ygrab>vqGrab_GlassYtop OR vqGrab_Ygrab<vqGrab_GlassYbtm THEN
        dlog( Txt:='!! Grab in %ld is outside (%ld|%ld)', Lvl:=1, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_GlassYbtm/1E3, Val3:=vqGrab_GlassYtop/1E3 );
        RETURN;
    END_IF;

    (* Visto che non ho vincoli (piedino) posso calcolarmi un profilo
       camme per portarla già alla posizione Y finale che desidero: *)
    Yo.yof := 1.0E-3 * TO_LREAL(TgtYbtm); (* [mm] *)

    Yo.w1 := PI_2 / (Yo.af - Yo.ai); (* π/2 / ∆α *)

    (* Il secondo tratto della camma collassa *)
    Yo.acr := Yo.af;
    Yo.yocr := Yo.yof;
    Yo.w2 := 0.0;
END_IF; (* - Rotazione lastra grossa/piccola *)

(* Profilo del piedino ausiliario rotazioni riscontro (É un piedino dei riscontri) *)
Xp.d := 1.0E-3 * TO_LREAL(vqGrab_Ygrab-vqGrab_GlassYbtm); (* [mm] Punto di presa relativo risp. bordo sotto *)


(* -- Determina fattibilità della rotazione -- *)

(* Ingombro effettivo della rotazione lato riscontro
            +-----+--------------+
            ¦     __.--''\       ¦
            ¦   ''|       \      ¦
            ¦    \| .      \     ¦
            ¦   _.O'        \    ¦
            ¦     |\         \   ¦
            ¦     | \   __..--   ¦
            ¦     |  --'         ¦
            +-----+--------------+--> x   *)
vqRot_Xmin := vqGrab_Ygrab - vqGrab_GlassYtop - vqGrab_RotMargin;
vqRot_Xmax := TO_DINT(1.0E3 * fnLength( TO_LREAL(vqGrab_GlassWidth)/1.0E3, Xp.d )) + vqGrab_RotMargin;
(* Dovrebbe essere anche: vqRot_Xmax := vqRot_Xmin + vqRot_Diag + 2*vqGrab_RotMargin; *)
vqRot_Ymin := TO_DINT(1.0E3 * Yo.yocr);
vqRot_Ymax := vqRot_Ymin + vqRot_Diag;


(* L'area disponibile per rotazione prodotto lato riscontro
         +------------+ +-vqRotGrab_Ysup--------+
         |            |_| vqX_CollTopAlgn,  |
         |             |  vqY_CollTopAlgn   |
         |             |                        |
   vqRotGrab_Xinf      |                 vqRotGrab_Xsup
         |             |                        |
         +-------------+--vqRotGrab_Yinf--------+ *)

(* Per il controllo collisione con spalla, condizione necessaria
   perché non vi sia è che in corrispondenza dell'ascissa dello
   spigolo, il vertice alto (2) abbia ordinata minore a quella
   dello spigolo. Non so se sia anche sufficiente...
   Angolo corrispondente al momento in cui il vertice alto ha
   ascissa pari a quella dello spigolo spalla:
   α = arctg(w/(h-d)) - arcsin((Xob-Xg)/√(w²+(h-d)²))
   Questa espressione ha una interpretazione geometrica.
   L'ordinata del vertice 2 è:
   y2 = yo(α) + w sinα + h cosα *)
Yo( a:=ATAN(TO_LREAL(vqGrab_GlassWidth) / TO_LREAL(vqGrab_GlassYtop-vqGrab_Ygrab)) (* DANGER_DIVISION_BY_ZERO *)
       - ASIN(TO_LREAL(vqX_CollTopAlgn) / fnLength( TO_LREAL(vqGrab_GlassWidth), TO_LREAL(vqGrab_GlassYtop-vqGrab_Ygrab) )) );
Y2Coll := TO_DINT( 1.0E3 * Yo.value  +  TO_LREAL(vqGrab_GlassWidth) * SIN(Yo.a)  +  TO_LREAL(H) * COS(Yo.a) );
dlog( Txt:='Collision check: Y2=%ld < %ld A=%ld deg', Lvl:=5, Val1:=Y2Coll/1E3, Val2:=vqY_CollTopAlgn/1E3, Val3:=TO_DINT(RAD2DEG * Yo.a) );

(* Controllo collisione con spalla *)
IF Y2Coll >= vqY_CollTopAlgn THEN
    dlog( Txt:='!! Top collision', Lvl:=2 );
(* Controllo ingombro X a fine linea *)
ELSIF vqRot_Xmax > vqRotGrab_Xsup THEN
    dlog( Txt:='!! Xmax=%ld > %ld mm', Lvl:=2, Val1:=vqRot_Xmax/1E3, Val2:=vqRotGrab_Xsup/1E3 );
(* Controllo ingombro X lato rimanenza *)
ELSIF vqRot_Xmin < vqRotGrab_Xinf THEN
    dlog( Txt:='!! Xmin=%ld < %ld mm', Lvl:=2, Val1:=vqRot_Xmin/1E3, Val2:=vqRotGrab_Xinf/1E3 );
(* Controllo ingombro Y in alto *)
ELSIF vqRot_Ymax > vqRotGrab_Ysup THEN
    dlog( Txt:='!! Ymax=%ld > %ld mm', Lvl:=2, Val1:=vqRot_Ymax/1E3, Val2:=vqRotGrab_Ysup/1E3 );
ELSE
    (* Se qui si può fare *)
    dlog( Txt:='Ygrab=%ld, TgtYbtm=%ld, x=%ld|%ld', Lvl:=4, Val1:=vqGrab_Ygrab/1E3, Val2:=TgtYbtm/1E3, Val3:=vqRot_Xmin/1E3, Val4:=vqRot_Xmax/1E3 );
    Ok := TRUE;
END_IF; (* -- Controllo fattibilità *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbCalcRotBuf

{ DE:"Calcoli fattibilità rotazione su polmone con ventosa" }

	VAR_INPUT
	k_des : INT; { DE:"Rotazione indicata desiderata [90deg]" }
	Xmin : DINT; { DE:"Ascissa occupata da lastre accumulate [um]" }
	END_VAR

	VAR_OUTPUT
	k : INT; { DE:"Rotazione fattibile [90deg]" }
	R0 : DINT; { DE:"Distanza centro di rotazione e vertice 0 [um]" }
	R1 : DINT; { DE:"Distanza centro di rotazione e vertice 1 [um]" }
	R2 : DINT; { DE:"Distanza centro di rotazione e vertice 2 [um]" }
	R3 : DINT; { DE:"Distanza centro di rotazione e vertice 3 [um]" }
	R_dtch : DINT; { DE:"Distanza per controllo collisione lato stacco [um]" }
	R_feed : DINT; { DE:"Distanza per controllo collisione lato carico [um]" }
	Rmax_dtch : DINT; { DE:"Distanza centro di rotazione e punto collisione alto lato stacco [um]" }
	Rmax_feed : DINT; { DE:"Distanza centro di rotazione e punto collisione alto lato carico [um]" }
	Xfwd_rot : DINT; { DE:"Ascissa bordo avanti della lastra ruotata [um]" }
	Ybtm_rot : DINT; { DE:"Ordinata bordo basso della lastra ruotata [um]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	vqBufRot_GlassWidth : DINT; { DE:"Larghezza lastra da ruotare [um]" }
	vqBufRot_GlassHeight : DINT; { DE:"Altezza lastra da ruotare [um]" }
	vqBufRot_GlassXfwd : DINT; { DE:"Ascissa bordo avanti lastra da ruotare [um]" }
	vqBufRot_GlassYbtm : DINT; { DE:"Ordinata bordo basso lastra da ruotare [um]" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqRot_Diag : DINT; { DE:"Diagonale lastra in rotazione [um]" }
	vqRot_Xmin : DINT; { DE:"Ingombro rotazione: X minimo [um]" }
	vqRot_Xmax : DINT; { DE:"Ingombro rotazione: X massimo [um]" }
	vqRot_Ymin : DINT; { DE:"Ingombro rotazione: Y minimo [um]" }
	vqRot_Ymax : DINT; { DE:"Ingombro rotazione: Y massimo [um]" }
	vbBufRot_BigSheet : BOOL; { DE:"Rotazione lastra grossa" }
	CalcRotData : fbCalcRotData; { DE:"Calcoli comuni lastra in rotazione" }
	vdRot_Rmax : LREAL; { DE:"Distanza tra punto presa e vertice più lontano [m]" }
	vdRot_Dm : LREAL; { DE:"Distanza tra punto presa e centro di massa lastra in rotazione [m]" }
	vdRot_Mass : LREAL; { DE:"Massa della lastra in rotazione [Kg]" }
	vdRot_Jgrab : LREAL; { DE:"Momento d'inerzia rispetto il centro di massa della lastra in rotazione [Kg m²]" }
	vqBufRot_Xc : DINT; { DE:"Posizione X centro rotazione [um]" }
	vqBufRot_Yc : DINT; { DE:"Posizione Y centro rotazione [um]" }
	vqBufRot_Radius : DINT; { DE:"Raggio ventosa rotazione su polmone [um]" }
	vqBufRot_Yfix : DINT; { DE:"Margine aggiuntivo bordo sotto dopo rotazione ventosa [um]" }
	vqBufRot_WidthMax : DINT; { DE:"Massima larghezza ruotabile sul polmone [um]" }
	vqBufRot_HeightMax : DINT; { DE:"Massima altezza ruotabile sul polmone [um]" }
	vqBufRot_WidthMin : DINT; { DE:"Minima larghezza ruotabile sul polmone [um]" }
	vqBufRot_HeightMin : DINT; { DE:"Minima altezza ruotabile sul polmone [um]" }
	vqBufRot_MassMax : DINT; { DE:"Massima massa ruotabile sul polmone [g]" }
	vqX_CollTopFeed : DINT; { DE:"X punto collisione corpo estraneo a monte [um]" }
	vqY_CollTopFeed : DINT; { DE:"Y punto collisione corpo estraneo a monte [um]" }
	vqX_CollTopDtch : DINT; { DE:"X punto collisione carpenteria in alto lato stacco [um]" }
	vqY_CollTopDtch : DINT; { DE:"Y punto collisione carpenteria in alto lato stacco [um]" }
	vqRot_MaxLeanOut : DINT; { DE:"Massima sporgenza vetro fuori dal tavolo ammessa [um]" }
	vqYph_DtchLast : DINT; { DE:"Ordinata ultima fotocellula su stacco [um]" }
	vqYo_SheetFeed : DINT; { DE:"Ordinata ideale/tipica della lastra in arrivo dal carico [um]" }
	END_VAR

	{ CODE:ST }(*    fbCalcRotBuf (Strato M-series)
    ----------------------------------------------

    OVERVIEW
    ----------------------------------------------
    Calcoli relativi alla fattibilità della
    rotazione su polmone indicata.
      spalla                          spalla
      carico █      +--------+      █ stacco
                    |  O--Yc |
                  H |  ¦     |             y^
                    |  Xc    |              |
                    +--------+ - Ybtm       +--> x
                        W    |
                            Xfwd
    I controlli sono:
      .Rispetto dei range dimensioni ruotabili
      .Collisione con spalla lato stacco e lato carico
      .Calcolo dell'area di rotazione
    Nota: Il chiamante tiene conto di eventuali lastre
          sul carico, mediante Xmin

    RETURN VALUE
    ----------------------------------------------
    Se fattibile il valore indicato della rotazione
    rimane invariato, altrimenti il valore viene
    posto a zero.
    Eventualmente si sovrascrive il valore della
    rotazione alternativa fattibile.

    DETAILS
    ----------------------------------------------
    La rotazione su polmone è ottenuta con una
    ventosa.
    Il senso di rotazione viene indicato rispetto
    il sistema di riferimento della macchina in
    multipli di 90°.
*)

dlog( Txt:='fbCalcRotBuf: Checking rot %ld deg of %ldx%ld mm', Lvl:=4, Val1:=90 * TO_DINT(k), Val2:=vqBufRot_GlassWidth/1E3, Val3:=vqBufRot_GlassHeight/1E3 );


(* -- Controlli globali di fattibilità --
      Se non rispettate abortisco subito, non ha senso proseguire *)
k := k_des;

(* Rotazione inutile *)
IF k=0 OR MOD(k,4)=0 THEN
    dlog( Txt:='! Rot %ld deg is useless', Lvl:=4, Val1:=90 * TO_DINT(k) );
    k := 0;
    RETURN;
(* Le dimensioni lastra devono essere nel range *)
ELSIF vqBufRot_GlassWidth>vqBufRot_WidthMax OR vqBufRot_GlassHeight>vqBufRot_HeightMax THEN
    dlog( Txt:='!! Too big %ldx%ld mm', Lvl:=2, Val1:=vqBufRot_GlassWidth/1E3, Val2:=vqBufRot_GlassHeight/1E3 );
    k := 0;
    RETURN;
ELSIF vqBufRot_GlassWidth<vqBufRot_WidthMin OR vqBufRot_GlassHeight<vqBufRot_HeightMin THEN
    dlog( Txt:='!! Too small %ldx%ld mm', Lvl:=2, Val1:=vqBufRot_GlassWidth/1E3, Val2:=vqBufRot_GlassHeight/1E3 );
    k := 0;
    RETURN;
END_IF;

(* Determina se lastra grossa? *)
(* vbBufRot_BigSheet := ...  *)

(* Calcolo la diagonale della lastra da ruotare *)
vqRot_Diag := fnLength_DINT(vqBufRot_GlassWidth, vqBufRot_GlassHeight);

(* Distanza tra centro di rotazione e i punti di collisione *)
Rmax_dtch := fnLength_DINT( vqX_CollTopDtch - vqBufRot_Xc,  vqY_CollTopDtch - vqBufRot_Yc );
Rmax_feed := fnLength_DINT( vqX_CollTopFeed - vqBufRot_Xc,  vqY_CollTopFeed - vqBufRot_Yc );


(* --- Vediamo se si può fare --- *)

(* Vedi se devo calcolarmi io la posizione bordo avanti *)
IF vqBufRot_GlassXfwd=NO_POS_UM THEN
    (* La posizione in X dipende dal senso di rotazione, infatti il bordo sotto deve essere a 'vqYo_SheetFeed' *)
    IF k=1 THEN
        (* Rotazione +90°: il bordo indietro diventa il bordo sotto *)
        vqBufRot_GlassXfwd := vqBufRot_Xc + vqBufRot_GlassWidth - (vqBufRot_Yc - vqYo_SheetFeed - vqBufRot_Yfix);
    ELSIF k=-1 THEN
        (* Rotazione -90°: il bordo avanti diventa il bordo sotto *)
        vqBufRot_GlassXfwd := vqBufRot_Xc + (vqBufRot_Yc - vqYo_SheetFeed - vqBufRot_Yfix);
        dlog( Txt:='Xfwd=Xc+Yc-Yo=%ld+%ld-%ld=%ld', Lvl:=4, Val1:=vqBufRot_Xc/1E3, Val2:=vqBufRot_Yc/1E3, Val3:=(vqYo_SheetFeed+vqBufRot_Yfix)/1E3, Val4:=vqBufRot_GlassXfwd/1E3 );
    ELSE
        (* In ogni altro caso centro la lastra *)
        vqBufRot_GlassXfwd := vqBufRot_Xc + vqBufRot_GlassWidth/2;
        (* dlog( Txt:='fbCalcRotBuf: Centering on cup Xfwd=Xc+W/2=%ld+%ld=%ld', Lvl:=4, Val1:=vqBufRot_Xc/1E3, Val2:=vqBufRot_GlassWidth/2E3, Val3:=vqBufRot_GlassXfwd/1E3 ); *)
    END_IF;
END_IF;

(* Calcolo inerzie e distanze *)
CalcRotData( W:=TO_LREAL(vqBufRot_GlassWidth)/1.0E6,
             H:=TO_LREAL(vqBufRot_GlassHeight)/1.0E6,
             D:=TO_LREAL(vqGlass_Thckn)/1.0E6,
             DXc:=TO_LREAL(vqBufRot_Xc-vqBufRot_GlassXfwd+vqBufRot_GlassWidth)/1.0E6,
             DYc:=TO_LREAL(vqBufRot_Yc-vqBufRot_GlassYbtm)/1.0E6 );
(* Calculated: vdRot_Dm, vdRot_Rmax, vdRot_Mass, vdRot_Jgrab *)


(* Controlli fattibilità dopo i calcoli *)
(* Il centro di rotazione deve essere interno alla lastra
IF NOT fnInRange_DINT(vqBufRot_GlassXfwd - vqBufRot_Xc, 0, vqBufRot_GlassWidth) OR
   NOT fnInRange_DINT(vqBufRot_Yc - vqBufRot_GlassYbtm, 0, vqBufRot_GlassHeight) THEN
    dlog( Txt:='fbCalcRotBuf: !! C outside glass', Lvl:=2 );
    k := 0;
    RETURN;  *)
(* Di più: la ventosa non deve uscire dal vetro *)
IF (vqBufRot_Xc - vqBufRot_Radius) < (vqBufRot_GlassXfwd - vqBufRot_GlassWidth) OR
   (vqBufRot_Xc + vqBufRot_Radius) > vqBufRot_GlassXfwd OR
   (vqBufRot_Yc + vqBufRot_Radius) > (vqBufRot_GlassYbtm + vqBufRot_GlassHeight) OR
   (vqBufRot_Yc - vqBufRot_Radius) < vqBufRot_GlassYbtm THEN
    dlog( Txt:='!! Cup outside glass %ldx%ld fwd=%ld btm=%ld', Lvl:=2, Val1:=vqBufRot_GlassWidth/1E3, Val2:=vqBufRot_GlassHeight/1E3, Val3:=vqBufRot_GlassXfwd/1E3, Val4:=vqBufRot_GlassYbtm/1E3 );
    k := 0;
    RETURN;
(* Non deve essere troppo pesante *)
ELSIF TO_DINT(1.0E3 * vdRot_Mass) > vqBufRot_MassMax THEN
    dlog( Txt:='!! Too heavy %ld > %ld Kg', Lvl:=2, Val1:=TO_DINT(vdRot_Mass), Val2:=vqBufRot_MassMax/1E3 );
    k := 0;
    RETURN;
END_IF;

(*                                                              R3 +---+ R2
   Calcolo le distanze tra il centro di rotazione e i vertici      |\ /|
                                                     y^            | C |
                                                      |            |/ \|
                                                      +--> x    R0 +---+ R1 *)
R0 := fnLength_DINT( vqBufRot_GlassXfwd - vqBufRot_GlassWidth - vqBufRot_Xc, vqBufRot_GlassYbtm                        - vqBufRot_Yc );
R1 := fnLength_DINT( vqBufRot_GlassXfwd                       - vqBufRot_Xc, vqBufRot_GlassYbtm                        - vqBufRot_Yc );
R2 := fnLength_DINT( vqBufRot_GlassXfwd                       - vqBufRot_Xc, vqBufRot_GlassYbtm + vqBufRot_GlassHeight - vqBufRot_Yc );
R3 := fnLength_DINT( vqBufRot_GlassXfwd - vqBufRot_GlassWidth - vqBufRot_Xc, vqBufRot_GlassYbtm + vqBufRot_GlassHeight - vqBufRot_Yc );

(* Default posizione della lastra ruotata: non ruotata *)
Xfwd_rot := vqBufRot_GlassXfwd;
Ybtm_rot := vqBufRot_GlassYbtm;

(* Ingombro effettivo della rotazione *)
(* A seconda della rotazione *)
IF k=1 THEN
    (* Rotazione +90° (rispetto sist. rif. macchina)
            +-------------------+
            ¦    __.--''\ 2     ¦
            ¦ 3''        \      ¦
            ¦   \   \  .  \     ¦
            ¦    \ _.O'    \    ¦
            ¦     \   \     \   ¦
            ¦      \   __..-- 1 ¦  y^
            ¦     0 --'         ¦   |
            +-------------------+   +--> x   *)

    R_feed := MAX(R2, R3); (* Per controllo collisione lato carico *)
    R_dtch := MAX(R1, R2); (* Per controllo collisione lato stacco *)

    vqRot_Xmin := vqBufRot_Xc - R3;
    vqRot_Xmax := vqBufRot_Xc + R1;
    vqRot_Ymin := vqBufRot_Yc - R0;
    vqRot_Ymax := vqBufRot_Yc + R2;

    (* Posizione della lastra ruotata *)
    Xfwd_rot := vqBufRot_Xc + (vqBufRot_Yc - vqBufRot_GlassYbtm);
    Ybtm_rot := vqBufRot_Yc - (vqBufRot_Xc - (vqBufRot_GlassXfwd - vqBufRot_GlassWidth));

ELSIF k=-1 THEN
    (* Rotazione -90° (rispetto sist. rif. macchina)
            +-------------------+
            ¦     3 /'.._       ¦
            ¦      /     ``-.   ¦
            ¦     /         / 2 ¦
            ¦    /_  /     /    ¦
            ¦   /  'O._   /     ¦
            ¦ 0 `-./     /      ¦  y^
            ¦      `-._ / 1     ¦   |
            +-------------------+   +--> x   *)

    R_feed := MAX(R3, R0); (* Per controllo collisione lato carico *)
    R_dtch := MAX(R2, R3); (* Per controllo collisione lato stacco *)

    vqRot_Xmin := vqBufRot_Xc - R0;
    vqRot_Xmax := vqBufRot_Xc + R2;
    vqRot_Ymin := vqBufRot_Yc - R1;
    vqRot_Ymax := vqBufRot_Yc + R3;

    (* Posizione della lastra ruotata *)
    Xfwd_rot := vqBufRot_Xc + (vqBufRot_GlassYbtm + vqBufRot_GlassHeight - vqBufRot_Yc);
    Ybtm_rot := vqBufRot_Yc - (vqBufRot_GlassXfwd - vqBufRot_Xc);

ELSIF k=2 THEN
    (* Rotazione +180° (rispetto sist. rif. macchina)
            +-------------------+
            ¦    __.--''\ 2     ¦
            ¦ 3''        \      ¦
            ¦   \   \  .  \     ¦
            ¦    \ _.O'    \    ¦
            ¦     \   \     \   ¦
            ¦      \   __..-- 1 ¦  y^
            ¦     0 --'         ¦   |
            +-------------------+   +--> x   *)

    R_feed := MAX(R3, R2); (* Per controllo collisione lato carico *)
    R_dtch := MAX(R2, R1, R0); (* Per controllo collisione lato stacco *)

    vqRot_Xmin := vqBufRot_Xc - MAX(R3,R2);
    vqRot_Xmax := vqBufRot_Xc + MAX(R1,R0);
    vqRot_Ymin := vqBufRot_Yc - MAX(R0,R3);
    vqRot_Ymax := vqBufRot_Yc + MAX(R2,R1);

    (* Posizione della lastra ruotata *)
    Xfwd_rot := vqBufRot_Xc + (vqBufRot_Xc - (vqBufRot_GlassXfwd - vqBufRot_GlassWidth));
    Ybtm_rot := vqBufRot_Yc - (vqBufRot_GlassYbtm + vqBufRot_GlassHeight - vqBufRot_Yc);

ELSIF k=-2 THEN
    (* Rotazione -180° (rispetto sist. rif. macchina)
            +-------------------+
            ¦     3 /'.._       ¦
            ¦      /     ``-.   ¦
            ¦     /         / 2 ¦
            ¦    /_  /     /    ¦
            ¦   /  'O._   /     ¦
            ¦ 0 `-./     /      ¦  y^
            ¦      `-._ / 1     ¦   |
            +-------------------+   +--> x   *)

    R_feed := MAX(R3, R0); (* Per controllo collisione lato carico *)
    R_dtch := MAX(R2, R3, R0); (* Per controllo collisione lato stacco *)

    vqRot_Xmin := vqBufRot_Xc - MAX(R0,R1);
    vqRot_Xmax := vqBufRot_Xc + MAX(R2,R3);
    vqRot_Ymin := vqBufRot_Yc - MAX(R1,R2);
    vqRot_Ymax := vqBufRot_Yc + MAX(R3,R0);

    (* Posizione della lastra ruotata *)
    Xfwd_rot := vqBufRot_Xc + (vqBufRot_Xc - (vqBufRot_GlassXfwd - vqBufRot_GlassWidth));
    Ybtm_rot := vqBufRot_Yc - (vqBufRot_GlassYbtm + vqBufRot_GlassHeight - vqBufRot_Yc);
ELSE
    (* Non ha senso ruotare più di 180° *)
    dlog( Txt:='!! Unsupported %ld deg', Lvl:=4, Val1:=90 * TO_DINT(k) );
    k := 0;
    RETURN;
END_IF;


(* -- Determina fattibilità della rotazione -- *)

(* Controllo collisione con spalla lato stacco *)
IF R_dtch >= Rmax_dtch THEN
    dlog( Txt:='!! Dtch collision R=%ld > %ld', Lvl:=2, Val1:=R_dtch/1E3, Val2:=Rmax_dtch/1E3 );
    k := 0;
(* Controllo collisione con spalla lato carico *)
ELSIF R_feed >= Rmax_feed THEN
    dlog( Txt:='!! Feed collision R=%ld > %ld', Lvl:=2, Val1:=R_feed/1E3, Val2:=Rmax_feed/1E3 );
    k := 0;
(* La lastra ruotata dovrebbe avere una posizione 'Ybtm_rot ~ vqYo_SheetFeed'
   Non deve essere sotto le rotelle e deve essere leggibile dalla fotocellula si stacco *)
ELSIF Ybtm_rot<0 OR Ybtm_rot>=vqYph_DtchLast THEN
    dlog( Txt:='!! Ybtm_rot=%ld mm (vqYph_DtchLast=%ld)', Lvl:=2, Val1:=Ybtm_rot/1E3, Val2:=vqYph_DtchLast/1E3 );
    k := 0;
(* Controllo ingombro X sul carico (eventuali lastre presenti sul carico) *)
ELSIF vqRot_Xmin < Xmin THEN
    dlog( Txt:='!! Xmin=%ld < %ld mm', Lvl:=2, Val1:=vqRot_Xmin/1E3, Val2:=Xmin/1E3 );
    k := 0;
(* Nota: altri vincoli di uscita dal tavolo o altre collisioni dovrebbero
         essere implicitamente rispettati dato il montaggio ventosa e
         posizionamento lastra *)
(* Controllo ingombro X a fine linea
ELSIF vqRot_Xmax > (vqX_AlgnTableEnd + vqRot_MaxLeanOut) THEN
    dlog( Txt:='fbCalcRotBuf: !! Xmax=%ld > %ld mm', Lvl:=2, Val1:=vqRot_Xmax/1E3, Val2:=((vqX_AlgnTableEnd + vqRot_MaxLeanOut))/1E3 );
    k := 0; *)
(* Controllo ingombro Y in alto
ELSIF vqRot_Ymax > (vq[ivqAx_PosLim+AX_YSUP-1] + vqRot_MaxLeanOut) THEN
    dlog( Txt:='fbCalcRotBuf: !! Ymax=%ld > %ld mm', Lvl:=2, Val1:=vqRot_Ymax/1E3, Val2:=(vq[ivqAx_PosLim+AX_YSUP-1] + vqRot_MaxLeanOut)/1E3 );
    k := 0; *)
ELSE
    (* Se qui si può fare *)
    (* k := k_des; (* Già fatto all'inizio *)
    dlog( Txt:='%ld deg (x=%ld|%ld)', Lvl:=4, Val1:=90 * TO_DINT(k), Val2:=vqRot_Xmin/1E3, Val3:=vqRot_Xmax/1E3 );
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbCalcRotData

{ DE:"Calcolo dati derivati della lastra in rotazione" }

	VAR_INPUT
	W : LREAL; { DE:"Larghezza lastra da ruotare [m]" }
	H : LREAL; { DE:"Altezza lastra da ruotare [m]" }
	D : LREAL; { DE:"Spessore vetro da ruotare [m]" }
	DXc : LREAL; { DE:"X relativo centro rotazione [m]" }
	DYc : LREAL; { DE:"Y relativo centro rotazione [m]" }
	END_VAR

	VAR_EXTERNAL
	vdRot_Rmax : LREAL; { DE:"Distanza tra punto presa e vertice più lontano [m]" }
	vdRot_Dm : LREAL; { DE:"Distanza tra punto presa e centro di massa lastra in rotazione [m]" }
	vdRot_Mass : LREAL; { DE:"Massa della lastra in rotazione [Kg]" }
	vdRot_Jgrab : LREAL; { DE:"Momento d'inerzia rispetto il centro di massa della lastra in rotazione [Kg m²]" }
	END_VAR

	{ CODE:ST }(*    fbCalcRotData (Strato M-series)
    ----------------------------------------------

    OVERVIEW
    ----------------------------------------------
    Calcolo dati derivati          3 +---------+ 2
    della lastra in rotazione        |         |
    per la cinematica e            H | (Xc,Yc) |
    dinamica del movimento           |  o      |
                                   0 +---------+ 1
    CONTRACT                              W
    ----------------------------------------------
    Assumo lastra rettangolare omogenea
    Centro di rotazione all'interno della lastra

    EXAMPLE OF USAGE
    ----------------------------------------------
    CalcRotData : fbCalcRotData; { DE:"Calcoli comuni lastra in rotazione" }
    CalcRotData( W:=TO_LREAL(vqW)/1.0E6, H:=TO_LREAL(vqH)/1.0E6, D:=TO_LREAL(vqThckn)/1.0E6,
                 DXc:=TO_LREAL((vqDXc)/1.0E6, DYc:=TO_LREAL(vqDYc)/1.0E6 );
    // Calculated: vdRot_Dm, vdRot_Rmax, vdRot_Mass, vdRot_Jgrab
*)

(* Distanza tra centro di rotazione e vertici
vdRot_R0 := fnLength(   DXc,   DYc );
vdRot_R1 := fnLength( W-DXc,   DYc );
vdRot_R2 := fnLength( W-DXc, H-DYc );
vdRot_R3 := fnLength(   DXc, H-DYc );
(* Distanza tra centro rotazione e vertice più lontano
vdRot_Rmax := MAX( vdRot_R0, vdRot_R1, vdRot_R2, vdRot_R3 ); *)

(* Ma poiché so che il centro di rotazione è all'interno della lastra: *)
vdRot_Rmax := fnLength( MAX(DXc,W-DXc), MAX(DYc,H-DYc) );
(* Assicuro non nullo, evitiamo divisioni per zero *)
IF vdRot_Rmax<1.0 THEN vdRot_Rmax:=1.0; END_IF;

(* Distanza tra centro rotazione e centro di massa
   √(W/2 - (Xc-Xo))² + (H/2 - (Yc-Yo))² *)
vdRot_Dm := fnLength( W/2.0 - DXc, H/2.0 - DYc );

(* Massa *)
vdRot_Mass := GlassDensity * D * W * H; (* [Kg] *)

(* Momento di inerzia
   Rispetto il centro di massa di un rettangolo omogeneo è:
                Jm = M·(w²+h²)/12  [Kg m²]
   Su un'asse parallelo è:
                J' = Jm + M·d² *)
vdRot_Jgrab := vdRot_Mass * ((W*W) + (H*H)) / 12.0; (* [Kg m²] *)
vdRot_Jgrab := vdRot_Jgrab + (vdRot_Mass * vdRot_Dm * vdRot_Dm); (* [Kg m²] *)
    (* Momenti di inerzia tipici
       Lastra 1000x1000 3+3 presa a 500: J=6.5 Kgm²
       Lastra 6000x3210 10+10 presa a 2500: J=13680 Kgm² *)
(* Assicuro non nullo, evitiamo divisioni per zero *)
IF vdRot_Jgrab<0.1 THEN vdRot_Jgrab:=0.1; END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbAlignable

{ DE:"Controllo riscontrabilità di un vetro" }

	VAR_INPUT
	ybtm : DINT; { DE:"Bottom edge" }
	ytop : DINT; { DE:"Top edge" }
	END_VAR

	VAR_OUTPUT
	ok : BOOL; { DE:"Almeno due piedini intersecano l'area" }
	none : BOOL; { DE:"Nessun piedino interseca l'area" }
	idx_btm : INT; { DE:"Indice primo piedino in basso che riscontra [1..vnAlgnBlks_N]" }
	idx_top : INT; { DE:"Indice ultimo piedino in alto che riscontra [1..vnAlgnBlks_N]" }
	END_VAR

	VAR_EXTERNAL
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	ivqAlgnBlks_Y : INT; { DE:"Accesso alle ordinate dei piedini di riscontro" }
	vnAlgnBlks_N : INT; { DE:"Numero dei piedini di riscontro" }
	END_VAR

	{ CODE:ST }(*

    OVERVIEW
    ----------------------------------------------
    Given the align blocks ordinate array, check
    if a vertical edge is intersecated by at least
    two align blocks.

               - ■ - -  Y₃
    ytop +----+
         |    |- ■ - -  Y₂
         |    |- ■ - -  Y₁
    Ymin +----+
        --------------------->

    EXAMPLE OF USAGE
    ----------------------------------------------
    Alignable( ybtm:=vqY_BtmEdge, ytop:=vqY_TopEdge );
    IF Alignable.q THEN ... // Riscontra almeno con due piedini
    // Per controllare collisione con un corpo:
    Alignable( ybtm:=YroomM-vqAlgnBlks_R, ytop:=YroomP+vqAlgnBlks_R );
    IF Alignable.ok THEN ... È riscontrabile
    ELSIF Alignable.none THEN ... Non collide con i piedini
*)

(* Cerco il primo piedino in basso *)
idx_btm := 1;
WHILE idx_btm <= vnAlgnBlks_N DO
    IF vq[ivqAlgnBlks_Y+idx_btm] > ytop THEN
        (* Ho superato il vetro! Nessun piedino riscontra *)
        idx_btm := vnAlgnBlks_N + 1;
        idx_top := idx_btm;
        ok := FALSE;
        none := TRUE;
        RETURN;
    ELSIF vq[ivqAlgnBlks_Y+idx_btm] >= ybtm THEN
        EXIT; (* Lo riscontra! Trovato piedino basso *)
    ELSE
        idx_btm := idx_btm + 1; (* See upper next *)
    END_IF;
END_WHILE;
(* Se nessun piedino trovato idx_btm=vnAlgnBlks_N+1 *)

(* Cerco l'ultimo piedino in alto *)
idx_top := vnAlgnBlks_N; (* Upper block *)
WHILE idx_top > idx_btm DO
    IF vq[ivqAlgnBlks_Y+idx_top] < ytop THEN
        EXIT; (* Lo riscontra! Trovato piedino alto *)
    ELSE
        (* Questo non lo riscontra, vedo quello sotto *)
        idx_top := idx_top - 1; (* See lower next *)
    END_IF;
END_WHILE;
(* Se nessun piedino trovato: idx_btm=vnAlgnBlks_N+1, idx_top=vnAlgnBlks_N *)
(* Se ho trovato un piedino basso ma non trovo il piedino alto: idx_top=idx_btm *)

(* Riscontrabilità: almeno due piedini *)
ok := idx_btm<idx_top;
none := idx_btm>vnAlgnBlks_N;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbTiltable

{ DE:"Controllo basculabilità con ribaltina fine linea" }

	VAR_INPUT
	ybtm : DINT; { DE:"Bottom edge ordinate [um]" }
	ytop : DINT; { DE:"Top edge ordinate [um]" }
	xbck : DINT; { DE:"Abscissa of backward edge [um]" }
	xfwd : DINT; { DE:"Abscissa of forward edge [um]" }
	END_VAR

	VAR_OUTPUT
	q : BOOL; { DE:"Result" }
	idx_btm : INT; { DE:"Indice primo braccio in basso che appoggia [1..vnTiltOutArms_N]" }
	idx_top : INT; { DE:"Indice ultimo braccio in alto che appoggia [1..vnTiltOutArms_N]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	ivqTiltOutArms_Y : INT; { DE:"Accesso alle ordinate dei piedini di riscontro" }
	vnTiltOutArms_N : INT; { DE:"Numero dei piedini di riscontro" }
	vqTiltOut_Xo : DINT; { DE:"Ascissa dei piedini automatici della ribaltina [um]" }
	vqTiltOut_ArmLength : DINT; { DE:"Lunghezza delle braccia ribaltina [um]" }
	vqTiltOut_ArmWidth : DINT; { DE:"Larghezza braccia ribaltina [um]" }
	vqTiltOut_MinWidth : DINT; { DE:"Minima larghezza da ribaltare [um]" }
	vqTiltOut_MaxWidth : DINT; { DE:"Massima larghezza ribaltabile automaticamente [um]" }
	END_VAR

	{ CODE:ST }(*

      OVERVIEW
      ----------------------------------------------
      Check the tiltability of a piece with the
      tilt arms on line end, given arms ordinates

      CONTRACT
      ----------------------------------------------
      Assumes sheet not rotated and homogeneous
        ==========- Y₃
      ytop +----+
        ===|====|=- Y₂
        ===|====|=- Y₁
      Ybtm +----+
      --------------------->

      EXAMPLE OF USAGE
      ----------------------------------------------
      Tiltable( ybtm:=vqY_BtmEdge, ytop:=vqY_TopEdge, xbck:=Xbck, xfwd:=Xfwd );
      IF Tiltable.q THEN ...
*)

dlog( Txt:='fbTiltable: Checking x:%ld|%ld y:%ld|%ld', Lvl:=3, Val1:=xbck/1E3, Val2:=xfwd/1E3, Val3:=ybtm/1E3, Val4:=ytop/1E3 );

(* --- Dimensioni nel range indicato dall'operatore --- *)
q := fnInRange_DINT(xfwd-xbck, vqTiltOut_MinWidth, vqTiltOut_MaxWidth);
IF NOT q THEN
    dlog( Txt:='! w=%ld (%ld|%ld)', Lvl:=2, Val1:=(xfwd-xbck)/1E3, Val2:=vqTiltOut_MinWidth/1E3, Val3:=vqTiltOut_MaxWidth/1E3 );
    RETURN;
END_IF;

(* --- Controllo ribaltabilità in X --- *)
q := fnInRange_DINT(vqTiltOut_Xo-xfwd, -1E3, 150E3) AND (* Il bordo avanti deve precedere i piedini ma non troppo *)
    (xbck+(xfwd-xbck)/2) > (vqTiltOut_Xo-vqTiltOut_ArmLength); (* Baricentro entro le braccia *)
IF NOT q THEN
    dlog( Txt:='! Bad X', Lvl:=2 );
    RETURN;
END_IF;

(* --- Controllo ribaltabilità in Y --- *)
(* Vediamo le braccia estreme che lo ribaltano *)
(* Cerco il primo braccio in basso *)
idx_btm := INT#1;
WHILE idx_btm <= vnTiltOutArms_N DO
    IF vq[ivqTiltOutArms_Y+idx_btm] > ytop THEN
        (* Ho superato il vetro! Nessun braccio trovato *)
        idx_btm := vnTiltOutArms_N + INT#1;
        idx_top := idx_btm;
        q := FALSE;
        dlog( Txt:='! No arms', Lvl:=2 );
        RETURN;
    ELSIF ybtm < (vq[ivqTiltOutArms_Y+idx_btm] + vqTiltOut_ArmWidth/2) THEN
        EXIT; (* Appoggia! Ho trovato il braccio basso *)
    ELSE
        idx_btm := idx_btm + INT#1; (* See upper next *)
    END_IF;
END_WHILE;

(* Cerco l'ultimo braccio in alto *)
idx_top := vnTiltOutArms_N;
WHILE idx_top > idx_btm DO
    IF ytop > (vq[ivqTiltOutArms_Y+idx_top] - vqTiltOut_ArmWidth/2) THEN
        EXIT; (* Appoggia! Ho trovato il braccio alto *)
    ELSE
        idx_top := idx_top - INT#1; (* See lower next *)
    END_IF;
END_WHILE;
(* Nota: se non trovo il braccio alto: idx_top==idx_btm *)

(* Ribaltabilità Y *)
q := idx_btm<idx_top AND (* Almeno due braccia... *)
     fnInRange_DINT(ybtm+(ytop-ybtm)/2, vq[ivqTiltOutArms_Y+idx_btm], vq[ivqTiltOutArms_Y+idx_top]); (* Baricentro entro le braccia *)
IF NOT q THEN
    dlog( Txt:='! Bad Y (Yb%d=%ld Yb%d=%ld)', Lvl:=2, Val1:=TO_DINT(idx_btm), Val2:=vq[ivqTiltOutArms_Y+idx_btm]/1E3, Val3:=TO_DINT(idx_top), Val4:=vq[ivqTiltOutArms_Y+idx_top]/1E3 );
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbShiftable

{ DE:"Controllo trasportabilità con cinghie" }

	VAR_INPUT
	iY : INT; { DE:"Belts ordinates array vq index" }
	N : INT; { DE:"Belts number" }
	W : DINT; { DE:"Belt width [um]" }
	ybtm : DINT; { DE:"Bottom edge ordinate [um]" }
	ytop : DINT; { DE:"Top edge ordinate [um]" }
	END_VAR

	VAR_OUTPUT
	q : BOOL; { DE:"Result" }
	idx_btm : INT; { DE:"Indice prima cinghia che appoggia [1..N]" }
	idx_top : INT; { DE:"Indice ultima cinghia che appoggia [1..N]" }
	END_VAR

	VAR_EXTERNAL
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	vqBelts_MinGripDY : DINT; { DE:"Minima banda Y contatto gomma-vetro per trasportabilità [um]" }
	END_VAR

	{ CODE:ST }(*

      OVERVIEW
      ----------------------------------------------
      Un pezzo è trasportabile automaticamente con
      cinghie se attraversato da almeno due cinghie.
      Le ordinate si riferiscono a quelle dello stacco,
      si può assumere che le altre siano più o meno
      allineate.
      Una cinghia appoggia abbastanza al vetro se
      la banda di contatto è almeno vqBelts_MinGripDY.

      EXAMPLE OF USAGE
      ----------------------------------------------
      Shiftable( iY:=ivqDtchBelts_Y, N:=vnDtchBelts_N, W:=vqDtchBelts_Size,
                 ybtm:=vqY_BtmEdge, ytop:=vqY_TopEdge );
      IF Shiftable.q THEN ...
*)

(* Cerco la prima cinghia in basso *)
idx_btm := INT#1;
WHILE idx_btm <= N DO
    IF vq[iY+idx_btm] > ytop THEN
        (* Ho superato il vetro! Nessuna cinghia trovata *)
        idx_btm := N + INT#1;
        idx_top := idx_btm;
        q := FALSE;
        RETURN;
    ELSIF ybtm <= (vq[iY+idx_btm] + W/2 - vqBelts_MinGripDY) THEN
        EXIT; (* Appoggia! Ho trovato la cinghia bassa *)
    ELSE
        idx_btm := idx_btm + INT#1; (* See upper next *)
    END_IF;
END_WHILE;

(* Cerco l'ultima cinghia in alto *)
idx_top := N;
WHILE idx_top > idx_btm DO
    IF ytop > (vq[iY+idx_top] - W/2 + vqBelts_MinGripDY) THEN
        EXIT; (* Appoggia! Ho trovato la cinghia alta *)
    ELSE
        idx_top := idx_top - INT#1; (* See lower next *)
    END_IF;
END_WHILE;
(* Nota: se non trovo la cinghia alta: idx_top==idx_btm *)

(* Traslabilità con cinghie: almeno due cinghie *)
q := idx_btm<idx_top;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbSelectProdVents

{ DE:"Seleziona zone cuscino aria riscontro" }

	VAR_INPUT
	Xfwd : DINT; { DE:"Ascissa bordo avanti lastra [um]" }
	Ytop : DINT; { DE:"Ordinata bordo superiore lastra [um]" }
	END_VAR

	VAR_OUTPUT
	Mask : INT; { DE:"Maschera ventilatori da azionare" }
	END_VAR

	VAR_EXTERNAL
	vqX_AlgnBandC : DINT; { DE:"Ascissa fine zona cuscino aria riscontri taglio [um]" }
	vqY_AlgnBandB : DINT; { DE:"Ordinata fine zona cuscino aria riscontri banda bassa [um]" }
	vqY_AlgnBandM : DINT; { DE:"Ordinata fine zona cuscino aria riscontri banda mediana [um]" }
	END_VAR

	{ CODE:ST }(*

    OVERVIEW
    ----------------------------------------------
    Seleziona quali zone cuscino aria riscontro
    azionare data la posizione e le dimensioni
    lastra.
    Mantenere coerente con 'SelectProdVents.src'
*)

(* A livello di X *)
IF Xfwd < vqX_AlgnBandC THEN
    (* Praticamente il vetro non appoggia sui riscontri *)
    Mask := 0; (* Non accendo niente *)
ELSIF Xfwd < (vqX_AlgnBandC + 200E3) THEN
    (* Solo quelli del premilastra *)
    Mask := BIT_VENT_ALGN_C;
ELSE
    (* Il vetro appoggia un bel po' *)
    Mask := BIT_VENT_ALGN_C OR BIT_VENT_ALGN_B;

    (* Vediamo le Y: so quanto è alto e assumo dove potrebbe essere posizionato *)
    IF Ytop > (vqY_AlgnBandM + 200E3) THEN
        Mask := Mask OR BIT_VENT_ALGN_M OR BIT_VENT_ALGN_T;
    ELSIF Ytop > (vqY_AlgnBandB + 200E3) THEN
        Mask := Mask OR BIT_VENT_ALGN_M;
    END_IF;
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbSelectRemnVents

{ DE:"Seleziona zone cuscino aria zona rimanenza" }

	VAR_INPUT
	Xbck : DINT; { DE:"Ascissa bordo indietro lastra [um]" }
	END_VAR

	VAR_OUTPUT
	Mask : INT; { DE:"Maschera ventilatori da azionare" }
	END_VAR

	VAR_EXTERNAL
	vqDtch_Xbegin : DINT; { DE:"Ascissa inizio zona stacco [um]" }
	vqFeed_Xend : DINT; { DE:"Ascissa bordo avanti del tavolo di carico [um]" }
	END_VAR

	{ CODE:ST }(*

    OVERVIEW
    ----------------------------------------------
    Seleziona quali zone cuscino aria zona rimanenza
    azionare data la posizione lastra.
    Mantenere coerente con 'SelectRemnVents.src'
*)

Mask := 0; (* Default: non accendo niente *)

IF Xbck < -200E3 THEN (* Se sforo oltre il taglio per più di 20cm *)
    Mask := Mask OR BIT_VENT_DTCH; (* Richiedi ventilatori modulo stacco *)

    IF Xbck < (vqDtch_Xbegin-200E3) THEN (* Se sforo oltre lo stacco per più di 20cm *)
        Mask := Mask OR BIT_VENT_BUF; (* Richiedi ventilatori modulo polmone *)

        IF Xbck < (vqFeed_Xend-300E3) THEN (* Se sforo sul carico per più di 30cm *)
            Mask := Mask OR BIT_VENT_FEED; (* Richiedi ventilatori modulo carico *)
            (* Nota: Uso solo BIT_VENT_FEED per non far muovere le lastre accumulate *)
        END_IF;
    END_IF;
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbCalcAlgnDelta

{ DE:"Calcola spazio di riscontro" }

	VAR_INPUT
	Width : DINT; { DE:"Larghezza lastra [um]" }
	Height : DINT; { DE:"Altezza lastra [um]" }
	Align : DINT; { DE:"Quota di arrivo riscontro [um]" }
	END_VAR

	VAR_OUTPUT
	Delta : DINT; { DE:"Risultato del calcolo [um]" }
	Excess : DINT; { DE:"Sforamento della quota massima [um]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	vqAlgn_MinDelta : DINT; { DE:"Spostamento minimo di riscontro garantito [um]" }
	vqAlgn_AddDelta : DINT; { DE:"Spostamento di riscontro aggiuntivo per lastre basse [um]" }
	vqAlgnBlks_DY1_2 : DINT; { DE:"Distanza tra piedino di riscontro 1 e 2 [um]" }
	vqShift_MaxTurn : DINT; { DE:"Massimo fuori squadra ammesso dopo traslazione [mdeg]" }
	vqAlgnMax : DINT; { DE:"Massima quota riscontrabile (senza spazio riscontro) [um]" }
	END_VAR

	{ CODE:ST }(*

    OVERVIEW
    ----------------------------------------------
    Calcola lo spostamento necessario per
    riscontrare una lastra avente certe dimensioni.

    DETAILS
    ----------------------------------------------
    Se la lastra è "bassa" la proiezione su X del
    lato da riscontrare è sì più piccola, ma è
    anche più piccola la coppia esercitata dai
    piedini ravvicinati.
    Se la lastra è larga ha bisogno di più momento
    per raddrizzarsi, quindi serve più spazio
*)

(* Il delta riscontro è dato dalla somma di:
   .Minimo fisso garantito
   .Raddrizzamento lastra ruotata: proiezione attesa dell'altezza su x *)
Delta := vqAlgn_MinDelta +
         TO_DINT( TO_LREAL(Height) * SIN(MDEG2RAD * TO_LREAL(vqShift_MaxTurn)) );

(* Malus a lastre larghe e basse *)
IF Height<=0 THEN
    (* Intercettiamo altezza ignota, aumentiamo di un po' *)
    Delta := Delta + vqAlgn_AddDelta;
ELSIF Width>Height AND Height>vqAlgnBlks_DY1_2 THEN
    (* Lastra più larga che alta, riscontrabile automaticamente:
       aumento spazio di riscontro, che al massimo  è 'vqAlgn_AddDelta'
       su lastre con aspect ratio 0.25 ad es. 2000x500 *)
    Delta := Delta + TO_DINT( TO_LREAL(vqAlgn_AddDelta) * MIN(1.0, 0.25 * TO_LREAL(Width) / TO_LREAL(Height)) );
END_IF;

(* Controllo: rileva sforamento riscontro massimo *)
Excess := (Align + Delta) - vqAlgnMax;
IF Excess > 0 THEN
    (* Con questo spazio di riscontro andrei fuori limite (Xr.PosLim)
       Mi sforzo comunque di riscontrare sacrificando lo spazio di riscontro *)
    Delta := MAX(vqAlgnMax - Align, 0);
    (* Nota: La sequenza di riscontro cercherà di riscontrare sacrificando
             il margine di salita piedini vqAlgn_UpMargin => vqAlgn_MinUpMargin *)

    (* Notifico eventuale decremento dello spazio di riscontro per riscontrare vicino al limite *)
    dlog( Txt:='! Align %ld exceeds by %ld mm, Delta=%ld', Lvl:=2, Val1:=Align/1E3, Val2:=Excess/1E3, Val3:=Delta/1E3 );
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbGuessSheetSize

{ DE:"Reimposta dimensioni lastra da fotocellule" }

	VAR_EXTERNAL
	vqProc_Algn : DINT; { DE:"Quota riscontro per taglio/processazione [um]" }
	fcDtchLast : fbPhotoCell; { DE:"Ultima fotocellula su modulo stacco (IFC_DTCH_LAST)" }
	fcDtchBegin : fbPhotoCell; { DE:"Fotocellula inizio modulo stacco (IFC_DTCH_BEGIN)" }
	fcBufBegin : fbPhotoCell; { DE:"Fotocellula inizio zona polmone (IFC_BUF_BEGIN)" }
	fcFeedEnd : fbPhotoCell; { DE:"Fotocellula fine modulo di carico (IFC_FEED_END)" }
	vqProd_Width : DINT; { DE:"Dimensione longitudinale prodotto del taglio [um]" }
	vqRemn_Width : DINT; { DE:"Dimensione longitudinale rimanenza del taglio [um]" }
	vqCut_Height : DINT; { DE:"Lunghezza taglio/altezza pezzi dichiarata [um]" }
	vqSubSheet_Width : DINT; { DE:"Dimensione longitudinale lastra in arrivo [um]" }
	vqSubSheet_Height : DINT; { DE:"Dimensione trasversale lastra in arrivo [um]" }
	vqSubSheet_ProcWidth : DINT; { DE:"Dimensione longitudinale lastra in arrivo (dopo la rotazione) [um]" }
	vqSubSheet_ProcHeight : DINT; { DE:"Dimensione trasversale lastra in arrivo (dopo la rotazione) [um]" }
	vdSubSheet_Mass : LREAL; { DE:"Massa della sottolastra corrente [Kg]" }
	vdProd_Mass : LREAL; { DE:"Massa del prodotto del passo corrente [Kg]" }
	vdRemn_Mass : LREAL; { DE:"Massa della rimanenza del passo corrente [Kg]" }
	vdSubSheet_Jm : LREAL; { DE:"Momento d'inerzia rispetto il centro di massa sottolastra corrente [Kg m²]" }
	vdProd_Jm : LREAL; { DE:"Momento d'inerzia rispetto il centro di massa del prodotto [Kg m²]" }
	vdRemn_Jm : LREAL; { DE:"Momento d'inerzia rispetto il centro di massa della rimanenza [Kg m²]" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqRemn_DtchMinWidth : DINT; { DE:"Rimanenza minima separabile automaticamente [um]" }
	vqHoldPadsAlgn_X : DINT; { DE:"Ascissa dei tamponi fermavetro (lato riscontro) [um]" }
	vqDtch_CurrX : DINT; { DE:"Posizione attuale del modulo di stacco [um]" }
	vqDXph_DtchBegin : DINT; { DE:"Offset fotocellula inizio stacco/esp rifili 'IFC_DTCH_BEGIN' [um]" }
	vqDXph_DtchLast : DINT; { DE:"Offset ultima fotocellula su stacco 'IFC_DTCH_LAST' [um]" }
	vqXph_BufBegin : DINT; { DE:"Ascissa fotocellula inizio polmone 'IFC_BUF_BEGIN' [um]" }
	vqXph_FeedEnd : DINT; { DE:"Ascissa fotocellula fine carico 'IFC_FEED_END' [um]" }
	vqYmax : DINT; { DE:"Ordinata massima del bordo vetro [um]" }
	vnMach_Type : INT; { DE:"Tipo macchina (0:Dummy 1:StratoS 10:StratoW 11:ActiveHP)" }
	vnBuf_Type : INT; { DE:"Tipo modulo/zona polmone" }
	END_VAR

	{ CODE:ST }(*

    OVERVIEW
    ----------------------------------------------
    Cerca di capire le dimensioni lastra in base
    a quota di riscontro e stato delle fotocellule,
    usato in caso di 'vbSloppyManual'.
    Modifica i dati del passo!
    Vedi anche 'GuessSheetSize.src'

    CONTRACT
    ----------------------------------------------
    .Passo di lavorazione valorizzato
    .Lastra più o meno in posizione
*)

(* La larghezza del prodotto è molto facile: *)
vqProd_Width := vqProc_Algn; (* Quota di riscontro *)

(* La larghezza della rimanenza da fotocellule: *)
IF fcFeedEnd.q AND fcBufBegin.q AND fcDtchBegin.q AND fcDtchLast.q THEN
    (* Arrivo fino a fine carico, assumo 1m oltre la fotocellula *)
    vqRemn_Width := TO_DINT(1000E3) - vqXph_FeedEnd;
ELSIF fcBufBegin.q AND fcDtchBegin.q AND fcDtchLast.q THEN
    (* Arrivo fino a inizio polmone *)
    vqRemn_Width := -vqXph_BufBegin;
ELSIF (fcDtchBegin.q OR (vnMach_Type=1 AND vnBuf_Type>0)) AND fcDtchLast.q THEN (* Le StratoS non hanno IFC_DTCH_BEGIN! *)
    (* Arrivo fino a inizio stacco, assumo 1m oltre la fotocellula *)
    vqRemn_Width := TO_DINT(1000E3) - (vqDtch_CurrX+vqDXph_DtchBegin);
ELSIF fcDtchLast.q THEN
    (* Arrivo fino a fine stacco, assumo 2cm oltre la fotocellula *)
    vqRemn_Width := TO_DINT(20E3) - (vqDtch_CurrX+vqDXph_DtchLast);
ELSE
    (* Non sento vetro in zona rimanenza
       Su macchine StratoW/HP assicuro ciclica rifilo con pericolo di caduta
       Su macchine StratoS voglio i tamponi e non i premilastra per l'incisione *)
    vqRemn_Width := SEL(vnMach_Type>=10,vqHoldPadsAlgn_X,vqRemn_DtchMinWidth);
END_IF;

(* Assumo una altezza pessimistica per assicurare i ventilatori delle bande alte *)
vqCut_Height := vqYmax - 500E3;

(* Ora ho tutte le informazioni per le dimensioni complete,
   assumendo di non avere rotazioni sulla lastra in arrivo *)
vqSubSheet_ProcWidth := vqProd_Width + vqRemn_Width;
vqSubSheet_ProcHeight := vqCut_Height;

vqSubSheet_Width := vqSubSheet_ProcWidth;
vqSubSheet_Height := vqSubSheet_ProcHeight;
(* dlog( Txt:='fbGuessSheetSize: Guessed sheet size %ldx%ld mm', Lvl:=3, Val1:=vqSubSheet_Width/1E3, Val1:=vqSubSheet_Height/1E3 ); *)

(* --Ricalcolo grandezze derivate-- *)
(* Calcolo delle masse *)
vdSubSheet_Mass := fnGlassMass(vqSubSheet_Width,vqSubSheet_Height,vqGlass_Thckn);
vdProd_Mass := fnGlassMass(vqProd_Width,vqCut_Height,vqGlass_Thckn);
vdRemn_Mass := vdSubSheet_Mass - vdProd_Mass;

(* Calcolo dei momenti di inerzia rispetto il centro di massa [Kg m²] *)
(* Nota: il momento d'inerzia su un'asse parallelo è J' = J + M·d²
         sullo spigolo del rettangolo è Jmax = M·(w²+h²)/3   *)
vdSubSheet_Jm := vdSubSheet_Mass * (POW(TO_LREAL(vqSubSheet_Width)/1.0E6,2.0)+POW(TO_LREAL(vqSubSheet_Height)/1.0E6,2.0)) / 12.0; (* M·(w²+h²)/12 *)
vdProd_Jm := vdProd_Mass * (POW(TO_LREAL(vqProd_Width)/1.0E6,2.0)+POW(TO_LREAL(vqCut_Height)/1.0E6,2.0)) / 12.0; (* M·(w²+h²)/12 *)
vdRemn_Jm := vdRemn_Mass * (POW(TO_LREAL(vqRemn_Width)/1.0E6,2.0)+POW(TO_LREAL(vqCut_Height)/1.0E6,2.0)) / 12.0; (* M·(w²+h²)/12 *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbGuessSheetPos

{ DE:"Valuta posizione lastra da fotocellule" }

	VAR_INPUT
	W : DINT; { DE:"Larghezza lastra [um]" }
	END_VAR

	VAR_OUTPUT
	Xfwd : DINT; { DE:"Posizione bordo avanti [um]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	fcDtchLast : fbPhotoCell; { DE:"Ultima fotocellula su modulo stacco (IFC_DTCH_LAST)" }
	fcDtchBegin : fbPhotoCell; { DE:"Fotocellula inizio modulo stacco (IFC_DTCH_BEGIN)" }
	fcBufBegin : fbPhotoCell; { DE:"Fotocellula inizio zona polmone (IFC_BUF_BEGIN)" }
	fcFeedEnd : fbPhotoCell; { DE:"Fotocellula fine modulo di carico (IFC_FEED_END)" }
	vqDtch_CurrX : DINT; { DE:"Posizione attuale del modulo di stacco [um]" }
	vqDXph_DtchLast : DINT; { DE:"Offset ultima fotocellula su stacco [um]" }
	vqDXph_DtchBegin : DINT; { DE:"Offset fotocellula inizio stacco/esp rifili [um]" }
	vqDtch_Xbegin : DINT; { DE:"Ascissa inizio zona stacco [um]" }
	vqXph_BufBegin : DINT; { DE:"Ascissa fotocellula inizio polmone [um]" }
	vqXph_FeedBegin : DINT; { DE:"Ascissa fotocellula inizio carico [um]" }
	vqXph_FeedEnd : DINT; { DE:"Ascissa fotocellula fine carico [um]" }
	vqFeed_Xend : DINT; { DE:"Ascissa bordo avanti del tavolo di carico [um]" }
	vbExtractDone : BOOL; { DE:"Sottolastra in arrivo estratta da carico" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vbSloppyManual : BOOL; { DE:"Modalità manuale senza inserire dimensioni lastra" }
	END_VAR

	{ CODE:ST }(*

    OVERVIEW
    ----------------------------------------------
    Cerca di capire la posizione della lastra
    in base allo stato delle fotocellule

    DETAILS
    ----------------------------------------------
    La lastra viene posta più indietro possibile
    per assicurare tutto lo spostamento avanti
    necessario.
    Xfwd deve essere sempre negativo, in modo
    che se assegnato a vqSubSheet_X non verrà mai
    ereditato dal passo seguente.

    CONTRACT
    ----------------------------------------------
    .Passo di lavorazione valorizzato
    .Lastra più o meno in posizione
*)

(* Stima posizione X lastra *)
IF fcDtchLast.q THEN
    (* dlog( Txt:='fbGuessSheetPos: On IFC_DTCH_LAST', Lvl:=3 ); *)
    (* Pongo il vetro prima della fotocellula impegnata:
       questa posizione incoerente forzerà la manovra di
       disimpegno fotocellula *)
    Xfwd := (vqDtch_CurrX+vqDXph_DtchLast) - 20E3;
ELSIF fcDtchBegin.q THEN
    (* dlog( Txt:='fbGuessSheetPos: On IFC_DTCH_BEGIN', Lvl:=3 ); *)
    Xfwd := vqDtch_CurrX+vqDXph_DtchBegin;
ELSIF fcBufBegin.q THEN
    (* dlog( Txt:='fbGuessSheetPos: On IFC_BUF_BEGIN', Lvl:=3 ); *)
    Xfwd := vqXph_BufBegin;
ELSIF fcFeedEnd.q THEN
    (* dlog( Txt:='fbGuessSheetPos: On IFC_FEED_END', Lvl:=3 ); *)
    Xfwd := vqXph_FeedEnd;
ELSIF vbSloppyManual AND NOT vbAutoMode THEN
    (* Se non conosco dimensioni lastra, assicuro un certo spostamento *)
    Xfwd := vqXph_FeedBegin;
ELSIF NOT vbExtractDone THEN
    (* A casa di zio, ma comunque sul tavolo *)
    Xfwd := vqXph_FeedBegin + W;
ELSE (* La lastra dovrebbe essere già in zona processazione, eppure nessuna fotocellula impegnata, boh *)
    Xfwd := MIN(vqDtch_Xbegin, vqDtch_CurrX+vqDXph_DtchLast - 20E3, -1000E3);
END_IF;
dlog( Txt:='fbGuessSheetPos: Assuming in Xfwd=%ld mm', Lvl:=2, Val1:=Xfwd/1E3 );

(* Assunzione posizione Y lastra
Y := vqYo_SheetFeed; *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbMachSettings

{ DE:"Valorizza i parametri sacri" }

	VAR_IN_OUT
	Load : BOOL; { DE:"Load command" }
	Save : BOOL; { DE:"Save command" }
	END_VAR

	VAR_OUTPUT
	JustLoaded : BOOL; { DE:"Valori appena caricati (alto per un ciclo)" }
	Loaded : BOOL; { DE:"Valori caricati" }
	END_VAR

	VAR_EXTERNAL
	Cnc : fbCncM32; { DE:"Cnc device" }
	dlog : fbLog; { DE:"Logging facility" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vbMachSettings : BOOL; { DE:"Lettura effettuata" }
	vqSwVer : DINT; { DE:"Versione definizioni" }
	vqMachSettingsVer : DINT; { DE:"Versione file parametri macchina" }
	vaMachName : VASTR; { DE:"Machine name" }
	vaRelNotes : VASTR; { DE:"Note di rilascio" }
	END_VAR

	VAR
	UdtData : fbUdtData; { DE:"Caricamento dei dati utente" }
	END_VAR

	{ CODE:ST }(*    fbMachSettings (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Carica il file 'MachSettings.udt' contenente
      i parametri macchina.

      SIGNALS
      ----------------------------------------------
        Load __――――――――――_____
      Loaded ____________――――― (ok)
      Loaded _________________ (error)

      EXAMPLE OF USAGE
      ----------------------------------------------
      MachSettings : fbMachSettings; { DE:"Caricamento dei parametri macchina" }
      IF MachSettings.Load THEN
          MachSettings();
          IF NOT MachSettings.Load AND NOT MachSettings.Loaded THEN
              -Load error!-
          END_IF;
      END_IF;
*)
IF JustLoaded THEN
    JustLoaded := FALSE;
    (* Controllo valori parametri (CheckMachPars.src)
       Viene chiamato nel programma Homing-*.src
       Se canale disponibile, provo a lanciare anche da qui *)
    IF Cnc.Chn1.Status=CS_READY THEN
        Cnc.Chn1.PrgPth := 'CheckMachPars.obj';
        Cnc.Chn1.StartPrg := TRUE;
    END_IF;
    Load := FALSE; (* Signal end of operation *)
ELSIF UdtData.Load THEN
    UdtData(); (* Nota: qui aggiorna UdtData.Load *)
    IF UdtData.Done THEN
        dlog( Txt:='-> Loaded MachSettings.udt v.%ld on defvar v.%ld', Lvl:=2, Val1:=vqMachSettingsVer/1000, Val2:=vqSwVer/1000 );
        (* Valida i settaggi caricati *)
        IF NOT vbMachSettings THEN
            Load := FALSE; (* Signal end of operation *)
            ThrowEmg(Idx:=EMG_CRITICAL, Txt:='vbMachSettings==0');
        (* Confronto la major release della versione SW *)
        ELSIF (vqMachSettingsVer/1000) <> (vqSwVer/1000) THEN
            Load := FALSE; (* Signal end of operation *)
            ThrowEmg(Idx:=EMG_SWVERSION, Txt:='EMG_SWVERSION');
        ELSE
            JustLoaded := TRUE; (* Segnale attivo per un ciclo *)
            Loaded := TRUE;
        END_IF;
    ELSIF NOT UdtData.Load THEN
        Load := FALSE; (* Signal end of operation *)
        vbMachSettings := FALSE; (* Assicuro falso *)
        ThrowEmg(Idx:=EMG_CRITICAL, Txt:='Cannot load MachSettings.udt');
    END_IF;
ELSE
    IF Load THEN
        dlog( Txt:='! Loading MachSettings.udt', Lvl:=2 );

        (* Inizializzo alcuni dati che si caricheranno *)
        vbMachSettings := FALSE;
        vaMachName := '';
        vaRelNotes := '';

        Loaded := FALSE;
        UdtData.Pth := 'MachSettings.udt';
        UdtData.Chn := 1;
        UdtData.Load := TRUE;
        UdtData();

    ELSIF Save THEN
        dlog( Txt:='Saving to MachSettings-curr.udt', Lvl:=1 );
        UdtData.Pth := 'MachSettings-curr.udt';
        UdtData.Chn := 1;
        UdtData.Save := TRUE;
        UdtData();
        Save := FALSE; (* Signal end of operation *)
    END_IF;
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbParDefaults

{ DE:"Valorizza i parametri utente" }

	VAR_IN_OUT
	Load : BOOL; { DE:"Load command" }
	Save : BOOL; { DE:"Save command" }
	END_VAR

	VAR_OUTPUT
	Loaded : BOOL; { DE:"Valori caricati" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	vbParDefaults : BOOL; { DE:"Lettura effettuata" }
	END_VAR

	VAR
	UdtData : fbUdtData; { DE:"Caricamento dei dati utente" }
	END_VAR

	{ CODE:ST }(*    fbParDefaults (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Carica il file 'ParDefaults.udt' contenente
      i parametri utente di default.

      SIGNALS
      ----------------------------------------------
        Load __――――――――――_____
      Loaded ____________――――― (ok)
      Loaded _________________ (error)

      EXAMPLE OF USAGE
      ----------------------------------------------
      ParDefaults : fbParDefaults; { DE:"Caricamento dei parametri utente" }
      IF ParDefaults.Load THEN
          ParDefaults();
          IF NOT ParDefaults.Load AND NOT ParDefaults.Loaded THEN
              -Load error!-
          END_IF;
      END_IF;
*)
IF UdtData.Load THEN
    UdtData(); (* Nota: qui aggiorna UdtData.Load *)
    IF UdtData.Done THEN
        Load := FALSE; (* Signal end of operation *)
        IF NOT vbParDefaults THEN
            dlog( Txt:='fbParDefaults: !! vbParDefaults still null', Lvl:=0 );
        (* ELSE
            dlog( Txt:='fbParDefaults: Loaded', Lvl:=2 ); *)
        END_IF;
        Loaded := TRUE;
        (* I parametri caricati verranno validati al momento *)
    ELSIF NOT UdtData.Load THEN
        Load := FALSE; (* Signal end of operation *)
        dlog( Txt:='fbParDefaults: !! Cannot load ParDefaults.udt', Lvl:=0 );
    END_IF;
ELSE
    IF Load THEN
        dlog( Txt:='Loading ParDefaults.udt', Lvl:=2 );
        vbParDefaults := FALSE; (* Scritto nel file UDT *)
        Loaded := FALSE;
        UdtData.Pth := 'ParDefaults.udt';
        UdtData.Chn := 1;
        UdtData.Load := TRUE;
        UdtData();

    ELSIF Save THEN
        dlog( Txt:='Saving to ParDefaults-curr.udt', Lvl:=1 );
        UdtData.Pth := 'ParDefaults-curr.udt';
        UdtData.Chn := 1;
        UdtData.Save := TRUE;
        UdtData();
        Save := FALSE; (* Signal end of operation *)
    END_IF;
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbMachine

{ DE:"Stato della macchina" }

	VAR_INPUT
	Busy : BOOL; { DE:"Something is working" }
	Test : BOOL; { DE:"Enter in test mode" }
	ActReady : BOOL; { DE:"Actuators and main drives are enabled and ready" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato automa generale" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	MachSettings : fbMachSettings; { DE:"Machine parameters" }
	vnMach_Type : INT; { DE:"Tipo macchina 'ID_MACHINE'" }
	Cnc : fbCncM32; { DE:"Cnc device" }
	vbBtnStop : BOOL; { DE:"Richiesta di fermare/abortire il lavoro" }
	vbStopSignal : BOOL; { DE:"Dispatched stop request signal to freeze/abort current operation" }
	vbHomingDone : BOOL; { DE:"Homing-*.src was successfully executed" }
	vnProcPhase : INT; { DE:"Fase corrente della sequenza di processazione/taglio" }
	vnDeferredAction : INT; { DE:"Azione programmata a macchina pronta" }
	vbBtnPark : BOOL; { DE:"Ripristino macchina e parcheggio assi" }
	vbBtnStartCut : BOOL; { DE:"Esegui la processazione della lastra riscontrata" }
	vbBtnMoveAndAlign : BOOL; { DE:"Esegui posizionamento e riscontro vetro (lastra sui riscontri)" }
	vbBtnStartStep : BOOL; { DE:"Esegui il passo di lavorazione" }
	vnShapeProc_Cmd : INT; { DE:"Comando sequenze processazione sagoma" }
	END_VAR

	VAR
	TinitPulse : Tpulse; { DE:"A beat during startup" }
	BusyDelayedOff : Toff; { DE:"Delay off of Busy signal" }
	END_VAR

	{ CODE:ST }(*    Machine status (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Machine status
*)

(* Ritarda lo spegnimento del segnale busy *)
BusyDelayedOff( in:=Busy, pt:=200 );


(* ---- Core state machine ---- *)
CASE Status OF

    (*
    MS_PAUSING / MS_RESUMING
    Cnc.Chn1.Status=CS_HOLD
    Cnc.Chn1.Status=CS_RUN
    *)

    (* ------------------------------------------------------------------- *)
    MS_BUSY : (* --------------------------------------------------------- *)
        (*
          The machine is doing something (the CNC is running).
          Check when done, and if a stop (hold) is given.
        *)
        (* TODO 3: Freeze? *)
        IF NOT BusyDelayedOff.q THEN
            Status := MS_JUSTDONE;
        ELSE
            (* Working *)

            (* Se va via qualche consenso mentre si lavora:
            IF Freeze / NOT Allow THEN
                (* Suspend sequences
                Cnc.Chn1.Hold := TRUE; (* Ensure an immediate stop
                Status := MS_HALTING; (* Start Halting sequence
            END_IF;
            *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_READY : (* -------------------------------------------------------- *)
        (*
          If here the axes and CNC are ready, so the machine can move.
          Here must check those requirements and if machine go busy.
        *)
        IF NOT ActReady THEN
            Status := MS_JUSTOFFLINE;
        ELSIF Test THEN
            Status := MS_TEST;
        ELSIF Busy THEN
            Status := MS_BUSY;
        ELSIF vnDeferredAction<>CMD_STOP THEN
            dlog( Txt:='fbMachine: Deferred action %d', Lvl:=3, Val1:=TO_DINT(vnDeferredAction) );
            (* Nota: Se siamo qui vbHomingDone è vero *)
            CASE vnDeferredAction OF
                CMD_PARK: vbBtnPark := TRUE;
                CMD_STARTCUT: vbBtnStartCut := TRUE;
                CMD_AUTOALGN: vbBtnMoveAndAlign := TRUE;
                CMD_STARTSTEP: vbBtnStartStep := TRUE;
                CMD_STARTSHAPE: vnShapeProc_Cmd := 1;
                (* CMD_CUSTOM1: vbBtnCustom1 := TRUE; *)
                (* CMD_CUSTOM2: vbBtnCustom2 := TRUE; *)
                ELSE dlog( Txt:='!! Unknown action %d', Lvl:=2, Val1:=TO_DINT(vnDeferredAction) );
            END_CASE;
            vnDeferredAction := CMD_STOP; (* Eat *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_ONLINE : (* ------------------------------------------------------- *)
        (*
          Here the axes are zeroed and ready, now it's
          time to check if the CNC device is ready
        *)
        IF NOT ActReady THEN
            Status := MS_JUSTOFFLINE;
        ELSIF Test THEN
            Status := MS_TEST;
        ELSIF Cnc.Ok AND Cnc.Chn1.Status=CS_READY THEN
            Status := MS_JUSTREADY;
        ELSIF Cnc.Ok AND Busy THEN
            Status := MS_BUSY;
        ELSE
            SET_MSG(MSG_CNCNOTREADY, 'MSG_CNCNOTREADY', 0);
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_OFFLINE : (* ------------------------------------------------------ *)
        (*
          Here the axes are not ready, time to check
          when they turn back operative (power-on)
        *)
        IF ActReady THEN
            Status := MS_JUSTONLINE;
        ELSIF Test THEN
            Status := MS_TEST;
        ELSE
            SET_MSG(MSG_DRIVESOFFLINE,'MSG_DRIVESOFFLINE',TO_DINT(Status));
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_HOMING : (* ------------------------------------------------------- *)
        (*
          If here the Homing program is running,
          check what happened after execution
        *)
        (* Check homing done *)
        IF Cnc.Chn1.Status=CS_HOMING THEN
            (* Wait homing completion *)
            SET_MSG(MSG_HOMING,'MSG_HOMING',TO_DINT(Status));
        ELSE
            RST_MSG(MSG_HOMING);
            (* See result *)
            IF vbHomingDone THEN
                Status := MS_ONLINE;
            ELSE
                dlog( Txt:='fbMachine: !! Homing not completed', Lvl:=2 );
                Status := MS_WAITHOMING;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_WAITHOMING : (* --------------------------------------------------- *)
        (*
          Axes are powered but not yet zeroed, waiting
          homing command to perform axes zeroing
          Note: somewhere there is Cnc.Chn1.StartHoming
        *)
        IF NOT ActReady THEN
            (* Axes/Actuations no more ready *)
            RST_MSG(MSG_WAITHOMING);
            Status := MS_JUSTOFFLINE;
        ELSIF Test THEN
            RST_MSG(MSG_WAITHOMING);
            Status := MS_TEST;
        ELSIF Cnc.Chn1.Status=CS_HOMING THEN
            RST_MSG(MSG_WAITHOMING);
            Status := MS_HOMING;
        ELSE
            SET_MSG(MSG_WAITHOMING,'MSG_WAITHOMING',TO_DINT(Status));
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_ERROR : (* -------------------------------------------------------- *)
        (*
          An error (alarm or emergency) is occurred!
        *)
        IF NOT Cnc.Error THEN
            Status := MS_JUSTRESTORED;
        ELSIF Test THEN
            Status := MS_TEST;
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_JUSTDONE : (* ----------------------------------------------------- *)
        (*
          This is a transition status (active for one PLC cycle)
          the machine has just completed a busy state
        *)
        (* dlog( Txt:='[[MS_JUSTDONE]]', Lvl:=6 ); *)
        vnProcPhase := 0;
        Status := MS_ONLINE;


    (* ------------------------------------------------------------------- *)
    MS_JUSTRESTORED : (* ------------------------------------------------- *)
        (*
          This is a transition status (active for one PLC cycle)
          An emergency is just restored (Follows 'MS_ERROR')
        *)
        dlog( Txt:='[[MS_JUSTRESTORED]]', Lvl:=5 );
        Status := MS_UNKNOWN; (* See what to do *)


    (* ------------------------------------------------------------------- *)
    MS_JUSTERROR : (* ---------------------------------------------------- *)
        (*
          This is a transition status (active for one PLC cycle)
          An emergency is just occurred! (Precedes 'MS_ERROR')
        *)
        dlog( Txt:='[[MS_JUSTERROR]]', Lvl:=5 );
        vbStopSignal := FALSE; (* Remove dispatched stop signal *)

        (* TODO 4: Assicura di rifare l'azzeramento se...
        IF Cnc.CritEmg THEN
            vbHomingDone := FALSE; (* Force homing
        END_IF; *)
        Status := MS_ERROR;


    (* ------------------------------------------------------------------- *)
    MS_JUSTREADY : (* ---------------------------------------------------- *)
        (*
          This is a transition status (active for one PLC cycle)
          from now the machine is ready to move
        *)
        dlog( Txt:='[[MS_JUSTREADY]]', Lvl:=5 );
        RST_MSG(MSG_CNCNOTREADY);
        RST_MSG(MSG_MACHNOTREADY); (* Usato per dare feedback ai comandi *)
        IF vbHomingDone THEN
            Status := MS_READY;
        ELSE
            Status := MS_WAITHOMING;
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_JUSTONLINE : (* --------------------------------------------------- *)
        (*
          This is a transition status (active for one PLC cycle)
          from now axes are ready (to be zeroed or to start)
        *)
        dlog( Txt:='[[MS_JUSTONLINE]]', Lvl:=5 );
        RST_MSG(MSG_DRIVESOFFLINE);
        Status := MS_ONLINE;


    (* ------------------------------------------------------------------- *)
    MS_JUSTOFFLINE : (* -------------------------------------------------- *)
        (*
          This is a transition status (active for one PLC cycle)
          from now axes are no more ready
        *)
        dlog( Txt:='[[MS_JUSTOFFLINE]]', Lvl:=5 );
        Status := MS_OFFLINE;


    (* ------------------------------------------------------------------- *)
    MS_JUSTINIT : (* -------------------------------------------------- *)
        (*
          This is a transition status (active for one PLC cycle)
          from now the machine is initialized
        *)
        (* Operazioni una tantum all'inizializzazione *)
        dlog( Txt:='[[MS_JUSTINIT]]', Lvl:=5 );
        RST_MSG(MSG_BOOTING);
        (* If not an emulated machine, force homing not done *)
        vbHomingDone := vnMach_Type=0;
        (* Could launch a reset here *)
        IF Cnc.Error THEN
            Cnc.Reset := TRUE;
        END_IF;
        Status := MS_JUSTOFFLINE;


    (* ------------------------------------------------------------------- *)
    MS_INIT : (* ----------------------------------------------------- *)
        (*
          Wait subsystems initializations
          I/O and drives fieldbus
        *)
        TinitPulse(in:=Status=MS_INIT, pt:=2500);
        IF TinitPulse.q THEN
            (* Check device/fieldbus init *)
            IF Cnc.Status>DS_INIT THEN
                Status := MS_JUSTINIT;
            ELSE
                SET_MSG(MSG_BOOTING,'MSG_BOOTING', TO_DINT(Status));
                (* Give periodically a reset to remove possible bus errors *)
                Cnc.Reset := TRUE;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_BOOTING : (* ------------------------------------------------------ *)
        (*
          Just executed the 'Init' task
          waiting MachSettings to be properly loaded
        *)
        IF MachSettings.Load THEN
            (* Sta caricando i dati dei settaggi macchina *)
            MachSettings();
        ELSE
            IF MachSettings.Loaded THEN
                Status := MS_INIT;
            ELSE
                dlog( Txt:='fbMachine: !! Cannot read MachSettings.udt', Lvl:=0 );
                Status := MS_ABORT;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_TEST : (* --------------------------------------------------------- *)
        (*
          Forcing IOs, moving axes in semiauto mode
        *)
        IF Test THEN
            SET_MSG(MSG_TESTMODE,'MSG_TESTMODE',TO_DINT(Status));
        ELSE
            RST_MSG(MSG_TESTMODE);
            Status := MS_UNKNOWN;
        END_IF;


    (* ------------------------------------------------------------------- *)
    MS_ABORT : (* -------------------------------------------------------- *)
        (*
          Not recoverable error, block machine until reboot
        *)
        SET_MSG(MSG_ABORTED,'MSG_ABORTED',0);


    (* ------------------------------------------------------------------- *)
    ELSE (* -------------------------------------------------------------- *)
        (* 'MS_UNKNOWN'
          Determina subito stato corrente senza fare troppi "giri"
          Contratto: non impostare 'MS_UNKNOWN' prima di 'MS_JUSTINIT'
        *)
        IF NOT ActReady THEN
            Status := MS_JUSTOFFLINE;
        ELSIF Cnc.Ok AND Cnc.Chn1.Status=CS_READY THEN
            Status := MS_JUSTREADY;
        ELSE
            Status := MS_JUSTONLINE;
        END_IF;

END_CASE; (* --- CASE Status *)


(* -- Overall Hooks -- *)
(* Se Cnc in emergenza, vado nello stato di errore *)
(* Cnc.Status=DS_ERROR *)
IF Cnc.Error AND Status>MS_JUSTINIT AND Status<=MS_UNKNOWN
             AND Status<>MS_JUSTERROR AND Status<>MS_ERROR
             AND Status<>MS_TEST THEN

    (* Ensure a stop signals *)
    dlog( Txt:='fbMachine: ! Dispatching stop on Cnc.Error', Lvl:=5 );
    vbStopSignal := TRUE; (* Dispatch the stop signal *)

    Status := MS_JUSTERROR;
END_IF;


(* -- Monitors -- *)
vn[ivnStatus+ID_MACHINE] := Status;
vb[ivbAtRest+ID_MACHINE] := Status=MS_READY OR Status=MS_ERROR OR Status=MS_ONLINE OR Status=MS_OFFLINE;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbSafety

{ DE:"Manage safety unit signals" }

	VAR_IN_OUT
	RequestEmg : BOOL; { DE:"Manda in emergenza la centralina" }
	AirLamiReady : fbDelayedRise; { DE:"Aria ok per attuazioni modulo laminato" }
	END_VAR

	VAR_OUTPUT
	Rearming : DINT := 0; { DE:"Sequenza di riarmo potenza" }
	DrivesOn : BOOL; { DE:"Consenso generale abilitazione linea assi" }
	AllActReady : BOOL; { DE:"Assi e attuazioni modulo laminato pronte" }
	PneumActReady : BOOL; { DE:"Attuazioni pneumatiche modulo laminato pronte" }
	PreAlarm : BOOL; { DE:"Sicurezze in preallarme" }
	InFeedZone : BOOL; { DE:"Operatore in zona carico/accumulo" }
	InOutZone : BOOL; { DE:"Operatore in zona fine linea" }
	EmgBtn : BOOL; { DE:"An emergency button is pushed" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	Mach : fbMachine; { DE:"Machine status logic" }
	Cnc : fbCncM32; { DE:"Cnc device" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	vbHeartBeat : BOOL; { DE:"Battito di vita 1s" }
	vbBtnReset : BOOL; { DE:"Reset Cnc (emergenze/messaggi)" }
	vbRstSvcs : BOOL; { DE:"Reset subsystems commands/services" }
	vnScu_Type : INT; { DE:"Tipo centralina di sicurezza" }
	vqScu_RearmTime : DINT; { DE:"Tempo attesa riarmo sicurezze [ms]" }
	vqScu_RearmCycles : DINT; { DE:"Cicli attesa riarmo sicurezze (v. vqScu_RearmTime)" }
	vqAirPrsFallMaxTime : DINT; { DE:"Tempo tolleranza cadute pressione di linea [ms]" }
	vqScu_ReleaseDelay : DINT; { DE:"Ritardo per fare uscire l'operatore dalle zone protette [s]" }
	I_SCU_CRITICAL : BOOL; { DE:"Emergenza critica da centralina di sicurezza (funghi, finecorsa)" }
	I_SCU_GATE : BOOL; { DE:"Emergenza cancello aperto" }
	I_SCU_INAIR_MACH : BOOL; { DE:"Pressione aria ingresso modulo laminato (1:OK, dal pressostato)" }
	I_SCU_INAIR_FEED : BOOL; { DE:"Pressione aria ingresso modulo carico (1:OK, dal pressostato)" }
	I_SCU_AIR_MACH : BOOL; { DE:"Presenza aria modulo laminato (tagliata da sicurezze)" }
	I_SCU_SAFETY_MACH : BOOL; { DE:"Intervento sicurezze zona macchina (0:Ok)" }
	I_SCU_SAFETY_IN : BOOL; { DE:"Intervento sicurezze zona a monte della macchina (carico) (0:Ok)" }
	I_SCU_SAFETY_OUT : BOOL; { DE:"Intervento sicurezze zona a valle della macchina (0:Ok)" }
	I_SCU_POW_CA : BOOL; { DE:"Potenza gruppo assi movimentazione carico" }
	I_SCU_POW_C : BOOL; { DE:"Potenza gruppo assi movimentazione laminato (cinghie+pinza)" }
	I_SCU_POW_Y : BOOL; { DE:"Potenza gruppo assi taglio (stacco+carrelli)" }
	I_SCU_POW_X : BOOL; { DE:"Potenza gruppo assi riscontri/fine linea" }
	I_SCU_WARN_MACH : BOOL; { DE:"Preallarme zona macchina" }
	I_SCU_POW_MACH : BOOL; { DE:"Attuazioni modulo di taglio alimentate (1:Ok)" }
	I_SCU_POW_FEED : BOOL; { DE:"Attuazioni modulo di carico alimentate (1:Ok)" }
	I_SCU_POW_TILTOUT : BOOL; { DE:"Ribaltina scarico pezzi alimentata (1:Ok)" }
	I_SCU_POW_CLAMPS : BOOL; { DE:"Premilastra pronti (i premilastra sono gestiti a parte) (1:Ok)" }
	ICM_EMGBTN_MAIN : BOOL; { DE:"Fungo su pulpito principale" }
	ICM_EMGBTN_CABINET : BOOL; { DE:"Fungo su armadio quadro elettrico" }
	ICM_EMGBTN_OUTZONE : BOOL; { DE:"Fungo su pulsantiera fine linea" }
	ICM_EMGBTN_FEED : BOOL; { DE:"Fungo in zona carico (palina barriera)" }
	ICM_EMGBTN_BUF : BOOL; { DE:"Fungo in zona polmone" }
	ICM_EMGBTN_EBRK : BOOL; { DE:"Fungo su tavolo di troncaggio a valle" }
	I_SCU_POWKEYON : BOOL; { DE:"Contatto monostabile chiave linea" }
	IFC_HATCH1_CLOSED : BOOL; { DE:"Sensore sportello ispezione lato operatore chiuso (1:OK)" }
	O_SCU_MACHOK : BOOL; { DE:"Richiesta emergenza da parte della logica di macchina (1:OK)" }
	O_SCU_CANENTER_CUT : BOOL; { DE:"Consenso apertura cancello zona taglio (macchina ferma)" }
	O_SCU_OUTZONE_BUSY : BOOL; { DE:"Segnalazione operatore in zona fine linea (cambio dinamico aree)" }
	END_VAR

	VAR
	SafetyOn : fbEdges; { DE:"Una o più sicurezze intervenute" }
	InAirLami : fbDelayedFall; { DE:"Pressione aria in arrivo a modulo laminato (1:OK)" }
	InAirFeed : Toff; { DE:"Pressione aria in arrivo a carico (1:OK)" }
	AirBlockTout : Ton; { DE:"Rilevazione anomalia scarico aria" }
	TOutZoneBusy : Toff; { DE:"Tempo liberazione area protetta" }
	eOutZoneBusy : fbEdges; { DE:"Fronti liberazione area protetta" }
	val : DINT; { DE:"Temporary" }
	END_VAR

	{ CODE:ST }(*    fbSafety (Project Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Contiene le logiche relative alle sicurezze,
      interazioni con la centralina, messaggistica
      e diagnostica.

      NOTES
      ----------------------------------------------
      Conviene mantenere l'interfaccia generica delle
      define dell'iomap, senza inventarmi una
      ulteriore astrazione dell'interfaccia.

      EXAMPLE OF USAGE
      ----------------------------------------------
      Scu : fbSafety; { DE:"Safety unit" }
      Scu();
*)

(* -- Get signals -- *)
(* Basing on type (0:none 1:Digital-IO 2:Sick-Ethercat) *)
IF vnScu_Type=2 THEN
    IF vb[iVB_SYS_ECAT_OPER] THEN
        (* Read signals from Sick on EtherCAT
           Bits are in: group<x [0÷N-1]> byte<y [0÷n-1]>: vq[ivqScuBits+10*<x>+<y>]
           See also: ivqScuBits,SCU_GROUP_SIZE *)
        (* Nota: I segnali 'O_SCU_*' sono portati col filo *)
        val := vq[ivqScuBits + SCU_GROUP_SIZE*2 + 8]; (* Take G2B8 *)
        I_SCU_CRITICAL := (val & 16#1) <> 0; (* G2B8:0 *)
        I_SCU_GATE := (val & 16#2) <> 0; (* G2B8:1 *)
        (* I_SCU_INAIR_MACH Questo arriva direttamente da ingresso digitale *)
        (* I_SCU_INAIR_FEED Questo arriva direttamente da ingresso digitale *)
        I_SCU_AIR_MACH := (val & 16#80) <> 0; (* G2B8:7 Pressostato a valle *)
        I_SCU_SAFETY_MACH := (val & 16#8) <> 0; (* G2B8:3 *)
    	I_SCU_SAFETY_IN := (val & 16#10) <> 0; (* G2B8:4 *)
    	I_SCU_SAFETY_OUT := (val & 16#20) <> 0; (* G2B8:5 *)
        I_SCU_WARN_MACH := FALSE;
        I_SCU_POW_MACH := (val & 16#40) <> 0; (* G2B8:6 *)

        val := vq[ivqScuBits + SCU_GROUP_SIZE*2 + 9]; (* Take G2B8 *)
        I_SCU_POW_CA := (val & 16#1) <> 0; (* G2B9:0 *)
        I_SCU_POW_C := (val & 16#2) <> 0; (* G2B9:1 *)
        I_SCU_POW_Y := (val & 16#4) <> 0; (* G2B9:2 *)
        I_SCU_POW_X := (val & 16#8) <> 0; (* G2B9:3 *)
        I_SCU_POWKEYON := (val & 16#10) <> 0; (* G2B9:4 *)

        val := vq[ivqScuBits + SCU_GROUP_SIZE*1 + 2]; (* Take G1B2 *)
        I_SCU_POW_CLAMPS := (val & 16#2) <> 0; (* G1B2:1 *)
        I_SCU_POW_TILTOUT := TRUE;
        I_SCU_POW_FEED := I_SCU_POW_CA;

        (* Meglio non leggere direttamente gli ingressi, potrebbero cambiare! * )
        val := vq[ivqScuBits + SCU_GROUP_SIZE*0 + 1]; (* Take G0B1 * )
        I_SCU_POWKEYON := (val & 16#4) <> 0; (* G0B1:2 *)
    ELSE
        (* Default sicuro per i segnali *)
        (* I_SCU_CRITICAL := FALSE; *)
        (* I_SCU_GATE := FALSE; *)
        I_SCU_AIR_MACH := FALSE; (* Meglio non pilotare le proporzionali *)
        (* I_SCU_SAFETY_MACH := FALSE; *)
    	(* I_SCU_SAFETY_IN := FALSE; *)
    	(* I_SCU_SAFETY_OUT := FALSE; *)
        (* I_SCU_WARN_MACH := FALSE; *)
        (* I_SCU_POW_MACH := FALSE; *)
        (* I_SCU_POW_CA := FALSE; *)
        (* I_SCU_POW_C := FALSE; *)
        (* I_SCU_POW_Y := FALSE; *)
        (* I_SCU_POW_X := FALSE; *)
        (* I_SCU_POW_CLAMPS := FALSE; *)
        (* I_SCU_POW_TILTOUT := TRUE; *)
        (* I_SCU_POW_FEED := TRUE; *)
        (* I_SCU_POWKEYON := FALSE; *)
    END_IF;

END_IF;


(* - Pressostati -
    tollero cadute di pressione entro un certo tempo *)
(* Pressione aria in ingresso alla macchina *)
InAirLami( in:=I_SCU_INAIR_MACH, pt:=TO_UDINT(vqAirPrsFallMaxTime) );
InAirFeed( in:=I_SCU_INAIR_FEED, pt:=TO_UDINT(vqAirPrsFallMaxTime) );
(* Aria pronta per le attuazioni (segnale usato per pilotare le proporzionali) *)
AirLamiReady( in:=InAirLami.q AND I_SCU_AIR_MACH, pt:=500 );


(* - Assicura emergenza se gli attuatori pneum non hanno pressione -
     Occhio che il ripristino dell'aria scaricata ci mette 0.7-0.9s,
     non alzare emergenza mentre sto dando la chiave *)
IF NOT InAirLami.q AND Rearming<=0 THEN (* AND vn[ivnStatus+ID_MACHINE]>MS_INIT *)
    SET_MSG(MSG_AIRLOW_LAMI,'MSG_AIRLOW_LAMI',0);
    ThrowEmg(Idx:=EMG_NOAIR, Txt:='EMG_NOAIR');
END_IF;
(* Per quanto riguarda il modulo di carico sono più tollerante,
   in genere non pregiudica il taglio *)

(* Verifica anomalia scarico aria: se centralina in emergenza mi
   aspetto che cada la pressione dell'aria tagliata entro 1s *)
AirBlockTout( in:=I_SCU_CRITICAL AND I_SCU_AIR_MACH, pt:=1000 );
IF AirBlockTout.q AND NOT Cnc.Error THEN
    dlog( Txt:='fbSafety: !! Air not cut off within %ld s', Lvl:=1, Val1:=TO_DINT(AirBlockTout.pt/1E3) );
    ThrowEmg(Idx:=EMG_CRITICAL, Txt:='AirBlockTout');
END_IF;



(* -- Richiesta emergenza da centralina -- *)
IF I_SCU_CRITICAL AND NOT Cnc.Error THEN
    ThrowEmg(Idx:=EMG_SCU, Txt:='EMG_SCU');
END_IF;


(* -- Pulsanti emergenza (funghi) --
   Nota: Questi ingressi sono solo segnalazioni,
         l'azione effettiva è gestita anche dalla centralina di sicurezza,
         io comunque mi assicuro di lanciare un'emergenza *)
EmgBtn := ICM_EMGBTN_MAIN OR ICM_EMGBTN_CABINET OR ICM_EMGBTN_OUTZONE OR
          ICM_EMGBTN_FEED OR ICM_EMGBTN_BUF OR ICM_EMGBTN_EBRK;
IF EmgBtn THEN
    IF ICM_EMGBTN_MAIN AND NOT Cnc.Error THEN (* AND NOT I_SCU_CRITICAL *)
        ThrowEmg(Idx:=EMG_USER, Txt:='EMG_USER (main board)');
    END_IF;
    IF ICM_EMGBTN_CABINET AND NOT Cnc.Error THEN
        ThrowEmg(Idx:=EMG_USER, Txt:='EMG_USER (cabinet)');
    END_IF;
    IF ICM_EMGBTN_OUTZONE AND NOT Cnc.Error THEN
        ThrowEmg(Idx:=EMG_USER, Txt:='EMG_USER (out zone)');
    END_IF;
    IF ICM_EMGBTN_FEED AND NOT Cnc.Error THEN
        ThrowEmg(Idx:=EMG_USER, Txt:='EMG_USER (feed table)');
    END_IF;
    IF ICM_EMGBTN_BUF AND NOT Cnc.Error THEN
        ThrowEmg(Idx:=EMG_USER, Txt:='EMG_USER (buffer)');
    END_IF;
    IF ICM_EMGBTN_EBRK AND NOT Cnc.Error THEN
        ThrowEmg(Idx:=EMG_USER, Txt:='EMG_USER (ebrk)');
    END_IF;
END_IF;


(* Per quanto riguarda altro, lascio che sia la centralina
   a decidere se lanciare una emergenza
IFC_HATCH1_CLOSED, IFC_MAIN_CABINET
IF I_SCU_GATE AND NOT Cnc.Error THEN
    ThrowEmg(Idx:=EMG_SAFETY, Txt:='Gate');
END_IF;
*)


(* -- Riarmo potenza/inserzione linea --
    Quando l'operatore gira la chiave di potenza sul contatto monostabile
    inizia la sequenza di riarmo macchina:
      1) Attende ripristino emergenze della centralina di sicurezza
      2) Dirama il comando di reset macchina
      3) Attendi che l'aria vada in pressione nelle attuazioni pneumatiche
*)
(* PowKeyOn( in:=I_SCU_POWKEYON ); *)
IF Rearming<=0 THEN
    (* Not rearming, see if someone is turning the key on *)
    IF I_SCU_POWKEYON THEN
        dlog( Txt:='fbSafety: Rearming... (%ld cycles timeout)', Lvl:=4, Val1:=vqScu_RearmCycles );
        Rearming := 1;
    END_IF;
ELSIF Rearming<vqScu_RearmCycles THEN
    (* Wait Scu ok with timeout, ex. vqScu_RearmCycles=500*4ms=2s *)
    IF PneumActReady AND NOT I_SCU_CRITICAL THEN
        dlog( Txt:='fbSafety: Rearming: Scu ok on cycle %d, giving reset', Lvl:=4, Val1:=Rearming );
        vbBtnReset := TRUE;
        Rearming := vqScu_RearmCycles; (* Proceed *)
    ELSE
        (* Waiting Scu ok... *)
        Rearming := Rearming + 1;
        (* Intercept rearming timeout *)
        IF Rearming>=vqScu_RearmCycles AND NOT I_SCU_POWKEYON THEN
            dlog( Txt:='fbSafety: !! Rearming timed out (%d cycles) waiting Scu ok', Lvl:=2, Val1:=Rearming );
            Rearming := 0;
        END_IF;
    END_IF;
ELSE
    (* Now wait key release, air pressure and reset done *)
    IF NOT I_SCU_POWKEYON THEN
        (* Chiave rilasciata, rileva se centralina è ancora ok *)
        IF SafetyOn.in THEN
            dlog( Txt:='fbSafety: !! Rearming aborted by Scu', Lvl:=2 );
            Rearming := 0;
        (* Se aria stabilizzata e reset eseguito, ho finito *)
        ELSIF AirLamiReady.q AND NOT vbBtnReset THEN
            (* Rearm completed *)
            RST_MSG_IF_ON(MSG_AIRLOW_LAMI);
            RST_MSG_IF_ON(MSG_AIRLOW_FEED);
            dlog( Txt:='fbSafety: Rearm completed', Lvl:=4 );
            Rearming := 0;
        END_IF;
    END_IF;
END_IF; (* -- sequenza di riarmo *)



(* -- Consenso generale abilitazione linea assi --
   v. anche I_SCU_POWKEYON *)
DrivesOn := I_SCU_POW_Y
            (* AND I_SCU_POW_X (* Questo no per permettere ready anche con riscontri non in linea *)
            AND I_SCU_POW_C; (* Per assicurare abilitazione pinza *)


(* - Segnalazione di sicurezze intervenute modulo laminato - *)
SafetyOn( in:=I_SCU_SAFETY_MACH ); (* OR I_SCU_SAFETY_IN OR I_SCU_SAFETY_OUT *)

(* - Diagnostica sicurezze - *)
IF SafetyOn.rise THEN

    (* Sicurezze intervenute: vediamo perché *)
    IF I_SCU_GATE THEN
        dlog( Txt:='fbSafety: !! Gate', Lvl:=1 );
    ELSIF EmgBtn THEN
        dlog( Txt:='fbSafety: !! Emg btn', Lvl:=1 );
    ELSIF NOT IFC_HATCH1_CLOSED THEN
        dlog( Txt:='fbSafety: !! Hatch opened', Lvl:=1 );
    (* ELSIF NOT IFC_MAIN_CABINET THEN
        dlog( Txt:='fbSafety: !! Cabinet opened', Lvl:=1 ); *)
    ELSIF NOT I_SCU_INAIR_MACH THEN
        dlog( Txt:='fbSafety: !! Air fault on lami module', Lvl:=1 );
    ELSIF NOT I_SCU_INAIR_FEED THEN
        dlog( Txt:='fbSafety: !! Air fault on feed module', Lvl:=1 );
    ELSE
        dlog( Txt:='fbSafety: !! Safety device', Lvl:=1 );
    END_IF;

    (* Notify safety signals *)
    IF NOT I_SCU_POW_Y THEN dlog( Txt:='! CutZone inhibited', Lvl:=1 ); END_IF;
    IF NOT I_SCU_POW_C THEN dlog( Txt:='! Belts inhibited', Lvl:=1 ); END_IF;
    IF NOT I_SCU_POW_X THEN dlog( Txt:='! Algn inhibited', Lvl:=1 ); END_IF;
    IF NOT I_SCU_POW_CA THEN dlog( Txt:='! Feed inhibited', Lvl:=1 ); END_IF;

ELSIF SafetyOn.fall THEN
    (* Sicurezze ripristinate *)
    dlog( Txt:='fbSafety: Restored', Lvl:=3 );
END_IF;


(* - Segnale attuazioni pneumatiche pronte - *)
PneumActReady := I_SCU_POW_MACH AND I_SCU_AIR_MACH;

(* - Segnale attuazioni totali pronte - *)
AllActReady := I_SCU_POW_X AND I_SCU_POW_Y AND I_SCU_POW_C AND PneumActReady AND I_SCU_POW_CLAMPS;
(* AND I_SCU_POW_CA *)
(* Nota: le cinghie carico le considero un po' a parte *)


(* - Sicurezze in preallarme - *)
PreAlarm := I_SCU_WARN_MACH;
(* PreAlarmFeed := I_SCU_WARN_FEED; *)


(* - Zone occupate da operatore - *)
InFeedZone := NOT I_SCU_POW_CA; (* NOT I_SCU_POW_FEED *)
InOutZone := NOT I_SCU_POW_TILTOUT;


(* --- Uscite alla centralina --- *)

(* - Richieste di emergenza alla centralina - *)
(* Notifica emergenza da parte della logica di macchina (1:OK) *)
O_SCU_MACHOK := NOT RequestEmg;
IF RequestEmg AND SafetyOn.in THEN
    (* Safety unit responded, reset request *)
    RequestEmg := FALSE; (* eat *)
    O_SCU_MACHOK := TRUE;
END_IF;

(* Consenso apertura cancello zona taglio *)
O_SCU_CANENTER_CUT := NOT Mach.Busy;

(* Segnale operatore in zona fine linea per separare a mano pezzo preinciso *)
TOutZoneBusy( in:=IS_MSG(REQ_WORK_PRESCORED), pt:=TO_UDINT(vqScu_ReleaseDelay) );
O_SCU_OUTZONE_BUSY := TOutZoneBusy.q;
(* Notifiche nel log *)
eOutZoneBusy( in:=O_SCU_OUTZONE_BUSY );
IF eOutZoneBusy.rise THEN
    dlog( Txt:='fbSafety: ! UserArea permitted', Lvl:=3 );
ELSIF eOutZoneBusy.fall THEN
    dlog( Txt:='fbSafety: ! UserArea protected', Lvl:=3 );
END_IF;

(* - Altre uscite -
   O_SCU_TILTOUT_AUTO: vedi 'fbTiltOut'
   O_SCU_GRABBER_ISON: vedi 'fbGrabber'
*)


(* -- Feedback -- *)
IF vbHeartBeat THEN

    (* Notifica fungo premuto *)
    SET_MSG_IF(EmgBtn,MSG_EMGBUTTON,'MSG_EMGBUTTON',0);

    (* Notifica intervento sicurezze *)
    SET_MSG_IF(SafetyOn.in,MSG_SAFETY_LAMI,'MSG_SAFETY_LAMI',0);

    (* Notifica cancelli non chiusi e riarmati *)
    SET_MSG_IF(I_SCU_GATE,MSG_GATE_LAMI,'MSG_GATE_LAMI',0);

    (* Notifiche mancanza aria: non si auto-resettano *)
    IF NOT InAirFeed.q AND NOT IS_MSG(MSG_AIRLOW_FEED) THEN
        SET_MSG(MSG_AIRLOW_FEED,'MSG_AIRLOW_FEED',0);
    END_IF;

    (* Notifica sportello aperto *)
    SET_MSG_IF(NOT IFC_HATCH1_CLOSED,MSG_HATCH1,'MSG_HATCH1',0);

    (* Notifica armadio quadro aperto
    SET_MSG_IF(NOT IFC_MAIN_CABINET,MSG_MAIN_CABINET,'IFC_MAIN_CABINET',0);
    *)

    (* Notifica attuazioni non pronte *)
    SET_MSG_IF(NOT I_SCU_POW_MACH,MSG_LAMI_NOTREADY,'MSG_LAMI_NOTREADY',0);

    (* Notifica premilastra pneumatici non pronti *)
    IF AO_DTCH_PV1>0 THEN (* vnClampAlgn_Type=1 OR vnClampDtch_Type=1 *)
        SET_MSG_IF(NOT I_SCU_POW_CLAMPS AND vn[ivnStatus+ID_MACHINE]=MS_BUSY,MSG_CLAMPS_NOTREADY,'MSG_CLAMPS_NOTREADY',0);
    END_IF;

END_IF; (* vbHeartBeat *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbProbe

{ DE:"Manage position latches to measure a sheet" }

	VAR_IN_OUT
	Reset : BOOL; { DE:"Reset command" }
	END_VAR

	VAR_INPUT
	Activate : BOOL; { DE:"Attiva catture con sonda" }
	ProbeIdx : INT; { DE:"Indice sonda - IRQ index" }
	AxIdx : INT; { DE:"Indice asse da catturare" }
	Back : BOOL; { DE:"Direzione di movimento" }
	SweepMode : BOOL; { DE:"Modalità spazzata (applica compensazioni e controllo schegge)" }
	END_VAR

	VAR_OUTPUT
	Input : BOOL; { DE:"Stato segnale sull'ingresso veloce" }
	Status : INT; { DE:"Current status" }
	SliversCount : INT; { DE:"Counter of discarded small splinters found" }
	EdgeIn : DINT; { DE:"Measure of enter glass edge [um]" }
	EdgeOut : DINT; { DE:"Measure of exit glass edge [um]" }
	LastRiseLatch : DINT; { DE:"Latch of a rising edge [um]" }
	LastFallLatch : DINT; { DE:"Latch of a falling edge [um]" }
	NewRiseLatch : BOOL; { DE:"Active for one cycle" }
	NewFallLatch : BOOL; { DE:"Active for one cycle" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	vqEdgeDet_FiltSize : DINT; { DE:"Dimensioni filtro pagliuzze (sonde vetro) [um]" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqAdjProbe_Thckn : DINT; { DE:"Spessore complessivo utilizzato nella taratura ricerca [um]" }
	ivqAx_CurrSpd : INT; { DE:"Array monitor velocità corrente assi [um/min]" }
	ivnProbe_Latency : INT; { DE:"Array latenza sonde" }
	ivqProbe_FixFwdIn : INT; { DE:"Array compensazione fissa sonde (entrata verso quote pos)" }
	ivqProbe_FixFwdOut : INT; { DE:"Array compensazione fissa sonde (uscita verso quote pos)" }
	ivqProbe_FixBckIn : INT; { DE:"Array compensazione fissa sonde (entrata verso quote neg)" }
	ivqProbe_FixBckOut : INT; { DE:"Array compensazione fissa sonde (uscita verso quote neg)" }
	ivqProbe_FixThckn : INT; { DE:"Array compensazione distanza sonda-vetro" }
	END_VAR

	VAR
	IrqLatch : fbIrqLatch; { DE:"Facility to get latches" }
	thckn_fix : DINT; { DE:"Correzione spessore [um]" }
	END_VAR

	{ CODE:ST }(*    fbProbe (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Attiva ed elabora le catture della posizione
      di un'asse per dare la misura della lastra.
      Dovrebbe gestire filtro antipagliuzze e
      compensazioni sonda

      COMPENSAZIONI
      ----------------------------------------------
      C'è una differenza tra il fronte di salita e
      di discesa:
                        Y ^ out+|   |in-
                          |=====^===v===
                          |=============
                          |=============
                          |=====^===v===
                             in+|   |out-
      SIGNALS
      ----------------------------------------------
       Activate __―――――――――――――――――――_____

                             PS_DONE
                        ____‾‾‾‾‾‾‾‾‾
         Status __——‾‾‾‾    PS_ABORT _____STS_IDLE
                            ‾‾‾‾‾‾‾‾‾

      EXAMPLE OF USAGE
      ----------------------------------------------
      Probe1 : fbProbe; { DE:"Measure sheet service" }
*)

(* -- Initialize registers service -- *)
IF Reset THEN
    EdgeIn := NO_POS_UM;
    EdgeOut := NO_POS_UM;
    LastRiseLatch := NO_POS_UM;
    LastFallLatch := NO_POS_UM;

    IrqLatch( Reset:=TRUE );

    Reset := FALSE; (* eat *)
END_IF;


(* -- Rapid deactivation service -- *)
IF Status>=PS_ENABLING AND NOT Activate THEN
    IrqLatch( Activate:=FALSE );
    Status := PS_DISABLING;
END_IF;


(* -- Collect raw latches -- *)
(* Segnali attivi per un ciclo: *)
NewRiseLatch := FALSE;
NewFallLatch := FALSE;
IF Status>PS_WAITMOVE THEN
    (* Monitor probe latched position *)
    IrqLatch();

    IF IrqLatch.RiseLatch<>NO_POS_UM THEN
        (* Catturato un fronte di salita *)
        (* Controllo doveroso: scarta catture vicinissime *)
        IF IrqLatch.FallLatch<>NO_POS_UM THEN
            (* Salita e discesa occorsi entro un ciclo di controllo, scarto tutto *)
            dlog( Txt:='fbProbe %d: ! Discarded pulse rise %ld fall %ld um', Lvl:=1, Val1:=TO_DINT(ProbeIdx), Val2:=IrqLatch.RiseLatch, Val3:=IrqLatch.FallLatch);
            SliversCount := SliversCount + 1;
            IrqLatch.RiseLatch := NO_POS_UM; (* Eat latch *)
            IrqLatch.FallLatch := NO_POS_UM; (* Eat latch *)
        ELSE
            (* Registro la cattura del fronte di salita *)
            LastRiseLatch := IrqLatch.RiseLatch + vq[ivqProbe_DY+ProbeIdx];
            IrqLatch.RiseLatch := NO_POS_UM; (* Eat latch *)
            NewRiseLatch := TRUE;
            IF Back THEN (* vq[ivqAx_CurrSpd+AxIdx-1]<0 *)
                (* Entrando sul bordo alto *)
                IF SweepMode THEN (* Applico correzione solo nelle spazzate *)
                    LastRiseLatch := LastRiseLatch + vq[ivqProbe_FixBckIn+ProbeIdx];
                END_IF;
                (* La compensazione spessore alto è verso l'interno del vetro (in basso) *)
                thckn_fix := TO_DINT(TO_LREAL(vqAdjProbe_Thckn-vqGlass_Thckn)/1000.0 * TO_LREAL(vq[ivqProbe_FixThckn+ProbeIdx]));
            ELSE
                (* Entrando sul bordo basso *)
                IF SweepMode THEN (* Applico correzione solo nelle spazzate *)
                    LastRiseLatch := LastRiseLatch + vq[ivqProbe_FixFwdIn+ProbeIdx];
                END_IF;
                (* La compensazione spessore alto è verso l'interno del vetro (in alto) *)
                thckn_fix := TO_DINT(TO_LREAL(vqGlass_Thckn-vqAdjProbe_Thckn)/1000.0 * TO_LREAL(vq[ivqProbe_FixThckn+ProbeIdx]));
            END_IF;
            (* Compensazione distanza sonda-vetro (che varia con lo spessore vetro se la sonda è sopra)
               Se la sonda si avvicina la cattura si allontana dal vetro: dobbiamo compensare verso l'interno *)
            IF thckn_fix<>0 THEN
                dlog( Txt:='fbProbe %d: Thickness fix (rise): %ld um', Lvl:=5, Val1:=TO_DINT(ProbeIdx), Val2:=thckn_fix );
                LastRiseLatch := LastRiseLatch + thckn_fix;
            END_IF;
        END_IF;

    ELSIF IrqLatch.FallLatch<>NO_POS_UM THEN
        (* Catturato un fronte di discesa *)
        (* Controllo doveroso: scarta catture vicinissime *)
        IF IrqLatch.RiseLatch<>NO_POS_UM THEN
            (* Discesa e salita occorsi entro un ciclo di controllo, scarto tutto *)
            dlog( Txt:='fbProbe %d: ! Discarded pulse fall %ld rise %ld um', Lvl:=2, Val1:=TO_DINT(ProbeIdx), Val2:=IrqLatch.FallLatch, Val3:=IrqLatch.RiseLatch);
            SliversCount := SliversCount + 1;
            IrqLatch.RiseLatch := NO_POS_UM; (* Eat latch *)
            IrqLatch.FallLatch := NO_POS_UM; (* Eat latch *)
        ELSE
            (* Registro la cattura del fronte di discesa *)
            LastFallLatch := IrqLatch.FallLatch + vq[ivqProbe_DY+ProbeIdx];
            IrqLatch.FallLatch := NO_POS_UM; (* Eat latch *)
            NewFallLatch := TRUE;
            IF Back THEN (* vq[ivqAx_CurrSpd+AxIdx-1]<0 *)
                (* Uscendo sul bordo basso *)
                IF SweepMode THEN (* Applico correzione solo nelle spazzate *)
                    LastFallLatch := LastFallLatch + vq[ivqProbe_FixBckOut+ProbeIdx];
                END_IF;
                (* La compensazione spessore alto è verso l'interno del vetro (in alto) *)
                thckn_fix := TO_DINT(TO_LREAL(vqGlass_Thckn-vqAdjProbe_Thckn)/1000.0 * TO_LREAL(vq[ivqProbe_FixThckn+ProbeIdx]));
            ELSE
                (* Uscendo sul bordo alto *)
                IF SweepMode THEN (* Applico correzione solo nelle spazzate *)
                    LastFallLatch := LastFallLatch + vq[ivqProbe_FixFwdOut+ProbeIdx];
                END_IF;
                (* La compensazione spessore alto è verso l'interno del vetro (in basso) *)
                thckn_fix := TO_DINT(TO_LREAL(vqAdjProbe_Thckn-vqGlass_Thckn)/1000.0 * TO_LREAL(vq[ivqProbe_FixThckn+ProbeIdx]));
            END_IF;
            (* Compensazione distanza sonda-vetro (che varia con lo spessore vetro se la sonda è sopra)
               Se la sonda si avvicina la cattura si allontana dal vetro: dobbiamo compensare verso l'interno *)
            IF thckn_fix<>0 THEN
                dlog( Txt:='fbProbe %d: Thickness fix (fall): %ld um', Lvl:=5, Val1:=TO_DINT(ProbeIdx), Val2:=thckn_fix );
                LastFallLatch := LastFallLatch + thckn_fix;
            END_IF;
        END_IF;
    END_IF;
END_IF;



(* --- Latch arming sequences --- *)
CASE Status OF

    PS_SEARCHFALL : (* Cerco il fronte di discesa ossia il bordo di uscita *)
        (* IF Activate THEN (* Intercettato a monte *)
        IF NewFallLatch THEN
            (* Catturato un fronte di discesa, forse sto uscendo dal vetro *)
            IF ABS(LastFallLatch-EdgeIn)>vqEdgeDet_FiltSize OR NOT SweepMode THEN
                (* Acquisisco la misura *)
                EdgeOut := LastFallLatch;
                Status := PS_DONE; (* Measure successful *)
                dlog( Txt:='fbProbe %d: Exited in ax%d %ld um ', Lvl:=6, Val1:=TO_DINT(ProbeIdx), Val2:=TO_DINT(IrqLatch.AxIdx), Val3:=EdgeOut );
            ELSE
                (* È una scheggia, devo rifare tutto *)
                dlog( Txt:='fbProbe %d: ! Sliver %ld = %ld-%ld um', Lvl:=2, Val1:=TO_DINT(ProbeIdx), Val2:=(LastFallLatch-EdgeIn), Val3:=LastFallLatch, Val4:=EdgeIn); (* Val4:=vq[ivqAx_CurrSpd+AxIdx-1]/1E6 *)
                SliversCount := SliversCount + 1;
                EdgeIn := NO_POS_UM; (* Discard first measure *)
                Status := PS_SEARCHRISE;
            END_IF;
        ELSIF NewRiseLatch THEN
            (* Catturato un fronte di salita mentre attendo un fronte di discesa: scarto *)
            dlog( Txt:='fbProbe %d: ! Rise at ax%d %ld mm ', Lvl:=2, Val1:=TO_DINT(ProbeIdx), Val2:=TO_DINT(AxIdx), Val3:=LastRiseLatch/1E3 );
            SliversCount := SliversCount + 1;
        END_IF;


    PS_SEARCHRISE : (* Cerco il fronte salita ossia il bordo di entrata *)
        (* IF Activate THEN (* Intercettato a monte *)
        IF NewRiseLatch THEN
            (* Catturato un fronte di salita, forse sto entrando in un vetro *)
            IF EdgeIn=NO_POS_UM THEN
                (* Ok, è la prima cattura *)
                EdgeIn := LastRiseLatch; (* Questo è il bordo di entrata del vetro *)
                Status := PS_SEARCHFALL; (* Adesso cerco il bordo di uscita *)
                dlog( Txt:='fbProbe %d: Entered in ax%d %ld um', Lvl:=6, Val1:=TO_DINT(ProbeIdx), Val2:=TO_DINT(AxIdx), Val3:=EdgeIn );
            ELSE
                (* Non è la prima! Ha mancato un fronte di discesa? *)
                EdgeIn := NO_POS_UM; (* Discard previous measure *)
                Status := PS_ABORT; (* Abortisco misura? *)
                dlog( Txt:='fbProbe %d: !! Missing fall in %ld|%ld', Lvl:=2, Val1:=TO_DINT(ProbeIdx), Val2:=EdgeIn/1E3, Val3:=LastRiseLatch/1E3 );
            END_IF;
        ELSIF NewFallLatch THEN
            (* Catturato un fronte di discesa mentre attendo un fronte di salita: scarto *)
            (* Magari sono partito con la sonda su qualcosa? *)
            dlog( Txt:='fbProbe %d: ! Fall at ax%d %ld mm', Lvl:=3, Val1:=TO_DINT(ProbeIdx), Val2:=TO_DINT(AxIdx), Val3:=LastFallLatch/1E3 );
        END_IF;


    PS_WAITMOVE : (* Wait axis to move *)
        (* IF Activate THEN (* Intercettato a monte *)
        IF ABS(vq[ivqAx_CurrSpd+AxIdx-1]) > 10E3 THEN (* 60E3 um/min = 1 mm/s *)
            Status := PS_SEARCHRISE;
        END_IF;


    PS_ENABLING : (* Wait probe ready *)
        IrqLatch( Activate:=TRUE );
        IF IrqLatch.Status=TS_ON THEN
            (* Warn if probe is already reading *)
            IF IrqLatch.Input THEN
                dlog( Txt:='fbProbe %d: ! Already on glass', Lvl:=3, Val1:=TO_DINT(ProbeIdx));
            END_IF;
            dlog( Txt:='fbProbe %d: Activated', Lvl:=6, Val1:=TO_DINT(ProbeIdx));
            Status := PS_WAITMOVE;
        END_IF;


    PS_DISABLING : (* Deactivating probe *)
        IrqLatch( Activate:=FALSE );
        IF IrqLatch.Status=TS_OFF THEN
            dlog( Txt:='fbProbe %d: Deactivated', Lvl:=6, Val1:=TO_DINT(ProbeIdx));
            Status := STS_IDLE;
        END_IF;


    STS_IDLE :
        IF Activate THEN
            SliversCount := 0;
            (* Reset := TRUE; *)
            EdgeIn := NO_POS_UM;
            EdgeOut := NO_POS_UM;
            LastRiseLatch := NO_POS_UM;
            LastFallLatch := NO_POS_UM;

            (* Lancio function block gestione ingresso veloce *)
            IrqLatch(
                     Irq:=ProbeIdx,
                     AxIdx:=AxIdx,
                     ProbeLatency:=vn[ivnProbe_Latency+ProbeIdx],
                     Activate:=TRUE,
                     Reset:=IrqLatch.Status<>TS_OFF
                    );
            Status := PS_ENABLING;
        END_IF;


    ELSE (* PS_ABORT, PS_DONE : *)
        IF NOT Activate THEN
            IrqLatch( Activate:=FALSE );
            Status := PS_DISABLING;
        END_IF;

END_CASE;

(*  -- Monitors -- *)
Input := IrqLatch.Input;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbVentOnOffSeq

{ DE:"Sequenze attuazione ventilatori cuscino aria" }

	VAR_INPUT
	TurnOnMotor : BOOL; { DE:"Keep motor rotation" }
	Activate : BOOL; { DE:"Open the air flow request" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	ID : INT; { DE:"Component univocal identification index" }
	NotAcq_PowerSource : BOOL := FALSE; { DE:"Do not acquire electrical grid for motor starting" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Status of the system" }
	MotorOutput : BOOL; { DE:"Turn on motor output" }
	ShutOutput : BOOL; { DE:"Open shut output" }
	AirCushionReady : BOOL; { DE:"Cuscino aria pronto" }
	END_VAR

	VAR_EXTERNAL
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	PowerSource : INT; { DE:"Alimentazione elettrica, evitare sovraccarichi" }
	vqVent_RampTime : DINT; { DE:"Attesa motore ventilatore a regime [ms]" }
	vqVent_ShutTime : DINT; { DE:"Attesa apertura/chiusura serranda [ms]" }
	END_VAR

	VAR
	TOnDelay : Ton; { DE:"Ritardo motori a regime" }
	TShutDelay : Ton; { DE:"Ritardo serranda" }
	END_VAR

	{ CODE:ST }(*    fbVentOnOffSeq (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Attuazione dei ventilatori del cuscino d'aria

      Risorse occupate:
        .'PowerSource' (alimentazione elettrica)

      USAGE
      ----------------------------------------------
      VAR
      VentSeq : fbVentOnOffSeq; { DE:"Air blower sequence" }
      END_VAR
*)

(* -- State machine -- *)
TOnDelay( in:=Status=TS_GOINGON OR Status=STS_ERROR, pt:=TO_UDINT(vqVent_RampTime) );
TShutDelay( in:=(Status=TS_WAITON AND ShutOutput) OR Status=TS_GOINGOFF, pt:=TO_UDINT(vqVent_ShutTime) );
CASE Status OF

    TS_ON : (* Motor running, shut opened *)
        ShutOutput := Activate AND Allow;
        MotorOutput := Allow;
        IF NOT ShutOutput THEN
            Status := TS_GOINGOFF; (* Wait shut close *)
        (* ELSIF NOT TurnOnMotor (* Non ha senso fermare il motore! *)
        END_IF;

    TS_WAITON : (* Motor running, shut closed *)
        ShutOutput := Activate AND Allow;
        IF TShutDelay.q THEN
            Status := TS_ON;
        ELSIF NOT Allow OR (NOT TurnOnMotor AND NOT Activate) THEN
            MotorOutput := FALSE;
            Status := TS_WAITOFF;
        END_IF;

    TS_GOINGON : (* Wait motor to reach the speed *)
        IF NOT Allow OR (NOT TurnOnMotor AND NOT Activate) THEN
            IF PowerSource=ID THEN PowerSource := 0; END_IF; (* Motore spento *)
            MotorOutput := FALSE;
            Status := TS_WAITOFF;
        ELSIF TOnDelay.q THEN
            IF PowerSource=ID THEN PowerSource := 0; END_IF; (* Motore avviato *)
            Status := TS_WAITON;
        END_IF;

    TS_GOINGOFF : (* Motor running, waiting shut closing *)
        ShutOutput := FALSE;
        IF TShutDelay.q THEN
            IF TurnOnMotor AND Allow THEN
                Status := TS_WAITON;
            ELSE
                MotorOutput := FALSE;
                Status := TS_WAITOFF;
            END_IF;
        END_IF;

    TS_WAITOFF : (* Waiting motor stop, shut closed *)
        MotorOutput := FALSE;
        Status := SEL(Allow, STS_ERROR, TS_OFF);

    TS_OFF : (* Motor still and shut closed *)
        IF Allow AND (TurnOnMotor OR Activate) THEN
            (* Per partire mi serve acquisire la linea elettrica? *)
            IF PowerSource=0 OR PowerSource=ID OR NotAcq_PowerSource THEN
                IF NOT NotAcq_PowerSource THEN PowerSource := ID; END_IF; (* Acquisisco la linea elettrica *)
                TurnOnMotor := TRUE; (* Assicuro comando motore *)
                MotorOutput := TRUE; (* Spunto motore *)
                Status := TS_GOINGON;
            END_IF;
        ELSE
            MotorOutput := FALSE;
            ShutOutput := FALSE;
        END_IF;

    STS_ERROR :
        (* Torno nello stato normale dopo un po' di tempo *)
        IF TOnDelay.q THEN
            Status := TS_OFF;
        END_IF;

END_CASE; (* -- State machine *)

(* -- Monitors -- *)
(* AirCushionReady := Status=TS_ON OR NOT Activate; *)
(* Per evitare di commutare troppo il segnale: *)
AirCushionReady := Status=TS_ON OR (Status<>STS_ERROR AND NOT Activate);
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := NOT ShutOutput;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbVents

{ DE:"Gestione zone cuscino d'aria per la movimentazione vetro" }

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vbHeartBeat : BOOL; { DE:"Battito di vita 1s" }
	vbStopSignal : BOOL; { DE:"Dispatched stop request signal to freeze/abort current operation" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	VentOutZone : fbVentOnOffSeq; { DE:"Ventilatori zona fine linea" }
	VentAlgnB : fbVentOnOffSeq; { DE:"Ventilatori zona riscontri banda bassa" }
	VentAlgnM : fbVentOnOffSeq; { DE:"Ventilatori zona riscontri banda mediana" }
	VentAlgnT : fbVentOnOffSeq; { DE:"Ventilatori zona riscontri banda alta" }
	VentAlgnC : fbVentOnOffSeq; { DE:"Ventilatori zona premilastra riscontri" }
	VentDtch : fbVentOnOffSeq; { DE:"Ventilatori zona stacco" }
	VentBuf : fbVentOnOffSeq; { DE:"Ventilatori zona buffer" }
	VentFeed : fbVentOnOffSeq; { DE:"Ventilatori zona carico" }
	vbVent_AutoMotorsOn : BOOL; { DE:"Accendi i ventilatori all'avvio macchina" }
	vbVent_JoinedAlgnCT : BOOL; { DE:"Zone aria riscontri banda alta e premilastra sono unite" }
	vbVent_NoDtchMotor : BOOL; { DE:"La zona stacco usa il motore della zona premilastra riscontri" }
	vbVent_IndepOutZone : BOOL; { DE:"Zona aria fine linea indipendente" }
	vqY_AlgnBandB : DINT; { DE:"Ordinata fine zona cuscino aria riscontri banda bassa [um]" }
	vqY_AlgnBandM : DINT; { DE:"Ordinata fine zona cuscino aria riscontri banda mediana [um]" }
	vbVent_CmdAllCutZone : BOOL; { DE:"Le pedaliere azionano sempre tutta la zona taglio" }
	vqVent_CmdHoldTime : DINT; { DE:"Tempo per doppio comando pedaliere [ms]" }
	vqVent_OffDelay : DINT; { DE:"Ritardo spegnimento ventilatori per inattività [ms]" }
	vqVent_RampTime : DINT; { DE:"Attesa motore ventilatore a regime [ms]" }
	vnBuf_Type : INT; { DE:"Tipo modulo polmone" }
	vnShiftFeed_Sts : INT; { DE:"Stato sequenze cinghie carico" }
	ICM_VENT_LOAD : BOOL; { DE:"Comando in zona caricatrice del cuscino aria" }
	ICM_VENT_FEED : BOOL; { DE:"Comando in zona fine carico del cuscino aria" }
	ICM_VENT_REMN : BOOL; { DE:"Comando in zona rimanenza del cuscino aria" }
	ICM_VENT_PROD : BOOL; { DE:"Comando in zona prodotto del cuscino aria" }
	ICM_VENT_OUTZONE : BOOL; { DE:"Comando in zona fine linea del cuscino aria" }
	vnVents_Cmd : INT; { DE:"Comando gruppi ventilatori cuscino aria a bit" }
	vnVents_CmdOvl : INT; { DE:"Overlay permanente (usato per pilotaggio con cinghie)" }
	vbVents_MotorsOn : BOOL; { DE:"Avvia motori senza aprire le serrande" }
	vnVents_MotorOff : INT; { DE:"Forza motore spento (anche con serrande aperte)" }
	vnVentProd_Flux : INT; { DE:"Impostazione flusso aria ventilatori zona prodotto [%]" }
	vnVentRemn_Flux : INT; { DE:"Impostazione flusso aria ventilatori zona rimanenza [%]" }
	vnVentFeed_Flux : INT; { DE:"Impostazione flusso aria ventilatori modulo di carico [%]" }
	vbAirCushionReady : BOOL; { DE:"Stato complessivo del cuscino d'aria" }
	IPR_VENT_OUTZONE : BOOL; { DE:"Protezione motore ventilatori zona fine linea (0:Ok)" }
	O_VENT_OUTZONE : BOOL; { DE:"Accensione ventilatori zona fine linea" }
	O_VENTSHUT_OUTZONE : BOOL; { DE:"Aziona serranda ventilatori zona fine linea" }
	IPR_VENT_ALGN_B : BOOL; { DE:"Protezione motore ventilatori zona riscontri mediani (0:Ok)" }
	O_VENT_ALGN_B : BOOL; { DE:"Accensione ventilatori ventilatori zona riscontri mediani" }
	O_VENTSHUT_ALGN_B : BOOL; { DE:"Aziona serranda ventilatori zona riscontri mediani" }
	IPR_VENT_ALGN_M : BOOL; { DE:"Protezione motore ventilatori zona riscontri mediani (0:Ok)" }
	O_VENT_ALGN_M : BOOL; { DE:"Accensione ventilatori ventilatori zona riscontri mediani" }
	O_VENTSHUT_ALGN_M : BOOL; { DE:"Aziona serranda ventilatori zona riscontri mediani" }
	IPR_VENT_ALGN_T : BOOL; { DE:"Protezione motore ventilatori zona riscontri alti (0:Ok)" }
	O_VENT_ALGN_T : BOOL; { DE:"Accensione ventilatori ventilatori zona riscontri alti" }
	O_VENTSHUT_ALGN_T : BOOL; { DE:"Aziona serranda ventilatori zona riscontri alti" }
	IPR_VENT_ALGN_C : BOOL; { DE:"Protezione motore ventilatori zona taglio (0:Ok)" }
	O_VENT_ALGN_C : BOOL; { DE:"Accensione ventilatori zona taglio" }
	O_VENTSHUT_ALGN_C : BOOL; { DE:"Aziona serranda ventilatori zona taglio" }
	IPR_VENT_DTCH : BOOL; { DE:"Protezione motore ventilatori modulo stacco (0:Ok)" }
	O_VENT_DTCH : BOOL; { DE:"Accensione ventilatori modulo stacco" }
	O_VENTSHUT_DTCH : BOOL; { DE:"Aziona serranda ventilatori modulo stacco" }
	IPR_VENT_BUF : BOOL; { DE:"Protezione motore ventilatori modulo polmone (0:Ok)" }
	O_VENT_BUF : BOOL; { DE:"Accensione ventilatori modulo polmone" }
	O_VENTSHUT_BUF : BOOL; { DE:"Aziona serranda ventilatori modulo polmone" }
	O_VENT_FEED : BOOL; { DE:"Accensione ventilatori modulo carico" }
	IPR_VENT1_FEED : BOOL; { DE:"Protezione motore ventilatori modulo carico lato polmone (0:Ok)" }
	O_VENT1SHUT_FEED : BOOL; { DE:"Aziona serranda ventilatori modulo carico lato polmone" }
	O_VENT1FLUX_FEED : BOOL; { DE:"Modulazione flusso aria ventilatori modulo carico lato polmone" }
	O_REQ_VENT1FEED : BOOL; { DE:"Segnale richiesta ventilatori 1 carico (per macchina esterna)" }
	O_VENT2_FEED : BOOL; { DE:"Accensione ventilatori modulo carico lato caricatrice" }
	IPR_VENT2_FEED : BOOL; { DE:"Protezione motore ventilatori modulo carico lato caricatrice (0:Ok)" }
	O_VENT2SHUT_FEED : BOOL; { DE:"Aziona serranda ventilatori modulo carico lato caricatrice" }
	O_VENT2FLUX_FEED : BOOL; { DE:"Modulazione flusso aria ventilatori modulo carico lato caricatrice" }
	IPR_VENT_FEED2 : BOOL; { DE:"Protezione motore ventilatori tavolo aggiuntivo carico alto (0:Ok)" }
	O_VENT_FEED2 : BOOL; { DE:"Accensione ventilatori tavolo aggiuntivo carico alto" }
	O_VENTSHUT_FEED2 : BOOL; { DE:"Aziona serranda ventilatori tavolo aggiuntivo carico alto" }
	vbFeedAux_Present : BOOL; { DE:"Presenza tavolo di supporto sopra il carico" }
	vnComboFloat_Type : INT; { DE:"Tipo macchina monolitico combinata" }
	FeedTilt : fbFeedTilt; { DE:"Basculamento del modulo di carico" }
	I_SCU_POW_MACH : BOOL; { DE:"Attuazioni modulo di taglio pronte (1:Ok)" }
	I_SCU_POW_FEED : BOOL; { DE:"Attuazioni modulo di carico alimentate (1:Ok)" }
	END_VAR

	VAR
	CmdVentLoad : fbCmdHeld; { DE:"Pedaliera zona carico" }
	CmdVentFeed : fbCmdHeld; { DE:"Pedaliera zona approvvigionamento" }
	CmdVentRemn : fbCmdHeld; { DE:"Pedaliera zona rimanenza" }
	CmdVentProd : fbCmdHeld; { DE:"Pedaliera zona prodotto" }
	CmdVentOutZone : fbCmdHeld; { DE:"Pedaliera zona fine linea" }
	TVentsFeedOffDelay : Ton; { DE:"Spegnimento automatico motori zona carico/accumulo" }
	TVentsRemnOffDelay : Ton; { DE:"Spegnimento automatico motori zona rimanenza" }
	TVentsProdOffDelay : Ton; { DE:"Spegnimento automatico motori zona prodotto" }
	TVents1FeedStarted : Ton; { DE:"Motore principale zona carico/accumulo a regime" }
	END_VAR

	{ CODE:ST }(*    fbVents (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Contiene la logica sull'uso complessivo dei
      ventilatori cuscino d'aria.
      L'accensione scaglionata è gestita grazie
      alla risorsa condivisa 'PowerSource'.
      Le zone ventilatori si dividono in:
         .Modulo riscontri zona premilastra
         .Modulo riscontri banda bassa
         .Modulo riscontri banda mediana
         .Modulo riscontri banda alta
         .Modulo stacco
         .Modulo polmone
         .Modulo carico

      NOTES
      ----------------------------------------------
      La zona polmone potrebbe essere un modulo
      indipendente oppure da una zona nel modulo di
      carico. In tal caso mappare la termica a
      a IPR_VENT_BUF e non IPR_VENT1_FEED.
      Il modulo di carico è dotato di un solo motore
      ventilatori ma di due serrande che servono due
      zone (lato caricatrice e lato polmone): questo
      consente di supportare le configurazioni senza
      il modulo polmone indipendente.

      EXAMPLE OF USAGE
      ----------------------------------------------
      Vents : fbVents; { DE:"Sistema galleggiamento vetro" }
      Vents();
*)

(*     Zone ventilatori cuscino d'aria e pedaliere

  Sulle macchine piccole ALGN_C e ALGN_T sono uniti e comandati usando ALGN_T
       +---------------------++-------++---+ +---+------------+
       |      F      |   F   ||   B   || D |=| A |   ALGN_T   |
       |      E          E   ||   U   || T |=| L  ------------|
       |      E      |   E   ||   F   || C |=| G |   ALGN_M   |
       |      D          D   ||       || H |=| N  ------------|
       |      2      |   1   ||       ||   |=| C |   ALGN_B   | []
       +---------------------++-------++---+ +---+------------+ ICM_VENT_OUTZONE
         []              []           []        []
   ICM_VENT_LOAD  ICM_VENT_FEED  ICM_VENT_REMN  ICM_VENT_PROD )

(* -- Gestione comandi manuali (pedaliere) -- *)

(* La pedaliera sul tavolo di carico
   è dedicata alla movimentazione tra carico e caricatrice *)
CmdVentLoad( in:=ICM_VENT_LOAD, pt:=TO_UDINT(vqVent_CmdHoldTime) );
IF CmdVentLoad.click THEN
    (* Commuta il comando *)
    IF (vnVents_Cmd & MSK_VENT_FEED)=0 THEN
        vnVentFeed_Flux := 100; (* Ripristino massimo flusso *)
        vnVents_Cmd := vnVents_Cmd OR MSK_VENT_FEED;
    ELSE
        (* Mi assicuro di spegnere anche il polmone *)
        vnVents_Cmd := vnVents_Cmd & NOT (MSK_VENT_FEED OR BIT_VENT_BUF);
    END_IF;
ELSIF CmdVentLoad.held_pls THEN
    (* Pedaliera mantenuta schiacciata (attivo per solo uno scan): anche il polmone *)
    vnVents_Cmd := vnVents_Cmd OR (MSK_VENT_FEED OR BIT_VENT_BUF);
END_IF;

(* La pedaliera in zona approvvigionamento/fine carico
   è dedicata alla movimentazione tra carico e polmone *)
CmdVentFeed( in:=ICM_VENT_FEED, pt:=TO_UDINT(vqVent_CmdHoldTime) );
IF CmdVentFeed.click THEN
    (* Commuta il comando *)
    IF (vnVents_Cmd & MSK_VENT_FEED)=0 THEN
        vnVentFeed_Flux := 100; (* Ripristino massimo flusso *)
        vnVents_Cmd := vnVents_Cmd OR MSK_VENT_FEED;
    ELSE
        (* Mi assicuro di spegnere tutto *)
        vnVents_Cmd := vnVents_Cmd & NOT (MSK_VENT_FEED OR MSK_VENT_REMN);
    END_IF;
ELSIF CmdVentFeed.held_pls THEN
    (* Pedaliera mantenuta schiacciata (attivo per solo uno scan): anche il polmone *)
    vnVents_Cmd := vnVents_Cmd OR (MSK_VENT_FEED OR BIT_VENT_BUF);
    (* Pedaliera mantenuta schiacciata (attivo per solo uno scan): anche zona rimanenza
    vnVents_Cmd := vnVents_Cmd OR (MSK_VENT_FEED OR MSK_VENT_REMN); *)
END_IF;

(* La pedaliera in zona rimanenza
   è dedicata alla movimentazione tra stacco e riscontri *)
CmdVentRemn( in:=ICM_VENT_REMN, pt:=TO_UDINT(vqVent_CmdHoldTime) );
IF CmdVentRemn.click THEN
    (* Commuta comando gruppo ventilatori *)
    IF (vnVents_Cmd & MSK_VENT_REMN)=0 THEN
        vnVents_Cmd := vnVents_Cmd OR SEL(vbVent_CmdAllCutZone, MSK_VENT_REMN, MSK_VENT_LAMI);
        (* Occhio che azionando BIT_VENT_FEED potrebbero muoversi pezzi accodati *)
    ELSE
        (* Mi assicuro di spegnere tutto *)
        vnVents_Cmd := vnVents_Cmd & NOT (MSK_VENT_LAMI OR MSK_VENT_FEED);
    END_IF;
ELSIF CmdVentRemn.held_pls THEN
    (* Pedaliera mantenuta schiacciata (attivo per solo uno scan): anche riscontri *)
    vnVents_Cmd := vnVents_Cmd OR MSK_VENT_LAMI;
    (* Se non c'è il polmone, anche tutto il carico *)
    IF vnBuf_Type=0 THEN
        vnVents_Cmd := vnVents_Cmd OR MSK_VENT_FEED;
    END_IF;
END_IF;

(* La pedaliera in zona prodotto
   è dedicata alla movimentazione tra riscontri e stacco *)
CmdVentProd( in:=ICM_VENT_PROD, pt:=TO_UDINT(vqVent_CmdHoldTime) );
IF CmdVentProd.click THEN
    (* Commuta comando gruppo ventilatori *)
    IF (vnVents_Cmd & MSK_VENT_PROD)=0 THEN
        vnVents_Cmd := vnVents_Cmd OR SEL(vbVent_CmdAllCutZone, MSK_VENT_PROD, MSK_VENT_LAMI);
    ELSE
        (* Mi assicuro di spegnere tutto *)
        vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_LAMI;
    END_IF;
ELSIF CmdVentProd.held_pls THEN
    (* Pedaliera mantenuta schiacciata (attivo per solo uno scan): anche stacco+polmone *)
    vnVents_Cmd := vnVents_Cmd OR MSK_VENT_LAMI;
END_IF;

(* La pedaliera a fine linea
   è dedicata alla movimentazione sui riscontri *)
CmdVentOutZone( in:=ICM_VENT_OUTZONE, pt:=TO_UDINT(vqVent_CmdHoldTime) );
IF CmdVentOutZone.click THEN
    (* Commuta comando gruppo ventilatori *)
    IF vbVent_IndepOutZone THEN
        (* Zona fine linea indipendente *)
        IF (vnVents_Cmd & BIT_VENT_OUTZONE)=0 THEN
            vnVents_Cmd := vnVents_Cmd OR BIT_VENT_OUTZONE;
        ELSE
            vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_OUTZONE;
        END_IF;
    ELSE
        (* Comanda tutte le aree riscontro *)
        IF (vnVents_Cmd & MSK_VENT_PROD)=0 THEN
            vnVents_Cmd := vnVents_Cmd OR MSK_VENT_PROD;
        ELSE
            (* Mi assicuro di spegnere tutto *)
            vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_LAMI;
        END_IF;
    END_IF;
ELSIF CmdVentOutZone.held_pls THEN
    (* Pedaliera mantenuta schiacciata (attivo per solo uno scan) *)
    IF vbVent_IndepOutZone THEN
        vnVents_Cmd := vnVents_Cmd OR BIT_VENT_OUTZONE;
    ELSE
        vnVents_Cmd := vnVents_Cmd OR MSK_VENT_LAMI;
    END_IF;
END_IF;



(* -- Risposta al segnale di stop -- *)
IF vbStopSignal AND vnVents_Cmd<>0 THEN
    dlog( Txt:='fbVents: Stop', Lvl:=4 );
    vnVents_Cmd := 0;
END_IF;



(* -- Avvio automatico dei motori --
      All'avvio macchina e ripristino emg  *)
IF (vbVent_AutoMotorsOn AND vn[ivnStatus+ID_MACHINE]=MS_JUSTREADY) THEN
    (* dlog( Txt:='fbVents: Vent motors auto turn-on', Lvl:=5 ); *)
    vbVents_MotorsOn := TRUE;
END_IF;


(* -- Comando esplicito avvio dei motori -- *)
IF vbVents_MotorsOn THEN
    vbVents_MotorsOn := FALSE; (* Eat *)
	(* VentOutZone.TurnOnMotor := TRUE; *)
	VentAlgnB.TurnOnMotor := TRUE;
	VentAlgnM.TurnOnMotor := TRUE;
	VentAlgnT.TurnOnMotor := TRUE;
	VentAlgnC.TurnOnMotor := TRUE;
	VentDtch.TurnOnMotor := TRUE;
	VentBuf.TurnOnMotor := TRUE;
    IF vnBuf_Type=0 THEN
        VentFeed.TurnOnMotor := TRUE;
    END_IF;
(* Se carico la lastra da squadrare è meglio avere i motori
   dei ventilatori carico in moto in modo da avere sempre
   lo stesso comportamento in squadratura *)
ELSIF vnShiftFeed_Sts=SHF_FEED_LDGET THEN
	VentFeed.TurnOnMotor := TRUE;
END_IF;
(* Nota: l'accensione scaglionata è gestita automaticamente
         con la risorsa condivisa 'PowerSource' *)

(* -- Spegnimento in caso di inattività --
      Divido in zone distinte: carico, rimanenza e prodotto *)
TVentsFeedOffDelay( in:=(vnVents_Cmd & MSK_VENT_FEED)=0 AND VentFeed.TurnOnMotor, pt:=TO_UDINT(vqVent_OffDelay) );
IF TVentsFeedOffDelay.q THEN
    dlog( Txt:='fbVents: Feed vents off (%ld s)', Lvl:=5, Val1:=vqVent_OffDelay/1000);
	VentFeed.TurnOnMotor := FALSE;
END_IF;

TVentsRemnOffDelay( in:=(vnVents_Cmd & MSK_VENT_REMN)=0 AND (VentDtch.TurnOnMotor OR VentBuf.TurnOnMotor), pt:=TO_UDINT(vqVent_OffDelay) );
IF TVentsRemnOffDelay.q THEN
    dlog( Txt:='fbVents: Remn vents off (%ld s)', Lvl:=5, Val1:=vqVent_OffDelay/1000);
	VentDtch.TurnOnMotor := FALSE;
	VentBuf.TurnOnMotor := FALSE;
END_IF;

TVentsProdOffDelay( in:=(vnVents_Cmd & MSK_VENT_PROD)=0 AND vn[ivnStatus+ID_STEPSEQ]<>STSEQ_CUT AND (VentAlgnC.TurnOnMotor OR VentAlgnB.TurnOnMotor), pt:=TO_UDINT(vqVent_OffDelay) );
IF TVentsProdOffDelay.q THEN
    dlog( Txt:='fbVents: Prod vents off (%ld s)', Lvl:=5, Val1:=vqVent_OffDelay/1000);
	VentAlgnC.TurnOnMotor := FALSE;
	VentAlgnB.TurnOnMotor := FALSE;
	VentAlgnM.TurnOnMotor := FALSE;
	VentAlgnT.TurnOnMotor := FALSE;
	VentOutZone.TurnOnMotor := FALSE;
END_IF;

(* Segnale cuscino d'aria pronto *)
vbAirCushionReady := VentAlgnB.AirCushionReady AND (* Nota: VentOutZone è escluso *)
                     VentAlgnM.AirCushionReady AND
                     VentAlgnT.AirCushionReady AND
                     VentAlgnC.AirCushionReady AND
                     VentDtch.AirCushionReady AND
                     VentBuf.AirCushionReady AND
                     VentFeed.AirCushionReady;
(* vbAirCushionReady := AirCushionReady; *)


(* -- Ventilatori zona fine linea -- *)
(* I ventilatori zona fine linea possono funzionare se: *)
VentOutZone.Allow := I_SCU_POW_MACH AND (* Attuazioni pneumatiche modulo taglio attivate *)
                     NOT IPR_VENT_OUTZONE; (* Protezioni ok *)
IF (VentOutZone.TurnOnMotor OR VentOutZone.Activate) AND NOT VentOutZone.Allow THEN
    (* Abortisco il comando *)
    vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_OUTZONE;
    VentOutZone.TurnOnMotor := FALSE;
    (* Notifico con messaggio?
    SET_MSG(MSG_LOCK_VENT_OUTZONE,'MSG_LOCK_VENT_OUTZONE',0); *)
    (* Qui potrei fare un po' di diagnostica
    IF NOT I_SCU_POW_MACH THEN
        dlog( Txt:='fbVents: !! VentOutZone blocked by I_SCU_POW_MACH', Lvl:=3 );
    ELSIF IPR_VENT_OUTZONE THEN
        dlog( Txt:='fbVents: !! VentOutZone blocked by IPR_VENT_OUTZONE', Lvl:=3 );
    ELSE
        dlog( Txt:='fbVents: !! VentOutZone blocked', Lvl:=3 );
    END_IF; *)
END_IF;
VentOutZone( ID:=ID_VENT_OUTZONE, Activate:=((vnVents_Cmd OR vnVents_CmdOvl) & BIT_VENT_OUTZONE)<>0, NotAcq_PowerSource:=NOT vbVent_IndepOutZone );
O_VENT_OUTZONE := VentOutZone.MotorOutput AND (vnVents_MotorOff & BIT_VENT_OUTZONE)=0;
O_VENTSHUT_OUTZONE := VentOutZone.ShutOutput;



(* -- Ventilatori zona riscontri banda alta -- *)
(* I ventilatori riscontro banda alta possono funzionare se: *)
VentAlgnT.Allow := I_SCU_POW_MACH AND (* Attuazioni pneumatiche modulo taglio attivate *)
                   vn[ivnStatus+ID_MACHINE]<>MS_ERROR AND (* Macchina non in errore *)
                   NOT IPR_VENT_ALGN_T; (* Protezioni ok *)
IF (VentAlgnT.TurnOnMotor OR VentAlgnT.Activate) AND NOT VentAlgnT.Allow THEN
    (* Abortisco il comando *)
    vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_ALGN_T;
    VentAlgnT.TurnOnMotor := FALSE;
    (* Notifico con messaggio?
    SET_MSG(MSG_LOCK_VENT_ALGN_T,'MSG_LOCK_VENT_ALGN_T',0); *)
    (* Qui potrei fare un po' di diagnostica
    IF NOT I_SCU_POW_MACH THEN
        dlog( Txt:='fbVents: !! VentAlgnT blocked by I_SCU_POW_MACH', Lvl:=3 );
    ELSIF vn[ivnStatus+ID_MACHINE]=MS_ERROR THEN
        dlog( Txt:='fbVents: !! VentAlgnT blocked by Emg', Lvl:=3 );
    ELSIF IPR_VENT_ALGN_T THEN
        dlog( Txt:='fbVents: !! VentAlgnT blocked by IPR_VENT_ALGN_T', Lvl:=3 );
    ELSE
        dlog( Txt:='fbVents: !! VentAlgnT blocked', Lvl:=3 );
    END_IF; *)
END_IF;
VentAlgnT( ID:=ID_VENT_ALGN_T, Activate:=((vnVents_Cmd OR vnVents_CmdOvl) & BIT_VENT_ALGN_T)<>0, NotAcq_PowerSource:=vbVent_JoinedAlgnCT );
(* Le zone riscontro taglio e banda alta sono unite? (macchine piccole) *)
IF vbVent_JoinedAlgnCT THEN
    (* Piloto la banda alta anche con i comandi a zona taglio *)
    O_VENT_ALGN_T := (VentAlgnT.MotorOutput OR VentAlgnC.MotorOutput) AND (vnVents_MotorOff & BIT_VENT_ALGN_T)=0;
    O_VENTSHUT_ALGN_T := VentAlgnT.ShutOutput OR VentAlgnC.ShutOutput;
ELSE
    O_VENT_ALGN_T := VentAlgnT.MotorOutput AND (vnVents_MotorOff & BIT_VENT_ALGN_T)=0;
    O_VENTSHUT_ALGN_T := VentAlgnT.ShutOutput;
END_IF;
(* Regolazione flusso cuscino aria della zona riscontri banda alta
Con serranda: 'O_*SHUT*' apre la serranda piccola e 'O_*FLUX*' apre tutto,
              il vincolo è che 'O_*FLUX*' non deve essere ON se 'O_*SHUT*' è OFF
O_VENTFLUX_ALGN_T := O_VENTSHUT_ALGN_T AND vnVentProd_Flux>50;
*)



(* -- Ventilatori zona riscontri banda mediana -- *)
(* I ventilatori riscontro banda mediana possono funzionare se: *)
VentAlgnM.Allow := I_SCU_POW_MACH AND (* Attuazioni pneumatiche modulo taglio attivate *)
                   vn[ivnStatus+ID_MACHINE]<>MS_ERROR AND (* Macchina non in errore *)
                   NOT IPR_VENT_ALGN_M; (* Protezioni ok *)
IF (VentAlgnM.TurnOnMotor OR VentAlgnM.Activate) AND NOT VentAlgnM.Allow THEN
    (* Abortisco il comando *)
    vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_ALGN_M;
    VentAlgnM.TurnOnMotor := FALSE;
    (* Notifico con messaggio?
    SET_MSG(MSG_LOCK_VENT_ALGN_M,'MSG_LOCK_VENT_ALGN_M',0); *)
    (* Qui potrei fare un po' di diagnostica
    IF NOT I_SCU_POW_MACH THEN
        dlog( Txt:='fbVents: !! VentAlgnM blocked by I_SCU_POW_MACH', Lvl:=3 );
    ELSIF vn[ivnStatus+ID_MACHINE]=MS_ERROR THEN
        dlog( Txt:='fbVents: !! VentAlgnM blocked by Emg', Lvl:=3 );
    ELSIF IPR_VENT_ALGN_M THEN
        dlog( Txt:='fbVents: !! VentAlgnM blocked by IPR_VENT_ALGN_M', Lvl:=3 );
    ELSE
        dlog( Txt:='fbVents: !! VentAlgnM blocked', Lvl:=3 );
    END_IF; *)
END_IF;
VentAlgnM( ID:=ID_VENT_ALGN_M, Activate:=((vnVents_Cmd OR vnVents_CmdOvl) & BIT_VENT_ALGN_M)<>0, NotAcq_PowerSource:=(vqY_AlgnBandM<=vqY_AlgnBandB) );
O_VENT_ALGN_M := VentAlgnM.MotorOutput AND (vnVents_MotorOff & BIT_VENT_ALGN_M)=0;
O_VENTSHUT_ALGN_M := VentAlgnM.ShutOutput;
(* Regolazione flusso cuscino aria della zona riscontri banda mediana
Con serranda: 'O_*SHUT*' apre la serranda piccola e 'O_*FLUX*' apre tutto,
              il vincolo è che 'O_*FLUX*' non deve essere ON se 'O_*SHUT*' è OFF
O_VENTFLUX_ALGN_M := O_VENTSHUT_ALGN_M AND vnVentProd_Flux>50;
*)


(* -- Ventilatori zona riscontri banda bassa -- *)
(* I ventilatori riscontro banda bassa possono funzionare se: *)
VentAlgnB.Allow := I_SCU_POW_MACH AND (* Attuazioni pneumatiche modulo taglio attivate *)
                   vn[ivnStatus+ID_MACHINE]<>MS_ERROR AND (* Macchina non in errore *)
                   NOT IPR_VENT_ALGN_B; (* Protezioni ok *)
IF (VentAlgnB.TurnOnMotor OR VentAlgnB.Activate) AND NOT VentAlgnB.Allow THEN
    (* Abortisco il comando *)
    vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_ALGN_B;
    VentAlgnB.TurnOnMotor := FALSE;
    (* Notifico con messaggio?
    SET_MSG(MSG_LOCK_VENT_ALGN_B,'MSG_LOCK_VENT_ALGN_B',0); *)
    (* Qui potrei fare un po' di diagnostica
    IF NOT I_SCU_POW_MACH THEN
        dlog( Txt:='fbVents: !! VentAlgnB blocked by I_SCU_POW_MACH', Lvl:=3 );
    ELSIF vn[ivnStatus+ID_MACHINE]=MS_ERROR THEN
        dlog( Txt:='fbVents: !! VentAlgnB blocked by Emg', Lvl:=3 );
    ELSIF IPR_VENT_ALGN_B THEN
        dlog( Txt:='fbVents: !! VentAlgnB blocked by IPR_VENT_ALGN_B', Lvl:=3 );
    ELSE
        dlog( Txt:='fbVents: !! VentAlgnB blocked', Lvl:=3 );
    END_IF; *)
END_IF;
VentAlgnB( ID:=ID_VENT_ALGN_B, Activate:=((vnVents_Cmd OR vnVents_CmdOvl) & BIT_VENT_ALGN_B)<>0 );
O_VENT_ALGN_B := VentAlgnB.MotorOutput AND (vnVents_MotorOff & BIT_VENT_ALGN_B)=0;
O_VENTSHUT_ALGN_B := VentAlgnB.ShutOutput;
(* Regolazione flusso cuscino aria della zona riscontri banda bassa
Con serranda: 'O_*SHUT*' apre la serranda piccola e 'O_*FLUX*' apre tutto,
              il vincolo è che 'O_*FLUX*' non deve essere ON se 'O_*SHUT*' è OFF
O_VENTFLUX_ALGN_B := O_VENTSHUT_ALGN_B AND vnVentProd_Flux>50;
*)


(* -- Ventilatori zona premilastra riscontri -- *)
(* I ventilatori riscontro zona taglio possono funzionare se: *)
VentAlgnC.Allow := I_SCU_POW_MACH AND (* Attuazioni pneumatiche modulo taglio attivate *)
                   vn[ivnStatus+ID_MACHINE]<>MS_ERROR AND (* Macchina non in errore *)
                   NOT IPR_VENT_ALGN_C; (* Protezioni ok *)
IF (VentAlgnC.TurnOnMotor OR VentAlgnC.Activate) AND NOT VentAlgnC.Allow THEN
    (* Abortisco il comando *)
    vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_ALGN_C;
    VentAlgnC.TurnOnMotor := FALSE;
    (* Notifico con messaggio?
    SET_MSG(MSG_LOCK_VENT_ALGN_C,'MSG_LOCK_VENT_ALGN_C',0); *)
    (* Qui potrei fare un po' di diagnostica
    IF NOT I_SCU_POW_MACH THEN
        dlog( Txt:='fbVents: !! VentAlgnC blocked by I_SCU_POW_MACH', Lvl:=3 );
    ELSIF vn[ivnStatus+ID_MACHINE]=MS_ERROR THEN
        dlog( Txt:='fbVents: !! VentAlgnC blocked by Emg', Lvl:=3 );
    ELSIF IPR_VENT_ALGN_C THEN
        dlog( Txt:='fbVents: !! VentAlgnC blocked by IPR_VENT_ALGN_C', Lvl:=3 );
    ELSE
        dlog( Txt:='fbVents: !! VentAlgnC blocked', Lvl:=3 );
    END_IF; *)
END_IF;
VentAlgnC( ID:=ID_VENT_ALGN_C, Activate:=((vnVents_Cmd OR vnVents_CmdOvl) & BIT_VENT_ALGN_C)<>0 );
O_VENT_ALGN_C := (VentAlgnC.MotorOutput OR (vbVent_NoDtchMotor AND O_VENT_DTCH)) AND (vnVents_MotorOff & BIT_VENT_ALGN_C)=0;
O_VENTSHUT_ALGN_C := VentAlgnC.ShutOutput;
(* Regolazione flusso cuscino aria della zona premilastra riscontri
Con serranda: 'O_*SHUT*' apre la serranda piccola e 'O_*FLUX*' apre tutto,
              il vincolo è che 'O_*FLUX*' non deve essere ON se 'O_*SHUT*' è OFF
O_VENTFLUX_ALGN_B := O_VENTSHUT_ALGN_B AND vnVentProd_Flux>50;
*)


(* -- Ventilatori zona stacco -- *)
(* I ventilatori dello stacco possono funzionare se: *)
VentDtch.Allow := I_SCU_POW_MACH AND (* Attuazioni pneumatiche modulo taglio attivate *)
                  vn[ivnStatus+ID_MACHINE]<>MS_ERROR AND (* Macchina non in errore *)
                  NOT IPR_VENT_DTCH; (* Protezioni ok *)
IF (VentDtch.TurnOnMotor OR VentDtch.Activate) AND NOT VentDtch.Allow THEN
    (* Abortisco il comando *)
    vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_DTCH;
    VentDtch.TurnOnMotor := FALSE;
    (* Notifico con messaggio?
    SET_MSG(MSG_LOCK_VENT_DTCH,'MSG_LOCK_VENT_DTCH',0); *)
    (* Qui potrei fare un po' di diagnostica
    IF NOT I_SCU_POW_MACH THEN
        dlog( Txt:='fbVents: !! VentDtch blocked by I_SCU_POW_MACH', Lvl:=3 );
    ELSIF vn[ivnStatus+ID_MACHINE]=MS_ERROR THEN
        dlog( Txt:='fbVents: !! VentDtch blocked by Emg', Lvl:=3 );
    ELSIF IPR_VENT_DTCH THEN
        dlog( Txt:='fbVents: !! VentDtch blocked by IPR_VENT_DTCH', Lvl:=3 );
    ELSE
        dlog( Txt:='fbVents: !! VentDtch blocked', Lvl:=3 );
    END_IF; *)
END_IF;
VentDtch( ID:=ID_VENT_DTCH, Activate:=((vnVents_Cmd OR vnVents_CmdOvl) & BIT_VENT_DTCH)<>0, NotAcq_PowerSource:=vbVent_NoDtchMotor );
O_VENT_DTCH := VentDtch.MotorOutput AND (vnVents_MotorOff & BIT_VENT_DTCH)=0;
O_VENTSHUT_DTCH := VentDtch.ShutOutput;
(* Regolazione flusso cuscino aria della zona stacco
Con serranda: 'O_*SHUT*' apre la serranda piccola e 'O_*FLUX*' apre tutto,
              il vincolo è che 'O_*FLUX*' non deve essere ON se 'O_*SHUT*' è OFF
O_VENTFLUX_DTCH := O_VENTSHUT_DTCH AND vnVentRemn_Flux>50;
*)


(* -- Ventilatori zona polmone -- *)
(* I ventilatori del polmone possono funzionare se: *)
VentBuf.Allow := I_SCU_POW_MACH AND (* Attuazioni pneumatiche modulo taglio attivate *)
                 vn[ivnStatus+ID_MACHINE]<>MS_ERROR AND (* Macchina non in errore *)
                 NOT IPR_VENT_BUF; (* Protezioni ok *)
(* vnBuf_Type>0 VentFeed.Allow *)
IF (VentBuf.TurnOnMotor OR VentBuf.Activate) AND NOT VentBuf.Allow THEN
    (* Abortisco il comando *)
    vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_BUF;
    VentBuf.TurnOnMotor := FALSE;
    (* Notifico con messaggio?
    SET_MSG(MSG_LOCK_VENT_BUF,'MSG_LOCK_VENT_BUF',0); *)
    (* Qui potrei fare un po' di diagnostica
    IF NOT I_SCU_POW_MACH THEN
        dlog( Txt:='fbVents: !! VentBuf blocked by I_SCU_POW_MACH', Lvl:=3 );
    ELSIF vn[ivnStatus+ID_MACHINE]=MS_ERROR THEN
        dlog( Txt:='fbVents: !! VentBuf blocked by Emg', Lvl:=3 );
    ELSIF IPR_VENT_BUF THEN
        dlog( Txt:='fbVents: !! VentBuf blocked by IPR_VENT_BUF', Lvl:=3 );
    ELSE
        dlog( Txt:='fbVents: !! VentBuf blocked', Lvl:=3 );
    END_IF; *)
END_IF;
VentBuf( ID:=ID_VENT_BUF, Activate:=((vnVents_Cmd OR vnVents_CmdOvl) & BIT_VENT_BUF)<>0 );
O_VENT_BUF := VentBuf.MotorOutput AND (vnVents_MotorOff & BIT_VENT_BUF)=0;
O_VENTSHUT_BUF := VentBuf.ShutOutput;
(* Regolazione flusso cuscino aria della zona polmone
Con serranda: 'O_*SHUT*' apre la serranda piccola e 'O_*FLUX*' apre tutto,
              il vincolo è che 'O_*FLUX*' non deve essere ON se 'O_*SHUT*' è OFF
O_VENTFLUX_BUF := O_VENTSHUT_BUF AND vnVentRemn_Flux>50;
*)



(* -- Ventilatori zona carico -- *)
VentFeed( ID:=ID_VENT_FEED,
          Allow := I_SCU_POW_FEED AND (* Attuazioni pneumatiche alimentate *)
                  (* I_SCU_INAIR_FEED AND (* Aria modulo di carico *)
                  (* ( vnComboFloat_Type<=0 OR I_FLOAT_READY ) AND (* Macchina combinata pronta? Forse meglio far passare la richiesta *)
                  FeedTilt.Down AND (* Basculamento basso *)
                  vn[ivnStatus+ID_MACHINE]<>MS_ERROR AND (* Macchina non in errore *)
                  NOT (IPR_VENT1_FEED OR IPR_VENT2_FEED), (* Protezioni ok *)
          Activate:=((vnVents_Cmd OR vnVents_CmdOvl) & MSK_VENT_FEED)<>0 );
(* Assicuro comandi via *)
IF NOT VentFeed.Allow THEN
    vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_FEED;
    VentFeed.TurnOnMotor := FALSE;
END_IF;

(* Gestisco qui quali sono gli I/O effettivi da
   utilizzare: se non c'è il polmone, devo usare
   la corrispondente zona del modulo carico *)
IF vnBuf_Type>0 THEN
    (* Se c'è il modulo polmone indipendente, accendi tutto *)
    (* Nota: Usare solo O_VENT1SHUT_FEED per quando riscontro, se no si muovono lastre accumulate!! *)
    O_VENT_FEED := VentFeed.MotorOutput AND (vnVents_MotorOff & MSK_VENT_FEED)=0;
    O_VENT1SHUT_FEED := VentFeed.ShutOutput AND ((vnVents_Cmd OR vnVents_CmdOvl) & BIT_VENT_FEED)<>0;
    O_VENT2SHUT_FEED := VentFeed.ShutOutput AND ((vnVents_Cmd OR vnVents_CmdOvl) & BIT_VENT_LOAD)<>0;
    (* Segnale richiesta per macchina esterna *)
    O_REQ_VENT1FEED := VentFeed.Activate;
ELSE
    (* Se non c'è polmone:
       VentBuf pilota il lato approvvigionamento, se ci sono i consensi
       VentFeed pilota solo lato caricatrice *)
    O_VENT_FEED := (VentFeed.MotorOutput OR (VentFeed.Allow AND VentBuf.MotorOutput)) AND (vnVents_MotorOff & MSK_VENT_FEED)=0;
    O_VENT1SHUT_FEED := VentFeed.Allow AND VentBuf.ShutOutput;
    O_VENT2SHUT_FEED := VentFeed.ShutOutput;
    (* Segnale richiesta per macchina esterna *)
    O_REQ_VENT1FEED := VentFeed.Activate OR VentBuf.Activate;
END_IF;

(* Gestione accensione del secondo gruppo motori (lato caricatrice)
   Non voglio che lo spunto sia contemporaneo a O_VENT_FEED *)
TVents1FeedStarted( in:=O_VENT_FEED, pt:=TO_UDINT(vqVent_RampTime) );
O_VENT2_FEED := TVents1FeedStarted.q;

(* Piloto i ventilatori dell'eventuale tavolo di supporto
   Se c'è un monolitico combinato è lui a gestirseli *)
IF vbFeedAux_Present AND vnComboFloat_Type=0 THEN
    O_VENT_FEED2 := O_VENT_FEED;
    O_VENTSHUT_FEED2 := O_VENT1SHUT_FEED;
END_IF;

(* Regolazione flusso cuscino aria della zona carico
Con inverter: la velocità del motore dei ventilatori è regolata,
              il flusso d'aria dipende dalla velocità con la legge
              implementata in 'fbAirFlowCalc'
IF AO_###_VENTFLOW>0 THEN
    vnVentFeed_Flux potrebbe essere calcolato da:
    fbAirFlowCalc( Thckn:=TO_LREAL(vqGlass_Thckn), MaxThckn:=TO_LREAL(vqMaxFluxThckn) );
    vnVentFeed_Flux := VentFlowCalc.RefSpd;
    VentRefSpd( Index:=AO_###_VENTFLOW, ValueSet:=fbAirFlowCalc.RefSpd, ValueMax:=fbAirFlowCalc.MaxSpd );
    VentRefSpd( Index:=AO_###_VENTFLOW, ValueSet:=vnVentFeed_Flux, ValueMax:=100 );
END_IF;
Con serranda: 'O_*SHUT*' apre la serranda piccola e 'O_*FLUX*' apre tutto,
              il vincolo è che 'O_*FLUX*' non deve essere ON se 'O_*SHUT*' è OFF *)
O_VENT1FLUX_FEED := O_VENT1SHUT_FEED AND vnVentFeed_Flux>50;
O_VENT2FLUX_FEED := O_VENT2SHUT_FEED AND vnVentFeed_Flux>50;



(* -- Task a bassa priorità -- *)
IF vbHeartBeat THEN

    (* Notifica termica ventilatori zona fine linea *)
    IF IPR_VENT_OUTZONE AND NOT IS_MSG(MSG_PR_VENT_OUTZONE) THEN
        (* dlog( Txt:='fbVents: !! OutZone vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT_OUTZONE,'MSG_PR_VENT_OUTZONE',0);
    END_IF;

    (* Notifica termica ventilatori riscontri zona premilastra *)
    IF IPR_VENT_ALGN_C AND NOT IS_MSG(MSG_PR_VENT_ALGN_C) THEN
        (* dlog( Txt:='fbVents: !! AlgnC vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT_ALGN_C,'MSG_PR_VENT_ALGN_C',0);
    END_IF;

    (* Notifica termica ventilatori riscontri banda bassa *)
    IF IPR_VENT_ALGN_B AND NOT IS_MSG(MSG_PR_VENT_ALGN_B) THEN
        (* dlog( Txt:='fbVents: !! AlgnB vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT_ALGN_B,'MSG_PR_VENT_ALGN_B',0);
    END_IF;

    (* Notifica termica ventilatori riscontri banda mediana *)
    IF IPR_VENT_ALGN_M AND NOT IS_MSG(MSG_PR_VENT_ALGN_M) THEN
        (* dlog( Txt:='fbVents: !! AlgnM vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT_ALGN_M,'MSG_PR_VENT_ALGN_M',0);
    END_IF;

    (* Notifica termica ventilatori riscontri banda alta *)
    IF IPR_VENT_ALGN_T AND NOT IS_MSG(MSG_PR_VENT_ALGN_T) THEN
        (* dlog( Txt:='fbVents: !! AlgnT vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT_ALGN_T,'MSG_PR_VENT_ALGN_T',0);
    END_IF;

    (* Notifica termica ventilatori stacco *)
    IF IPR_VENT_DTCH AND NOT IS_MSG(MSG_PR_VENT_DTCH) THEN
        (* dlog( Txt:='fbVents: !! Dtch vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT_DTCH,'MSG_PR_VENT_DTCH',0);
    END_IF;

    (* Notifica termica ventilatori polmone *)
    IF IPR_VENT_BUF AND NOT IS_MSG(MSG_PR_VENT_BUF) THEN
        (* dlog( Txt:='fbVents: !! Buf vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT_BUF,'MSG_PR_VENT_BUF',0);
    END_IF;

    (* Notifica termiche ventilatori modulo di carico *)
    IF IPR_VENT1_FEED AND NOT IS_MSG(MSG_PR_VENT1_FEED) THEN
        (* dlog( Txt:='fbVents: !! Feed1 vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT1_FEED,'MSG_PR_VENT1_FEED',0);
    END_IF;
    IF IPR_VENT2_FEED AND NOT IS_MSG(MSG_PR_VENT2_FEED) THEN
        (* dlog( Txt:='fbVents: !! Feed2 vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT2_FEED,'MSG_PR_VENT2_FEED',0);
    END_IF;
    IF IPR_VENT_FEED2 AND NOT IS_MSG(MSG_PR_VENT_FEED2) THEN
        (* dlog( Txt:='fbVents: !! FeedAux vents HW failure', Lvl:=1 ); *)
        SET_MSG(MSG_PR_VENT_FEED2,'MSG_PR_VENT_FEED2',0);
    END_IF;


    (* Reset messaggio ventilatori riscontri zona premilastra non permessi
    IF VentAlgnC.Allow AND IS_MSG(MSG_LOCK_VENT_ALGN_C) THEN
        RST_MSG(MSG_LOCK_VENT_ALGN_C);
    END_IF;

    (* Reset messaggio ventilatori riscontri banda bassa non permessi
    IF VentAlgnB.Allow AND IS_MSG(MSG_LOCK_VENT_ALGN_B) THEN
        RST_MSG(MSG_LOCK_VENT_ALGN_B);
    END_IF;

    (* Reset messaggio ventilatori riscontri banda mediana non permessi
    IF VentAlgnM.Allow AND IS_MSG(MSG_LOCK_VENT_ALGN_M) THEN
        RST_MSG(MSG_LOCK_VENT_ALGN_M);
    END_IF;

    (* Reset messaggio ventilatori riscontri banda alta non permessi
    IF VentAlgnT.Allow AND IS_MSG(MSG_LOCK_VENT_ALGN_T) THEN
        RST_MSG(MSG_LOCK_VENT_ALGN_T);
    END_IF;

    (* Reset messaggio ventilatori stacco non permessi
    IF VentDtch.Allow AND IS_MSG(MSG_LOCK_VENT_DTCH) THEN
        RST_MSG(MSG_LOCK_VENT_DTCH);
    END_IF;

    (* Reset messaggio ventilatori polmone non permessi
    IF VentBuf.Allow AND IS_MSG(MSG_LOCK_VENT_BUF) THEN
        RST_MSG(MSG_LOCK_VENT_BUF);
    END_IF;

    (* Reset messaggio ventilatori modulo di carico non permessi
    IF VentFeed.Allow AND IS_MSG(MSG_LOCK_VENT_FEED) THEN
        RST_MSG(MSG_LOCK_VENT_FEED);
    END_IF;    *)

END_IF; (* vbHeartBeat *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbBeltsOutZone

{ DE:"Cinghie a fine linea" }

	VAR_IN_OUT
	Cmd : ST_BELTSCMD; { DE:"Command data" }
	END_VAR

	VAR_INPUT
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	END_VAR

	VAR_OUTPUT
	CurrPos : DINT; { DE:"Current position [um]" }
	CurrSpd : DINT; { DE:"Current speed [um/min]" }
	Arrived : BOOL; { DE:"Asse giunto a destinazione" }
	Belts2Fault : BOOL; { DE:"Gruppo cinghie gemelle non risponde" }
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Rulli a riposo" }
	ID : INT := ID_BELTS_OUTZONE; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	Co : fbM32Axis; { DE:"Asse cinghie fine linea AX_CO" }
	IFC_OUTZONE_BELTS_DWN : BOOL; { DE:"Sensore cinghie fine linea basse" }
	IFC_OUTZONE_BELTS_UP : BOOL; { DE:"Sensore cinghie fine linea alte" }
	O_OUTZONE_BELTS_UP : BOOL; { DE:"Aziona salita cinghie fine linea" }
	vqBelts_OutTime : DINT; { DE:"Tempo minimo attesa salita cinghie [ms]" }
	vqBelts_InTime : DINT; { DE:"Tempo attesa discesa cinghie [ms]" }
	vbBelts_HoldStartPos : BOOL; { DE:"Condizione aggiuntiva per partenza posizionamento cinghie" }
	vbBeltsAlgn_HaveFcDown : BOOL; { DE:"Cinghie riscontri dotate di sensore su posizione bassa" }
	Co2 : fbM32Axis; { DE:"Asse cinghie gemelle fine linea AX_CO2" }
	IFC_OUTZONE2_BELTS_UP : BOOL; { DE:"Sensore cinghie gemelle fine linea alte" }
	O_OUTZONE2_BELTS_UP : BOOL; { DE:"Aziona salita cinghie gemelle fine linea" }
	vqBelts2_ToutCheck : DINT; { DE:"Tempo controllo cinghie gemelle [ms]" }
	END_VAR

	VAR
	IsUp : BOOL; { DE:"Consider ready up" }
	IsDown : BOOL; { DE:"Consider ready down" }
	TWaitUp : Ton; { DE:"Timer to wait the belts out" }
	TWaitDwn : Ton; { DE:"Timer to wait the belts in" }
	TUpDwnTout : Ton; { DE:"Timeout on belts up/down" }
	TBelts2Fault : Ton; { DE:"Timeout cinghie gemelle" }
	END_VAR

	{ CODE:ST }(*    fbBeltsOutZone (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Servizi relativi alle cinghie in zona fine linea.
*)

IF vbBeltsAlgn_HaveFcDown THEN
    (* Ci sono solo i sensori cinghie basse *)
    IsUp := NOT IFC_OUTZONE_BELTS_DWN OR Co.Emulated;
    IsDown := IFC_OUTZONE_BELTS_DWN OR Co.Emulated;
ELSE
    (* Ci sono solo i sensori cinghie alte *)
    IsUp := IFC_OUTZONE_BELTS_UP OR Co.Emulated;
    IsDown := NOT IFC_OUTZONE_BELTS_UP OR Co.Emulated;
END_IF;

(* - State machine - *)
BELT_SEQ('fbBeltsOutZone',Co,TRUE,IsDown,IsUp,O_OUTZONE_BELTS_UP);

(* -- Gruppo cinghie aggiuntivo --  *)
IF NOT Co2.Emulated THEN
    BELTS_GROUP2(Co2,O_OUTZONE2_BELTS_UP,IFC_OUTZONE2_BELTS_UP,Co,O_OUTZONE_BELTS_UP);
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbRollsAlgn

{ DE:"Cinghie/Rulli di trasporto su modulo riscontri" }

	VAR_IN_OUT
	Cmd : ST_BELTSCMD; { DE:"Command data" }
	END_VAR

	VAR_INPUT
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	END_VAR

	VAR_OUTPUT
	CurrPos : DINT; { DE:"Current position [um]" }
	CurrSpd : DINT; { DE:"Current speed [um/min]" }
	Arrived : BOOL; { DE:"Asse giunto a destinazione" }
	Belts2Fault : BOOL; { DE:"Gruppo cinghie gemelle non risponde" }
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Rulli a riposo" }
	ID : INT := ID_ROLLS_ALGN; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	Cr : fbM32Axis; { DE:"Asse rulli modulo riscontro AX_CR" }
	IFC_ALGN_ROLLS_DWN : BOOL; { DE:"Sensore cinghie/rulli su riscontro basse" }
	IFC_ALGN_ROLLS_UP : BOOL; { DE:"Sensore rulli alti modulo riscontri" }
	O_ALGN_ROLLS_UP : BOOL; { DE:"Aziona salita rulli modulo riscontri" }
	vqBelts_OutTime : DINT; { DE:"Tempo minimo attesa salita cinghie [ms]" }
	vqBelts_InTime : DINT; { DE:"Tempo attesa discesa cinghie [ms]" }
	vbBelts_HoldStartPos : BOOL; { DE:"Condizione aggiuntiva per partenza posizionamento cinghie" }
	vbBeltsAlgn_HaveFcDown : BOOL; { DE:"Cinghie riscontri dotate di sensore su posizione bassa" }
	vbClampAlgn_AlmostUp : BOOL; { DE:"Segnale per anticipo attesa premilastra alto" }
	Cr2 : fbM32Axis; { DE:"Asse cinghie/rulli gemelle riscontro AX_CR2" }
	IFC_ALGN2_ROLLS_UP : BOOL; { DE:"Sensore cinghie gemelle su riscontro alte" }
	O_ALGN2_ROLLS_UP : BOOL; { DE:"Aziona salita cinghie gemelle su riscontro" }
	vqBelts2_ToutCheck : DINT; { DE:"Tempo controllo cinghie gemelle [ms]" }
	END_VAR

	VAR
	IsUp : BOOL; { DE:"Consider ready up" }
	IsDown : BOOL; { DE:"Consider ready down" }
	TWaitUp : Ton; { DE:"Timer to wait the belts out" }
	TWaitDwn : Ton; { DE:"Timer to wait the belts in" }
	TUpDwnTout : Ton; { DE:"Timeout on belts up/down" }
	TBelts2Fault : Ton; { DE:"Timeout cinghie gemelle" }
	END_VAR

	{ CODE:ST }(*    fbRollsAlgn (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Servizi relativi ai rulli di trasporto su modulo
      riscontri.
*)

IF vbBeltsAlgn_HaveFcDown THEN
    (* Ci sono solo i sensori cinghie basse *)
    IsUp := NOT IFC_ALGN_ROLLS_DWN OR Cr.Emulated;
    IsDown := IFC_ALGN_ROLLS_DWN OR Cr.Emulated;
ELSE
    (* Ci sono solo i sensori cinghie alte *)
    IsUp := IFC_ALGN_ROLLS_UP OR Cr.Emulated;
    IsDown := NOT IFC_ALGN_ROLLS_UP OR Cr.Emulated;
END_IF;

(* - State machine - *)
BELT_SEQ('fbRollsAlgn',Cr,vbClampAlgn_AlmostUp,IsDown,IsUp,O_ALGN_ROLLS_UP);

(* -- Gruppo cinghie aggiuntivo --  *)
IF NOT Cr2.Emulated THEN
    BELTS_GROUP2(Cr2,O_ALGN2_ROLLS_UP,IFC_ALGN2_ROLLS_UP,Cr,O_ALGN_ROLLS_UP);
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbBeltsDtch

{ DE:"Trasportatori su modulo stacco" }

	VAR_IN_OUT
	Cmd : ST_BELTSCMD; { DE:"Command data" }
	END_VAR

	VAR_INPUT
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	CanGoUp : BOOL; { DE:"Condizioni da attendere per la salita" }
	END_VAR

	VAR_OUTPUT
	CurrPos : DINT; { DE:"Current position [um]" }
	CurrSpd : DINT; { DE:"Current speed [um/min]" }
	Arrived : BOOL; { DE:"Asse giunto a destinazione" }
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Cinghie a riposo" }
	ID : INT := ID_BELTS_DTCH; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	Cs : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo stacco (Detach) AX_CS" }
	IFC_DTCH_BELTS_UP : BOOL; { DE:"Sensore cinghie alte modulo stacco" }
	O_DTCH_BELTS_UP : BOOL; { DE:"Aziona salita cinghie stacco" }
	vqBelts_OutTime : DINT; { DE:"Tempo minimo attesa salita cinghie [ms]" }
	vqBelts_InTime : DINT; { DE:"Tempo attesa discesa cinghie [ms]" }
	vbBelts_HoldStartPos : BOOL; { DE:"Condizione aggiuntiva per partenza posizionamento cinghie" }
	vbClampDtch_AlmostUp : BOOL; { DE:"Segnale per anticipo attesa premilastra alto" }
	END_VAR

	VAR
	IsUp : BOOL; { DE:"Consider ready up" }
	IsDown : BOOL; { DE:"Consider ready down" }
	TWaitUp : Ton; { DE:"Timer to wait the belts out" }
	TWaitDwn : Ton; { DE:"Timer to wait the belts in" }
	TUpDwnTout : Ton; { DE:"Timeout on belts up/down" }
	END_VAR

	{ CODE:ST }(*    fbBeltsDtch (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Servizi relativi alle cinghie di trasporto su
      modulo stacco.
*)

IsUp := IFC_DTCH_BELTS_UP OR Cs.Emulated;
IsDown := NOT IFC_DTCH_BELTS_UP OR Cs.Emulated;

(* - State machine - *)
BELT_SEQ('fbBeltsDtch',Cs,vbClampDtch_AlmostUp,IsDown,IsUp,O_DTCH_BELTS_UP);

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbBeltsBuf

{ DE:"Trasportatori su modulo polmone" }

	VAR_IN_OUT
	Cmd : ST_BELTSCMD; { DE:"Command data" }
	END_VAR

	VAR_INPUT
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	END_VAR

	VAR_OUTPUT
	CurrPos : DINT; { DE:"Current position [um]" }
	CurrSpd : DINT; { DE:"Current speed [um/min]" }
	Arrived : BOOL; { DE:"Asse giunto a destinazione" }
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Cinghie a riposo" }
	ID : INT := ID_BELTS_BUF; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	Cb : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo stacco (Detach) AX_CS" }
	IFC_BUF_BELTS_UP : BOOL; { DE:"Sensore cinghie alte modulo polmone" }
	O_BUF_BELTS_UP : BOOL; { DE:"Aziona salita cinghie polmone" }
	vqBelts_OutTime : DINT; { DE:"Tempo minimo attesa salita cinghie [ms]" }
	vqBelts_InTime : DINT; { DE:"Tempo attesa discesa cinghie [ms]" }
	vbBelts_HoldStartPos : BOOL; { DE:"Condizione aggiuntiva per partenza posizionamento cinghie" }
	END_VAR

	VAR
	IsUp : BOOL; { DE:"Consider ready up" }
	IsDown : BOOL; { DE:"Consider ready down" }
	TWaitUp : Ton; { DE:"Timer to wait the belts out" }
	TWaitDwn : Ton; { DE:"Timer to wait the belts in" }
	TUpDwnTout : Ton; { DE:"Timeout on belts up/down" }
	END_VAR

	{ CODE:ST }(*    fbBeltsBuf (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Servizi relativi alle cinghie di trasporto su
      modulo polmone.

      DETAILS
      ----------------------------------------------
      Queste cinghie sono opzionali e possono non
      esistere!
*)

IsUp := IFC_BUF_BELTS_UP OR Cb.Emulated;
IsDown := NOT IFC_BUF_BELTS_UP OR Cb.Emulated;

(* - State machine - *)
BELT_SEQ('fbBeltsBuf',Cb,TRUE,IsDown,IsUp,O_BUF_BELTS_UP);

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbBeltsFeed

{ DE:"Trasportatori su modulo carico" }

	VAR_IN_OUT
	Cmd : ST_BELTSCMD; { DE:"Command data" }
	END_VAR

	VAR_INPUT
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	END_VAR

	VAR_OUTPUT
	CurrPos : DINT; { DE:"Current position [um]" }
	CurrSpd : DINT; { DE:"Current speed [um/min]" }
	Arrived : BOOL; { DE:"Asse giunto a destinazione" }
	Belts2Fault : BOOL; { DE:"Gruppo cinghie gemelle non risponde" }
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Cinghie a riposo" }
	ID : INT := ID_BELTS_FEED; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	Ca : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo carico/accumulo AX_CA" }
	IFC_FEED_BELTS_UP : BOOL; { DE:"Sensore cinghie alte modulo stacco" }
	O_FEED_BELTS_UP : BOOL; { DE:"Aziona salita cinghie stacco" }
	vqBelts_OutTime : DINT; { DE:"Tempo minimo attesa salita cinghie [ms]" }
	vqBelts_InTime : DINT; { DE:"Tempo attesa discesa cinghie [ms]" }
	vbBelts_HoldStartPos : BOOL; { DE:"Condizione aggiuntiva per partenza posizionamento cinghie" }
	Ca2 : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo carico/accumulo AX_CA" }
	IFC_FEED2_BELTS_UP : BOOL; { DE:"Sensore cinghie alte tavolo aggiuntivo carico alto" }
	O_FEED2_BELTS_UP : BOOL; { DE:"Aziona salita cinghie carico aggiuntivo alto" }
	vqBelts2_ToutCheck : DINT; { DE:"Tempo controllo cinghie gemelle [ms]" }
	END_VAR

	VAR
	IsUp : BOOL; { DE:"Consider ready up" }
	IsDown : BOOL; { DE:"Consider ready down" }
	TWaitUp : Ton; { DE:"Timer to wait the belts out" }
	TWaitDwn : Ton; { DE:"Timer to wait the belts in" }
	TUpDwnTout : Ton; { DE:"Timeout on belts up/down" }
	TBelts2Fault : Ton; { DE:"Timeout cinghie gemelle" }
	END_VAR

	{ CODE:ST }(*    fbBeltsFeed (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Servizi relativi alle cinghie di trasporto su
      modulo di carico.
*)

IsUp := IFC_FEED_BELTS_UP OR Ca.Emulated;
IsDown := NOT IFC_FEED_BELTS_UP OR Ca.Emulated;

(* - State machine - *)
BELT_SEQ('fbBeltsFeed',Ca,TRUE,IsDown,IsUp,O_FEED_BELTS_UP);


(* -- Cinghie tavolo supporto carico --
   Sono cinghie gemelle che inseguono sempre quelle del carico *)
IF NOT Ca2.Emulated THEN
    BELTS_GROUP2(Ca2,O_FEED2_BELTS_UP,IFC_FEED2_BELTS_UP,Ca,O_FEED_BELTS_UP);
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbBelts

{ DE:"Gestore del movimento cinghie con inseguimenti" }

	VAR_IN_OUT
	Cmd : INT; { DE:"Comando: CMD_ACTIVATE, CMD_MOVETO" }
	END_VAR

	VAR_INPUT
	MasterIdx : INT; { DE:"Indice dell'asse da inseguire" }
	MasterTgt : DINT; { DE:"Muovi il Master a quota relativa [um], 0 per fermarlo" }
	MasterSpd : DINT; { DE:"Velocità Master [um/min]" }
	MasterAcc : INT; { DE:"Parzializzazione accelerazione Master [%]" }
	SlaveBelts : INT; { DE:"Selezione a bit delle cinghie che inseguono" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del sistema cinghie" }
	AllowedBelts : INT; { DE:"Monitor a bit dei consensi alle cinghie" }
	ManagedBelts : INT; { DE:"Maschera delle cinghie gestite" }
	OperatingBelts : INT; { DE:"Monitor a bit delle cinghie in movimento/inseguimento" }
	ActiveBelts : INT; { DE:"Monitor a bit delle cinghie alte pronte per il movimento" }
	AtRestBelts : INT; { DE:"Monitor a bit delle cinghie a riposo" }
	Master_CurrPos : DINT; { DE:"Posizione corrente Master [um]" }
	Master_CurrSpd : DINT; { DE:"Velocità corrente Master [um/min]" }
	Master_Status : INT; { DE:"Stato del Master" }
	Master_Arrived : BOOL; { DE:"Flag asse Master arrivato a destinazione" }
	ID : INT := ID_BELTS; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	Co : fbM32Axis; { DE:"Asse cinghie/Conveyors zona fine linea/uscita pezzi (Output) AX_CO" }
	Cr : fbM32Axis; { DE:"Asse rulli modulo riscontro AX_CR" }
	Cs : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo stacco (Detach) AX_CS" }
	Cb : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo polmone (Buffer) AX_CB" }
	Ca : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo carico/Accumulo AX_CA" }
	BeltsOutZone : fbBeltsOutZone; { DE:"Cinghie a fine linea" }
	RollsAlgn : fbRollsAlgn; { DE:"Rulli/Cinghie di trasporto su modulo riscontri" }
	BeltsDtch : fbBeltsDtch; { DE:"Trasportatori su modulo stacco" }
	BeltsBuf : fbBeltsBuf; { DE:"Trasportatori su modulo polmone" }
	BeltsFeed : fbBeltsFeed; { DE:"Trasportatori su modulo di carico" }
	vnBelts_Act : INT; { DE:"Maschera forzatura attivazione cinghie" }
	vqShift_HeavyThckn : DINT; { DE:"Soglia spessore per accensione cuscino aria e minori accelerazioni [um]" }
	vnBelts_HeavyAcc : INT; { DE:"Parzializzazione accelerazione traslazione lastre pesanti [%]" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vnVents_CmdOvl : INT; { DE:"Overlay permanente (usato per pilotaggio con cinghie)" }
	vbBelts_WaitStartPosCond : BOOL; { DE:"Attiva condizione di partenza posizionamento cinghie" }
	vbBelts_HoldStartPos : BOOL; { DE:"Condizione aggiuntiva per partenza posizionamento cinghie" }
	vbAirCushionReady : BOOL; { DE:"Stato complessivo del cuscino d'aria" }
	vqRollsAlgn_Target : DINT; { DE:"Movimento cinghie riscontro [um]" }
	vqRollsAlgn_MaxSpeed : DINT; { DE:"Velocità movimento cinghie riscontro [um/min]" }
	vnRollsAlgn_Accel : INT; { DE:"Accelerazione movimento cinghie riscontro [%]" }
	vbRollsAlgn_Arrived : BOOL; { DE:"Cinghie riscontro arrivate" }
	END_VAR

	VAR
	master_idx : INT; { DE:"Indice master impostato" }
	master_tgt : DINT; { DE:"Quota obiettivo master impostata [um]" }
	master_spd : DINT; { DE:"Velocità master impostata [um/min]" }
	master_acc : INT; { DE:"Accelerazione master impostata [%]" }
	slave_belts : INT; { DE:"Inseguimenti impostati" }
	END_VAR

	{ CODE:ST }(*    fbBelts (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Gestione del movimento cinghie e inseguimenti
         ·Cinghie carico/accumulo
         ·Cinghie polmone (opzionali)
         ·Cinghie stacco
         ·Cinghie/Rulli zona taglio riscontri
         ·Cinghie fine linea
*)

(* -- Gestione delle cinghie a bit: monitor -- *)
AllowedBelts := 0;
OperatingBelts := 0;
ActiveBelts := 0;
AtRestBelts := 0;

IF BeltsOutZone.Allow                 THEN AllowedBelts := AllowedBelts OR BIT_BELTS_OUTZONE; END_IF;
IF BeltsOutZone.Status=BLT_OPERATING  THEN OperatingBelts := OperatingBelts OR BIT_BELTS_OUTZONE;
ELSIF BeltsOutZone.Status=BLT_ENABLED THEN ActiveBelts := ActiveBelts OR BIT_BELTS_OUTZONE;
ELSIF BeltsOutZone.AtRest             THEN AtRestBelts := AtRestBelts OR BIT_BELTS_OUTZONE; END_IF;

IF RollsAlgn.Allow                 THEN AllowedBelts := AllowedBelts OR BIT_ROLLS_ALGN; END_IF;
IF RollsAlgn.Status=BLT_OPERATING  THEN OperatingBelts := OperatingBelts OR BIT_ROLLS_ALGN;
ELSIF RollsAlgn.Status=BLT_ENABLED THEN ActiveBelts := ActiveBelts OR BIT_ROLLS_ALGN;
ELSIF RollsAlgn.AtRest             THEN AtRestBelts := AtRestBelts OR BIT_ROLLS_ALGN; END_IF;

IF BeltsDtch.Allow                 THEN AllowedBelts := AllowedBelts OR BIT_BELTS_DTCH; END_IF;
IF BeltsDtch.Status=BLT_OPERATING  THEN OperatingBelts := OperatingBelts OR BIT_BELTS_DTCH;
ELSIF BeltsDtch.Status=BLT_ENABLED THEN ActiveBelts := ActiveBelts OR BIT_BELTS_DTCH;
ELSIF BeltsDtch.AtRest             THEN AtRestBelts := AtRestBelts OR BIT_BELTS_DTCH; END_IF;

IF BeltsBuf.Allow                  THEN AllowedBelts := AllowedBelts OR BIT_BELTS_BUF; END_IF;
IF BeltsBuf.Status=BLT_OPERATING   THEN OperatingBelts := OperatingBelts OR BIT_BELTS_BUF;
ELSIF BeltsBuf.Status=BLT_ENABLED  THEN ActiveBelts := ActiveBelts OR BIT_BELTS_BUF;
ELSIF BeltsBuf.AtRest              THEN AtRestBelts := AtRestBelts OR BIT_BELTS_BUF; END_IF;

IF BeltsFeed.Allow                 THEN AllowedBelts := AllowedBelts OR BIT_BELTS_FEED; END_IF;
IF BeltsFeed.Status=BLT_OPERATING  THEN OperatingBelts := OperatingBelts OR BIT_BELTS_FEED;
ELSIF BeltsFeed.Status=BLT_ENABLED THEN ActiveBelts := ActiveBelts OR BIT_BELTS_FEED;
ELSIF BeltsFeed.AtRest             THEN AtRestBelts := AtRestBelts OR BIT_BELTS_FEED; END_IF;


(* Monitors asse master - sarebbe meglio usare array e accesso con indice? *)
CASE master_idx OF
    Cs.Idx :
        Master_Status := BeltsDtch.Status;
        Master_Arrived := Cs.Arrived;
        (* Master_InPosDelta := Cs.InPosDelta; *)
        Master_CurrPos := Cs.CurrPos;
        Master_CurrSpd := Cs.CurrSpd;
    Cr.Idx :
        Master_Status := RollsAlgn.Status;
        Master_Arrived := Cr.Arrived;
        (* Master_InPosDelta := Cr.InPosDelta; *)
        Master_CurrPos := Cr.CurrPos;
        Master_CurrSpd := Cr.CurrSpd;
    Cb.Idx :
        Master_Status := BeltsBuf.Status;
        Master_Arrived := Cb.Arrived;
        (* Master_InPosDelta := Cb.InPosDelta; *)
        Master_CurrPos := Cb.CurrPos;
        Master_CurrSpd := Cb.CurrSpd;
    Ca.Idx :
        Master_Status := BeltsFeed.Status;
        Master_Arrived := Ca.Arrived;
        (* Master_InPosDelta := Ca.InPosDelta; *)
        Master_CurrPos := Ca.CurrPos;
        Master_CurrSpd := Ca.CurrSpd;
    Co.Idx :
        Master_Status := BeltsOutZone.Status;
        Master_Arrived := Co.Arrived;
        (* Master_InPosDelta := Co.InPosDelta; *)
        Master_CurrPos := Co.CurrPos;
        Master_CurrSpd := Co.CurrSpd;
END_CASE;


(* -- Gestione delle cinghie a bit: comandi -- *)

(* Cambio dinamico dell'asse master *)
IF master_idx<>MasterIdx AND Status>BLT_DISABLING AND Status<BLT_OPERATING THEN
    dlog( Txt:='fbBelts: Changing master %d => %d', Lvl:=5, Val1:=TO_DINT(master_idx), Val2:=TO_DINT(MasterIdx) );

    (* I comandi MasterTgt,MasterSpd sono già stati reimpostati *)
    (* Reimposto il comando del master corrente *)
    CASE MasterIdx OF
        Cs.Idx : BeltsDtch.Cmd.Target := 0;
        Cr.Idx : RollsAlgn.Cmd.Target := 0;
        Cb.Idx : BeltsBuf.Cmd.Target := 0;
        Ca.Idx : BeltsFeed.Cmd.Target := 0;
        Co.Idx : BeltsOutZone.Cmd.Target := 0;
    END_CASE;
    master_idx := MasterIdx; (* Applied *)

    (* Reimposto gli inseguimenti *)
    IF (SlaveBelts & BIT_BELTS_OUTZONE)<>0 THEN
        IF master_idx<>Co.Idx THEN
            BeltsOutZone.Cmd.Follow := master_idx;
        ELSE
            BeltsOutZone.Cmd.Follow := 0;
            SlaveBelts := SlaveBelts & NOT BIT_BELTS_OUTZONE;
        END_IF;
    END_IF;
    IF (SlaveBelts & BIT_ROLLS_ALGN)<>0 THEN
        IF master_idx<>Cr.Idx THEN
            RollsAlgn.Cmd.Follow := master_idx;
        ELSE
            RollsAlgn.Cmd.Follow := 0;
            SlaveBelts := SlaveBelts & NOT BIT_ROLLS_ALGN;
        END_IF;
    END_IF;
    IF (SlaveBelts & BIT_BELTS_DTCH)<>0 THEN
        IF master_idx<>Cs.Idx THEN
            BeltsDtch.Cmd.Follow := master_idx;
        ELSE
            BeltsDtch.Cmd.Follow := 0;
            SlaveBelts := SlaveBelts & NOT BIT_BELTS_DTCH;
        END_IF;
    END_IF;
    IF (SlaveBelts & BIT_BELTS_BUF)<>0 THEN
        IF master_idx<>Cb.Idx THEN
            BeltsBuf.Cmd.Follow := master_idx;
        ELSE
            BeltsBuf.Cmd.Follow := 0;
            SlaveBelts := SlaveBelts & NOT BIT_BELTS_BUF;
        END_IF;
    END_IF;
    IF (SlaveBelts & BIT_BELTS_FEED)<>0 THEN
        IF master_idx<>Ca.Idx THEN
            BeltsFeed.Cmd.Follow := master_idx;
        ELSE
            BeltsFeed.Cmd.Follow := 0;
            SlaveBelts := SlaveBelts & NOT BIT_BELTS_FEED;
        END_IF;
    END_IF;
    slave_belts := SlaveBelts; (* Applied *)

    (* Cinghie gestite: master + slaves *)
    CASE master_idx OF
        Cs.Idx : ManagedBelts := SlaveBelts OR BIT_BELTS_DTCH;
                 BeltsDtch.Cmd.Target := 0;
        Cr.Idx : ManagedBelts := SlaveBelts OR BIT_ROLLS_ALGN;
                 RollsAlgn.Cmd.Target := 0;
        Cb.Idx : ManagedBelts := SlaveBelts OR BIT_BELTS_BUF;
                 BeltsBuf.Cmd.Target := 0;
        Ca.Idx : ManagedBelts := SlaveBelts OR BIT_BELTS_FEED;
                 BeltsFeed.Cmd.Target := 0;
        Co.Idx : ManagedBelts := SlaveBelts & BIT_BELTS_OUTZONE;
                 BeltsOutZone.Cmd.Target := 0;
    END_CASE;

    (* Attivo tutte le cinghie gestite *)
    vnBelts_Act := ManagedBelts;
    Status := BLT_ENABLING;
END_IF; (* Cambio dinamico del Master *)

(* -Inserzione e disinserzione dinamica inseguimenti- *)
IF slave_belts<>SlaveBelts AND Status>=BLT_ENABLING AND Cmd<>CMD_STOP THEN

    IF (SlaveBelts & BIT_BELTS_FEED)=0 AND (slave_belts & BIT_BELTS_FEED)<>0 THEN
        dlog( Txt:='fbBelts: BeltsFeed unfollows %d', Lvl:=7, Val1:=TO_DINT(BeltsFeed.Cmd.Follow) );
        BeltsFeed.Cmd.Follow := 0;
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_FEED;
        ManagedBelts := ManagedBelts & NOT BIT_BELTS_FEED;
    ELSIF (SlaveBelts & BIT_BELTS_FEED)<>0 AND BeltsFeed.Cmd.Follow=0 AND master_idx<>Ca.Idx THEN
        dlog( Txt:='fbBelts: BeltsFeed follows %d', Lvl:=7, Val1:=TO_DINT(master_idx) );
        BeltsFeed.Cmd.Follow := master_idx;
        vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED;
        ManagedBelts := ManagedBelts OR BIT_BELTS_FEED;
    END_IF;

    IF (SlaveBelts & BIT_BELTS_BUF)=0 AND (slave_belts & BIT_BELTS_BUF)<>0 THEN
        dlog( Txt:='fbBelts: BeltsBuf unfollows %d', Lvl:=7, Val1:=TO_DINT(BeltsBuf.Cmd.Follow) );
        BeltsBuf.Cmd.Follow := 0;
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_BUF;
        ManagedBelts := ManagedBelts & NOT BIT_BELTS_BUF;
    ELSIF (SlaveBelts & BIT_BELTS_BUF)<>0 AND BeltsBuf.Cmd.Follow=0 AND master_idx<>Cb.Idx THEN
        dlog( Txt:='fbBelts: BeltsBuf follows %d', Lvl:=7, Val1:=TO_DINT(master_idx) );
        BeltsBuf.Cmd.Follow := master_idx;
        vnBelts_Act := vnBelts_Act OR BIT_BELTS_BUF;
        ManagedBelts := ManagedBelts OR BIT_BELTS_BUF;
    END_IF;

    IF (SlaveBelts & BIT_BELTS_DTCH)=0 AND (slave_belts & BIT_BELTS_DTCH)<>0 THEN
        dlog( Txt:='fbBelts: BeltsDtch unfollows %d', Lvl:=7, Val1:=TO_DINT(BeltsDtch.Cmd.Follow) );
        BeltsDtch.Cmd.Follow := 0;
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_DTCH;
        ManagedBelts := ManagedBelts & NOT BIT_BELTS_DTCH;
    ELSIF (SlaveBelts & BIT_BELTS_DTCH)<>0 AND BeltsDtch.Cmd.Follow=0 AND master_idx<>Cs.Idx THEN
        dlog( Txt:='fbBelts: BeltsDtch follows %d', Lvl:=7, Val1:=TO_DINT(master_idx) );
        BeltsDtch.Cmd.Follow := master_idx;
        vnBelts_Act := vnBelts_Act OR BIT_BELTS_DTCH;
        ManagedBelts := ManagedBelts OR BIT_BELTS_DTCH;
    END_IF;

    IF (SlaveBelts & BIT_ROLLS_ALGN)=0 AND (slave_belts & BIT_ROLLS_ALGN)<>0 THEN
        dlog( Txt:='fbBelts: Rolls unfollows %d', Lvl:=7, Val1:=TO_DINT(RollsAlgn.Cmd.Follow) );
        RollsAlgn.Cmd.Follow := 0;
        vnBelts_Act := vnBelts_Act & NOT BIT_ROLLS_ALGN;
        ManagedBelts := ManagedBelts & NOT BIT_ROLLS_ALGN;
    ELSIF (SlaveBelts & BIT_ROLLS_ALGN)<>0 AND RollsAlgn.Cmd.Follow=0 AND master_idx<>Cr.Idx THEN
        dlog( Txt:='fbBelts: Rolls follows %d', Lvl:=7, Val1:=TO_DINT(master_idx) );
        RollsAlgn.Cmd.Follow := master_idx;
        vnBelts_Act := vnBelts_Act OR BIT_ROLLS_ALGN;
        ManagedBelts := ManagedBelts OR BIT_ROLLS_ALGN;
    END_IF;

    IF (SlaveBelts & BIT_BELTS_OUTZONE)=0 AND (slave_belts & BIT_BELTS_OUTZONE)<>0 THEN
        dlog( Txt:='fbBelts: BeltsOutZone unfollows %d', Lvl:=7, Val1:=TO_DINT(BeltsOutZone.Cmd.Follow) );
        BeltsOutZone.Cmd.Follow := 0;
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_OUTZONE;
        ManagedBelts := ManagedBelts & NOT BIT_BELTS_OUTZONE;
    ELSIF (SlaveBelts & BIT_BELTS_OUTZONE)<>0 AND BeltsOutZone.Cmd.Follow=0 AND master_idx<>Co.Idx THEN
        dlog( Txt:='fbBelts: BeltsOutZone follows %d', Lvl:=7, Val1:=TO_DINT(master_idx) );
        BeltsOutZone.Cmd.Follow := master_idx;
        vnBelts_Act := vnBelts_Act OR BIT_BELTS_OUTZONE;
        ManagedBelts := ManagedBelts OR BIT_BELTS_OUTZONE;
    END_IF;

    slave_belts := SlaveBelts; (* Applied *)
END_IF; (* Inserzione e disinserzione dinamica inseguimenti *)



(* - Servizio di movimentazione cinghie complessive - *)
CASE Status OF

    (* ------------------------------------------------------------------- *)
    BLT_OPERATING : (* Master movement in progress *)
        IF Master_Arrived THEN
            dlog( Txt:='fbBelts: Master %d arrived to %ld mm', Lvl:=5, Val1:=TO_DINT(master_idx), Val2:=Master_CurrPos/1E3 );
            Cmd := CMD_STOP; (* Resetto comando (scendo) *)
            Status := BLT_STOPPING;
        (* Abortisci se viene tolto/modificato il comando *)
        ELSIF Cmd<CMD_MOVETO THEN
            dlog( Txt:='fbBelts: Master %d Cmd=%d at %ld mm', Lvl:=2, Val1:=TO_DINT(master_idx), Val2:=TO_DINT(Cmd), Val3:=Master_CurrPos/1E3 );
            Status := BLT_STOPPING;
        ELSIF (OperatingBelts & slave_belts) <> slave_belts THEN
            dlog( Txt:='fbBelts: !! One or more slaves off (0x%X)', Lvl:=1, Val1:=TO_DINT(slave_belts & NOT OperatingBelts) );
            Cmd := CMD_STOP; (* Resetto comando (scendo) *)
            Status := BLT_STOPPING;
        ELSIF Master_Status<BLT_OPERATING THEN
            dlog( Txt:='fbBelts: ! Master %d ended (%d) at %ld mm', Lvl:=2, Val1:=TO_DINT(master_idx), Val2:=TO_DINT(Master_Status), Val3:=Master_CurrPos/1E3 );
            Cmd := CMD_ACTIVATE; (* Resetto comando (ma rimango alto) *)
            Status := BLT_STOPPING;
        (* Cambio dinamico target *)
        ELSIF master_tgt <> MasterTgt THEN
            dlog( Txt:='fbBelts: Master %d ChangeTgt %ld -> %ld mm (at %ld mm)', Lvl:=5, Val1:=TO_DINT(master_idx), Val2:=master_tgt/1E3, Val3:=MasterTgt/1E3, Val4:=Master_CurrPos/1E3 );
            (* Vedo se posso applicarlo *)
            IF VN_AX(iVN_AX_FASE,master_idx)<AFS_POS_DEC THEN
                CASE master_idx OF
                    Cs.Idx : BeltsDtch.Cmd.Target := MasterTgt;
                    Cr.Idx : RollsAlgn.Cmd.Target := MasterTgt;
                    Cb.Idx : BeltsBuf.Cmd.Target := MasterTgt;
                    Ca.Idx : BeltsFeed.Cmd.Target := MasterTgt;
                    Co.Idx : BeltsOutZone.Cmd.Target := MasterTgt;
                END_CASE;
                master_tgt := MasterTgt; (* applied *)
            ELSE
                MasterTgt := master_tgt; (* Not applied *)
            END_IF;
        (* Cambio dinamico velocità *)
        ELSIF master_spd <> MasterSpd THEN
            dlog( Txt:='fbBelts: Master %d ChangeSpd %ld -> %ld m/min (at %ld mm)', Lvl:=5, Val1:=TO_DINT(master_idx), Val2:=master_spd/1E6, Val3:=MasterSpd/1E6, Val4:=Master_CurrPos/1E3 );
            CASE master_idx OF
                Cs.Idx : BeltsDtch.Cmd.MaxSpeed := MasterSpd;
                Cr.Idx : RollsAlgn.Cmd.MaxSpeed := MasterSpd;
                Cb.Idx : BeltsBuf.Cmd.MaxSpeed := MasterSpd;
                Ca.Idx : BeltsFeed.Cmd.MaxSpeed := MasterSpd;
                Co.Idx : BeltsOutZone.Cmd.MaxSpeed := MasterSpd;
            END_CASE;
            master_spd := MasterSpd; (* applied *)
        (* Cambio dinamico accelerazione: non possibile *)
        (* ELSIF master_acc <> MasterAcc THEN *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    BLT_STOPPING : (* Wait master stop (slaves locked) *)
        vnVents_CmdOvl := 0; (* Via il cuscino aria *)
        (* Fermo il master *)
        CASE master_idx OF
            Cs.Idx : BeltsDtch.Cmd.Target := 0;
            Cr.Idx : RollsAlgn.Cmd.Target := 0;
            Cb.Idx : BeltsBuf.Cmd.Target := 0;
            Ca.Idx : BeltsFeed.Cmd.Target := 0;
            Co.Idx : BeltsOutZone.Cmd.Target := 0;
        END_CASE;
        (* Attendo che il master si fermi *)
        IF Master_Status < BLT_STOPPING THEN
            dlog( Txt:='fbBelts: Master %d stopped at %ld mm', Lvl:=5, Val1:=TO_DINT(master_idx), Val2:=Master_CurrPos/1E3 );
            IF Cmd=CMD_STOP THEN
                (* Stacco gli inseguimenti *)
                IF (slave_belts & BIT_BELTS_OUTZONE)<>0 THEN BeltsOutZone.Cmd.Follow := 0; END_IF;
                IF (slave_belts & BIT_ROLLS_ALGN)<>0 THEN RollsAlgn.Cmd.Follow := 0; END_IF;
                IF (slave_belts & BIT_BELTS_DTCH)<>0 THEN BeltsDtch.Cmd.Follow := 0; END_IF;
                IF (slave_belts & BIT_BELTS_BUF)<>0  THEN BeltsBuf.Cmd.Follow := 0;  END_IF;
                IF (slave_belts & BIT_BELTS_FEED)<>0 THEN BeltsFeed.Cmd.Follow := 0; END_IF;
                (* Disattivo le cinghie gestite, tanto voglio anche scendere *)
                vnBelts_Act := vnBelts_Act & NOT ManagedBelts;
                Status := BLT_DISABLING;
            ELSE (* CMD_ACTIVATE *)
                (* Mi sono fermato con cinghie alte e inseguimenti attivi *)
                Status := BLT_ENABLED;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    BLT_WAITSTART : (* Waiting master start movement *)
        (* Abortisci se viene tolto/modificato il comando *)
        IF Cmd<CMD_MOVETO THEN
            Status := BLT_STOPPING;
        ELSIF Master_Status<BLT_ENABLED THEN
            dlog( Txt:='fbBelts: !! WAITSTART: Master %d not ready (%d)', Lvl:=1, Val1:=TO_DINT(master_idx), Val2:=TO_DINT(Master_Status) );
            Cmd := CMD_STOP; (* Resetto comando (scendo) *)
            Status := BLT_STOPPING;
        ELSIF Master_Status=BLT_OPERATING OR
              ABS(Master_CurrPos-MasterTgt)<=Cs.InPosDelta THEN (* Evito blocco per posizionamenti così piccoli che lo stato torna subito in BLT_ENABLED *)
            (* Vedi se serve il cuscino d'aria: Praticamente richiedo tutte le zone eccetto il tavolo di riscontro *)
            vnVents_CmdOvl := SEL( vqGlass_Thckn>=vqShift_HeavyThckn, INT#0, NOT MSK_VENT_PROD );
            Status := BLT_OPERATING;
        END_IF;


    (* ------------------------------------------------------------------- *)
    BLT_ENABLED : (* Ready for movement (master and slaves) *)
        (* Abortisci se viene tolto il comando *)
        IF Cmd=CMD_STOP THEN
            (* Stacco gli inseguimenti *)
            IF (slave_belts & BIT_BELTS_OUTZONE)<>0  THEN BeltsOutZone.Cmd.Follow := 0;  END_IF;
            IF (slave_belts & BIT_ROLLS_ALGN)<>0 THEN RollsAlgn.Cmd.Follow := 0; END_IF;
            IF (slave_belts & BIT_BELTS_DTCH)<>0 THEN BeltsDtch.Cmd.Follow := 0; END_IF;
            IF (slave_belts & BIT_BELTS_BUF)<>0  THEN BeltsBuf.Cmd.Follow := 0;  END_IF;
            IF (slave_belts & BIT_BELTS_FEED)<>0 THEN BeltsFeed.Cmd.Follow := 0; END_IF;
            (* Disattivo le cinghie gestite *)
            vnBelts_Act := vnBelts_Act & NOT ManagedBelts;
            Status := BLT_DISABLING;
        ELSIF (OperatingBelts & slave_belts) <> slave_belts THEN
            dlog( Txt:='fbBelts: ! Slaves (0x%X) not operating (0x%X)', Lvl:=3, Val1:=TO_DINT(slave_belts), Val2:=TO_DINT(OperatingBelts) );
            Status := BLT_ENABLING;
        ELSIF Master_Status<BLT_ENABLED OR (Master_Status<>BLT_ENABLED AND Cmd=CMD_MOVETO) THEN
            dlog( Txt:='fbBelts: Master %d not enabled (%d)', Lvl:=3, Val1:=TO_DINT(master_idx), Val2:=TO_DINT(Master_Status) );
            Status := BLT_ENABLING;
        ELSIF Cmd=CMD_MOVETO THEN
            (* Setto quota obiettivo, velocità e accelerazione del master *)
            master_tgt := MasterTgt;
            master_spd := MasterSpd;
            (* Se lastre pesanti applico parzializzazione delle accelerazioni *)
            IF vqGlass_Thckn >= vqShift_HeavyThckn THEN
                master_acc := LIMIT( IN:=TO_INT(TO_LREAL(vnBelts_HeavyAcc)/100.0 * TO_LREAL(MasterAcc)), MN:=5, MX:=100 );
            ELSE
                master_acc := MasterAcc;
            END_IF;
            dlog( Txt:='fbBelts: Move master %d to %ld V=%ld m/min a=%d%%', Lvl:=5, Val1:=TO_DINT(master_idx), Val2:=master_tgt/1E3, Val3:=master_spd/1E6, Val4:=TO_DINT(master_acc) );

            CASE master_idx OF
                Cs.Idx : BeltsDtch.Cmd.Target := master_tgt;
                         BeltsDtch.Cmd.MaxSpeed := master_spd;
                         BeltsDtch.Cmd.Accel := master_acc;
                Cr.Idx : RollsAlgn.Cmd.Target := master_tgt;
                         RollsAlgn.Cmd.MaxSpeed := master_spd;
                         RollsAlgn.Cmd.Accel := master_acc;
                Cb.Idx : BeltsBuf.Cmd.Target := master_tgt;
                         BeltsBuf.Cmd.MaxSpeed := master_spd;
                         BeltsBuf.Cmd.Accel := master_acc;
                Ca.Idx : BeltsFeed.Cmd.Target := master_tgt;
                         BeltsFeed.Cmd.MaxSpeed := master_spd;
                         BeltsFeed.Cmd.Accel := master_acc;
                Co.Idx : BeltsOutZone.Cmd.Target := master_tgt;
                         BeltsOutZone.Cmd.MaxSpeed := master_spd;
                         BeltsOutZone.Cmd.Accel := master_acc;
            END_CASE;
            Status := BLT_WAITSTART;

            (* Mah, questo lo controllo dopo?
            IF ABS(Master_CurrPos-MasterTgt) > Cs.InPosDelta THEN
            ELSE
                dlog( Txt:='fbBelts: Master %d already at %d mm', Lvl:=1, Val1:=TO_DINT(master_idx), Val2:=MasterTgt/1E3 );
                Cmd := CMD_STOP;
                Status := BLT_STOPPING;
            END_IF; *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    BLT_ENABLING : (* Waiting ready for movement (master and slaves) *)
        (* Abortisci se viene tolto il comando *)
        IF Cmd=CMD_STOP THEN
            (* Stacco gli inseguimenti *)
            IF (slave_belts & BIT_BELTS_OUTZONE)<>0 THEN BeltsOutZone.Cmd.Follow := 0; END_IF;
            IF (slave_belts & BIT_ROLLS_ALGN)<>0 THEN RollsAlgn.Cmd.Follow := 0; END_IF;
            IF (slave_belts & BIT_BELTS_DTCH)<>0 THEN BeltsDtch.Cmd.Follow := 0; END_IF;
            IF (slave_belts & BIT_BELTS_BUF)<>0  THEN BeltsBuf.Cmd.Follow := 0;  END_IF;
            IF (slave_belts & BIT_BELTS_FEED)<>0 THEN BeltsFeed.Cmd.Follow := 0; END_IF;
            (* Disattivo le cinghie gestite *)
            vnBelts_Act := vnBelts_Act & NOT ManagedBelts;
            Status := BLT_DISABLING;
        (* Attendo consensi cinghie *)
        ELSIF (AllowedBelts & ManagedBelts)=ManagedBelts THEN
            vnBelts_Act := ManagedBelts; (* Attivo tutte le cinghie gestite (master+slaves) *)
            (* Procedi quando slaves agganciati e master pronto *)
            IF (OperatingBelts & SlaveBelts)=SlaveBelts AND Master_Status=BLT_ENABLED THEN
                (* Master_Arrived := FALSE; (* Abbastanza inutile, visto che è monitorato sopra *)
                Status := BLT_ENABLED;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    BLT_DISABLING : (* Wait full down *)
        (* Contratto: comando disattivazione già dato *)
        (* Attendo che tutte le cinghie gestite siano a riposo *)
        IF (AtRestBelts & ManagedBelts)=ManagedBelts THEN
            (* Se avessi solo fermato gli inseguimenti ora le dovrei far abbassare *)
            dlog( Txt:='fbBelts: All belts (0x%X) at rest', Lvl:=6, Val1:=TO_DINT(ManagedBelts) );
            ManagedBelts := 0;
            Cmd := CMD_STOP;
            Status := BLT_DISABLED;
            (* Here the result? IF Master_Arrived THEN DONE *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    ELSE (* BLT_DISABLED *)
        IF Cmd<>CMD_STOP THEN (* CMD_ACTIVATE, CMD_MOVETO *)
            (* Gli argomenti sono: MasterIdx, MasterTgt, MasterSpd, SlaveBelts *)
            master_idx := MasterIdx; (* Applied *)

            (* Imposto gli inseguimenti *)
            IF (SlaveBelts & BIT_BELTS_OUTZONE)<>0 AND master_idx<>Co.Idx THEN
                BeltsOutZone.Cmd.Follow := master_idx;
                BeltsOutZone.Cmd.Target := 0;
            ELSE
                SlaveBelts := SlaveBelts & NOT BIT_BELTS_OUTZONE;
            END_IF;
            IF (SlaveBelts & BIT_ROLLS_ALGN)<>0 AND master_idx<>Cr.Idx THEN
                RollsAlgn.Cmd.Follow := master_idx;
                RollsAlgn.Cmd.Target := 0;
            ELSE
                SlaveBelts := SlaveBelts & NOT BIT_ROLLS_ALGN;
            END_IF;
            IF (SlaveBelts & BIT_BELTS_DTCH)<>0 AND master_idx<>Cs.Idx THEN
                BeltsDtch.Cmd.Follow := master_idx;
                BeltsDtch.Cmd.Target := 0;
            ELSE
                SlaveBelts := SlaveBelts & NOT BIT_BELTS_DTCH;
            END_IF;
            IF (SlaveBelts & BIT_BELTS_BUF)<>0 AND master_idx<>Cb.Idx THEN
                BeltsBuf.Cmd.Follow := master_idx;
                BeltsBuf.Cmd.Target := 0;
            ELSE
                SlaveBelts := SlaveBelts & NOT BIT_BELTS_BUF;
            END_IF;
            IF (SlaveBelts & BIT_BELTS_FEED)<>0 AND master_idx<>Ca.Idx THEN
                BeltsFeed.Cmd.Follow := master_idx;
                BeltsFeed.Cmd.Target := 0;
            ELSE
                SlaveBelts := SlaveBelts & NOT BIT_BELTS_FEED;
            END_IF;
            slave_belts := SlaveBelts; (* Applied *)

            (* Cinghie gestite: master + slaves *)
            CASE master_idx OF
                Cs.Idx : ManagedBelts := slave_belts OR BIT_BELTS_DTCH;
                         BeltsDtch.Cmd.Target := 0;
                Cr.Idx : ManagedBelts := slave_belts OR BIT_ROLLS_ALGN;
                         RollsAlgn.Cmd.Target := 0;
                Cb.Idx : ManagedBelts := slave_belts OR BIT_BELTS_BUF;
                         BeltsBuf.Cmd.Target := 0;
                Ca.Idx : ManagedBelts := slave_belts OR BIT_BELTS_FEED;
                         BeltsFeed.Cmd.Target := 0;
                Co.Idx : ManagedBelts := slave_belts & BIT_BELTS_OUTZONE;
                         BeltsOutZone.Cmd.Target := 0;
            END_CASE;

            vnBelts_Act := ManagedBelts; (* Attivo tutte le cinghie gestite (master+slaves) *)
            Status := BLT_ENABLING;
        END_IF;

END_CASE; (* -- servizio movimentazione cinghie *)


(* -- Attivazione cinghie (salita e abilitazione asse) -- *)
BeltsOutZone.Cmd.Activate := (vnBelts_Act & BIT_BELTS_OUTZONE)<>0 OR BeltsOutZone.Cmd.Target<>0 OR BeltsOutZone.Cmd.Follow<>0;
RollsAlgn.Cmd.Activate := (vnBelts_Act & BIT_ROLLS_ALGN)<>0 OR RollsAlgn.Cmd.Target<>0 OR RollsAlgn.Cmd.Follow<>0;
BeltsDtch.Cmd.Activate := (vnBelts_Act & BIT_BELTS_DTCH)<>0 OR BeltsDtch.Cmd.Target<>0 OR BeltsDtch.Cmd.Follow<>0;
BeltsBuf.Cmd.Activate := (vnBelts_Act & BIT_BELTS_BUF)<>0 OR BeltsBuf.Cmd.Target<>0 OR BeltsBuf.Cmd.Follow<>0;
BeltsFeed.Cmd.Activate := (vnBelts_Act & BIT_BELTS_FEED)<>0 OR BeltsFeed.Cmd.Target<>0 OR BeltsFeed.Cmd.Follow<>0;



(* -- Interfaccia movimentazione da programmi -- *)
IF vqRollsAlgn_Target<>0 AND RollsAlgn.Status<=BLT_ENABLED THEN
    dlog( Txt:='RollsAlgn: %ld mm (%ld m/min, %d%%)', Lvl:=3, Val1:=vqRollsAlgn_Target/1E3, Val2:=vqRollsAlgn_MaxSpeed/1E6, Val3:=TO_DINT(vnRollsAlgn_Accel) );
    RollsAlgn.Cmd.Target := vqRollsAlgn_Target;
    RollsAlgn.Cmd.MaxSpeed := vqRollsAlgn_MaxSpeed;
    RollsAlgn.Cmd.Accel := vnRollsAlgn_Accel;
    vqRollsAlgn_Target := 0; (* Eat *)
END_IF;
vbRollsAlgn_Arrived := RollsAlgn.Arrived;


(* Condizione di partenza posizionamento: aria pronta *)
vbBelts_HoldStartPos := vbBelts_WaitStartPosCond AND NOT vbAirCushionReady;


(* -- Monitors -- *)
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := Status=BLT_DISABLED;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbShift

{ DE:"Sistema dei trasportatori per la traslazione lastra" }

	VAR_INPUT
	Abort : BOOL; { DE:"Segnale di stop/annullamento sequenza" }
	Allow : BOOL; { DE:"Consensi" }
	AllowManual : BOOL; { DE:"Consensi aggiuntivi al movimento manuale" }
	FeedOutBack : BOOL; { DE:"Lastra indietro tavolo di carico" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Sistema a riposo" }
	ID : INT := ID_SHIFT; { DE:"Identificativo del sistema" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vbHeartBeat : BOOL; { DE:"Battito di vita ogni secondo" }
	vdPlcScanTime : LREAL; { DE:"Tempo di scansione del PLC [s]" }
	vqWorkSettings : DINT; { DE:"Selettori ritentivi di lavorazione" }
	vqAx_StopSpaceTol : DINT; { DE:"Tolleranza sul calcolo dello spazio di stop [um]" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	fcOutzoneEnd : fbPhotoCell; { DE:"Fotocellula a fine linea (IFC_OUTZONE_END)" }
	fcOutzoneNearEnd : fbPhotoCell; { DE:"Fotocellula prossimità fine linea (IFC_OUTZONE_NEAREND)" }
	fcOutzoneBegin : fbPhotoCell; { DE:"Fotocellula fine zona cinghie riscontro e inizio zona uscita pezzi a fine linea (IFC_OUTZONE_BEGIN)" }
	fcDtchLast : fbPhotoCell; { DE:"Ultima fotocellula su modulo stacco (IFC_DTCH_LAST)" }
	fcDtchBegin : fbPhotoCell; { DE:"Fotocellula inizio modulo stacco (IFC_DTCH_BEGIN)" }
	fcBufBegin : fbPhotoCell; { DE:"Fotocellula inizio zona polmone (IFC_BUF_BEGIN)" }
	fcFeedEnd : fbPhotoCell; { DE:"Fotocellula fine modulo di carico (IFC_FEED_END)" }
	fcFeedNearEnd : fbPhotoCell; { DE:"Fotocellula prossimità fine modulo di carico (IFC_FEED_NEAREND)" }
	IFC_FEED_NEARBEGIN : BOOL; { DE:"Fotocellula prossimità inizio modulo di carico" }
	fcFeedBegin : fbPhotoCell; { DE:"Fotocellula inizio modulo di carico (IFC_FEED_BEGIN)" }
	Co : fbM32Axis; { DE:"Asse cinghie/Conveyors zona fine linea/uscita pezzi (Output) AX_CO" }
	Cr : fbM32Axis; { DE:"Asse rulli modulo riscontro AX_CR" }
	Cs : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo stacco (Detach) AX_CS" }
	Cb : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo polmone (Buffer) AX_CB" }
	Ca : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo carico/Accumulo AX_CA" }
	BeltsOutZone : fbBeltsOutZone; { DE:"Cinghie a fine linea" }
	RollsAlgn : fbRollsAlgn; { DE:"Rulli/Cinghie di trasporto su modulo riscontri" }
	BeltsDtch : fbBeltsDtch; { DE:"Trasportatori su modulo stacco" }
	BeltsBuf : fbBeltsBuf; { DE:"Trasportatori su modulo polmone" }
	BeltsFeed : fbBeltsFeed; { DE:"Trasportatori su modulo di carico" }
	Belts : fbBelts; { DE:"Gestore movimentazione cinghie" }
	vnBelts_Act : INT; { DE:"Maschera forzatura attivazione cinghie" }
	vnBelts_Cmd : INT; { DE:"Comando esterno cinghie" }
	vnBelts_MasterIdx : INT; { DE:"Comando cinghie: Indice dell'asse da inseguire" }
	vnBelts_MasterAcc : INT; { DE:"Comando cinghie: Parzializzazione accelerazione Master [%]" }
	vnBelts_SlaveBelts : INT; { DE:"Comando cinghie: Selezione a bit delle cinghie che inseguono" }
	vqBelts_MasterSpd : DINT; { DE:"Comando cinghie: Velocità Master [um/min]" }
	vqBelts_MasterTgt : DINT; { DE:"Comando cinghie: Quota obiettivo [um]" }
	vnShift_Cmd : INT; { DE:"Comando a sistema di trasporto vetro" }
	vnShift_Seq : INT; { DE:"Stato/risultato sequenza di movimentazione cinghie" }
	vqShift_MetPhCells : DINT; { DE:"Fotocellule incontrate" }
	vbShift_AlmostThere : BOOL; { DE:"Chiamata Lastra: Quasi arrivata per riscontro" }
	vbShift_AlmostIns : BOOL; { DE:"Accumulo Lastra: Quasi inserita nel carico" }
	SelectProdVents : fbSelectProdVents; { DE:"Seleziona zone cuscino aria zona riscontro" }
	vnVents_Cmd : INT; { DE:"Comando gruppi ventilatori cuscino aria a bit" }
	vbVents_MotorsOn : BOOL; { DE:"Avvia motori senza aprire le serrande" }
	vbExtractDone : BOOL; { DE:"Lastra in arrivo estratta da carico" }
	vbShift_DumpRemn : BOOL; { DE:"Consegna/espulsione rimanenza lato stacco" }
	vnShift_DumpSeq : INT; { DE:"Stato/risultato sequenza di evacuazione rifilo 'ID_SHIFT'" }
	vbRemn_Dumpable : BOOL; { DE:"Si deve espellere automaticamente la rimanenza nel cassone" }
	vqRemn_X : DINT; { DE:"Posizione bordo avanti della rimanenza [um]" }
	vqRemn_Width : DINT; { DE:"Dimensione longitudinale rimanenza del taglio [um]" }
	vqDump_AddMove : DINT; { DE:"Spostamento finale cinghie per espulsione nel cassone [um]" }
	vqDump_TurnHeight : DINT; { DE:"Altezza rimanenza con pericolo di rotazione [um]" }
	vqDump_MinSlip : DINT; { DE:"Slittamento cinghie previsto minimo [um]" }
	vqDump_SlipWidth : DINT; { DE:"Larghezza rimanenza con pericolo di slittamento cinghie [um]" }
	vqDump_SlipCoeff : DINT; { DE:"Slittamento previsto cinghie per ogni um sotto [um/um]" }
	vqShift_RemnTakePos : DINT; { DE:"Posizione prelievo rimanenza grossa [um]" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vnRemn_Id : INT; { DE:"Identificativo rimanenza" }
	vbAck_CheckSensors : BOOL; { DE:"Non fidarti del reset richieste, controlla fotocellule" }
	vqDtch_CurrX : DINT; { DE:"Posizione attuale del modulo di stacco [um]" }
	vbDtch_HoldGlassAlgn : BOOL; { DE:"Tieni fermo vetro su riscontri" }
	vnDtch_Cmd : INT; { DE:"Comando stacco" }
	vnDtch_Seq : INT; { DE:"Risultato sequenza stacco" }
	vqDtch_Tgt : DINT; { DE:"Posizione obiettivo stacco [um]" }
	vnCarriages_Cmd : INT; { DE:"Comando carrelli coordinati" }
	OutZone : fbOutZone; { DE:"Zona fine linea" }
	vqX_OutZoneBegin : DINT; { DE:"Ascissa inizio zona fine linea [um]" }
	vqX_OutZoneEnd : DINT; { DE:"Ascissa fine zona fine linea/consegna pezzi [um]" }
	O_SCU_OUTZONE_BUSY : BOOL; { DE:"Segnalazione operatore in zona fine linea (cambio dinamico aree)" }
	vqAlgn_CurrX : DINT; { DE:"Posizione attuale dei piedini riscontri selezionati [um]" }
	vnAlgnBlocks_Sts : INT; { DE:"Stato dei piedini di riscontro" }
	vqAlgnDrag_Tgt : DINT; { DE:"Posizione di arrivo del bordo avanti nel trascinamento avanti [um]" }
	vqAlgnDrag_Width : DINT; { DE:"Larghezza pezzo da trascinare a fine linea [um]" }
	vnAlgn_DragSeq : INT; { DE:"Stato/risultato sequenza di trascinamento con riscontri" }
	vqAlgn_BlkBackRoom : DINT; { DE:"Spazio da liberare dietro i piedini per poterli alzare [um]" }
	vqAlgn_BlkFrontRoom : DINT; { DE:"Spazio da liberare davanti ai piedini per poterli alzare [um]" }
	vnAlgn_DeliverCmd : INT; { DE:"Servizio generico estrazione/consegna pezzo a valle" }
	vnAlgn_DeliverSeq : INT; { DE:"Stato/risultato sequenza di estrazione/consegna pezzo a valle" }
	vbAlgnDlvr_AlmostDone : BOOL; { DE:"Sequenza di consegna a buon punto" }
	ICM_ACKNOWLEDGE : BOOL; { DE:"Conferma richieste, intervento manuale effettuato" }
	vnComboFloat_Type : INT; { DE:"Tipo macchina monolitico combinata" }
	I_FLOAT_READY : BOOL; { DE:"Permesso da monolitico combinato per usare le sue risorse" }
	vqDXph_Size : DINT; { DE:"Larghezza fotocellule per correzione lettura in rilascio [um]" }
	vqXph_FeedBegin : DINT; { DE:"Ascissa fotocellula inizio carico [um]" }
	vqXph_FeedNearEnd : DINT; { DE:"Ascissa fotocellula prossimità fine carico [um]" }
	vqXph_FeedEnd : DINT; { DE:"Ascissa fotocellula fine carico [um]" }
	vqXph_BufBegin : DINT; { DE:"Ascissa fotocellula inizio polmone [um]" }
	vqDXph_DtchBegin : DINT; { DE:"Offset fotocellula inizio stacco/esp rifili [um]" }
	vqDXph_DtchLast : DINT; { DE:"Offset ultima fotocellula su stacco [um]" }
	vqYph_DtchLast : DINT; { DE:"Ordinata ultima fotocellula su stacco [um]" }
	vqXph_OutZoneBegin : DINT; { DE:"Ascissa fotocellula inizio zona fine linea [um]" }
	vqAlgn_DragMinDisp : DINT; { DE:"Movimento minimo per cui vale la pena spostare il pezzo [um]" }
	vqDtch_Width : DINT; { DE:"Dimensione orizzontale/longitudinale (X) modulo di stacco [um]" }
	vqDtch_Xbegin : DINT; { DE:"Ascissa inizio zona stacco [um]" }
	vqBuf_Width : DINT; { DE:"Dimensione orizzontale/longitudinale (X) modulo [um]" }
	vqFeed_Width : DINT; { DE:"Dimensione orizzontale/longitudinale (X) modulo [um]" }
	vqFeed_Xend : DINT; { DE:"Posizione bordo avanti del tavolo di carico [um]" }
	vnBuf_Type : INT; { DE:"Tipo modulo/zona polmone 'ID_BUF' (0:feed 1:belts)" }
	vqX_AlgnBandC : DINT; { DE:"Ascissa fine zona cuscino aria riscontri taglio [um]" }
	vqY_AlgnBandB : DINT; { DE:"Ordinata fine zona cuscino aria riscontri banda bassa [um]" }
	vqY_AlgnBandM : DINT; { DE:"Ordinata fine zona cuscino aria riscontri banda mediana [um]" }
	vqShift_MaxGlassThckn : DINT; { DE:"Spessore complessivo massimo movimentabile [um]" }
	vqShift_PassMinWidth : DINT; { DE:"Larghezza minima vetro per trasporto con cinghie [um]" }
	vqShift_CrossMinWidth : DINT; { DE:"Larghezza minima vetro per passaggio stacco-riscontri [um]" }
	Shiftable : fbShiftable; { DE:"Controllo trasportabilità con cinghie" }
	vbShift_PhLatencyFix : BOOL; { DE:"Applica correzione latenza fotocellule" }
	vbShift_PhIgnorePrev : BOOL; { DE:"Ignora intelligentemente le fotocellule nella chiamata" }
	vbShift_ForceMan : BOOL; { DE:"Cerca di eseguire sempre il movimento manuale" }
	vnShift_BeltsAlgnManMode : INT; { DE:"Modalità movimentazione manuale cinghie su riscontro (0:escluse, 1:Cr+Co se libera, 3:Cr+Co sempre)" }
	vqShift_GoodWidth : DINT; { DE:"Larghezza minima traslabile su riscontri senza avvicinam stacco [um]" }
	vbFloatStripesBreak : BOOL; { DE:"Troncaggio traversi monolitico" }
	vqX_BeltsEnd : DINT; { DE:"Estremo cinghie per controlli trasportabilità [um]" }
	vqX_RemnBeltsEnd : DINT; { DE:"Estremo cinghie lato rimanenza per controlli trasportabilità [um]" }
	vqDtchBelts_Dx : DINT; { DE:"Offset X delle cinghie rispetto bordo stacco [um]" }
	vbFeat_AlgnHasBelts : BOOL; { DE:"Riscontri provvisti di cinghie (non i rulli)" }
	vqX_AlgnBeltsBegin : DINT; { DE:"Ascissa inizio rulli/cinghie sui riscontri [um]" }
	vqX_AlgnBeltsEnd : DINT; { DE:"Ascissa fine rulli/cinghie sui riscontri [um]" }
	vqBelts_MinGripDX : DINT; { DE:"Minimo contatto X cinghie-vetro per trasportabilità [um]" }
	vqBeltsAlgn_MinGripDX : DINT; { DE:"Minimo contatto X cinghie riscontro-vetro [um]" }
	vbFeat_DtchHasBelts : BOOL; { DE:"Stacco provvisto di cinghie" }
	vnDtchBelts_N : INT; { DE:"Numero delle cinghie stacco" }
	vqDtchBelts_Size : DINT; { DE:"Larghezza banda gommmata cinghie a monte [um]" }
	vqX_CutZoneP : DINT; { DE:"Quota X inizio piano di appoggio/premilastra riscontri [um]" }
	vqH_SheetFeed : DINT; { DE:"Altezza tipica della lastra caricata [um]" }
	vqYo_SheetFeed : DINT; { DE:"Ordinata tipica della lastra in arrivo dal carico [um]" }
	vnBelts_VelPPd : INT; { DE:"Profilo curva S decelerazione cinghie assunto nelle stime [%]" }
	vqBelts_ManSpd : DINT; { DE:"Velocità manuale cinghie [um/min]" }
	vqBelts_SlowSpd : DINT; { DE:"Velocità cinghie per movimenti pericolosi [um/min]" }
	vqBelts_FwdSpd : DINT; { DE:"Velocità cinghie per chiamata lastra [um/min]" }
	vqBelts_DragSpd : DINT; { DE:"Velocità traslazione con lastra sui riscontri [um/min]" }
	vnBelts_DragAcc : INT; { DE:"Parzializzazione accelerazione traslazione con lastra sui riscontri [%]" }
	vqBelts_BckSpd : DINT; { DE:"Velocità cinghie per parcheggio rimanenza [um/min]" }
	vqBelts_DumpSpd : DINT; { DE:"Velocità cinghie per espulsione rifilo [um/min]" }
	vnBelts_DumpAcc : INT; { DE:"Parzializzazione accelerazione espulsione pezzo [%]" }
	vqBelts_LoadSpd : DINT; { DE:"Velocità caricatrice per carico lastra [um/min]" }
	vqBelts_UnloadSpd : DINT; { DE:"Velocità caricatrice per restituzione sfrido [um/min]" }
	vqBelts_ProbeSpd : DINT; { DE:"Velocità cinghie per ricerca/misura [um/min]" }
	vqBelts_StackDist : DINT; { DE:"Distanza lastre accodate sul carico [um]" }
	vbShift_FullIns : BOOL; { DE:"Effettua inserzioni complete nel carico" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqShift_GlassWidth : DINT; { DE:"Larghezza lastra movimentata [um]" }
	vqShift_GlassYbtm : DINT; { DE:"Ordinata bordo basso lastra movimentata [um]" }
	vqShift_GlassYtop : DINT; { DE:"Ordinata bordo alto lastra movimentata [um]" }
	vqShift_GlassX : DINT; { DE:"Posizione bordo avanti iniziale/corrente lastra movimentata [um]" }
	vqShift_TargetX : DINT; { DE:"Posizione bordo avanti finale lastra movimentata [um]" }
	vqShift_TargetTol : DINT; { DE:"Tolleranza sulla posizione finale della lastra movimentata [um]" }
	vbShift_NoRolls : BOOL; { DE:"Modificatore temporaneo per inibire rulli riscontro" }
	vbShift_KeepAirOn : BOOL; { DE:"Modificatore temporaneo: non spegnere aria riscontri" }
	vqRemn_DXdtch : DINT; { DE:"Posizione bordo avanti della rimanenza separata rispetto lo stacco [um]" }
	vbStepValid : BOOL; { DE:"Passo di lavorazione valido e caricato" }
	vqProcArea_Xmin : DINT; { DE:"Area processazione vetro: X minimo [um]" }
	vqSubSheet_X : DINT; { DE:"Posizione X bordo avanti della lastra in arrivo [um]" }
	GuessSheetPos : fbGuessSheetPos; { DE:"Indovina posizione lastra da fotocellule" }
	vnShiftFeed_Cmd : INT; { DE:"Comando a cinghie carico" }
	vnShiftFeed_Sts : INT; { DE:"Stato/risultato sequenze cinghie carico" }
	vnLoader_Type : INT; { DE:"Tipo caricatrice esterna 'ID_LOADER' (0:none 1:generic)" }
	vnShiftAlgn_Cmd : INT; { DE:"Comando sequenze cinghie riscontri" }
	END_VAR

	VAR
	ShiftFeed : fbShiftFeed; { DE:"Sequences of BeltsFeed" }
	ShiftAlgn : fbShiftAlgn; { DE:"Sequences of belts on align module" }
	ShiftRemnPostCut : fbShiftRemnPostCut; { DE:"Parallelized post cut remn shift sequences" }
	StartedX : DINT; { DE:"Ascissa di riferimento [um]" }
	TargetX : DINT; { DE:"Ascissa obiettivo corrente bordo avanti [um]" }
	Shift_Mass : LREAL; { DE:"Massa della lastra in movimentazione [Kg]" }
	Qx : DINT; { DE:"Temporaneo per quota memorizzata [um]" }
	Delta : DINT; { DE:"Temporaneo per cambio obiettivo e compensazione latenze [um]" }
	Prev_Status : INT; { DE:"Temporaneo per ricordarsi dello stato precedente" }
	Stop_On_Dtch : BOOL; { DE:"Necessario fermarsi sullo stacco per poi avvicinarlo" }
	Need_Dtch_Fwd : BOOL; { DE:"Serve lo stacco avanti prima di muovere con le cinghie" }
	QueuedCmd : INT; { DE:"Comando accodato, vedi vnShift_Cmd" }
	RequiredVents : INT; { DE:"Maschera dei ventilatori richiesti" }
	RemnBackByHand : fbEdges; { DE:"Fronte reset di REQ_BACK_REMN" }
	RemnTakeByHand : fbEdges; { DE:"Fronte reset di REQ_DUMP_REMN, REQ_TAKE_REMN" }
	RemnInsByHand : fbEdges; { DE:"Fronte reset di REQ_STACK_REMN" }
	END_VAR

	{ CODE:ST }(*    fbShift (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Sistema di trasporto vetro delle macchine
      per laminato, costituito nel suo insieme da:
         ·Cinghie carico/accumulo
         ·Cinghie polmone (opzionali)
         ·Cinghie stacco
         ·Rulli zona taglio
      I servizi che riguardano la traslazione delle
      lastre sono:
         .Carico lastra/Restituzione sfrido
         .Chiamata sottolastra
         .Movimento sottolastra zona processazione
         .Accumulo/Inserzione rimanenza/espulsione rifilo

      DETAILS
      ----------------------------------------------
      Alcune delle sequenze possono svolgersi
      parallelamente a 'vnShift_Cmd', vedi:
        .vbShift_DumpRemn (Movimenti rimanenza dopo taglio, espulsione rifilo)
        .vnShiftFeed_Cmd (inserzione, carico/restituzione sfrido, etichetttatura)
        .vnShiftAlgn_Cmd (Estrazione a fine linea)

      EXAMPLE OF USAGE
      ----------------------------------------------
      Shift : fbShift; { DE:"Sistema trasporto vetro" }
*)

(* -- Manage stop signal -- *)
IF Abort THEN
    (* Remove command(s) *)
    vnShift_Cmd := CMD_STOP;
    vnShiftFeed_Cmd := CMD_STOP;
    vnShiftAlgn_Cmd := CMD_STOP;
    vbShift_DumpRemn := FALSE;
(* ELSIF Suspend THEN (* Could suspend? servirebbe fermare l'asse e partire dallo step precedente *)
END_IF;
(* Notify abort *)
IF Status>STS_STOPPING AND vnShift_Cmd=CMD_STOP THEN
    dlog( Txt:='fbShift: !! Abort Sts=%d', Lvl:=3, Val1:=TO_DINT(Status) );
END_IF;


(* -- Overall belts sequences -- *)
CASE Status OF

    (* ------------------------------------------------------------------- *)
    SHF_PLACE_FWD : (* Placing sheet forward *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Rilevo arrivo in quota o problemi di movimentazione *)
        ELSIF Belts.Cmd<CMD_MOVETO THEN
            (* Comando movimento terminato! *)
            (* Può essere che se non arrivato sia in 'CMD_ACTIVATE' *)
            Belts.Cmd := CMD_STOP;

            IF ABS(Belts.MasterTgt - Belts.Master_CurrPos)<=vqShift_TargetTol THEN
                (* ABS(vqShift_TargetX-TargetX)<=vqShift_TargetTol *)
                vqShift_GlassX := TargetX; (* Arrivato a destinazione! *)
                IF vnShift_Cmd=SHFCMD_PLACE_SHEET THEN vqSubSheet_X := vqShift_GlassX; END_IF; (* TODO 5: togliere? *)

                (* Ho incontrato fotocellule? *)
                IF vqShift_MetPhCells>IDX_FC_FEED_BEGIN OR
                   StartedX>(vqDtch_CurrX+vqDXph_DtchLast) THEN
                    (* Nota: Se sono partito già appoggiato ai riscontri, è probabile
                             che non abbia incontrato fotocellule! D'altronde una
                             posizione di partenza positiva è sempre e solo ereditata
                             dallo step precedente, quindi mi fido. *)
                    IF Stop_On_Dtch THEN
                        (* Ok, sono sullo stacco, procedi con la manovra di avvicinamento *)
                        StartedX := vqShift_GlassX - Belts.Master_CurrPos;
                        Status := SHF_DTCH_STP;
                    ELSE
                        (* Se non sta riscontrando o trascinando assicuro ventilatori spenti *)
                        IF vn[ivnStatus+ID_ALGN]<ALSTS_ALIGNING AND NOT vbShift_KeepAirOn THEN
                            vnVents_Cmd := vnVents_Cmd & NOT RequiredVents; (* Assicuro ventilatori chiusi *)
                        END_IF;

                        (* Ok, ma la quota obiettivo era effettivamente raggiungibile? *)
                        IF (TargetX-vqShift_GlassWidth) <= vqX_BeltsEnd THEN (* Nota: Assumo di usare tutti i trasportatori *)
                            (* Dovrei averla raggiunta, non ho perso aderenza *)
                            dlog( Txt:='fbShift: Sheet placed to %ld mm', Lvl:=4, Val1:=TargetX/1E3 );
                            vnShift_Seq := SEQ_DONE;
                            Status := STS_STOPPING;
                        ELSE
                            (* Probabilmente ho perso aderenza, va posizionata a mano *)
                            dlog( Txt:='fbShift: !! Sheet w=%ld cant reach %ld mm', Lvl:=4, Val1:=vqShift_GlassWidth/1E3, Val2:=TargetX/1E3 );
                            Status := STS_ERROR;
                        END_IF;
                    END_IF;
                ELSE
                    (* Se non ho mai incontrato fotocellule partendo dalla zona rimanenza,
                       non sono mica sicuro di essere posizionato giusto! *)
                    dlog( Txt:='fbShift: !! No photocells after %ld mm', Lvl:=2, Val1:=Belts.MasterTgt/1E3 );
                    Status := STS_ERROR;
                END_IF;

                (* Lo stacco è in parcheggio? *)
                IF NOT vb[ivbAtRest+ID_DTCH] THEN
                    (* Se è possibile mando lo stacco in parcheggio da qui, sia che
                       la lastra debba essere agganciata o tagliata.
                       Non voglio che la lastra traslata si muova rispetto ai riscontri,
                       quindi se ho motivo di credere che il movimento stacco lo muova
                       bisogna bloccarlo con i premilastra riscontri *)
                    Delta := vqDtch_CurrX + vqShift_GlassWidth - TargetX; (* Coda sullo stacco *)
                    dlog( Txt:='fbShift: Parking Dtch (tail=%ld mm)', Lvl:=5, Val1:=Delta/1E3 );
                    (* TargetX-vqX_CutZoneP (* Vetro appoggiato ai riscontri *)
                    vbDtch_HoldGlassAlgn := Delta > MIN( 45E3, (TargetX-vqX_CutZoneP)/6 );
                    (* fcDtchLast.q AND vnShift_Cmd<>SHFCMD_FORW_ONALGN (* La fotocellula legge sempre, non è significativa *)

                    (* Volendo potrei controllare condizioni di caduta:
                    <vetro appoggiato sui riscontri> = TargetX - vqX_CutZoneP
                    <vetro appoggiato sullo stacco dopo parcheggio> = vq[ivqAx_HomePos+AX_XS-1] + vqShift_GlassWidth - TargetX
                    <vetro eventuamente a sbalzo> = vqShift_GlassWidth - TargetX
                    IF (vq[ivqAx_HomePos+AX_XS-1] + vqShift_GlassWidth - TargetX)<5E3 AND (TargetX-vqX_CutZoneP)<(vqShift_GlassWidth - TargetX - 20E3) THEN
                        dlog( Txt:='fbShift: !! Cannot park the dtch, glass %ld mm could fall', Lvl:=1, Val1:=vqShift_GlassWidth/1E3 );
                        SET_MSG(MSG_FALLINCUTZONE,'MSG_FALLINCUTZONE',0);
                    END_IF;
                    *)

                    (* Mando finalmente lo stacco in parcheggio *)
                    vnDtch_Cmd := CMD_PARK; (* Nota: Non aspetto che termini *)
                END_IF;
            ELSE
                dlog( Txt:='fbShift: !! PLACE_FWD: Not arrived %ld != %ld mm', Lvl:=2, Val1:=vqShift_GlassX/1E3, Val1:=TargetX/1E3 );
                Status := STS_ERROR;
            END_IF;
            (* Finally *)
            vbShift_KeepAirOn := FALSE; (* Ensure to reset this temporary modifier *)
        (* Rilevo eventi fotocellule per synch posizione *)
        ELSIF Belts.Status=BLT_OPERATING THEN
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqShift_GlassX := StartedX + Belts.Master_CurrPos;
            IF vnShift_Cmd=SHFCMD_PLACE_SHEET THEN vqSubSheet_X := vqShift_GlassX; END_IF; (* TODO 5: togliere? *)

            IF fcDtchLast.rise AND vqShift_MetPhCells<IDX_FC_DTCH_LAST THEN
                vqShift_MetPhCells := IDX_FC_DTCH_LAST;
                (* Posizione effettiva bordo avanti *)
                Delta := (vqDtch_CurrX+vqDXph_DtchLast);
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(Belts.Master_CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                dlog( Txt:='fbShift: Reached IFC_DTCH_LAST at %ld xfwd=%ld=>%ld (%ld)', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3, Val2:=vqShift_GlassX/1E3, Val3:=Delta/1E3, Val4:=(Delta - vqShift_GlassX)/1E3 );
                vqShift_GlassX := Delta; (* Aggiorno posizione bordo avanti *)
                StartedX := vqShift_GlassX - Belts.Master_CurrPos;
                (* Cambio target se fattibile *)
                Delta := TargetX - vqShift_GlassX; (* Quanto mi manca ad arrivare *)
                IF Delta > (vq[ivqAx_StopSpace+Belts.MasterIdx-1]+vqAx_StopSpaceTol) (* Nota: Sono tutti e due positivi, sto andando avanti *)
                   AND VN_AX(iVN_AX_FASE,Belts.MasterIdx)<AFS_POS_DEC THEN
                    Belts.MasterTgt := Belts.Master_CurrPos + Delta;
                ELSE
                    dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=Belts.MasterTgt/1E3, Val2:=(Belts.Master_CurrPos + Delta)/1E3 );
                    (* Status := STS_ERROR; *)
                END_IF;

                (* Verifica se lastra estratta (anche in base a dimensioni) *)
                IF NOT vbExtractDone THEN
                    IF vnBuf_Type>0 AND (NOT fcBufBegin.q OR vqShift_GlassWidth<(vqShift_GlassX-vqXph_BufBegin)) THEN
                        vbExtractDone := TRUE;
                    END_IF;
                END_IF;

                (* Quasi arrivato? Sì, sto per passare sul modulo riscontri *)
                vbShift_AlmostThere := TRUE; (* Segnale per far eventualmente partire la fase di riscontro *)

                IF vbFeat_AlgnHasBelts THEN
                    (* Il riscontro è dotato di cinghie *)
                    (* ...Sembra che in caso di aria accesa il vetro si possa spostare... *)
                    RequiredVents := 0;
                    vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_ALGN; (* Assicuro aria riscontri spenta *)
                ELSE
                    (* Il riscontro ha solo (forse) dei rulli *)
                    (* Rallento se necessario *)
                    IF Belts.MasterSpd > vqBelts_DragSpd THEN
                        Belts.MasterSpd := vqBelts_DragSpd;
                        (* dlog( Txt:='fbShift: Speed to %ld m/min', Lvl:=5, Val1:=Belts.MasterSpd/1E6 ); *)
                    END_IF;

                    (* Accendo i ventilatori necessari *)
                    (* SelectProdVents( Xfwd:=vqShift_TargetX, Ytop:=vqShift_GlassYtop ); *)
                    RequiredVents := SEL( vqShift_TargetX>vqX_AlgnBandC, BIT_VENT_ALGN_C, MSK_VENT_ALGN );
                    (* Mi serve anche la zona a fine linea? No, lasciala indipendente *)
                    (* IF vqShift_TargetX>vqX_OutZoneBegin THEN RequiredVents := RequiredVents OR BIT_VENT_OUTZONE; END_IF; *)
                    (* Mi serve anche la zona stacco? *)
                    IF Cs.Emulated THEN RequiredVents := RequiredVents OR BIT_VENT_DTCH; END_IF;
                    vnVents_Cmd := vnVents_Cmd OR RequiredVents;
                END_IF;

                (* Un doveroso controllo di caduta (anche se forse è un po' troppo tardi) *)
                IF TargetX>0 AND vqShift_GlassWidth <= 2*(vqX_CutZoneP-vqDtch_CurrX) THEN
                    dlog( Txt:='fbShift: !! Narrow sheet w=%ld would fall', Lvl:=1, Val1:=vqShift_GlassWidth/1E3 );
                    SET_MSG(MSG_FALLINCUTZONE,'MSG_FALLINCUTZONE',vqShift_GlassWidth);
                    Status := STS_ERROR;
                END_IF;

                (* Un controllo delle fotocellule per evitare la caduta di pezzettini
                   dimenticati: se abbastanza larga, deve leggere anche fcDtchBegin
                   Nota: a 60 m/min = 1 mm/ms in 16ms percorro 16mm *)
                Delta := vqDXph_DtchLast - vqDXph_DtchBegin + 10E3; (* Distanza tra le fotocellule stacco *)
                IF Delta>20E3 AND vqShift_GlassWidth>Delta AND NOT fcDtchBegin.q THEN
                    dlog( Txt:='fbShift: !! Sheet w=%ld not read on dtch', Lvl:=1, Val1:=vqShift_GlassWidth/1E3 );
                    Status := STS_ERROR;
                END_IF;

            ELSIF fcDtchBegin.rise AND vqShift_MetPhCells<IDX_FC_DTCH_BEGIN THEN
                vqShift_MetPhCells := IDX_FC_DTCH_BEGIN;
                (* Posizione effettiva bordo avanti *)
                Delta := vqDtch_CurrX + vqDXph_DtchBegin;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(Belts.Master_CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                dlog( Txt:='fbShift: Reached IFC_DTCH_BEGIN at %ld xfwd=%ld=>%ld (%ld)', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3, Val2:=vqShift_GlassX/1E3, Val3:=Delta/1E3, Val4:=(Delta - vqShift_GlassX)/1E3 );
                vqShift_GlassX := Delta; (* Aggiorno posizione bordo avanti *)
                StartedX := vqShift_GlassX - Belts.Master_CurrPos;
                (* Cambio target se fattibile *)
                Delta := TargetX - vqShift_GlassX; (* Quanto mi manca ad arrivare *)
                IF Delta > (vq[ivqAx_StopSpace+Belts.MasterIdx-1]+vqAx_StopSpaceTol) (* Nota: Sono tutti e due positivi, sto andando avanti *)
                   AND VN_AX(iVN_AX_FASE,Belts.MasterIdx)<AFS_POS_DEC THEN
                    Belts.MasterTgt := Belts.Master_CurrPos + Delta;
                (* ELSE dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=Belts.MasterTgt/1E3, Val2:=(Belts.Master_CurrPos + Delta)/1E3 ); *)
                END_IF;

                (* Verifica se lastra estratta (anche in base a dimensioni) *)
                IF NOT vbExtractDone AND (NOT fcBufBegin.q OR vqShift_GlassWidth<(vqShift_GlassX-vqXph_BufBegin)) THEN
                    vbExtractDone := TRUE;
                END_IF;

            ELSIF fcBufBegin.rise AND vqShift_MetPhCells<IDX_FC_BUF_BEGIN AND NOT vbExtractDone THEN
                vqShift_MetPhCells := IDX_FC_BUF_BEGIN;
                (* Posizione effettiva bordo avanti *)
                Delta := vqXph_BufBegin;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(Belts.Master_CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                dlog( Txt:='fbShift: Reached IFC_BUF_BEGIN at %ld xfwd=%ld=>%ld (%ld)', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3, Val2:=vqShift_GlassX/1E3, Val3:=Delta/1E3, Val4:=(Delta - vqShift_GlassX)/1E3 );
                vqShift_GlassX := Delta; (* Aggiorno posizione bordo avanti *)
                StartedX := vqShift_GlassX - Belts.Master_CurrPos;
                (* Cambio target se fattibile *)
                Delta := TargetX - vqShift_GlassX; (* Quanto mi manca ad arrivare *)
                IF Delta > (vq[ivqAx_StopSpace+Belts.MasterIdx-1]+vqAx_StopSpaceTol) (* Nota: Sono tutti e due positivi, sto andando avanti *)
                   AND VN_AX(iVN_AX_FASE,Belts.MasterIdx)<AFS_POS_DEC THEN
                    Belts.MasterTgt := Belts.Master_CurrPos + Delta;
                (* ELSE dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=Belts.MasterTgt/1E3, Val2:=(Belts.Master_CurrPos + Delta)/1E3 ); *)
                END_IF;

            ELSIF fcFeedEnd.rise AND vqShift_MetPhCells<IDX_FC_FEED_END AND NOT vbExtractDone THEN
                vqShift_MetPhCells := IDX_FC_FEED_END;
                (* Posizione effettiva bordo avanti *)
                Delta := vqXph_FeedEnd;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(Belts.Master_CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                dlog( Txt:='fbShift: Reached IFC_FEED_END at %ld xfwd=%ld=>%ld (%ld)', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3, Val2:=vqShift_GlassX/1E3, Val3:=Delta/1E3, Val4:=(Delta - vqShift_GlassX)/1E3 );
                vqShift_GlassX := Delta; (* Aggiorno posizione bordo avanti *)
                StartedX := vqShift_GlassX - Belts.Master_CurrPos;
                (* Cambio target se fattibile *)
                Delta := TargetX - vqShift_GlassX; (* Quanto mi manca ad arrivare *)
                IF Delta > (vq[ivqAx_StopSpace+Belts.MasterIdx-1]+vqAx_StopSpaceTol) (* Nota: Sono tutti e due positivi, sto andando avanti *)
                   AND VN_AX(iVN_AX_FASE,Belts.MasterIdx)<AFS_POS_DEC THEN
                    Belts.MasterTgt := Belts.Master_CurrPos + Delta;
                (* ELSE dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=Belts.MasterTgt/1E3, Val2:=(Belts.Master_CurrPos + Delta)/1E3 ); *)
                END_IF;

            END_IF; (* Fronti fotocellule durante 'SHF_PLACE_FWD' *)

            (* Intercetta arrivo sullo stacco nella manovra con i vetri stretti *)
            IF Stop_On_Dtch AND fcDtchLast.q AND vqDXph_DtchLast>-300E3 THEN (* Se fotocellula vicina al bordo *)
                (* Pezzo stretto, prima di mandarlo in là devo avvicinarmi con lo stacco *)
                dlog( Txt:='fbShift: Narrow stop on dtch (%ld)', Lvl:=3, Val1:=Belts.Master_CurrPos/1E3 );
                Belts.Cmd := CMD_ACTIVATE; (* Abortisci il movimento ma stai alto *)
                Belts.SlaveBelts := 0; (* Assumo che lo stacco sia il Master, abbasso le restanti *)
                Status := SHF_DTCH_STP;
                (* Occhio che si è fermato per un evento asincrono, sporgerà in là dello spazio di arresto! *)
            END_IF;

            (* Gestione estrazione dal carico *)
            (* Criticità: se ho coinvolto erroneamente le cinghie del carico
               spostando le lastre accodata sulla fotocellula con
               vbExtractDone=FALSE, le lastre accumulate non si fermeranno! *)
            IF (Belts.SlaveBelts & BIT_BELTS_FEED)<>0 THEN
                (* Rilevo sottolastra uscita dal tavolo di carico *)
                IF fcFeedEnd.fall_delayed OR fcBufBegin.fall_delayed THEN
                    dlog( Txt:='fbShift: Subsheet exited feed at %ld mm', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
                    vbExtractDone := TRUE;

                    (* Per controllare la distanza tra le lastre accodate preferirei
                       non fermare subito le cinghie carico ma portare eventuali
                       pezzi accodati sulla fotocellula di fine carico per
                       poi risposizionarli indietro in posizione nota.
                       Non voglio però che essi si fermino in parte sul polmone,
                       perché nel riposizionamento indietro sarebbero sottoposti
                       a cinghie polmone avanti e cinghie carico indietro!
                       Quindi se non ho abbastanza spazio per lo stop, fermo
                       subito le cinghie carico e riposiziono indietro alla cieca *)

                    (* Voglio fare questa operazione anche senza il polmone
                       perché devo assicurare sempre lo stacco libero *)
                    (* IF NOT Cb.Emulated THEN (* Solo se è presente il polmone? *)
                        Delta := fnRampSpace(V:=Ca.CurrSpd, ta:=vq[ivqAx_DecTime+AX_CA-1], p:=vnBelts_VelPPd); (* Potrei anche usare vq[ivqAx_StopSpace+AX_CA-1] *)
                        dlog( Txt:='fbShift: BeltsFeed could stop in %ld + %ld = %ld (max %ld)', Lvl:=6, Val1:=vqXph_FeedEnd/1E3, Val2:=Delta/1E3, Val3:=(vqXph_FeedEnd+Delta)/1E3, Val4:=vqFeed_Xend/1E3 );
                        (* Tolgo le cinghie carico e riporto indietro solo se riesco a fermarmi in tempo
                           senza che l'eventuale vetro successivo possa entrare nel polmone e consumare le
                           cinghie (carico va indietro mentre polmone va avanti) *)
                        IF (vqXph_FeedEnd + Delta) > vqFeed_Xend THEN
                            (* Se non fermo subito le cinghie del carico rischio di
                               portare la lastra accodata sul polmone/stacco *)
                            dlog( Txt:='fbShift: BeltsFeed no more needed', Lvl:=3 );
                            Belts.SlaveBelts := Belts.SlaveBelts & NOT BIT_BELTS_FEED;
                            (* Riposiziono indietro alla cieca: *)
                            (* TODO 1: Solo se ci sono lastre da riposizionare? vnTmpStackedSize, vnStackedSheets *)
                            vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED; (* BeltsFeed.Cmd.Activate := TRUE; *)
                            vnShiftFeed_Cmd := SHFCMD_FEED_INSPLACE;
                            (* In teoria dovrei riposizionarle indietro di '-Delta' *)

                            (* TODO 1: Per controllare la distanza sarebbe meglio
                               provare ad avanzare piano fino alla fotocellula: *)
                            (* vnShiftFeed_Cmd := SHFCMD_FEED_STACKFWD; *)
                        (* ELSE (* Non fermo subito le cinghie del carico *)
                        END_IF;

                    (* END_IF; (* Solo se è presente il polmone *)

                END_IF;

                (* Quando lastra già estratta dal modulo di carico rilevo arrivo
                   delle lastre accumulate per riposizionarle opportunamente *)
                IF fcFeedEnd.rise AND (vbExtractDone OR vqShift_MetPhCells>=IDX_FC_BUF_BEGIN) AND NOT Cb.Emulated THEN (* AND fcFeedNearEnd.q *)
                    (* Il vetro che rimane accumulato ha raggiunto la posizione nota 'fcFeedEnd' *)

                    dlog( Txt:='fbShift: Next subsheet on feed at %ld mm', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
                    Belts.MasterSpd := vqBelts_FwdSpd; (* Assicuro velocità normale avanti (all'estrazione avrei potuto diminuirla) *)

                    (* Stacco al volo l'inseguimento del carico (infatti ci sono le cinghie polmone) *)
                    Belts.SlaveBelts := Belts.SlaveBelts & NOT BIT_BELTS_FEED;
                    (* E richiedo alle cinghie del carico ora libere di fare il riposizionamentino *)
                    vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED; (* BeltsFeed.Cmd.Activate := TRUE; *)
                    vnShiftFeed_Cmd := SHFCMD_FEED_INSPLACE;
                END_IF;
            END_IF;

            (* Durante il passaggio della lastra al modulo riscontri *)
            IF vbShift_AlmostThere THEN

                (* Cambio la velocità delle cinghie, andando più piano.
                   Se la sequenza di evacuazione è in corso modulo la velocità
                   per evitare di cozzare con i piedini riscontro *)
                IF vn[ivnStatus+ID_ALGN]=ALSTS_DRAGFWD THEN (* vnAlgn_DeliverSeq>=DLVSEQ_DRAG_START *)
                    (* IF Belts.MasterSpd>vqBelts_SlowSpd THEN *)
                    Belts.MasterSpd := SEL((vqAlgn_CurrX-vqShift_GlassX)<200E3, vqBelts_SlowSpd, vqBelts_SlowSpd/4); (* Vedi anche: vqShift_HitMargin *)
                    (* dlog( Txt:='fbShift: Slowing speed to %ld m/min', Lvl:=5, Val1:=Belts.MasterSpd/1E6 ); *)
                (* Se sto per lasciare le cinghie, meglio andare piano per non lanciare la lastra lontano *)
                ELSIF (StartedX+vq[ivqAx_StopSpace+Belts.MasterIdx-1]-vqShift_GlassWidth)>vqX_BeltsEnd THEN
                    (* IF Belts.MasterSpd>vqBelts_SlowSpd THEN *)
                    Belts.MasterSpd := vqBelts_SlowSpd;
                    (* dlog( Txt:='fbShift: Slowing speed to %ld m/min', Lvl:=5, Val1:=Belts.MasterSpd/1E6 ); *)
                END_IF;

                (* Se la sequenza di evacuazione è fallita, fermati *)
                IF IS_MSG(REQ_TAKE_PROD) OR IS_MSG(REQ_DUMP_PROD) THEN
                    dlog( Txt:='fbShift: !! Extraction failed, aborting', Lvl:=1 );
                    Status := STS_ERROR;
                END_IF;

                (* Assicuro cuscino aria sui riscontri perché parte della lastra
                   striscerà su di essi;  *)
                IF ( (vqShift_TargetX-vqShift_GlassX)>100E3 (* Manca ancora tanto ad arrivare *)
                     OR Shift_Mass>=100.0 ) (* Lastra pesante *)
                   AND (vqShift_GlassX-vqShift_GlassWidth)<vqX_BeltsEnd THEN (* Sono sulle cinghie *)
                    vnVents_Cmd := vnVents_Cmd OR RequiredVents;
                (* Se perdo le cinghie meglio spegnere! *)
                ELSIF NOT vbShift_KeepAirOn THEN
                    IF (vnVents_Cmd & RequiredVents)<>0 THEN dlog( Txt:='fbShift: Turning off air (0x%X)', Lvl:=4, Val1:=TO_DINT(vnVents_Cmd) ); END_IF;
                    vnVents_Cmd := vnVents_Cmd & NOT RequiredVents;
                END_IF;

                (* Controllo sforamento fine linea (SHF_PLACE_FWD) *)
                (* TODO 3: Se c'è un tavolo a valle, stop e attesa consenso invasione *)
                IF fcOutzoneEnd.rise AND vqShift_GlassX>vqXph_OutZoneBegin THEN
                    dlog( Txt:='fbShift: !! IFC_OUTZONE_END while fwd', Lvl:=2 );
                    Status := STS_ERROR;
                END_IF;

                (* Se sto passando in là tutta la lastra
                   intercetto quando il bordo indietro lascia la fotocellula perché
                   probabilmente mi interessa di più il bordo indietro per agganciare/pinzare *)
                (* IF (TargetX-vqShift_GlassWidth) > (vqDtch_CurrX+vqDXph_DtchLast) THEN *)
                IF TargetX >= vqShift_GlassWidth THEN
                    (* ...Mi interessa il bordo dietro *)
                    IF fcDtchLast.fall_delayed THEN
                        vqShift_MetPhCells := IDX_FC_DTCH_LAST;
                        (* Aggiusto la posizione (la fotocellula è in vqDtch_CurrX+vqDXph_DtchLast) *)
                        (* Posizione effettiva bordo avanti *)
                        Delta := (vqDtch_CurrX+vqDXph_DtchLast) + vqDXph_Size + vqShift_GlassWidth; (* Piccola correzione con dimensione fotocellula *)
                        IF vbShift_PhLatencyFix THEN
                            (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                            Delta := Delta + TO_DINT(TO_LREAL(Belts.Master_CurrSpd) * vdPlcScanTime * 8.333E-3);
                        END_IF;
                        dlog( Txt:='fbShift: Left IFC_DTCH_LAST at %ld xfwd=%ld=>%ld (%ld)', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3, Val2:=vqShift_GlassX/1E3, Val3:=Delta/1E3, Val4:=(Delta - vqShift_GlassX)/1E3 );
                        vqShift_GlassX := Delta; (* Aggiorno posizione bordo avanti *)
                        StartedX := vqShift_GlassX - Belts.Master_CurrPos;
                        (* Cambio target se fattibile *)
                        Delta := TargetX - vqShift_GlassX; (* Quanto mi manca ad arrivare *)
                        IF Delta > (vq[ivqAx_StopSpace+Belts.MasterIdx-1]+vqAx_StopSpaceTol) (* Nota: Sono tutti e due positivi, sto andando avanti *)
                           AND VN_AX(iVN_AX_FASE,Belts.MasterIdx)<AFS_POS_DEC THEN
                            Belts.MasterTgt := Belts.Master_CurrPos + Delta;
                        ELSE
                            dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=Belts.MasterTgt/1E3, Val2:=(Belts.Master_CurrPos + Delta)/1E3 );
                        END_IF;

                        (* Se non ci sono cinghie riscontri tra poco perdo aderenza... Inutile andare avanti troppo? *)
                        (* Belts.MasterTgt := Belts.Master_CurrPos + vqX_AlgnBeltsEnd - (vqShift_GlassX-vqShift_GlassWidth); *)
                    END_IF;

                    (* Se non sto usando trasportatori su riscontro meglio evitare moto
                       incontrollato per abbrivio assicurando aria riscontri spenta *)
                    IF (Belts.SlaveBelts & BIT_ROLLS_ALGN)=0 THEN
                        RequiredVents := 0;
                        vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_ALGN_B; (* Assicuro aria riscontri spenta *)
                    END_IF;
                END_IF;

                (* La zona fine linea sta bloccando l'uso delle cinghie riscontro? *)
                IF (OutZone.Xbusy>vqX_AlgnBeltsEnd OR (fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY)) AND
                   TargetX>vqX_AlgnBeltsBegin AND (Belts.SlaveBelts & BIT_ROLLS_ALGN)=0 THEN
                    dlog( Txt:='fbShift: AlgnBelts waits OutZone.Xbusy=%ld', Lvl:=5, Val1:=OutZone.Xbusy/1E3 );
                    Belts.Cmd := CMD_ACTIVATE; (* Mi fermo con cinghie alte *)
                    Status := SHF_FWD_STOPOUTZ;
                (* Invado la zona a fine linea occupata? *)
                ELSIF NOT OutZone.Free AND
                     (TargetX + vqAlgn_BlkBackRoom) > OutZone.Xbusy THEN
                    dlog( Txt:='fbShift: Wait OutZone.Xbusy=%ld (%ld, %ld)', Lvl:=5, Val1:=OutZone.Xbusy/1E3, Val2:=Belts.MasterTgt/1E3, Val3:=Belts.Master_CurrPos/1E3 );
                    Belts.Cmd := CMD_ACTIVATE; (* Mi fermo con cinghie alte *)
                    Status := SHF_FWD_STOPOUTZ;
                (* Bloccherò la sequenza di evacuazione in corso? *)
                ELSIF vn[ivnStatus+ID_ALGN]=ALSTS_DRAGFWD AND (* vnAlgn_DeliverSeq=DLVSEQ_DRAGGING *)
                     (TargetX + vqAlgn_BlkFrontRoom) > (vqAlgnDrag_Tgt - vqAlgnDrag_Width) THEN
                    dlog( Txt:='fbShift: Wait dragging Xbck=%ld', Lvl:=5, Val1:=(vqAlgnDrag_Tgt-vqAlgnDrag_Width)/1E3 );
                    Belts.Cmd := CMD_ACTIVATE; (* Mi fermo con cinghie alte *)
                    Status := SHF_FWD_STOPOUTZ;
                END_IF; (* -- Controlli invasione fine linea *)

            END_IF; (* Passaggio lastra ai riscontri *)

        END_IF; (* Cinghie in moto *)


    (* ------------------------------------------------------------------- *)
    SHF_FWD_WAITDLVR : (* Waiting delivering of previous glass *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Sequenza di consegna a fine linea a buon punto *)
        ELSIF vnAlgn_DeliverSeq>SEQ_DONE AND NOT vbAlgnDlvr_AlmostDone THEN (* AND vqAlgnDlvr_Xbck<TargetX *)
            (* Attendo sequenza di consegna a fine linea *)
        (* Aggancio/prelievo con riscontri a buon punto *)
        ELSIF vn[ivnStatus+ID_ALGN]=ALSTS_DRAGFWD AND (vnAlgn_DragSeq<ALSEQ_DRAG_FORE OR vqAlgn_CurrX<(TargetX/2)) THEN
            (* Attendo sequenza di aggancio/prelievo con riscontri a buon punto *)
        (* Niente richieste di prelievo manuale (fallimento sequenze di consegna) *)
        ELSIF IS_MSG(REQ_TAKE_PROD) OR IS_MSG(REQ_DUMP_PROD) THEN
            (* Attendo presa in carico delle richieste *)
        (* Cinghie coinvolte pronte *)
        ELSIF BeltsDtch.Status>=BLT_STOPPING OR RollsAlgn.Status>=BLT_STOPPING THEN
            (* Attendo cinghie pronte *)
        ELSE
            (* Procedo col comando *)
            IF vnShift_Cmd=SHFCMD_FORW_ONALGN THEN
                (* Devo passare un vetro sui riscontri *)
                dlog( Txt:='fbShift: Start passing from %ld to %ld mm', Lvl:=4, Val1:=vqShift_GlassX/1E3, Val2:=vqShift_TargetX/1E3 );
                (* Potrebbe essere sia una rimanenza che un prodotto già in parte sui riscontri! *)
                (* Se ho un pezzo stretto dovrò fare la manovra di avvicinamento stacco *)
                IF vqShift_GlassWidth<vqShift_GoodWidth AND NOT Cs.Emulated AND vqShift_TargetX>(vqX_CutZoneP+10E3) THEN
                    TargetX := MAX(vqDtch_CurrX, vqDtch_CurrX+vqDXph_DtchLast+10E3); (* Dovrei portarla sul bordo dello stacco *)
                    IF vqShift_GlassX<TargetX AND NOT fcDtchLast.q THEN
                        (* È una rimanenza *)
                        Stop_On_Dtch := TRUE; (* Probabilmente ci sarà uno stop in vqDtch_CurrX+vqDXph_DtchLast *)
                        Belts.MasterSpd := vqBelts_SlowSpd; (* Vado piano, tanto dovrei essere già in zona *)
                        Belts.MasterAcc := 100; (* [%] *)
                    ELSE
                        (* Sono già avanti! Sarà un prodotto a cavallo della zona taglio *)
                        (* Mando subito lo stacco avanti e poi procedo? *)
                        dlog( Txt:='! Crossing prod', Lvl:=4 );
                        TargetX := vqShift_TargetX;
                        Stop_On_Dtch := FALSE;
                        Need_Dtch_Fwd := TRUE; (* Giusto per ricordarmelo, ma non dovrebbe essere usato *)
                        Belts.MasterSpd := vqBelts_FwdSpd;
                        Belts.MasterAcc := 100; (* [%] *)
                        Status := SHF_DTCH_STP;
                        (* Quello che voglio che accada è che lo stacco si avvicini
                           per poi procedere col movimento cinghie
                           Lo stacco potrebbe spostare il vetro avanti! *)
                        vnVents_Cmd := vnVents_Cmd OR BIT_VENT_DTCH;
                    END_IF;
                ELSE
                    (* Ho un vetro largo *)
                    TargetX := vqShift_TargetX;
                    Stop_On_Dtch := FALSE;
                    Belts.MasterSpd := SEL(vqShift_GlassX<vqShift_TargetX, vqBelts_DragSpd, vqBelts_FwdSpd);
                    Belts.MasterAcc := 100; (* [%] *)
                END_IF;
                (* Potrebbe essere sia una rimanenza che un prodotto già in parte sui riscontri! *)
                (* IF vqShift_GlassX<vqX_CutZoneP THEN *)

                (* Data la posizione iniziale, non mi aspetto di muovermi più di così: *)
                StartedX := vqShift_GlassX; (* Ricorda la posizione iniziale del bordo avanti *)
                Belts.MasterTgt := TargetX - StartedX; (* Movimento incrementale *)

                (* Eventuali vetri accodati possono crearmi fronti delle fotocellule:
                   devo inibire quelle che so che non incontrerò mai! *)
                IF vqShift_GlassX > (vqDtch_CurrX+vqDXph_DtchLast) THEN
                    vqShift_MetPhCells := IDX_FC_DTCH_LAST;
                ELSIF vqShift_GlassX > (vqDtch_CurrX+vqDXph_DtchBegin) THEN
                    vqShift_MetPhCells := IDX_FC_DTCH_BEGIN;
                ELSIF vqShift_GlassX > vqXph_BufBegin THEN
                    vqShift_MetPhCells := IDX_FC_BUF_BEGIN;
                ELSIF vqShift_GlassX > vqXph_FeedEnd THEN
                    vqShift_MetPhCells := IDX_FC_FEED_END;
                ELSE
                    vqShift_MetPhCells := IDX_FC_FEED_BEGIN;
                END_IF;

                (* Il Master sono le cinghie stacco 'BeltsDtch', BIT_BELTS_DTCH, Cs.Idx *)
                Belts.MasterIdx := Cs.Idx;
                Cs.Incremental := TRUE;
                (* Vediamo quali altre cinghie servono oltre a quelle dello stacco *)
                IF (vqShift_GlassX-vqShift_GlassWidth) < (vqDtch_Xbegin-100E3) THEN
                    (* Il bordo indietro è molto oltre lo stacco: servono cinghie a monte *)
                    Belts.SlaveBelts := SEL(Cb.Emulated, BIT_BELTS_BUF, 0);
                    (* Le cinghie del carico sono coinvolte se: *)
                    IF Cb.Emulated OR (* ...Non esistono le cinghie polmone *)
                       (* fcBufBegin.q OR (* ...Fotocellula inizio polmone attivata *)
                       (vqShift_GlassX-vqShift_GlassWidth) < vqFeed_Xend THEN (* ...Il bordo indietro della lastra coinvolge il carico *)
                        IF vb[ivbAtRest+ID_FEED_TILT] THEN
                            (* Il carico non è basculato, le cinghie carico dovrebbero essere disponibili *)
                            dlog( Txt:='Also BeltsFeed', Lvl:=5 );
                            Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED;
                        END_IF;
                    END_IF;
                END_IF; (* Altre cinghie a monte di quelle dello stacco *)

                (* I trasportatori su riscontro sono coinvolti se devo arrivare abbastanza avanti *)
                IF TargetX > vqX_AlgnBeltsBegin THEN
                    (* Occhio alla sicurezza (fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY) OR OutZone.Xbusy>vqX_AlgnBeltsEnd *)
                    Belts.SlaveBelts := Belts.SlaveBelts OR BIT_ROLLS_ALGN;
                END_IF;

                (* La zona fine linea è effettivamente occupata?
                   Il bordo avanti lastra ora si trova in StartedX *)
                OutZone.XcheckIfBusy := StartedX; (* Tra un ciclo PLC sono pronti 'Xbusy' e 'Free' *)

                (* Sono già praticamente ai riscontri *)
                vbShift_AlmostThere := TRUE;

                (* Default: procedi *)
                IF Status=SHF_FWD_WAITDLVR THEN
                    Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                    Status := SHF_PLACE_FWD;
                END_IF;
            ELSE
                (* In caso di comando non riconosciuto, torno a riconsideralo *)
                Status := STS_IDLE;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FWD_STOPOUTZ : (* Stop per attendere liberazione zona fine linea *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Attendo cinghie ferme *)
        ELSIF Belts.Master_Status<BLT_STOPPING THEN
            (* Prendo nota della posizione di stop? *)
            (* È il caso di aggiornare la posizione lastra! *)
            vqShift_GlassX := StartedX + Belts.Master_CurrPos;
            Status := SHF_FWD_WAITOUTZ;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FWD_WAITOUTZ : (* Attesa liberazione zona fine linea *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Attendo che finisca una eventuale sequenza di evacuazione in corso *)
        ELSIF vnAlgn_DeliverCmd<>CMD_STOP OR IS_MSG(REQ_TAKE_PROD) OR IS_MSG(REQ_DUMP_PROD) THEN
            (* Waiting deliver... *)
        (* Controllo liberazione zona fine linea *)
        ELSIF OutZone.Free AND NOT IS_MSG(REQ_FREE_OUTZONE)
              AND (NOT fcOutzoneBegin.q OR NOT O_SCU_OUTZONE_BUSY) THEN
            dlog( Txt:='fbShift: OutZone freed', Lvl:=5 );

            (* Vediamo se mi servono i rulli/cinghie riscontro *)
            IF TargetX>vqX_AlgnBeltsBegin THEN (* AND NOT vbShift_NoRolls, in teoria non dovrei farlo se non erano desiderati... *)
                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_ROLLS_ALGN;
            END_IF;

            (* Ricalcolo il movim incrementale per arrivare alla quota finale *)
            IF Belts.MasterTgt > Belts.Master_CurrPos THEN
                (* Dovrebbe essere minore di TargetX-StartedX *)
                StartedX := vqShift_GlassX; (* Il movimento è incrementale ripartendo da qui! *)
                Belts.MasterTgt := Belts.MasterTgt - Belts.Master_CurrPos;
                Belts.Cmd := CMD_MOVETO;
                (* Riprendo la sequenza
                   Nota: Posso essere arrivato qui solo da SHF_PLACE_FWD *)
                Status := SHF_PLACE_FWD;
            ELSE
                dlog( Txt:='!! Invalid pos %ld - %ld = %ld', Lvl:=2, Val1:=Belts.MasterTgt/1E3, Val2:=Belts.Master_CurrPos/1E3, Val3:=(Belts.MasterTgt - Belts.Master_CurrPos)/1E3 );
                (* In caso di asse cinghie emulato Master_CurrPos ha valori strani,
                   posso provare ad arrangiarmi: se stavo arrivando la cosa dovrebbe
                   essere accaduta più o meno all'impegno dell'ultima fotocellula,
                   quindi il vetro dovrebbe trovarsi lì più lo spazio di stop *)
                Delta := fnRampSpace(V:=Belts.MasterSpd, ta:=vq[ivqAx_DecTime+Belts.MasterIdx-1], p:=vnBelts_VelPPd);
                vqShift_GlassX := vqDtch_CurrX+vqDXph_DtchLast + Delta;
                Delta := TargetX - vqShift_GlassX;
                IF Delta>0 THEN
                    StartedX := vqShift_GlassX; (* Il movimento è incrementale ripartendo da qui! *)
                    Belts.MasterTgt := Delta;
                    Belts.Cmd := CMD_MOVETO;
                    Status := SHF_PLACE_FWD;
                ELSE
                    Status := STS_ERROR;
                END_IF;
            END_IF;
        (* Assicuro richiesta di liberare la zona fine linea *)
        ELSIF NOT IS_MSG(REQ_FREE_OUTZONE) AND NOT ICM_ACKNOWLEDGE THEN
            dlog( Txt:='fbShift: Requesting REQ_FREE_OUTZONE', Lvl:=4 );
            SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',0); (* Shift *)
        END_IF;


    (* -------------------------------------------------------------------
    SHF_FWD_WAITEVAC : (* Attendi che la sequenza di evacuazione sia a buon punto
        (* Rilevo condizioni abort sequenza
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Attendo che la sequenza di evacuazione sia a buon punto
        ELSIF vbAlgnDlvr_AlmostDone THEN
            dlog( Txt:='fbShift: Deliver is at %ld', Lvl:=5, Val1:=vqAlgnDlvr_Xbck/1E3 );
            Belts.Cmd := CMD_MOVETO;
            Status := SHF_PLACE_FWD;
        END_IF; *)


    (* ------------------------------------------------------------------- *)
    SHF_DTCH_STP : (* Fermati sullo stacco (vetri stretti) *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Attendo master fermo *)
        ELSIF Belts.Master_Status<BLT_STOPPING THEN

            (* Sono qui perché ho fermato la lastra sullo stacco? *)
            IF Stop_On_Dtch THEN
                (* The glass is supposed to be on Detach *)

                IF NOT Need_Dtch_Fwd THEN (* Ossia: Sono qui da fermo, non per uno stop *)
                    (* Meglio aggiornare la posizione effettiva del bordo lastra
                       magari si è fermata per un evento asincrono *)
                    vqShift_GlassX := StartedX + Belts.Master_CurrPos;

                    (* Controllo che il vetro sia effettivamente sullo stacco *)
                    IF NOT fcDtchLast.q THEN
                        dlog( Txt:='fbShift: !! Narrow not on Dtch', Lvl:=1 );
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;
                END_IF;

                (* Ok, ora devo avvicinarmi con lo stacco prima di passare questa striscia *)
                dlog( Txt:='fbShift: Narrow on Dtch (xfwd=%ld)', Lvl:=4, Val1:=vqShift_GlassX/1E3 );
                Qx := vqDtch_CurrX; (* Mi metto via la quota di partenza *)

                (* Sarebbe bene che le cinghie stacco rimangano su *)
                (* vnBelts_Act := vnBelts_Act OR BIT_BELTS_DTCH; *)
                (* Cinghie stacco ed eventualmente rulli rimangono attive, preparo già tutto qui *)
                Belts.MasterIdx := Cs.Idx;
                Cs.Incremental := TRUE;
                (* I trasportatori su riscontro sono coinvolti se devo arrivare abbastanza avanti *)
                (* Occhio alla sicurezza (fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY) OR OutZone.Xbusy>vqX_AlgnBeltsEnd *)
                Belts.SlaveBelts := SEL( vqShift_TargetX > vqX_AlgnBeltsBegin, INT#0, BIT_ROLLS_ALGN );
                Belts.Cmd := CMD_ACTIVATE; (* Cinghie alte *)

                (* Preparo subito i ventilatori della zona premilastra, per aiutare il passaggio *)
                RequiredVents := RequiredVents OR BIT_VENT_ALGN_C;
                vnVents_Cmd := vnVents_Cmd OR RequiredVents;
                vbDtch_HoldGlassAlgn := FALSE;
            (* ELSIF Need_Dtch_Fwd THEN
                vbDtch_HoldGlassAlgn := TRUE; (* Meglio tenere fermo il vetro *)
            END_IF;

            (* Procedo a muovere lo stacco in avanti *)
            vqDtch_Tgt := vq[ivqAx_PosLim+AX_XS-1] - MRGN_UM; (* [um] Vado più avanti possibile *)
            vnDtch_Cmd := CMD_MOVETO;

            (* Se i carrelli occupano l'area taglio devo toglierli di mezzo,
               altrimenti bloccheranno lo stacco avanti *)
            IF vnCarriages_Cmd=CMD_STOP AND NOT (vb[ivbAtRest+ID_CARR_SUP] AND vb[ivbAtRest+ID_CARR_INF]) THEN (* Carriages.AtRest *)
                dlog( Txt:='fbShift: ! Parking Carriages for Dtch', Lvl:=4 );
                vnCarriages_Cmd := CARCMD_FREEAREA;
            END_IF;

            Status := SHF_DTCH_MOV;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_DTCH_MOV : (* Avvicina lo stacco (vetri stretti) *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        ELSIF vnDtch_Cmd=CMD_STOP THEN
            (* Movimento stacco terminato *)
            vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_DTCH; (* Chiudi ventilatore stacco *)
            (* Vediamo risultato *)
            IF vnDtch_Seq=SEQ_DONE THEN
                (* dlog( Txt:='fbShift: Dtch fwd done', Lvl:=5 ); *)

                (* Se sono qui perché ho fermato la lastra sullo stacco... *)
                IF Stop_On_Dtch THEN
                    Stop_On_Dtch := FALSE; (* Eat *)

                    (* Ora devo portare avanti il vetro stretto con le cinghie,
                       prima però un doveroso controllo di caduta *)
                    IF vqShift_GlassWidth <= 2*(vqX_CutZoneP-vqDtch_CurrX) THEN
                        dlog( Txt:='fbShift: !! Narrow sheet w=%ld would fall', Lvl:=1, Val1:=vqShift_GlassWidth/1E3 );
                        SET_MSG(MSG_FALLINCUTZONE,'MSG_FALLINCUTZONE',vqShift_GlassWidth);
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;

                    (* Aggiorno la posizione del bordo lastra dopo il movimento stacco *)
                    vqShift_GlassX := vqShift_GlassX + (vqDtch_CurrX - Qx); (* Aggiungo il movimento stacco *)
                    TargetX := vqShift_TargetX; (* Assegno la destinazione finale *)

                    (* Adesso porto avanti il pezzo con le cinghie, ho già preparato tutto in 'SHF_DTCH_STP' *)
                    (* Noto che se va piano i pezzi piccoli fanno fatica a passare! *)
                    Belts.MasterTgt := TargetX - vqShift_GlassX; (* Movimento incrementale *)
                    Belts.MasterSpd := vqBelts_FwdSpd; (* vqBelts_DragSpd *)
                    Belts.MasterAcc := vnBelts_DragAcc; (* [%] *)

                    (* Fondamentali i ventilatori della zona premilastra, per aiutare il passaggio *)
                    RequiredVents := RequiredVents OR BIT_VENT_ALGN_C;
                    vnVents_Cmd := vnVents_Cmd OR RequiredVents;

                    (* Mi assicuro di ignorare le fotocellule, ormai sono oltre l'ultima *)
                    vqShift_MetPhCells := IDX_FC_DTCH_LAST;

                (* ELSE (* Need_Dtch_Fwd: Era solo richiesto il movimento stacco avanti, procedo a muovere le cinghie *)
                END_IF;

                (* Diamo il comando alle cinghie *)
                (* Nota: I controlli occupazione fine linea sono svolti in 'SHF_PLACE_FWD' *)
                vbShift_AlmostThere := TRUE;
                Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                Status := SHF_PLACE_FWD; (* Nota: Per ora non c'è la necessità di supportare SHF_PLACE_BCK *)
            ELSE
                dlog( Txt:='fbShift: !! Dtch fwd failed', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- * )
    SHF_PARK_DTCH : (* Waiting conditions to park detach *)


    (* ------------------------------------------------------------------- *)
    SHF_WAIT_DTCH : (* Wait detach in park before continue *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        ELSIF vb[ivbAtRest+ID_DTCH] THEN (* AND vnDtch_Cmd=CMD_STOP AND vn[ivnStatus+ID_DTCH]=STS_IDLE *)
            RST_MSG(MSG_NOTPARKED);
            Status := STS_IDLE;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_PLACE_BCK : (* Placing sheet backward *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Rilevo arrivo in quota o problemi di movimentazione *)
        ELSIF Belts.Cmd<CMD_MOVETO THEN
            (* Comando movimento terminato! *)
            (* Può essere che se non arrivato sia in 'CMD_ACTIVATE' *)
            Belts.Cmd := CMD_STOP;

            IF ABS(Belts.MasterTgt - Belts.Master_CurrPos)<=vqShift_TargetTol THEN
                vqShift_GlassX := TargetX; (* Arrivato a destinazione! *)
                IF vnShift_Cmd=SHFCMD_PLACE_SHEET THEN vqSubSheet_X := vqShift_GlassX; END_IF; (* TODO 5: togliere? *)

                dlog( Txt:='fbShift: Sheet placed back to %ld mm', Lvl:=4, Val1:=TargetX/1E3 );

                (* Se non sta riscontrando o trascinando assicuro ventilatori spenti *)
                IF vn[ivnStatus+ID_ALGN]<ALSTS_ALIGNING THEN
                    vnVents_Cmd := vnVents_Cmd & NOT RequiredVents; (* Assicuro ventilatori chiusi *)
                END_IF;

                (* Ho incontrato fotocellule?
                   Mah, andando indietro non è detto che le incontri
                IF vqShift_MetPhCells<=IDX_FC_FEED_BEGIN THEN
                    dlog( Txt:='fbShift: ! No photocells back after %ld mm', Lvl:=2, Val1:=Belts.MasterTgt/1E3 );
                END_IF; *)

                vnShift_Seq := SEQ_DONE;
                Status := STS_STOPPING;
                (* vnBelts_Act := 0; (* Un po' radicale: assicuro TUTTE le cinghie disattivate *)
            ELSE
                dlog( Txt:='fbShift: !! PLACE_BCK: Not arrived %ld != %ld mm', Lvl:=2, Val1:=vqShift_GlassX/1E3, Val1:=TargetX/1E3 );
                Status := STS_ERROR;
            END_IF;
            vbShift_KeepAirOn := FALSE; (* Ensure to reset this temporary modifier *)

        (* Rilevo eventi fotocellule per synch posizione *)
        ELSIF Belts.Status=BLT_OPERATING THEN
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqShift_GlassX := StartedX + Belts.Master_CurrPos;
            IF vnShift_Cmd=SHFCMD_PLACE_SHEET THEN vqSubSheet_X := vqShift_GlassX; END_IF; (* TODO 5: togliere? *)

            (* Assicuro cuscino aria fintanto sono sui riscontri *)
            IF vqShift_GlassX > vqX_CutZoneP THEN
                vnVents_Cmd := vnVents_Cmd OR RequiredVents;
            ELSIF NOT vbShift_KeepAirOn THEN
                vnVents_Cmd := vnVents_Cmd & NOT RequiredVents;
            END_IF;

            (* Abbasso la velocità se non sono coinvolte le cinghie carico e mi sto
               avvicinando al limite, per evitare di fermarmi troppo oltre il polmone: *)
            IF (Belts.SlaveBelts & BIT_BELTS_FEED)=0 AND Belts.MasterSpd>vqBelts_SlowSpd THEN
                IF fnInRange_DINT( (vqShift_GlassX - vqShift_GlassWidth) - vqFeed_Xend, 0, 200E3 ) THEN
                    Belts.MasterSpd := vqBelts_SlowSpd;
                END_IF;
            END_IF;

            (* Rilevo raggiungimento del bordo indietro del tavolo di carico *)
            IF FeedOutBack AND (Belts.SlaveBelts & BIT_BELTS_FEED)<>0 AND BeltsFeed.CurrSpd<0 THEN
                dlog( Txt:='fbShift: !! Place back reached IFC_FEED_BEGIN', Lvl:=2 );
                SET_MSG(REQ_STACKFULL,'REQ_STACKFULL',0);
                Status := STS_ERROR;
            (* Rilevo raggiungimento del limite polmone per coinvolgere le cinghie del carico
               Solo se manca ancora molto! Posso tollerare uno sforamento: (vqXph_BufBegin-vqFeed_Xend) *)
            ELSIF (fcBufBegin.q OR fcFeedEnd.rise) AND BeltsFeed.Status<BLT_OPERATING AND
                  (vqShift_TargetX-vqShift_GlassWidth)<vqXph_FeedEnd THEN
                Belts.Cmd := CMD_ACTIVATE; (* Fermati con cinghie alte *)
                dlog( Txt:='fbShift: Stopping at %ld for BeltsFeed', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
                (* Spazio di stop atteso:
                   Delta := fnRampSpace(V:=Belts.Master_CurrSpd, ta:=vq[ivqAx_DecTime+AX_CS-1], p:=vnBelts_VelPPd); *)
                (* Attacco al volo l'inseguimento delle cinghie carico e le attendo *)
                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED;
                Prev_Status := Status; (* Ricordati dove ero *)
                Status := SHF_BCK_WAITSTOP;

            (* Eventi fotocellule per synch posizione su bordo avanti ed eventuale sgancio
              NO!!: troppo pericoloso sincronizzarsi sulle fotocellule indietro
                    a causa ad es. di altri pezzi accodati. Se sono qui mi
                    sto fidando della posizione lastra data inizialmente *)
            END_IF;

        END_IF; (* Cinghie in moto *)


    (* ------------------------------------------------------------------- *)
    SHF_BCK_OFFDTCH : (* Indietreggiamento per disimpegno ultima fotocellula stacco *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Rilevo arrivo in quota o problemi di movimentazione *)
        ELSIF Belts.Cmd<CMD_MOVETO THEN
            (* Comando movimento terminato! *)
            (* Può essere che se non arrivato sia in 'CMD_ACTIVATE' *)
            Belts.Cmd := CMD_STOP;

            IF ABS(Belts.MasterTgt - Belts.Master_CurrPos)<=vqShift_TargetTol THEN
                vqShift_GlassX := TargetX; (* Arrivato a destinazione! *)
                IF vnShift_Cmd=SHFCMD_BACK_REMN THEN vqRemn_X := vqShift_GlassX; END_IF;

                IF NOT fcDtchLast.q THEN
                    (* Ok, arrivato a destinazione e fotocellula liberata *)
                    IF vnShift_Cmd<>SHFCMD_BACK_REMN THEN
                        (* Se stavo eseguendo un altro comando, torno allo stesso dopo che mi sono fermato *)
                        QueuedCmd := vnShift_Cmd; (* Procedi col comando attuale dopo lo stop *)
                    ELSE
                        (* Ho mandato indietro la rimanenza *)
                        dlog( Txt:='fbShift: Remn moved to %ld mm', Lvl:=3, Val1:=vqRemn_X/1E3 );
                        vnShift_Seq := SEQ_DONE;
                    END_IF;
                    Status := STS_STOPPING;
                ELSE
                    (* Fotocellula non liberata?? *)
                    dlog( Txt:='fbShift: !! IFC_DTCH_LAST not freed after %ld mm', Lvl:=2, Val1:=Belts.Master_CurrPos/1E3 );
                    Status := STS_ERROR;
                END_IF;
            ELSE
                dlog( Txt:='fbShift: !! Belts stopped freeing IFC_DTCH_LAST', Lvl:=2 );
                Status := STS_ERROR;
            END_IF;
            vbShift_KeepAirOn := FALSE; (* Ensure to reset this temporary modifier *)

        (* Rilevo eventi fotocellule *)
        ELSIF Belts.Status=BLT_OPERATING THEN
            (* Mah, in realtà quando libero non so dove è la lastra! *)
            vqShift_GlassX := StartedX + Belts.Master_CurrPos; (* Keep track of fwd edge position *)
            IF vnShift_Cmd=SHFCMD_BACK_REMN THEN vqRemn_X := vqShift_GlassX; END_IF;

            (* Assicuro cuscino aria fintanto sono sui riscontri *)
            IF vqShift_GlassX>vqX_CutZoneP THEN (* OR Cs.Emulated AND vqShift_GlassX>vqDtch_Xbegin *)
                vnVents_Cmd := vnVents_Cmd OR RequiredVents;
            ELSIF NOT vbShift_KeepAirOn THEN
                vnVents_Cmd := vnVents_Cmd & NOT RequiredVents;
            END_IF;

            (* Abbasso la velocità se non sono coinvolte le cinghie carico e mi sto
               avvicinando al limite, per evitare di fermarmi troppo oltre il polmone: *)
            IF (Belts.SlaveBelts & BIT_BELTS_FEED)=0 AND Belts.MasterSpd>vqBelts_SlowSpd AND
               fnInRange_DINT( (vqShift_GlassX - vqShift_GlassWidth) - vqFeed_Xend, 0, 500E3 ) THEN
                dlog( Txt:='fbShift: ! Slow down at Xbck=%ld mm', Lvl:=5, Val1:=(vqShift_GlassX - vqShift_GlassWidth)/1E3 );
                Belts.MasterSpd := vqBelts_SlowSpd;
            END_IF;

            (* Rilevo raggiungimento del bordo indietro del tavolo di carico *)
            IF FeedOutBack AND (Belts.SlaveBelts & BIT_BELTS_FEED)<>0 AND BeltsFeed.CurrSpd<0 THEN
                (* BeltsFeed.Status=BLT_OPERATING AND Ca.MovingBck AND vnShiftFeed_Sts=STS_IDLE *)
                dlog( Txt:='fbShift: !! Reached IFC_FEED_BEGIN freeing cutzone', Lvl:=2 );
                SET_MSG(REQ_STACKFULL,'REQ_STACKFULL',0);
                Status := STS_ERROR;
            (* Rilevo raggiungimento del limite polmone per coinvolgere le cinghie del carico
               Solo se per liberare la fotocellula dello stacco serve occupare troppa parte
               del modulo di carico *)
            ELSIF (fcBufBegin.q OR fcFeedEnd.rise) AND BeltsFeed.Status<BLT_OPERATING AND
                  ((vqDtch_CurrX+vqDXph_DtchLast)-vqShift_GlassWidth)<vqXph_FeedEnd THEN
                Belts.Cmd := CMD_ACTIVATE; (* Fermati con cinghie alte *)
                dlog( Txt:='fbShift: Stopping at %ld for BeltsFeed', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
                (* Spazio di stop atteso:
                   Delta := fnRampSpace(V:=Belts.Master_CurrSpd, ta:=vq[ivqAx_DecTime+AX_CS-1], p:=vnBelts_VelPPd); *)
                (* Attacco al volo l'inseguimento delle cinghie carico e le attendo *)
                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED;
                Prev_Status := Status; (* Ricordati dove ero *)
                Status := SHF_BCK_WAITSTOP;

            (* Rilevo disimpegno della fotocellula fine stacco
               Nota: Quando è presente il polmone non guardo solo il fronte fcDtchLast.fall_delayed
                     perchè potrebbe disimpegnarsi in 'SHF_BCK_WAITSTOP' per coinvolgere il carico *)
            ELSIF fcDtchLast.fall_delayed OR (NOT fcDtchLast.q AND NOT Cb.Emulated AND (vnShift_Cmd<>SHFCMD_BACK_REMN OR vqShift_TargetX=0)) THEN
                (* La lastra in arrivo/rimanenza ha liberato la fotocellula di synch posizione *)
                (* Calcoliamo la posizione di stop se dovessimo fermare le cinghie *)
                Delta := (vqDtch_CurrX+vqDXph_DtchLast) + fnRampSpace(V:=Belts.Master_CurrSpd, ta:=vq[ivqAx_DecTime+Belts.MasterIdx-1], p:=vnBelts_VelPPd);
                dlog( Txt:='fbShift: IFC_DTCH_LAST off after %ld mm (Xfwd_stop=%ld)', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3, Val2:=Delta/1E3 );
                (* A seconda della situazione: *)
                IF vnShift_Cmd<>SHFCMD_BACK_REMN THEN
                    (* Assumo di voler liberare la fotocellula per poi eseguire un comando successivo dopo che mi sono fermato *)
                    Belts.Cmd := CMD_ACTIVATE; (* Fermati con cinghie alte *)
                    QueuedCmd := vnShift_Cmd; (* Procedi col comando attuale dopo lo stop *)
                    Status := STS_STOPPING;
                    vqShift_GlassX := Delta; (* Aggiorno subito la posizione dopo lo stop *)
                ELSIF vqShift_TargetX=0 THEN
                    (* Volevo solo liberare la fotocellula di fine stacco *)
                    (* Siccome dovevo solo liberare, fermo *)
                    Belts.Cmd := 0; (* Ferma il movimento e scendi *)
                    vnShift_Seq := SEQ_DONE;
                    Status := STS_STOPPING;
                    vqShift_GlassX := Delta; (* Aggiorno subito la posizione dopo lo stop *)
                END_IF;
            END_IF; (* Fotocellula fine stacco disimpegnata! *)
        END_IF; (* Cinghie in moto *)


    (* ------------------------------------------------------------------- *)
    SHF_BCK_WAITSTOP : (* Attendi cinghie indietro ferme per poi attendere quelle di carico *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        ELSIF Belts.Master_Status<BLT_STOPPING THEN
            (* Cinghie ferme, posso calcolarmi quanto spazio manca all'arrivo: *)
            Qx := Belts.MasterTgt - Belts.Master_CurrPos;
            dlog( Txt:='fbShift: Stopped at %ld for FeedBelts, %ld to end', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3, Val2:=Qx/1E3 );

            (* Sembra che in caso di asse emulato ci possa essere qualche problemino! *)
            IF Qx<0 THEN
                (* Attendo cinghie carico per proseguire col movimento *)
                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED; (* Dovrebbe essere già stato dato *)
                Status := SHF_BCK_WAITFEED;
            ELSE
                dlog( Txt:='!! Invalid pos %ld - %ld = %ld', Lvl:=2, Val1:=Belts.MasterTgt/1E3, Val2:=Belts.Master_CurrPos/1E3, Val3:=Qx/1E3 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_BCK_WAITFEED : (* Attendi cinghie carico prima di proseguire *)
        (* IF BeltsFeed.Allow THEN
            Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED; *)
        IF vnShift_Cmd=CMD_STOP THEN (* OR (Belts.SlaveBelts & BIT_BELTS_FEED)=0 *)
            Status := STS_ERROR;
        ELSIF vnShiftFeed_Sts<>STS_IDLE OR vnShiftFeed_Cmd<>CMD_STOP OR NOT BeltsFeed.Allow THEN
            dlog( Txt:='fbShift: !! BeltsFeed not avail (Sts=%d Cmd=%d)', Lvl:=2, Val1:=TO_DINT(vnShiftFeed_Sts), Val2:=TO_DINT(vnShiftFeed_Cmd) );
            Status := STS_ERROR;
        ELSIF Prev_Status=STS_IDLE THEN
            (* Era solo un check sulla disponibilità delle cinghie carico *)
            Status := Prev_Status;
        (* Ho un movimento da completare: Attendo cinghie operative *)
        ELSIF BeltsFeed.Status=BLT_OPERATING AND Belts.Status=BLT_ENABLED THEN
            dlog( Txt:='fbShift: BeltsFeed ready, resuming Status %d (Move=%ld)', Lvl:=4, Val1:=TO_DINT(Prev_Status), Val2:=Qx/1E3 );
            Belts.MasterTgt := Qx;
            Belts.Cmd := CMD_MOVETO; (* Riprendi il movimento precedente *)
            Status := Prev_Status;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_BCK_FEED : (* Moving remnant to feed module *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Rilevo arrivo in quota o problemi di movimentazione *)
        ELSIF Belts.Cmd<CMD_MOVETO THEN
            IF Belts.Master_Arrived THEN
                dlog( Txt:='fbShift: !! IFC_BUF_BEGIN not found after %ld mm', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
            ELSE
                dlog( Txt:='fbShift: !! Belts stopped while inserting Remn', Lvl:=2 );
            END_IF;
            Status := STS_ERROR;
        (* Rilevo eventi fotocellule *)
        ELSIF Belts.Status=BLT_OPERATING THEN
            vqShift_GlassX := StartedX + Belts.Master_CurrPos; (* Keep track of fwd edge position *)
            IF vnShift_Cmd=SHFCMD_INS_REMN THEN vqRemn_X := vqShift_GlassX; END_IF;

            (* Alzo subito cinghie carico per guadagnare tempo
            IF BeltsFeed.Allow THEN
                vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED;
            END_IF; *)

            (* Rilevo basculamento del carico *)
            IF NOT vb[ivbAtRest+ID_FEED_TILT] THEN
                (* Mi assicuro di rallentare *)
                IF Belts.MasterSpd>vqBelts_SlowSpd THEN
                    Belts.MasterSpd := vqBelts_SlowSpd;
                END_IF;

                (* Se quasi al limite mi fermo? * )
                IF (vqShift_GlassX-vqShift_GlassWidth)<(vqFeed_Xend-500E3) THEN
                    dlog( Txt:='fbShift: !! Feed tilted', Lvl:=2 );
                    SET_MSG(MSG_FEEDTILT_TILTED,'MSG_FEEDTILT_TILTED',0);
                    Status := STS_ERROR;
                END_IF; *)
            END_IF;

            (* Rilevo raggiungimento del bordo indietro del tavolo di carico *)
            IF FeedOutBack AND BeltsFeed.Status=BLT_OPERATING AND BeltsFeed.CurrSpd<0 THEN
                dlog( Txt:='fbShift: !! Reached IFC_FEED_BEGIN', Lvl:=2 );
                SET_MSG(REQ_STACKFULL,'REQ_STACKFULL',0);
                Status := STS_ERROR;
            (* Rilevo impegno della fotocellula prossimità zona accumulo per coinvolgere le cinghie del carico *)
            ELSIF fcBufBegin.q THEN
                dlog( Txt:='fbShift: IFC_BUF_BEGIN on after %ld mm', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
                (* Mi fermo e aggancio le cinghie del carico *)
                (* Delta := vqXph_FeedNearEnd - vqXph_BufBegin - vqShift_GlassWidth; (* Il movimento incrementale successivo? *)
                Belts.Cmd := CMD_ACTIVATE; (* Fermati con cinghie alte *)
                QueuedCmd := vnShift_Cmd; (* Ridai il comando attuale dopo lo stop *)
                Status := STS_STOPPING;
            (* Rilevo mancato raggiungimento di IFC_BUF_BEGIN *)
            ELSIF fcFeedEnd.rise AND BeltsFeed.Status<BLT_OPERATING THEN
                dlog( Txt:='fbShift: !! Read IFC_FEED_END before IFC_BUF_BEGIN, aborting', Lvl:=1 );
                Status := STS_ERROR;
            (* Rilevo disimpegno dello stacco per liberare le sue cinghie *)
            ELSIF fcDtchBegin.fall_delayed THEN
                dlog( Txt:='fbShift: IFC_DTCH_BEGIN freed after %ld mm', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
                Belts.SlaveBelts := Belts.SlaveBelts & NOT BIT_BELTS_DTCH; (* Stacco al volo l'inseguimento *)
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_INS_FEED : (* Inserting remnant in feed module *)
        (* In sostanza è:
           .Con polmone è un movimento indietro del carico per far entrare la lastra
           .Senza polmone è un posizionamento indietro dove non ci si aspettano
            lastre accodate avanti (posso controllare fotocellule)
        *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Rilevo arrivo in quota o problemi di movimentazione *)
        ELSIF Belts.Cmd<CMD_MOVETO THEN
            (* Comando movimento terminato! *)
            (* Può essere che se non arrivato sia in 'CMD_ACTIVATE' *)
            Belts.Cmd := CMD_STOP;

            IF ABS(Belts.MasterTgt - Belts.Master_CurrPos)<=vqShift_TargetTol THEN
                (* Nota: Mi aspetto che vqShift_GlassX == TargetX *)
                (* Visto che non mi aspetto lastre avanti, posso controllare fotocellule *)
                IF TargetX < (vqDtch_CurrX + vqDXph_DtchBegin) AND fcDtchBegin.q THEN
                    dlog( Txt:='fbShift: !! INS_FEED: IFC_DTCH_BEGIN at %ld (belts at %ld)', Lvl:=2, Val1:=vqShift_GlassX/1E3, Val2:=Belts.Master_CurrPos/1E3 );
                    Status := STS_ERROR;
                ELSIF TargetX < vqXph_FeedEnd AND fcFeedEnd.q THEN
                    dlog( Txt:='fbShift: !! INS_FEED: IFC_FEED_END at %ld (belts at %ld)', Lvl:=2, Val1:=vqShift_GlassX/1E3, Val2:=Belts.Master_CurrPos/1E3 );
                    Status := STS_ERROR;
                ELSE
                    (* Tutto ok *)
                    (* vbExtractDone := FALSE; (* Nah... *)
                    dlog( Txt:='fbShift: Inserted at %ld (belts at %ld)', Lvl:=4, Val1:=vqShift_GlassX/1E3, Val2:=Belts.Master_CurrPos/1E3 );
                    vnShift_Seq := SEQ_DONE;
                    Status := STS_STOPPING;
                END_IF;
                (* vnBelts_Act := 0; (* Un po' radicale: assicuro TUTTE le cinghie disattivate *)
            ELSE
                dlog( Txt:='fbShift: !! Belts stopped while inserting', Lvl:=2 );
                Status := STS_ERROR;
            END_IF;
        (* Rilevo eventi fotocellule *)
        ELSIF Belts.Status=BLT_OPERATING THEN
            vqShift_GlassX := StartedX + Belts.Master_CurrPos; (* Keep track of fwd edge position *)
            IF vnShift_Cmd=SHFCMD_INS_REMN THEN vqRemn_X := vqShift_GlassX; END_IF;

            (* Rilevo raggiungimento del bordo indietro del tavolo di carico *)
            IF FeedOutBack AND BeltsFeed.CurrSpd<0 THEN
                dlog( Txt:='fbShift: !! Ins reached IFC_FEED_BEGIN', Lvl:=2 );
                SET_MSG(REQ_STACKFULL,'REQ_STACKFULL',0);
                Status := STS_ERROR;
            (* Rilevo disimpegno dello stacco per liberare le sue cinghie *)
            ELSIF fcDtchBegin.fall_delayed THEN
                dlog( Txt:='fbShift: IFC_DTCH_BEGIN freed after %ld mm', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
                Belts.SlaveBelts := Belts.SlaveBelts & NOT BIT_BELTS_DTCH; (* Stacco al volo l'inseguimento *)
            (* Rilevo disimpegno del polmone per aggiustare la quota di arrivo *)
            ELSIF fcBufBegin.fall_delayed THEN
                dlog( Txt:='fbShift: IFC_BUF_BEGIN freed after %ld mm', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
                Belts.SlaveBelts := Belts.SlaveBelts & NOT BIT_BELTS_BUF; (* Stacco al volo l'inseguimento *)
                vbShift_AlmostIns := TRUE; (* Quasi inserita *)
                BeltsFeed.Cmd.MaxSpeed := vqBelts_SlowSpd;
                (* Aggiusto la posizione *)
                vqShift_GlassX := vqXph_BufBegin; (* Aggiorno posizione bordo avanti *)
                StartedX := vqShift_GlassX - Belts.Master_CurrPos;
                (* Cambio target se fattibile *)
                Delta := TargetX - vqShift_GlassX; (* Quanto mi manca ad arrivare *)
                IF Delta < (vq[ivqAx_StopSpace+Belts.MasterIdx-1]-vqAx_StopSpaceTol) (* Nota: Sono tutti e due negativi, sto andando indietro *)
                   AND VN_AX(iVN_AX_FASE,Belts.MasterIdx)<AFS_POS_DEC THEN
                    Belts.MasterTgt := Belts.Master_CurrPos + Delta;
                (* ELSE dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=Belts.MasterTgt/1E3, Val2:=(Belts.Master_CurrPos + Delta)/1E3 ); *)
                END_IF;
            (* Eventuale aggiustamento su fotocellula del carico *)
            ELSIF fcFeedEnd.fall_delayed AND vbShift_AlmostIns THEN
                dlog( Txt:='fbShift: IFC_FEED_END freed after %ld mm', Lvl:=4, Val1:=Belts.Master_CurrPos/1E3 );
                BeltsFeed.Cmd.MaxSpeed := vqBelts_SlowSpd;
                (* Aggiusto la posizione *)
                vqShift_GlassX := vqXph_FeedEnd; (* Aggiorno posizione bordo avanti *)
                StartedX := vqShift_GlassX - Belts.Master_CurrPos;
                (* Cambio target se fattibile *)
                Delta := TargetX - vqShift_GlassX; (* Quanto mi manca ad arrivare *)

                IF Cb.Emulated THEN
                    (* Se non c'è polmone ho probabilmente già inserito? *)
                    QueuedCmd := CMD_STOP;
                    Belts.Cmd := CMD_STOP;
                    vnShift_Seq := SEQ_DONE;
                    Status := STS_STOPPING;
                ELSIF Delta < (vq[ivqAx_StopSpace+Belts.MasterIdx-1]-vqAx_StopSpaceTol) (* Nota: Sono tutti e due negativi, sto andando indietro *)
                   AND VN_AX(iVN_AX_FASE,Belts.MasterIdx)<AFS_POS_DEC THEN
                    Belts.MasterTgt := Belts.Master_CurrPos + Delta;
                (* ELSE dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=Belts.MasterTgt/1E3, Val2:=(Belts.Master_CurrPos + Delta)/1E3 ); *)
                END_IF;
            END_IF;

            (* Rallento se sono verso la fine del modulo di carico *)
            IF IFC_FEED_NEARBEGIN THEN
                Belts.MasterSpd := vqBelts_SlowSpd;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_MOVEALL_FWD : (* Manual fwd movement in progress *)
        IF vnShift_Cmd<>SHFCMD_MANUALFWD THEN
            (* dlog( Txt:='fbShift: Manual fwd stop', Lvl:=4 ); *)
            Belts.Cmd := 0; (* Ferma il movimento e scendi *)
            Status := STS_STOPPING;
        ELSIF fcOutzoneEnd.rise THEN
            dlog( Txt:='fbShift: ! Stop on IFC_OUTZONE_END', Lvl:=5 );
            Belts.Cmd := 0; (* Ferma il movimento e scendi *)
            Status := STS_STOPPING;
        (* Modulo la velocità in base a fotocellule *)
        ELSIF fcOutzoneEnd.q OR fcOutzoneNearEnd.q THEN
            Belts.MasterSpd := MIN(Belts.MasterSpd,vqBelts_SlowSpd);
        ELSIF fcDtchLast.q OR fcOutzoneBegin.q THEN
            (* Modulo la velocità in base allo stato dei piedini di riscontro *)
            Belts.MasterSpd := MIN(Belts.MasterSpd,SEL(vnAlgnBlocks_Sts>=TS_GOINGON, vqBelts_DragSpd, vqBelts_SlowSpd));
            (* IF vnAlgnBlocks_Sts>=TS_GOINGON THEN
                dlog( Txt:='fbShift: !! Manual fwd stopped for algn blocks up', Lvl:=5 );
                Belts.Cmd := 0;
                Status := STS_STOPPING;
            END_IF; *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_MOVEALL_BCK : (* Manual bck movement in progress *)
        IF vnShift_Cmd<>SHFCMD_MANUALBCK THEN
            (* dlog( Txt:='fbShift: Manual bck stop', Lvl:=4 ); *)
            Belts.Cmd := 0; (* Ferma il movimento e scendi *)
            Status := STS_STOPPING;
        (* Fermati al fronte dell'estremo indietro *)
        ELSIF fcFeedBegin.rise THEN
            dlog( Txt:='fbShift: ! Stop on IFC_FEED_BEGIN', Lvl:=5 );
            Belts.Cmd := 0; (* Ferma il movimento e scendi *)
            Status := STS_STOPPING;
        (* Se l'estremo indietro è occupato, non permettere di andare indietro *)
        ELSIF FeedOutBack AND NOT vbShift_ForceMan THEN
            Belts.Cmd := 0; (* Ferma il movimento e scendi *)
            Status := STS_STOPPING;
        (* Rallento se sono verso la fine
           Però in caso di rulliera potrebbe darmi fastidio, quindi non lo faccio se c'è caricatrice *)
        ELSIF (FeedOutBack OR IFC_FEED_NEARBEGIN) AND vnLoader_Type<=0 THEN
            Belts.MasterSpd := MIN(Belts.MasterSpd,vqBelts_SlowSpd);
        END_IF;

    (* ------------------------------------------------------------------- *)
    SHF_DRIVEN : (* Externally driven *)
        IF vnShift_Cmd<>SHFCMD_DRIVE THEN
            Belts.Cmd := 0; (* Ferma il movimento e scendi *)
            Status := STS_STOPPING;
        ELSE
            (* Pilota il servizio esternamente *)
            Belts.MasterIdx := vnBelts_MasterIdx;
            Belts.MasterTgt := vqBelts_MasterTgt;
            Belts.MasterSpd := vqBelts_MasterSpd;
            Belts.MasterAcc := vnBelts_MasterAcc;
            Belts.SlaveBelts := vnBelts_SlaveBelts;
            Belts.Cmd := vnBelts_Cmd;
            (* Eventuali monitors del servizio?
            vbXXX := Belts.Master_Arrived;
            vqXXX := Belts.Master_CurrPos *)
            (* Controllo fotocellula carico indietro *)
            IF FeedOutBack AND Ca.MovingBck THEN (* AND (Belts.SlaveBelts & BIT_BELTS_FEED=<>0 *)
                SET_MSG(REQ_STACKFULL,'REQ_STACKFULL',0);
                ThrowEmg(Idx:=EMG_DANGER, Txt:='IFC_FEED_BEGIN');
                vnShift_Cmd := CMD_STOP;
            END_IF;
        END_IF;

    (* ------------------------------------------------------------------- *)
    STS_MOVING : (* Generic move *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShift_Cmd=CMD_STOP THEN
            Status := STS_ERROR;
        (* Rilevo movimento finito *)
        ELSIF Belts.Cmd=CMD_STOP THEN
            (* Comando movimento terminato! *)
            IF Belts.Master_Arrived THEN
                vnShift_Seq := SEQ_DONE;
                Status := STS_STOPPING;
            ELSE
                dlog( Txt:='fbShift: !! Not arrived %ld != %ld mm', Lvl:=2, Val1:=vqShift_GlassX/1E3, Val1:=TargetX/1E3 );
                Status := STS_ERROR;
            END_IF;
        ELSIF Belts.Status=BLT_OPERATING THEN
            vqShift_GlassX := StartedX + Belts.Master_CurrPos;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_STOPPING : (* Wait belts stopped and down *)
        (* Comando stop già dato, attendo gestore movimentazione *)
        IF (Belts.Cmd=CMD_STOP AND Belts.Status=STS_IDLE) OR
           (Belts.Cmd=CMD_ACTIVATE AND Belts.Status=BLT_ENABLED) THEN
            (* Cinghie ferme: potrebbero però essere ancora alte *)

            (* Aggiorna la posizione della lastra dopo lo stop *)
            IF vnShift_Cmd=SHFCMD_BACK_REMN THEN (* TODO 2: Potrei farlo anche in altri casi? *)
                (* Questo dà problemi con cinghie emulate? *)
                vqShift_GlassX := StartedX + Belts.Master_CurrPos; (* Keep track of fwd edge position *)
                dlog( Txt:='fbShift: Sheet stopped at %ld=%ld+%ld mm', Lvl:=3, Val1:=vqShift_GlassX/1E3, Val2:=StartedX/1E3, Val3:=Belts.Master_CurrPos/1E3 );
            END_IF;

            (* Se cinghie alte e non c'è un comando in coda, le abbasso *)
            IF Belts.Status=BLT_ENABLED AND QueuedCmd=0 THEN
                dlog( Txt:='fbShift: ! Belts off, no queued cmds', Lvl:=2 );
                Belts.Cmd := 0;
            END_IF;

            (* Assicuro cinghie carico basse se stavo inserendo *)
            IF vnShift_Cmd=SHFCMD_INS_REMN AND Belts.MasterIdx=Ca.Idx THEN
                vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_FEED; (* BeltsFeed.Cmd.Activate := FALSE; *)
            END_IF;

            vnShift_Cmd := QueuedCmd; (* Comando successivo/Reset comando *)
            Status := STS_IDLE;
        END_IF;


    (* ------------------------------------------------------------------- * )
    STS_WAITAVAIL : (* Wait belts available * )
        IF (Belts.ActiveBelts & NeededBelts)=NeededBelts THEN
            Status := Prev_Status;
        END_IF; *)


    (* ------------------------------------------------------------------- *)
    STS_IDLE : (* Doing nothing *)
        IF Allow THEN
            (* Rispondi ai comandi *)
            IF vnShift_Cmd<>0 THEN
                vnShift_Seq := SEQ_START; (* Resetto risultato *)
                (* Reset stati *)
                QueuedCmd := CMD_STOP;
                RequiredVents := 0;
                vbShift_AlmostThere := FALSE;
                vqShift_MetPhCells := 0;
                (* Calcolo grandezze derivate *)
                Shift_Mass := fnGlassMass(vqShift_GlassWidth, vqShift_GlassYtop-vqShift_GlassYbtm, vqGlass_Thckn);

                (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
                (* Comando posizionamento lastra *)
                IF vnShift_Cmd=SHFCMD_PLACE_SHEET THEN
                    dlog( Txt:='fbShift: Place sheet %ldx%ld from %ld to %ld mm', Lvl:=4, Val1:=vqShift_GlassWidth/1E3, Val2:=(vqShift_GlassYtop-vqShift_GlassYbtm)/1E3, Val3:=vqShift_GlassX/1E3, Val4:=vqShift_TargetX/1E3 );

                    (* Vedi se è davvero necessario muoversi *)
                    IF ABS(vqShift_TargetX-vqShift_GlassX) < vqShift_TargetTol THEN
                        dlog( Txt:='! Sheet already at xfwd=%ld', Lvl:=2, Val1:=vqShift_GlassX/1E3 );
                        vnShift_Cmd := CMD_STOP; (* Eat command *)
                        vnShift_Seq := SEQ_DONE;
                        RETURN;
                    END_IF;

                    (* Stima posizione X lastra in base a stato fotocellule *)
                    IF vqShift_GlassX=NO_POS_UM THEN
                        (* Posizione iniziale non data, la decido io in base a fotocellule *)
                        GuessSheetPos( W:=vqShift_GlassWidth );
                        vqShift_GlassX := GuessSheetPos.Xfwd;
                    ELSE
                        (* Notifico incoerenze sulla posizione iniziale data *)
                        IF fcDtchLast.q AND vqShift_GlassX<(vqDtch_CurrX+vqDXph_DtchLast) THEN
                            dlog( Txt:='! Xfwd=%ld but on IFC_DTCH_LAST (%ld)', Lvl:=1, Val1:=vqShift_GlassX/1E3, Val2:=(vqDtch_CurrX+vqDXph_DtchLast)/1E3 );
                            (* NOTA: Farà manovra di disimpegno fotocellula *)
                        ELSIF fcDtchBegin.q AND vqShift_GlassX<(vqDtch_CurrX+vqDXph_DtchBegin) THEN
                            dlog( Txt:='! Xfwd=%ld but on IFC_DTCH_BEGIN (%ld)', Lvl:=1, Val1:=vqShift_GlassX/1E3, Val2:=(vqDtch_CurrX+vqDXph_DtchBegin)/1E3 );
                        ELSIF fcBufBegin.q AND vqShift_GlassX<vqXph_BufBegin THEN
                            dlog( Txt:='! Xfwd=%ld but on IFC_BUF_BEGIN (%ld)', Lvl:=1, Val1:=vqShift_GlassX/1E3, Val2:=vqXph_BufBegin/1E3 );
                        END_IF;
                    END_IF;

                    (* Assunzione posizione Y lastra
                    IF vqShift_GlassYbtm>=vqShift_GlassYtop THEN
                        vqShift_GlassYbtm := vqYo_SheetFeed;
                        vqShift_GlassYtop := vqShift_GlassYbtm + 1000E3;
                    END_IF; *)

                    (* Controllo precondizioni/requisiti per chiamata lastra *)
                    IF (vqShift_GlassYtop - vqShift_GlassYbtm)<1E3 THEN
                        dlog( Txt:='!! Invalid y=%ld|%ld', Lvl:=1, Val1:=vqShift_GlassYbtm/1E3, Val2:=vqShift_GlassYtop/1E3 );
                        Status := STS_ERROR;
                    ELSIF vqGlass_Thckn > vqShift_MaxGlassThckn THEN
                        dlog( Txt:='!! Too thick %ld>%ld', Lvl:=1, Val1:=vqGlass_Thckn/1E3, Val2:=vqShift_MaxGlassThckn/1E3 );
                        Status := STS_ERROR;
                    ELSIF vqShift_GlassX=NO_POS_UM THEN
                        dlog( Txt:='!! Undeclared position', Lvl:=1 );
                        Status := STS_ERROR;
                    ELSIF vqShift_TargetX > vqX_OutZoneEnd THEN
                        dlog( Txt:='!! Target %ld beyond OutZone (%ld mm)', Lvl:=1, Val1:=vqShift_TargetX/1E3, Val2:=vqX_OutZoneEnd/1E3 );
                        Status := STS_ERROR;
                    (* Voglio tutto libero a valle se sto estraendo dal carico *)
                    ELSIF vqShift_GlassX<vqDtch_Xbegin AND NOT vbExtractDone AND (fcDtchBegin.q OR fcDtchLast.q) AND NOT vbFloatStripesBreak THEN
                        dlog( Txt:='!! Wont extract with glass on dtch', Lvl:=1 );
                        SET_MSG(REQ_CLEARPROCAREA,'REQ_CLEARPROCAREA',0);
                        Status := STS_ERROR;
                    (* Voglio lo stacco in parcheggio *)
                    ELSIF NOT vb[ivbAtRest+ID_DTCH] THEN
                        (* Comanda stacco in park se fermo *)
                        IF vnDtch_Cmd=CMD_STOP THEN
                            dlog( Txt:='Parking Dtch', Lvl:=5 );
                            vnDtch_Cmd := CMD_PARK;
                        END_IF;
                        (* Se lo stacco sta andando in parcheggio, attendi *)
                        IF vnDtch_Cmd=CMD_PARK THEN
                            Status := SHF_WAIT_DTCH;
                        ELSE
                            dlog( Txt:='Dtch not in park', Lvl:=3 );
                            SET_MSG(MSG_NOTPARKED,'MSG_NOTPARKED Dtch',0);
                            Status := STS_ERROR;
                        END_IF;
                    (* Se sto già impegnando l'ultima fotocellula e non è possibile credere alla
                       posizione dichiarata 'vqShift_GlassX', faccio manovra di disimpegno fotocellula *)
                    ELSIF vqShift_GlassX<(vqDtch_CurrX+vqDXph_DtchLast) AND fcDtchLast.q THEN
                        dlog( Txt:='! Must free IFC_DTCH_LAST', Lvl:=3 );
                        (* Vado indietro per disimpegnare la fotocellula *)
                        (* Il Master sono le cinghie stacco 'BeltsDtch', BIT_BELTS_DTCH, Cs.Idx *)
                        Belts.MasterIdx := Cs.Idx;
                        Cs.Incremental := TRUE;
                        (* Vedo se devo subito coinvolgere il carico *)
                        IF Cb.Emulated OR  (* ...Non esistono le cinghie polmone *)
                           fcBufBegin.q OR (* ...Fotocellula inizio polmone attivata *)
                           (fcFeedEnd.q AND (* ...Fotocellula fine carico attivata -rischio di collisione- *)
                            (vnComboFloat_Type=0 OR I_FLOAT_READY)) THEN (* A meno che non ci sia una combinata attiva *)
                            dlog( Txt:='! Also BeltsFeed', Lvl:=3 );
                            Belts.SlaveBelts := BIT_BELTS_BUF OR BIT_BELTS_FEED;
                        ELSE
                            Belts.SlaveBelts := BIT_BELTS_BUF;
                        END_IF;
                        IF NOT vbShift_NoRolls THEN
                            (* Occhio alla sicurezza (fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY) OR OutZone.Xbusy>vqX_AlgnBeltsEnd *)
                           Belts.SlaveBelts := Belts.SlaveBelts OR BIT_ROLLS_ALGN;
                        END_IF;

                        (* Non mi aspetto di andare più indietro della dimensione lastra *)
                        StartedX := (vqDtch_CurrX+vqDXph_DtchLast) + vqShift_GlassWidth;
                        TargetX := StartedX - vqShift_GlassWidth;
                        Belts.MasterTgt := TargetX - StartedX; (* Movimento incrementale *)

                        (* Comando movimento per disimpegnare la fotocellula stacco e procedo *)
                        IF vbFeat_AlgnHasBelts THEN
                            Belts.MasterSpd := vqBelts_BckSpd;
                            Belts.MasterAcc := 100; (* [%] *)
                        ELSE
                            (* Eventuale cuscino aria necessario (cinghie indietro per disimpegno fotocellula stacco) *)
                            SelectProdVents( Xfwd:=vqShift_GlassX, Ytop:=vqShift_GlassYtop );
                            RequiredVents := SelectProdVents.Mask;
                            IF Cs.Emulated THEN RequiredVents := RequiredVents OR BIT_VENT_DTCH; END_IF;
                            (* Accendo aria *)
                            vnVents_Cmd := vnVents_Cmd OR RequiredVents;

                            Belts.MasterSpd := vqBelts_DragSpd;
                            Belts.MasterAcc := vnBelts_DragAcc; (* [%] *)
                        END_IF;
                        Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                        Status := SHF_BCK_OFFDTCH;
                        (* Nota: Il comando di chiamata verrà ridato dopo grazie a 'QueuedCmd' *)
                    ELSE
                        (* Ok, ci sono quasi i requisiti generali per la chiamata... *)
                        StartedX := vqShift_GlassX; (* Mi ricordo da dove parto *)
                        TargetX := vqShift_TargetX; (* Potrebbe variare se devo prima approcciare lo stacco *)
                        Stop_On_Dtch := FALSE; (* Default: Non bisogna fermarsi sullo stacco *)
                        Need_Dtch_Fwd := FALSE; (* Default: Non serve lo stacco avanti *)

                        (* -Distinguo se devo andare avanti o indietro- *)
                        IF StartedX <= TargetX THEN
                            dlog( Txt:='Sheet in %ld fwd to %ld mm', Lvl:=5, Val1:=vqShift_GlassX/1E3, Val2:=vqShift_TargetX/1E3 );

                            (* -Traslazione avanti-
                               Siamo qui tipicamente quando parte un passo per tagliare
                               una lastra sul carico o una rimanenza sul polmone,
                               ma potremmo essere qui anche a seguito di una rotazione
                               riscontri, nel caso in cui il taglio era soprea il punto di presa *)

                            (* Controllo limiti passaggio tra i moduli *)
                            Delta := SEL(vqShift_GlassX<0, vqShift_PassMinWidth, vqShift_CrossMinWidth );
                            IF vqShift_GlassWidth<Delta THEN
                                dlog( Txt:='!! Narrow W=%ld<%ld', Lvl:=1, Val1:=vqShift_GlassWidth/1E3, Val2:=Delta/1E3 );
                                Status := STS_ERROR;
                                RETURN;
                            END_IF;

                            (* Default: vado avanti a velocità normale *)
                            Belts.MasterSpd := vqBelts_FwdSpd;
                            Belts.MasterAcc := 100; (* [%] *)

                            (* Più veloce se devo estrarre? *)
                            (* IF NOT vbExtractDone AND vnStackedSheets>0 THEN Belts.MasterSpd := vqBelts_FwdSpd; *)

                            (* Più lento se il cambio target sull'ultima fotocellula può fallire:
                               .L'unica fotocellula che incontro è l'ultima (quindi posizione non nota)
                               .Posizione di arrivo pericolosamente vicina all'ultima fotocellula (riscontro a zero)
                                <stop-space> > (TargetX - (vqDtch_CurrX+vqDXph_DtchLast)) *)
                            Delta := fnRampSpace(V:=Belts.MasterSpd, ta:=vq[ivqAx_DecTime+Belts.MasterIdx-1], p:=vnBelts_VelPPd);
                            IF fcDtchBegin.q AND NOT fcDtchLast.q AND TargetX>0 AND Delta>=(TargetX - (vqDtch_CurrX+vqDXph_DtchLast)) THEN
                                Belts.MasterSpd := Belts.MasterSpd / 2;
                            END_IF;

                            (* Finirò sul modulo riscontri? *)
                            IF vqShift_TargetX > vqX_CutZoneP THEN
                                (* Vedo le zone aria del riscontro che mi servono (cinghie avanti) *)
                                SelectProdVents( Xfwd:=vqShift_TargetX, Ytop:=vqShift_GlassYtop );
                                RequiredVents := SelectProdVents.Mask;
                                (* Nota: in certi casi se non accendo l'aria dello stacco/polmone
                                         la lastra tende ad "impuntarsi" sulla gomma dei riscontri! *)
                                (* RequiredVents := RequiredVents OR MSK_VENT_REMN; *)
                                vbVents_MotorsOn := TRUE; (* Assicuro ventilatori pronti *)
                            ELSE
                                (* Non mi servirà alcuna aria *)
                                RequiredVents := 0;
                            END_IF;

                            (* Se la lastra è già appoggiata sui riscontri:
                                ▸Le cinghie stacco/rulli potrebbero scivolare di centimetri, sarebbe
                                  bene attendere il cuscino aria (vbAirCushionReady)
                                ▸La salita rulli potrebbe peggiorare il grip sulle cinghie stacco
                                 e aumentare l'attrito sul lato riscontri se c'è tanto vetro a valle
                            *)
                            IF StartedX>(vqDtch_CurrX+vqDXph_DtchLast) THEN (* StartedX>vqX_CutZoneP *)
                                (* Parte della lastra è oltre all'ultima fotocellula,
                                   tipicamente parte del vetro è già sul modulo di riscontro *)

                                IF fcDtchLast.q THEN
                                    (* Non mi aspetto di incontrare fotocellule quindi le ignoro tutte,
                                       in modo che lastre accodate o fronti spuri non diano problemi *)
                                    vqShift_MetPhCells := IDX_FC_DTCH_LAST;
                                END_IF;

                                IF vbFeat_AlgnHasBelts THEN
                                    (* Riscontro dotato di cinghie *)
                                    (* Se lastra stretta o senza grip sulle cinghie... *)
                                    IF vqShift_GlassWidth<vqShift_GoodWidth OR
                                       ( (vqShift_GlassX-vqX_AlgnBeltsBegin) < vqBeltsAlgn_MinGripDX AND
                                         (vqX_RemnBeltsEnd-(vqShift_GlassX-vqShift_GlassWidth)) < vqBelts_MinGripDX ) THEN
                                        (* Avvicino lo stacco *)
                                        Need_Dtch_Fwd := TRUE;
                                        (* Meglio andare piano *)
                                        Belts.MasterAcc := Belts.MasterAcc/2;
                                        Belts.MasterSpd := vqBelts_SlowSpd;
                                    (* Se non potrò usare le cinghie riscontro... *)
                                    ELSIF OutZone.Xbusy<=vqX_AlgnBeltsEnd OR NOT vbShift_NoRolls THEN
                                        (* ...Meglio andare piano *)
                                        Belts.MasterSpd := vqBelts_DragSpd;
                                        Belts.MasterAcc := vnBelts_DragAcc; (* [%] *)
                                    END_IF;
                                ELSE
                                    (* Riscontro con rulli o nulla *)
                                    (* Meglio andare piano *)
                                    Belts.MasterSpd := vqBelts_DragSpd;
                                    Belts.MasterAcc := vnBelts_DragAcc; (* [%] *)

                                    (* Se sono coinvolti solo i rulli riscontro potrebbero stortare
                                       la lastra, cerco di migliorare le cose con rampe lunghe *)
                                    IF NOT Cr.Emulated AND (vqShift_GlassX-vqShift_GlassWidth)>vqX_RemnBeltsEnd THEN
                                        (* Sono coinvolti i soli rulli *)
                                        Belts.MasterAcc := vnBelts_DragAcc/2;
                                    END_IF;

                                    (* Se lastra stretta o senza grip sulle cinghie... *)
                                    IF vbFeat_DtchHasBelts AND
                                       (vqShift_GlassWidth<vqShift_GoodWidth OR
                                       (vqX_RemnBeltsEnd-(vqShift_GlassX-vqShift_GlassWidth)) < vqBelts_MinGripDX ) THEN
                                        (* Avvicino lo stacco *)
                                        Need_Dtch_Fwd := TRUE;
                                        (* Meglio andare piano *)
                                        Belts.MasterAcc := vnBelts_DragAcc/2;
                                        Belts.MasterSpd := vqBelts_SlowSpd;
                                    END_IF;
                                END_IF;

                                vbShift_AlmostThere := TRUE; (* Sono quasi arrivato *)
                            ELSE
                                (* La lastra non ha ancora superato le fotocellule,
                                   sicuramente non appoggia al modulo di riscontro *)

                                (* Potrei ignorare le fotocellule che non mi aspetto di incontrare,
                                   in modo che lastre accodate o fronti spuri non diano problemi *)
                                IF vbShift_PhIgnorePrev OR Cb.Emulated THEN
                                    IF fcDtchLast.q  AND  vqShift_GlassX > (vqDtch_CurrX+vqDXph_DtchLast) THEN
                                        vqShift_MetPhCells := IDX_FC_DTCH_LAST;
                                    ELSIF fcDtchBegin.q  AND  vqShift_GlassX > (vqDtch_CurrX+vqDXph_DtchBegin) THEN
                                        vqShift_MetPhCells := IDX_FC_DTCH_BEGIN;
                                    ELSIF fcBufBegin.q  AND  vqShift_GlassX > vqXph_BufBegin THEN
                                        vqShift_MetPhCells := IDX_FC_BUF_BEGIN;
                                    ELSIF fcFeedEnd.q  AND  vqShift_GlassX > vqXph_FeedEnd THEN
                                        vqShift_MetPhCells := IDX_FC_FEED_END;
                                    (* ELSIF fcFeedNearEnd.q  AND  vqShift_GlassX > vqXph_FeedNearEnd THEN
                                        vqShift_MetPhCells := IDX_FC_FEED_NEAREND; *)
                                    ELSE
                                        vqShift_MetPhCells := IDX_FC_FEED_BEGIN;
                                    END_IF;
                                END_IF;

                                (* Se pezzo stretto, per passarlo ai riscontri devo avvicinare lo stacco? *)
                                IF vqShift_GlassWidth<vqShift_GoodWidth AND NOT Cs.Emulated
                                   AND (vqShift_GlassX<vqX_CutZoneP) AND vqShift_TargetX>(vqX_CutZoneP+10E3) THEN
                                    (* Prima lo porto sul bordo dello stacco *)
                                    Stop_On_Dtch := TRUE; (* Place forward on Dtch *)
                                    TargetX := (vqDtch_CurrX+vqDXph_DtchLast) + 20E3; (* vqDtch_CurrX - 20E3 *)
                                    dlog( Txt:='Placing narrow on Dtch at %ld mm', Lvl:=5, Val1:=TargetX/1E3 );
                                    (* Se molto vicino è meglio andare piano per stop asincrono su fotocellula *)
                                    IF fcDtchBegin.q OR (vqShift_GlassX > (vqDtch_CurrX+vqDXph_DtchBegin)) THEN
                                        Belts.MasterSpd := vqBelts_SlowSpd;
                                    END_IF;
                                END_IF;

                                (* Sono quasi arrivato se sono già sulle fotocellule dello stacco *)
                                vbShift_AlmostThere := fcDtchLast.q OR fcDtchBegin.q;
                            END_IF; (* Appoggia o meno al modulo di riscontro *)

                            (* Se ci sono quasi accendo subito l'aria che serve *)
                            IF (vbShift_AlmostThere OR vqShift_GlassX>-300E3) AND NOT Stop_On_Dtch THEN
                                vnVents_Cmd := vnVents_Cmd OR RequiredVents;
                            END_IF;

                            (* Data la posizione iniziale, non mi aspetto di muovermi più di così: *)
                            Belts.MasterTgt := TargetX - StartedX; (* Movimento incrementale *)
                            dlog( Txt:='Belts.MasterTgt=%ld-%ld=%ld mm', Lvl:=6, Val1:=TargetX/1E3, Val2:=StartedX/1E3, Val3:=Belts.MasterTgt/1E3 );

                            (* Il Master sono le cinghie stacco 'BeltsDtch', BIT_BELTS_DTCH, Cs.Idx
                               perché sono sempre coinvolte: *)
                            Belts.MasterIdx := Cs.Idx;
                            Cs.Incremental := TRUE;
                            (* Vediamo quali cinghie seguono *)
                            (* Si potrebbe decidere che cinghie servono e poi attenderle in STS_WAITAVAIL *)
                            Belts.SlaveBelts := SEL(Cb.Emulated, BIT_BELTS_BUF, 0);
                            (* Le cinghie del carico sono coinvolte se: *)
                            IF Cb.Emulated OR (* ...Non esistono le cinghie polmone *)
                               NOT vbExtractDone OR (* ...Devo estrarre dal carico *)
                               (* fcBufBegin.q OR (* ...Fotocellula inizio polmone attivata *)
                               (vqShift_GlassX-vqShift_GlassWidth) < vqFeed_Xend THEN (* ...Il bordo indietro della lastra coinvolge il carico *)
                                IF vb[ivbAtRest+ID_FEED_TILT] THEN
                                    (* Il carico non è basculato, le cinghie carico dovrebbero essere disponibili *)
                                    dlog( Txt:='Also BeltsFeed', Lvl:=5 );
                                    Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED;
                                END_IF;
                            END_IF;
                            (* Devo coinvolgere subito i rulli/cinghie su riscontro? *)
                            IF TargetX>vqX_AlgnBeltsBegin AND (* Devo andare abbastanza avanti *)
                               OutZone.Xbusy>vqX_AlgnBeltsEnd AND (* Non voglio alzarli sotto un pezzo da prelevare *)
                               NOT vbShift_NoRolls (* OR vbFeat_AlgnHasBelts *) THEN (* A volte non voglio i rulli (es. consegnando monolitico da aprire) *)
                                (* Occhio alla sicurezza (fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY) *)
                                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_ROLLS_ALGN;
                            ELSE
                                dlog( Txt:='! No RollsAlgn', Lvl:=5 );
                                IF vbShift_NoRolls THEN
                                    (* dlog( Txt:='fbShift: ! Excluding rolls', Lvl:=3 ); *)
                                    vbShift_NoRolls := FALSE; (* Eat *)
                                END_IF;
                            END_IF;

                            (* La zona fine linea è effettivamente occupata?
                               Il bordo avanti lastra ora si trova in vqShift_GlassX *)
                            OutZone.XcheckIfBusy := vqShift_GlassX; (* Tra un ciclo PLC sono pronti 'Xbusy' e 'Free' *)

                            (* Vedi se devo effettuare il movimento cinghie *)
                            IF ABS(Belts.MasterTgt) < vqShift_TargetTol THEN
                                dlog( Txt:='! Sheet already at %ld mm', Lvl:=2, Val1:=vqShift_GlassX/1E3 );
                                IF Stop_On_Dtch THEN
                                    (* Il vetro stretto è già sullo stacco, procedo ad avvicinarlo *)
                                    Status := SHF_DTCH_STP;
                                ELSE
                                    (* Mah, non è necessario muoversi! *)
                                    vnShift_Cmd := CMD_STOP; (* Eat command *)
                                    vnShift_Seq := SEQ_DONE;
                                END_IF;
                            ELSIF Need_Dtch_Fwd THEN (* AND NOT Stop_On_Dtch: Dovrebbe già essere così *)
                                (* Mi serve lo stacco avanti prima di muovere le cinghie *)
                                dlog( Txt:='Narrow needs Dtch fwd', Lvl:=5 );
                                Stop_On_Dtch := StartedX<vqX_CutZoneP; (* Il vetro si muove con lo stacco? *)
                                vbDtch_HoldGlassAlgn := NOT Stop_On_Dtch; (* Se c'è vetro sui riscontri, meglio tenerlo fermo *)
                                Status := SHF_DTCH_STP;
                            ELSE
                                (* Comando movimento cinghie e procedo *)
                                Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                                Status := SHF_PLACE_FWD;
                            END_IF;
                        ELSE (* StartedX > TargetX *)
                            dlog( Txt:='Sheet in %ld backward to %ld mm', Lvl:=5, Val1:=vqShift_GlassX/1E3, Val2:=vqShift_TargetX/1E3 );
                            (* -Traslazione indietro- *)

                            (* Default: Vado inditro a velocità normale *)
                            (* IF NOT vbExtractDone AND vnStackedSheets>0 THEN Belts.MasterSpd := vqBelts_FwdSpd; *)
                            Belts.MasterSpd := vqBelts_BckSpd;
                            Belts.MasterAcc := 100; (* [%] *)

                            (* Se la lastra è sui riscontri ci sono varie cose a cui stare attenti:
                                 .Bisogna attivare il cuscino aria per aiutare il movimento
                                 .Se il rapporto tra la parte di lastra sullo stacco e la parte
                                  sui riscontri propende per il secondo:
                                    ▸Le cinghie stacco potrebbero scivolare di centimetri
                                    ▸La salita rulli potrebbe peggiorare il grip sulle cinghie stacco
                                     e aumentare l'attrito sul lato riscontri *)
                            IF StartedX>vqX_CutZoneP THEN (* StartedX>vqX_RemnBeltsEnd *)
                                (* Lastra appoggia al modulo di riscontro *)

                                (* Siamo qui tipicamente perché è stata ruotata una lastra grossa
                                   con la pinza, poiché si tende a prendere in alto, è normale che
                                   si debba indietreggiare per posizionare per il riscontro/taglio *)

                                (* Controllo un ulteriore requisito, che la lastra sia ben sopra i
                                   i trasportatori, altrimenti non riesco ad arretrarla *)
                                IF (SEL(vqShift_GlassX>vqX_AlgnBeltsBegin,vqX_RemnBeltsEnd,vqX_BeltsEnd)-(vqShift_GlassX-vqShift_GlassWidth)) < vqBelts_MinGripDX THEN
                                    dlog( Txt:='!! No grip: Xbck=%ld>%ld mm', Lvl:=1, Val1:=(vqShift_GlassX-vqShift_GlassWidth)/1E3, Val2:=vqX_BeltsEnd/1E3 );
                                    Status := STS_ERROR;
                                    RETURN;
                                END_IF;

                                (* Se pezzo stretto sui riscontri perché mai dovrei posizionarlo indietro con le cinghie? Usa i riscontri! * )
                                IF vqShift_GlassWidth<vqShift_GoodWidth AND (vqShift_GlassX>(vqX_CutZoneP+vqShift_GlassWidth/2)) AND NOT vbFeat_AlgnHasBelts THEN
                                    dlog( Txt:='!! Too narrow W=%ld<%ld', Lvl:=1, Val1:=vqShift_GlassWidth/1E3, Val2:=vqShift_GoodWidth/1E3 );
                                    Status := STS_ERROR;
                                    RETURN;
                                END_IF; *)

                                (* Se il riscontro non è dotato di cinghie, meglio andare piano e
                                   accendere i ventilatori: c'è una parte di lastra che si trascina *)
                                IF NOT vbFeat_AlgnHasBelts THEN
                                    Belts.MasterSpd := vqBelts_DragSpd;
                                    Belts.MasterAcc := vnBelts_DragAcc; (* [%] *)
                                    (* Macchine StratoW (rulli riscontro): I soli rulli potrebbero stortare la lastra, rampe lunghe *)
                                    IF (vqShift_GlassX-vqShift_GlassWidth)>vqX_RemnBeltsEnd AND NOT Cr.Emulated THEN
                                        Belts.MasterAcc := Belts.MasterAcc/2;
                                    END_IF;

                                    (* Vedo le zone aria del riscontro che mi servono (cinghie indietro) *)
                                    SelectProdVents( Xfwd:=vqShift_GlassX, Ytop:=vqShift_GlassYtop );
                                    RequiredVents := SelectProdVents.Mask;
                                    IF Cs.Emulated THEN RequiredVents := RequiredVents OR BIT_VENT_DTCH; END_IF;
                                    (* Accendo aria *)
                                    vnVents_Cmd := vnVents_Cmd OR RequiredVents;
                                END_IF;

                                (* Sono quasi arrivato? *)
                                vbShift_AlmostThere := TargetX>0;
                            (* ELSIF StartedX>vqDtch_Xbegin AND Cs.Emulated THEN *)
                                (* Lo stacco è piccolo, non serve accendere aria *)
                            ELSE
                                (* Non appoggia al modulo di riscontro *)

                                (* Siamo qui tipicamente per posizionare la rimanenza
                                   sul sistema di rotazione del polmone o sul sistema
                                   di stoccaggio *)

                                (* TODO 1: La posizione presunta 'vqShift_GlassX' non è detto sia precisa
                                         se ho bisogno di essere accurato usa SHF_FWD_ONDTCH per misurare
                                         bordo lastra *)

                                RequiredVents := 0; (* Niente aria *)

                                (* Non arriverò mai in zona di processazione, sto andando indietro! *)
                                vbShift_AlmostThere := FALSE;
                            END_IF; (* Appoggia o meno al modulo di riscontro *)

                            (* Data la posizione iniziale, non mi aspetto di muovermi più di così: *)
                            Belts.MasterTgt := TargetX - StartedX; (* Movimento incrementale *)

                            (* Il Master sono le cinghie stacco 'BeltsDtch', BIT_BELTS_DTCH, Cs.Idx *)
                            (* Perché sono sempre coinvolte *)
                            Belts.MasterIdx := Cs.Idx;
                            Cs.Incremental := TRUE;
                            (* Vediamo quali cinghie seguono, il polmone è sempre coinvolto: *)
                            Belts.SlaveBelts := SEL(Cb.Emulated, BIT_BELTS_BUF, 0);
                            (* Le cinghie del carico sono coinvolte se: *)
                            IF Cb.Emulated OR (* ...Non esistono le cinghie polmone *)
                               fcBufBegin.q OR (* ...Fotocellula inizio polmone attivata *)
                               (vqShift_GlassX-vqShift_GlassWidth) < vqFeed_Xend THEN (* ...Il bordo indietro della lastra coinvolge il carico *)
                                dlog( Txt:='Also BeltsFeed', Lvl:=5 );
                                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED;
                            END_IF;
                            (* I rulli su riscontro sono coinvolti se parto abbastanza avanti;
                               ho comunque un modificatore temporaneo che consente di escluderli,
                               utile in caso di evacuazione di un monolitico già inciso *)
                            IF vqShift_GlassX>vqX_AlgnBeltsBegin AND NOT vbShift_NoRolls THEN
                                (* Occhio alla sicurezza (fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY) *)
                                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_ROLLS_ALGN;
                            ELSIF vbShift_NoRolls THEN
                                (* dlog( Txt:='fbShift: ! Excluding rolls', Lvl:=3 ); *)
                                vbShift_NoRolls := FALSE; (* Ensure to reset this temporary modifier *)
                            END_IF;

                            (* Vedi una volta di più se è davvero necessario muoversi *)
                            IF ABS(Belts.MasterTgt) < vqShift_TargetTol THEN
                                dlog( Txt:='! Sheet already at %ld mm', Lvl:=2, Val1:=vqShift_GlassX/1E3 );
                                vnShift_Cmd := CMD_STOP; (* Eat command *)
                                vnShift_Seq := SEQ_DONE;
                            ELSE
                                (* Comando movimento e procedo *)
                                Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                                Status := SHF_PLACE_BCK;
                            END_IF;
                        END_IF;
                    END_IF; (* Requisiti per SHFCMD_PLACE_SHEET *)

                (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
                (* Comando posizionamento preciso lastra *)
                ELSIF vnShift_Cmd=SHFCMD_PUT_SHEET THEN
                    dlog( Txt:='fbShift: Put sheet %ldx%ld from %ld to %ld mm', Lvl:=4, Val1:=vqShift_GlassWidth/1E3, Val2:=(vqShift_GlassYtop-vqShift_GlassYbtm)/1E3, Val3:=vqShift_GlassX/1E3, Val4:=vqShift_TargetX/1E3 );
                    (* Ho introdotto questo comando per posizionare piano lastre grandi da 0 alla posizione lametta inferiore per rifilo di testa *)
                    (* In teoria dovrei anche controllare trasportabilità e caduta *)
                    (* Mi fido degli argomenti dati, che devono essere corretti *)
                    (* Controllo argomenti *)
                    IF vqGlass_Thckn>vqShift_MaxGlassThckn  (* Troppo spesso *)
                       OR vqShift_GlassX=NO_POS_UM  (* Posizione non data *)
                       OR vqShift_TargetX>vqX_OutZoneEnd  (* Quota arrivo fuori a valle *)
                       OR (vqShift_TargetX-vqShift_GlassWidth)<vqXph_FeedBegin  (* Quota arrivo fuori a monte *)
                       OR (vqShift_TargetX-vqShift_GlassWidth)>vqX_BeltsEnd  (* Quota arrivo non raggiungibile *)
                       OR vqShift_GlassWidth<vqShift_PassMinWidth THEN (* vqFallWidth Larghezza lastra invalida *)
                        dlog( Txt:='!! Invalid args', Lvl:=1 );
                        Status := STS_ERROR;
                    ELSE
                        (* Gli argomenti sono ok *)
                        (* Vediamo che cinghie devo pilotare *)
                        IF vqShift_GlassX<vqFeed_Xend AND vqShift_TargetX<vqFeed_Xend THEN
                            (* Siamo solo sul carico *)
                            Belts.MasterIdx := Ca.Idx;
                            Ca.Incremental := TRUE;
                            Belts.SlaveBelts := 0;
                        ELSIF (vqShift_GlassX-vqShift_GlassWidth)>vqDtch_Xbegin AND
                              (vqShift_TargetX-vqShift_GlassWidth)>vqDtch_Xbegin THEN
                            (* Siamo a valle del polmone *)
                            Belts.MasterIdx := Cs.Idx;
                            Cs.Incremental := TRUE;
                            Belts.SlaveBelts := 0;
                            (* I rulli su riscontro sono coinvolti se sono abbastanza avanti *)
                            IF MAX(vqShift_GlassX,vqShift_TargetX) > vqX_AlgnBeltsBegin THEN
                                (* Occhio alla sicurezza (fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY) OR OutZone.Xbusy>vqX_AlgnBeltsEnd *)
                                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_ROLLS_ALGN;
                            END_IF;
                        ELSE
                            (* Devo coinvolgere anche le cinghie polmone *)
                            Belts.MasterIdx := Cs.Idx;
                            Cs.Incremental := TRUE;
                            Belts.SlaveBelts := SEL(Cb.Emulated, BIT_BELTS_BUF, 0);
                            (* I rulli su riscontro sono coinvolti se sono abbastanza avanti *)
                            IF MAX(vqShift_GlassX,vqShift_TargetX) > vqX_AlgnBeltsBegin THEN
                                (* Occhio alla sicurezza (fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY) OR OutZone.Xbusy>vqX_AlgnBeltsEnd *)
                                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_ROLLS_ALGN;
                            END_IF;
                            (* Le cinghie del carico sono coinvolte se: *)
                            IF Cb.Emulated OR (* ...Non esistono le cinghie polmone *)
                               (MIN(vqShift_GlassX,vqShift_TargetX)-vqShift_GlassWidth) < vqFeed_Xend THEN (* ...Il bordo indietro della lastra coinvolge il carico *)
                                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED;
                            END_IF;
                        END_IF;

                        (* Comando movimento e procedo *)
                        StartedX := vqShift_GlassX;
                        TargetX := vqShift_TargetX;
                        Belts.MasterTgt := TargetX - StartedX; (* Movimento incrementale *)
                        Belts.MasterSpd := 5E6; (* [um/min] Vado molto piano *)
                        Belts.MasterAcc := 10; (* [%] Voglio evitare strisciamenti *)
                        Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                        Status := STS_MOVING;

                    END_IF; (* Requisiti per SHFCMD_PUT_SHEET *)

                (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
                (* Passa un vetro dallo stacco ai riscontri *)
                ELSIF vnShift_Cmd=SHFCMD_FORW_ONALGN THEN
                    dlog( Txt:='fbShift: Passing %ldx%ld to Algn from %ld to %ld mm', Lvl:=4, Val1:=vqShift_GlassWidth/1E3, Val2:=(vqShift_GlassYtop-vqShift_GlassYbtm)/1E3, Val3:=vqShift_GlassX/1E3, Val4:=vqShift_TargetX/1E3 );
                    (* Controllo requisiti *)
                    IF vqShift_GlassWidth < vqShift_CrossMinWidth THEN
                        dlog( Txt:='!! Narrow W=%ld<%ld', Lvl:=1, Val1:=vqShift_GlassWidth/1E3, Val2:=vqShift_CrossMinWidth/1E3 );
                        Status := STS_ERROR;
                    ELSIF (vqShift_GlassYtop - vqShift_GlassYbtm)<1E3 THEN
                        dlog( Txt:='!! Invalid y=%ld|%ld', Lvl:=1, Val1:=vqShift_GlassYbtm/1E3, Val2:=vqShift_GlassYtop/1E3 );
                        Status := STS_ERROR;
                    ELSIF vqGlass_Thckn > vqShift_MaxGlassThckn THEN
                        dlog( Txt:='!! Too thick %ld>%ld', Lvl:=1, Val1:=vqGlass_Thckn/1E3, Val2:=vqShift_MaxGlassThckn/1E3 );
                        Status := STS_ERROR;
                    ELSIF vqShift_GlassX=NO_POS_UM THEN
                        dlog( Txt:='!! Undeclared position', Lvl:=1 );
                        Status := STS_ERROR;
                    ELSIF vqShift_GlassX > vqShift_TargetX THEN
                        dlog( Txt:='!! Cant go back from %ld to %ld mm', Lvl:=1, Val1:=vqShift_GlassX/1E3, Val2:=vqShift_TargetX/1E3 );
                        Status := STS_ERROR;
                    ELSIF vqShift_TargetX > vqX_OutZoneEnd THEN
                        dlog( Txt:='!! Target %ld beyond OutZone (%ld mm)', Lvl:=1, Val1:=vqShift_TargetX/1E3, Val2:=vqX_OutZoneEnd/1E3 );
                        Status := STS_ERROR;
                    ELSE
                        (* Ok, adesso ci sono tutti i requisiti per passare il vetro ai riscontri *)
                        (* Mi assicuro di attendere eventuali consegne precedenti *)
                        Status := SHF_FWD_WAITDLVR;
                    END_IF; (* Requisiti per SHFCMD_FORW_ONALGN *)

                (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
                (* Inserisci la rimanenza nel tavolo di carico / parcheggio lastra *)
                ELSIF vnShift_Cmd=SHFCMD_INS_REMN THEN
                    (* Assumo la posizione se non data *)
                    IF vqShift_GlassX=NO_POS_UM THEN
                        vqShift_GlassX := SEL( fcBufBegin.q, vqShift_GlassWidth/2, vqXph_BufBegin+vqShift_GlassWidth );
                    END_IF;
                    dlog( Txt:='fbShift: Inserting back %ldx%ld mm (Xfwd=%ld)', Lvl:=4, Val1:=vqShift_GlassWidth/1E3, Val2:=(vqShift_GlassYtop-vqShift_GlassYbtm)/1E3, Val3:=vqShift_GlassX/1E3 );
                    (* Controllo requisiti *)
                    IF vqShift_GlassWidth < vqShift_PassMinWidth THEN
                        dlog( Txt:='!! Narrow W=%ld<%ld', Lvl:=1, Val1:=vqShift_GlassWidth/1E3, Val2:=vqShift_PassMinWidth/1E3 );
                        Status := STS_ERROR;
                    ELSIF (vqShift_GlassYtop - vqShift_GlassYbtm)<1E3 THEN
                        dlog( Txt:='!! Invalid y=%ld|%ld', Lvl:=1, Val1:=vqShift_GlassYbtm/1E3, Val2:=vqShift_GlassYtop/1E3 );
                        Status := STS_ERROR;
                    ELSIF vqGlass_Thckn > vqShift_MaxGlassThckn THEN
                        dlog( Txt:='!! Too thick %ld>%ld', Lvl:=1, Val1:=vqGlass_Thckn/1E3, Val2:=vqShift_MaxGlassThckn/1E3 );
                        Status := STS_ERROR;
                    (* Voglio lo stacco in parcheggio *)
                    ELSIF NOT vb[ivbAtRest+ID_DTCH] THEN
                        dlog( Txt:='!! Dtch not parked', Lvl:=1 );
                        SET_MSG(MSG_NOTPARKED,'MSG_NOTPARKED: Dtch',0);
                        Status := STS_ERROR;
                    (* Non ci deve essere vetro sull'estremo indietro *)
                    ELSIF FeedOutBack THEN
                        dlog( Txt:='!! Feed full', Lvl:=1 );
                        SET_MSG(REQ_STACKFULL,'REQ_STACKFULL',0);
                        Status := STS_ERROR;
                    (* Niente richieste attive inerenti questa operazione *)
                    ELSIF IS_MSG(REQ_STACKFULL) OR IS_MSG(REQ_STACKBACK) THEN (* OR IS_MSG(REQ_STACK_REMN) *)
                        dlog( Txt:='!! Ongoing requests', Lvl:=1 );
                        Status := STS_ERROR;
                    ELSE
                        (* Ok, ci sono quasi tutti i requisiti per l'inserzione lastra *)

                        (* Non voglio basarmi troppo su vqShift_GlassWidth perché potrebbe avere un valore di default *)
                        (* Cosa significa accumulare una lastra nel carico?
                           Il succo è liberare la zona rimanenza perché il prodotto deve essere
                           ulteriormente processato, tipicamente deve essere ruotato.
                           Vanno previsti i seguenti casi:
                             ► Accumulo totale nel modulo di carico (cinghie polmone indipendenti)
                               In tal caso voglio liberare le cinghie polmone per disaccoppiare
                               le lastre accumulate dalle traslazioni di processazione:
                               la lastra viene inserita totalmente nel tavolo di carico
                             ► Allontanamento lastra (assenza polmone)
                               Qui non potrò mai disaccoppiare le traslazioni di processazione,
                               quindi tanto vale allontanare la lastra quanto basta per poter
                               proseguire con la processazione del prodotto
                             ► Stoccaggio con sistemi particolari
                               Ci sarà una sequenza per liberare il sistema di stoccaggio
                               e portare la lastra in prossimità per poter essere stoccata
                        *)
                        (* ► Accumulo tipico con polmone indipendente *)
                        (* ► TODO 3: Sistema di stoccaggio *)

                        (* Decido la quota di arrivo *)
                        (* Se carico basculato, meglio evitare collisioni *)
                        IF NOT vb[ivbAtRest+ID_FEED_TILT] THEN
                            vqShift_TargetX := vqFeed_Xend + vqShift_GlassWidth + 100E3;
                            dlog( Txt:='Backing up to %ld', Lvl:=4, Val1:=vqShift_TargetX/1E3 );
                        (* Liberazione area processazione (indietreggio del necessario) *)
                        ELSIF vbStepValid AND (Cb.Emulated OR NOT vbShift_FullIns)
                              AND NOT Cb.Emulated THEN (* Evito se macchina StratoS *)
                            vqShift_TargetX := vqProcArea_Xmin - vqBelts_StackDist; (*  *)
                            dlog( Txt:='Moving back to %ld', Lvl:=4, Val1:=vqShift_TargetX/1E3 );
                        (* Inserzione nel carico *)
                        ELSE
                            vqShift_TargetX := vqXph_FeedEnd - vqBelts_StackDist;
                            dlog( Txt:='Full insert (%ld)', Lvl:=4, Val1:=vqShift_TargetX/1E3 );
                        END_IF;
                        (* vqShift_TargetTol := vqShift_MovePosTol; *)

                        (* Non voglio fare movimenti avanti con le cinghie!! *)
                        IF vqShift_TargetX > vqShift_GlassX THEN
                            dlog( Txt:='!! Already back Xfwd=%ld<%ld', Lvl:=2, Val1:=vqShift_GlassX/1E3, Val2:=vqShift_TargetX/1E3 );
                            Status := STS_ERROR;
                            RETURN;
                        END_IF;

                        (* Preparo movimento, vedo se devo avvicinare o inserire la lastra nel carico *)
                        (* Se non c'è il polmone o il vetro è già sul carico, procedo subito con l'inserzione *)
                        IF fcBufBegin.q OR fcFeedEnd.q OR Cb.Emulated THEN
                            (* Il Master sono le cinghie carico 'BeltsFeed', BIT_BELTS_FEED, Ca.Idx *)
                            dlog( Txt:='Inserting in Feed', Lvl:=4 );
                            Belts.MasterIdx := Ca.Idx;
                            Ca.Incremental := TRUE;
                            IF Cb.Emulated THEN
                                (* Se non c'è il polmone devo coinvolgere stacco *)
                                Belts.SlaveBelts := BIT_BELTS_DTCH;
                            ELSIF fcDtchBegin.q THEN
                                Belts.SlaveBelts := BIT_BELTS_DTCH OR BIT_BELTS_BUF;
                            ELSE
                                Belts.SlaveBelts := BIT_BELTS_BUF;
                            END_IF;
                            Status := SHF_INS_FEED;
                        ELSE
                            (* Voglio portare la lastra in prossimità del carico per poi inserirla totalmente *)
                            (* Se c'è vetro non ben inserito c'è pericolo di collisione! *)
                            (* IF fcFeedEnd.q THEN dlog( Txt:='fbShift: ! May collide', Lvl:=3 ); END_IF; *)
                            (* Se carico basculato c'è pericolo di collisione! *)
                            (* Il Master sono le cinghie polmone 'BeltsBuf', BIT_BELTS_BUF, Cb.Idx *)
                            Belts.MasterIdx := Cb.Idx;
                            Cb.Incremental := TRUE;
                            Belts.SlaveBelts := BIT_BELTS_DTCH; (* Nota: i rulli ovviamente no! *)

                            (* Alzo subito cinghie carico per guadagnare tempo *)
                            vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED; (* BeltsFeed.Cmd.Activate := TRUE; *)
                            Status := SHF_BCK_FEED;
                        END_IF;

                        (* Quindi la quota iniziale e finale del bordo avanti: *)
                        StartedX := vqShift_GlassX;
                        TargetX := vqShift_TargetX; (* Quota di arrivo assoluta *)
                        vbShift_AlmostIns := Cb.Emulated;

                        (* Comando movimento e procedo *)
                        Belts.MasterSpd := SEL(vb[ivbAtRest+ID_FEED_TILT], vqBelts_SlowSpd, vqBelts_BckSpd );
                        Belts.MasterTgt := TargetX - StartedX;
                        Belts.MasterAcc := 100; (* [%] *)
                        Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                    END_IF; (* Requisiti per SHFCMD_INS_REMN *)

                (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
                (* Sposta un po' indietro la rimanenza per liberare zona taglio *)
                ELSIF vnShift_Cmd=SHFCMD_BACK_REMN THEN
                    dlog( Txt:='fbShift: Move back Remn %ldx%ld from %ld to %ld', Lvl:=4, Val1:=vqShift_GlassWidth/1E3, Val2:=(vqShift_GlassYtop-vqShift_GlassYbtm)/1E3, Val3:=vqShift_GlassX/1E3, Val4:=vqShift_TargetX/1E3 );
                    (* Controllo requisiti *)
                    (* Voglio lo stacco in parcheggio *)
                    IF vqShift_GlassWidth>vqDtch_Width/2 AND NOT vb[ivbAtRest+ID_DTCH] THEN
                        (* Comanda stacco in park se fermo *)
                        IF vnDtch_Cmd=CMD_STOP THEN
                            dlog( Txt:='Parking Dtch', Lvl:=5 );
                            vnDtch_Cmd := CMD_PARK;
                        END_IF;
                        (* Se lo stacco sta andando in parcheggio, attendi *)
                        IF vnDtch_Cmd=CMD_PARK THEN
                            Status := SHF_WAIT_DTCH;
                        ELSE
                            dlog( Txt:='!! Dtch not parked', Lvl:=1 );
                            SET_MSG(MSG_NOTPARKED,'MSG_NOTPARKED',0);
                            Status := STS_ERROR;
                        END_IF;
                    (* La lastra deve essere leggibile dalla fotocellula sullo stacco! *)
                    ELSIF vqShift_GlassYbtm>=vqYph_DtchLast OR vqShift_GlassYtop<=vqYph_DtchLast THEN
                        (* Meglio dare errore subito per bloccare le altre sequenze *)
                        dlog( Txt:='!! y=%ld|%ld outside ftc at %ld mm', Lvl:=2, Val1:=vqShift_GlassYbtm/1E3, Val2:=vqShift_GlassYtop/1E3, Val3:=vqYph_DtchLast/1E3 );
                        Status := STS_ERROR;
                    ELSE
                        (* Ok, ci sono i requisiti generali per lo spostamento rimanenza indietro *)
                        (* Controllo posizione dichiarata *)
                        IF vqShift_GlassX=NO_POS_UM THEN
                            (* Potrei forzare:
                            vqShift_GlassX := vqDtch_CurrX + vqRemn_DXdtch; *)
                            dlog( Txt:='!! vqShift_GlassX is undefined', Lvl:=2 );
                            Status := STS_ERROR;
                            RETURN;
                        END_IF;

                        (* Controllo un ulteriore requisito, che la lastra sia ben sopra
                           i trasportatori, altrimenti non riesco ad arretrarla *)
                        Delta := SEL(Cs.Emulated, vqDtch_CurrX+vqDtchBelts_Dx, vqX_RemnBeltsEnd) - vqBelts_MinGripDX; (* Soglia X grip cinghie *)
                        IF (vqShift_GlassX-vqShift_GlassWidth) > Delta THEN
                            dlog( Txt:='!! No grip for Remn Xbck=%ld>%ld', Lvl:=1, Val1:=(vqShift_GlassX-vqShift_GlassWidth)/1E3, Val2:=Delta/1E3 );
                            Status := STS_ERROR;
                            RETURN;
                        END_IF;

                        (* Vado indietro *)
                        (* Il Master sono le cinghie stacco 'BeltsDtch', BIT_BELTS_DTCH, Cs.Idx *)
                        Belts.MasterIdx := Cs.Idx;
                        Cs.Incremental := TRUE;
                        Belts.SlaveBelts := SEL(Cb.Emulated, BIT_BELTS_BUF, 0);
                        (* Vedo se devo subito coinvolgere il carico *)
                        IF Cb.Emulated OR
                           fcBufBegin.q OR  (* ...Fotocellula inizio polmone attivata *)
                           (fcFeedEnd.q AND (* ...Fotocellula fine carico attivata -rischio di collisione- *)
                            (vnComboFloat_Type=0 OR I_FLOAT_READY)) OR (* A meno che non ci sia una combinata attiva *)
                           (-vqShift_GlassWidth) < vqFeed_Xend THEN (* ...Il bordo indietro della lastra coinvolge il carico *)
                            Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED;
                        END_IF;

                        (* Di quanto mi devo spostare?
                           Se ho indicato qualcosa in 'vqShift_TargetX' assicuro
                           questo spostamento ignorando la fotocellula, altrimenti
                           non mi aspetto di andare indietro più della dimensione stacco.
                           Il movimento viene calcolato assumendo il bordo avanti attuale
                           della rimanenza in: vqDtch_CurrX + vqRemn_DXdtch *)
                        StartedX := vqShift_GlassX;
                        (* Per liberare la fotocellula devo arrivare a una quota inferiore a: *)
                        TargetX := (vqDtch_CurrX+vqDXph_DtchLast) - 100E3; (* Un margine di accuratezza su 'vqShift_GlassX' *)
                        (* Se ho specificato un target appropriato lo uso... *)
                        IF vqShift_TargetX < TargetX THEN
                            TargetX := vqShift_TargetX;
                        ELSE
                            (* ...Altrimenti mi fermerò alla liberazione della fotocellula *)
                            vqShift_TargetX := 0;
                        END_IF;
                        (* vqShift_TargetTol := vqShift_MovePosTol; *)

                        dlog( Txt:='Remn from %ld to %ld mm', Lvl:=4, Val1:=StartedX/1E3, Val2:=TargetX/1E3 );

                        (* Eventuale cuscino aria necessario (cinghie indietro per liberazione taglio) *)
                        SelectProdVents( Xfwd:=vqShift_GlassX, Ytop:=vqShift_GlassYtop );
                        RequiredVents := SelectProdVents.Mask;
                        (* Accendo aria *)
                        vnVents_Cmd := vnVents_Cmd OR RequiredVents;

                        (* Comando movimento e procedo *)
                        Belts.MasterTgt := TargetX - StartedX; (* Movimento incrementale *)
                        Belts.MasterSpd := vqBelts_BckSpd; (* [um/min] *)
                        Belts.MasterAcc := vnBelts_DumpAcc; (* [%] *)
                        Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                        Status := SHF_BCK_OFFDTCH;
                    END_IF;

                (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
                (* Posizionamento lastra generico *)
                (* ELSIF vnShift_Cmd=SHFCMD_PLACE THEN
                    (* Posizionamento lastra generico *)

                (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
                (* Comandi manuali *)
                ELSIF vnShift_Cmd=SHFCMD_MANUALFWD THEN
                    IF AllowManual THEN
                        (* RST_MSG(MSG_SHIFT_LOCKED); *)
                        (* Il Master sono le cinghie stacco 'BeltsDtch', BIT_BELTS_DTCH, Cs.Idx *)
                        Belts.MasterIdx := Cs.Idx;
                        Cs.Incremental := TRUE;
                        Belts.MasterTgt := vqDtch_Width+vqBuf_Width+vqFeed_Width;
                        Belts.MasterSpd := vqBelts_ManSpd;
                        Belts.MasterAcc := 100; (* [%] *)

                        (* Dichiara le cinghie che inseguono *)
                        Belts.SlaveBelts := SEL(Cb.Emulated, BIT_BELTS_BUF, 0);
                        (* Anche i trasportatori su riscontro? *)
                        IF RollsAlgn.Allow AND (vnShift_BeltsAlgnManMode>0 AND NOT vbFloatStripesBreak) THEN
                            Belts.SlaveBelts := Belts.SlaveBelts OR BIT_ROLLS_ALGN;
                            IF BeltsOutZone.Allow AND (OutZone.Free OR vnShift_BeltsAlgnManMode>1) THEN
                                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_OUTZONE;
                            END_IF;
                        END_IF;
                        (* Anche quelle del carico se disponibili *)
                        IF BeltsFeed.Allow AND (vnShiftFeed_Sts=STS_IDLE AND vnShiftFeed_Cmd=CMD_STOP) THEN
                            Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED;
                        END_IF;

                        dlog( Txt:='fbShift: Manual fwd (0x%X)', Lvl:=4, Val1:=TO_DINT(Belts.SlaveBelts) );
                        Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                        Status := SHF_MOVEALL_FWD;
                        vqSubSheet_X := NO_POS_UM; (* Resetto stato posiz lastra in modo che venga ricalcolato *)
                    (* ELSE
                        IF NOT IS_MSG(MSG_SHIFT_LOCKED) THEN dlog( Txt:='fbShift: manual command is not permitted while machine is working', Lvl:=1 ); END_IF;
                        SET_MSG(MSG_SHIFT_LOCKED,'MSG_SHIFT_LOCKED: Man',0); *)
                    END_IF;
                ELSIF vnShift_Cmd=SHFCMD_MANUALBCK THEN
                    IF AllowManual THEN
                        (* RST_MSG(MSG_SHIFT_LOCKED); *)
                        (* Il Master sono le cinghie stacco 'BeltsDtch', BIT_BELTS_DTCH, Cs.Idx *)
                        Belts.MasterIdx := Cs.Idx;
                        Cs.Incremental := TRUE;
                        Belts.MasterTgt := -(vqDtch_Width+vqBuf_Width+vqFeed_Width);
                        Belts.MasterSpd := vqBelts_ManSpd;
                        Belts.MasterAcc := 100; (* [%] *)

                        (* Dichiara le cinghie che inseguono *)
                        Belts.SlaveBelts := SEL(Cb.Emulated, BIT_BELTS_BUF, 0);
                        (* Anche i trasportatori su riscontro? *)
                        IF RollsAlgn.Allow AND (vnShift_BeltsAlgnManMode>0 AND NOT vbFloatStripesBreak) THEN
                            Belts.SlaveBelts := Belts.SlaveBelts OR BIT_ROLLS_ALGN;
                            IF BeltsOutZone.Allow AND (OutZone.Free OR vnShift_BeltsAlgnManMode>1) THEN
                                Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_OUTZONE;
                            END_IF;
                        END_IF;
                        (* Anche quelle del carico se disponibili *)
                        IF BeltsFeed.Allow AND (vnShiftFeed_Sts=STS_IDLE AND vnShiftFeed_Cmd=CMD_STOP) THEN
                            Belts.SlaveBelts := Belts.SlaveBelts OR BIT_BELTS_FEED;
                        END_IF;

                        dlog( Txt:='fbShift: Manual bck (0x%X)', Lvl:=4, Val1:=TO_DINT(Belts.SlaveBelts) );
                        Belts.Cmd := CMD_MOVETO; (* Sali e vai *)
                        Status := SHF_MOVEALL_BCK;
                        vqSubSheet_X := NO_POS_UM; (* Resetto stato posiz lastra in modo che venga ricalcolato *)
                    (* ELSE
                        IF NOT IS_MSG(MSG_SHIFT_LOCKED) THEN dlog( Txt:='fbShift: manual command is not permitted while machine is working', Lvl:=1 ); END_IF;
                        SET_MSG(MSG_SHIFT_LOCKED,'MSG_SHIFT_LOCKED: Man',0); *)
                    END_IF;

                (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
                (* Pilotaggio esterno *)
                ELSIF vnShift_Cmd=SHFCMD_DRIVE THEN
                    vnBelts_Cmd := CMD_STOP; (* Reset comando *)
                    Status := SHF_DRIVEN;

                (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
                ELSE
                    dlog( Txt:='fbShift: !! Unknown cmd=%d', Lvl:=1, Val1:=TO_DINT(vnShift_Cmd));
                    Status := STS_ERROR;
                END_IF; (* -- See command *)
            END_IF; (* -- Comando attivo *)
        END_IF; (* -- Allow *)

        (* -- Hook controlli comuni comandi -- *)
        IF vnShift_Cmd<>CMD_STOP AND Status<>STS_IDLE AND Belts.Cmd=CMD_MOVETO THEN

            (* Controllo trasportabilità Y *)
            IF vnShift_Cmd=SHFCMD_PLACE_SHEET OR
               vnShift_Cmd=SHFCMD_FORW_ONALGN OR
               vnShift_Cmd=SHFCMD_INS_REMN OR
               vnShift_Cmd=SHFCMD_BACK_REMN THEN
                Shiftable( iY:=ivqDtchBelts_Y, N:=vnDtchBelts_N, W:=vqDtchBelts_Size,
                           ybtm:=vqShift_GlassYbtm, ytop:=vqShift_GlassYtop );
                IF Shiftable.q THEN
                    dlog( Txt:='Using belts %d|%d (slaves=0x%X)', Lvl:=5, Val1:=TO_DINT(Shiftable.idx_btm), Val2:=TO_DINT(Shiftable.idx_top), Val3:=TO_DINT(Belts.SlaveBelts) );
                ELSE
                    dlog( Txt:='!! Cant shift y=%ld|%ld', Lvl:=2, Val1:=Shiftable.ybtm/1E3, Val2:=Shiftable.ytop/1E3 );
                    Status := STS_ERROR;
                END_IF;
            END_IF;

            (* Controllo disponibilità delle cinghie carico *)
            IF (Belts.SlaveBelts & BIT_BELTS_FEED)<>0 OR Belts.MasterIdx=Ca.Idx THEN
                (* Controllo conflitto con servizio cinghie carico *)
                IF vnShiftFeed_Sts<>STS_IDLE OR vnShiftFeed_Cmd<>CMD_STOP THEN
                    dlog( Txt:='!! BeltsFeed busy (sts=%d cmd=%d)', Lvl:=2, Val1:=TO_DINT(vnShiftFeed_Sts), Val2:=TO_DINT(vnShiftFeed_Cmd) );
                    SET_MSG(MSG_BELTSFEED_BUSY,'MSG_BELTSFEED_BUSY',0);
                    Status := STS_ERROR;
                (* Tavolo di carico basculato? *)
                ELSIF NOT vb[ivbAtRest+ID_FEED_TILT] THEN
                    dlog( Txt:='!! BeltsFeed tilted (cmd=%d)', Lvl:=2, Val1:=TO_DINT(vnShift_Cmd) );
                    SET_MSG(MSG_FEEDTILT_TILTED,'MSG_FEEDTILT_TILTED',0);
                    Status := STS_ERROR;
                (* Cinghie carico non disponibili? (es. Combinata sta lavorando) *)
                ELSIF NOT BeltsFeed.Allow THEN
                    dlog( Txt:='!! BeltsFeed unavailable (cmd=%d)', Lvl:=2, Val1:=TO_DINT(vnShift_Cmd) );
                    SET_MSG(MSG_BELTSFEED_BUSY,'MSG_BELTSFEED_BUSY',0);
                    Status := STS_ERROR;
                    (* Potrei attendere disponibilità? v. SHF_BCK_WAITFEED *)
                END_IF;
            END_IF;

        END_IF; (* --Hooks comandi *)


    (* ------------------------------------------------------------------- *)
    ELSE (* Errore sequenza (STS_ERROR) *)
        vnShift_Seq := SEQ_ERROR; (* Risultato di errore *)
        vnShift_Cmd := CMD_STOP; (* Eat command *)
        Belts.Cmd := CMD_STOP; (* Ferma il movimento e scendi *)
        (* vnBelts_Act := 0; (* Un po' radicale: assicuro TUTTE le cinghie disattivate *)
        vnVents_Cmd := vnVents_Cmd & NOT RequiredVents; (* Assicuro ventilatori chiusi *)
        RequiredVents := 0;
        (* Modificatori temporanei *)
        vbShift_NoRolls := FALSE;
        vbShift_KeepAirOn := FALSE;

        Status := STS_STOPPING;

END_CASE; (* -- overall belts sequences *)


(* -- Servizio di movimentazione complessiva cinghie -- *)
(* Nota: per la gestione del cuscino aria, vedi 'vqShift_HeavyThckn' *)
(* IF Status<>STS_IDLE OR Belts.OperatingBelts<>0 THEN (* Belts.Status>BLT_DISABLED *)
Belts();
(* Rifletti il comando esterno *)
IF Status=SHF_DRIVEN THEN vnBelts_Cmd := Belts.Cmd; END_IF;


(* -- BeltsFeed sequences --
   Qui parallelizzo le sequenze di movimentazione con le
   sole cinghie carico: carico lastra, restituzione sfrido, ... *)
ShiftFeed(); (* vnShiftFeed_Cmd, vnShiftFeed_Sts *)


(* -- ShiftAlgn sequences --
   Qui parallelizzo le sequenze di movimentazione con le cinghie
   a fine linea: evacuazione pezzo ActiveHP, passaggio pezzo a valle *)
ShiftAlgn(); (* vnShiftAlgn_Cmd, vnShiftAlgn_Sts *)


(* -- Remn post cut movements sequences --
   Qui parallelizzo le sequenze di post-movimentazione della rimanenza
   appena ottenuta dal taglio (quindi chiamate se 'vbDetachDone').
   Qui scarico rifilo nel cassone o sposto un po' indietro la
   rimanenza con le cinghie per toglierla dal premilastra dello stacco.
   Va bene anche per consegnare un pezzo da prelevare lato stacco *)
ShiftRemnPostCut(); (* vbShift_DumpRemn, vnShift_DumpSeq *)


(* - Hook reset richiesta indietreggiamento manuale della rimanenza - *)
RemnBackByHand( in:=IS_MSG(REQ_BACK_REMN) );
IF RemnBackByHand.fall THEN
    IF vbAck_CheckSensors AND fcDtchLast.q THEN
        dlog( Txt:='fbShift: ! Remn not backed: IFC_DTCH_LAST', Lvl:=2 );
        SET_MSG(REQ_BACK_REMN,'REQ_BACK_REMN',0);
    ELSE
        (* Stimo posizione rimanenza indietreggiata a mano
             Inizio zona stacco: vqDtch_Xbegin
             Bordo indietro del premilastra stacco: vqDtch_CurrX+vqClampDtch_DxM
             Fotocellula inizio stacco: vqDtch_CurrX+vqDXph_DtchBegin *)
        vqRemn_X := vqDXph_DtchBegin;
    END_IF;
END_IF;

(* - Hook reset richiesta prelievo manuale della rimanenza - *)
RemnTakeByHand( in:=IS_MSG(REQ_TAKE_REMN) OR IS_MSG(REQ_DUMP_REMN) );
IF RemnTakeByHand.fall THEN
    IF vbAck_CheckSensors AND fcDtchBegin.q THEN (* OR fcDtchLast.q (* a volte dà fastidio *)
        dlog( Txt:='fbShift: ! Remn not taken: IFC_DTCH_BEGIN', Lvl:=2 );
        IF vnRemn_Id=0 THEN SET_MSG(REQ_DUMP_REMN,'REQ_DUMP_REMN',0);
                       ELSE SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0); END_IF;
    ELSE
        vqRemn_X := NO_POS_UM; (* Rimanenza prelevata a mano *)
    END_IF;
END_IF;

(* - Hook reset richiesta inserzione manuale della rimanenza - *)
RemnInsByHand( in:=IS_MSG(REQ_STACK_REMN) );
IF RemnInsByHand.fall THEN
    IF vbAck_CheckSensors AND fcDtchBegin.q THEN (* OR fcDtchLast.q (* a volte dà fastidio *)
        dlog( Txt:='fbShift: ! Remn not inserted: IFC_DTCH_BEGIN', Lvl:=2 );
        SET_MSG(REQ_STACK_REMN,'REQ_STACK_REMN',0);
    ELSE
        vqRemn_X := NO_POS_UM; (* Rimanenza inserita/accumulata *)
    END_IF;
END_IF;



(* -- Notifiche a bassa priorità -- *)
IF vbHeartBeat THEN

    (* Reset messaggio trasportatori bloccati *)
    IF IS_MSG(MSG_SHIFT_LOCKED) AND Allow THEN
        RST_MSG(MSG_SHIFT_LOCKED);
    END_IF;

    (* Reset messaggio tavolo di carico occupato *)
    IF IS_MSG(MSG_SHIFT_FEEDBUSY) AND NOT (fcFeedNearEnd.q OR fcFeedEnd.q) THEN
        RST_MSG(MSG_SHIFT_FEEDBUSY);
    END_IF;

END_IF; (* vbHeartBeat *)


(* -- Monitors -- *)
AtRest := Status=STS_IDLE AND Belts.Status=STS_IDLE;
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbShiftRemnPostCut

{ DE:"Sequenze parallelizzate delle cinghie per movimentazione rimanenza" }

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vqWorkSettings : DINT; { DE:"Selettori ritentivi di lavorazione" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	HoldPads : fbHoldPads; { DE:"Tamponi fermavetro" }
	Cs : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo stacco (Detach) AX_CS" }
	BeltsDtch : fbBeltsDtch; { DE:"Trasportatori su modulo stacco" }
	Belts : fbBelts; { DE:"Gestore movimentazione cinghie" }
	vnShift_Cmd : INT; { DE:"Comando a sistema di trasporto vetro" }
	vnBelts_Act : INT; { DE:"Maschera attivazione cinghie" }
	Shiftable : fbShiftable; { DE:"Controllo trasportabilità con cinghie" }
	vnDtchBelts_N : INT; { DE:"Numero delle cinghie stacco" }
	vqDtchBelts_Size : DINT; { DE:"Larghezza banda gommmata cinghie a monte [um]" }
	SelectProdVents : fbSelectProdVents; { DE:"Seleziona zone cuscino aria zona riscontro" }
	vnVents_Cmd : INT; { DE:"Comando gruppi ventilatori cuscino aria a bit" }
	vqY_BtmEdge : DINT; { DE:"Quota misurata bordo vetro basso [um]" }
	vqY_TopEdge : DINT; { DE:"Quota misurata bordo vetro alto [um]" }
	vqCut_Length : DINT; { DE:"Lunghezza taglio effettiva [um]" }
	vbShift_DumpRemn : BOOL; { DE:"Consegna/espulsione rimanenza lato stacco" }
	vnShift_DumpSeq : INT; { DE:"Stato/risultato sequenza di evacuazione rifilo 'ID_SHIFT'" }
	vbRemn_Dumpable : BOOL; { DE:"Si deve espellere automaticamente la rimanenza nel cassone" }
	vqRemn_X : DINT; { DE:"Posizione bordo avanti della rimanenza [um]" }
	vqRemn_Width : DINT; { DE:"Dimensione longitudinale rimanenza del taglio [um]" }
	vqDump_AddMove : DINT; { DE:"Spostamento finale cinghie per espulsione nel cassone [um]" }
	vqDump_TurnHeight : DINT; { DE:"Altezza rimanenza con pericolo di rotazione [um]" }
	vqDump_MinSlip : DINT; { DE:"Slittamento cinghie previsto minimo [um]" }
	vqDump_SlipWidth : DINT; { DE:"Larghezza rimanenza con pericolo di slittamento cinghie [um]" }
	vqDump_SlipCoeff : DINT; { DE:"Slittamento previsto cinghie per ogni um sotto [um/um]" }
	vqShift_RemnTakePos : DINT; { DE:"Posizione prelievo rimanenza grossa [um]" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vnRemn_Id : INT; { DE:"Identificativo rimanenza" }
	vqDtch_CurrX : DINT; { DE:"Posizione attuale del modulo di stacco [um]" }
	vnDtch_Cmd : INT; { DE:"Comando stacco" }
	vqDtch_Tgt : DINT; { DE:"Posizione obiettivo stacco [um]" }
	vnDtch_Seq : INT; { DE:"Risultato sequenza stacco" }
	vbDtch_HoldGlassAlgn : BOOL; { DE:"Tieni fermo vetro su riscontri" }
	fcDtchBegin : fbPhotoCell; { DE:"Fotocellula inizio modulo stacco (IFC_DTCH_BEGIN)" }
	vqYph_DtchLast : DINT; { DE:"Ordinata ultima fotocellula su stacco [um]" }
	vqDXph_DtchBegin : DINT; { DE:"Offset fotocellula inizio stacco/esp rifili [um]" }
	vqDtch_Width : DINT; { DE:"Dimensione orizzontale/longitudinale (X) modulo di stacco [um]" }
	vqBelts_DumpSpd : DINT; { DE:"Velocità cinghie per espulsione rifilo [um/min]" }
	vnBelts_DumpAcc : INT; { DE:"Parzializzazione accelerazione espulsione pezzo [%]" }
	vqShift_GlassWidth : DINT; { DE:"Larghezza lastra movimentata [um]" }
	vqShift_GlassYbtm : DINT; { DE:"Ordinata bordo basso lastra movimentata [um]" }
	vqShift_GlassYtop : DINT; { DE:"Ordinata bordo alto lastra movimentata [um]" }
	vqShift_GlassX : DINT; { DE:"Posizione bordo avanti iniziale/corrente lastra movimentata [um]" }
	vqShift_TargetX : DINT; { DE:"Posizione bordo avanti finale lastra movimentata [um]" }
	vqShift_TargetTol : DINT; { DE:"Tolleranza sulla posizione finale della lastra movimentata [um]" }
	vqRemn_DXdtch : DINT; { DE:"Posizione bordo avanti della rimanenza separata rispetto lo stacco [um]" }
	END_VAR

	VAR
	delta : DINT; { DE:"Temporaneo" }
	END_VAR

	{ CODE:ST }(*    fbShiftRemnPostCut (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Sequenze cinghie movimentazione rimanenza
      post-taglio:
        .Espulsione rifilo
        .Indietreggiamento rimanenza per liberare area taglio

      NOTA
      ----------------------------------------------
      È il programma 'Detach-*.src' con 'vbRemn_Dumpable'
      che decide se la rimanenza va buttata nel cassone
*)

(* Notify abort * )
IF vnShift_DumpSeq>SEQ_DONE AND NOT vbShift_DumpRemn THEN
    dlog( Txt:='fbShiftRemn*: !! Abort Sts=%d', Lvl:=3, Val1:=TO_DINT(vnShift_DumpSeq) );
END_IF; *)

CASE vnShift_DumpSeq OF

    (* ------------------------------------------- *)
    DUMP_DTCHMOVE : (* Waiting detach movement *)
        IF vnDtch_Cmd=CMD_STOP THEN
            (* Movimento stacco terminato *)
            IF vnDtch_Seq=SEQ_DONE THEN
                (* Fatto, torniamo *)
                vnShift_DumpSeq := SEQ_START;
            ELSE
                (* Errore movimento stacco, termino *)
                (* dlog( Txt:='fbShiftRemn*: !! Detach move error', Lvl:=2 ); *)
                vnShift_DumpSeq := SEQ_JUSTERROR;
            END_IF;
        END_IF;

    (* ------------------------------------------- *)
    DUMP_DTCHPARK, DUMP_DTCHPARK_END : (* Waiting detach in park *)
        IF vnDtch_Cmd=CMD_STOP THEN
            (* Movimento stacco terminato *)
            (* IF vnDtch_Seq<>SEQ_DONE THEN (* Stacco non in parcheggio! *)
            IF vnShift_DumpSeq=DUMP_DTCHPARK THEN
                (* Sposto scarto grosso col sistema di traslazione alla quota di prelievo *)
                vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_DTCH; (* Assicuro niente aria in zona stacco *)
                IF vnShift_Cmd=0 AND vnDtch_Seq=SEQ_DONE THEN
                    dlog( Txt:='fbShiftRemn*: Moving big Remn %ldx%ld', Lvl:=2, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3 );
                    vqShift_GlassWidth := vqRemn_Width;
                    vqShift_GlassYbtm := vqY_BtmEdge;
                    vqShift_GlassYtop := vqY_TopEdge;
                    vqShift_GlassX := vqDtch_CurrX + vqRemn_DXdtch; (* = vqRemn_X Forzo io: più tollerante nel caso di comando manuale *)
                    vqShift_TargetX := vqShift_RemnTakePos; (* É da prelevare, portiamola indietro qui *)
                    vqShift_TargetTol := 10E3; (* vqShift_MovePosTol *)
                    vnShift_Cmd := SHFCMD_BACK_REMN;
                    (* Nota: Non mi interessa attendere la riuscita di questo comando *)
                ELSE
                    dlog( Txt:='fbShiftRemn*: ! Leaving big Remn %ldx%ld, vnShift_Cmd=%d', Lvl:=2, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=TO_DINT(vnShift_Cmd) );
                END_IF;
                (* In ogni caso, non l'ho buttata, richiederà prelievo a mano *)
                vnShift_DumpSeq := SEQ_JUSTERROR;
            ELSE
                (* Stacco parcheggiato, termino *)
                vbShift_DumpRemn := FALSE;
                vnShift_DumpSeq := SEQ_DONE;
            END_IF;
        END_IF;

    (* ------------------------------------------- *)
    DUMP_ENDING : (* Finalizing dump *)
        IF NOT vbShift_DumpRemn THEN
            (* dlog( Txt:='fbShiftRemn*: Ending aborted', Lvl:=2 ); *)
            vnShift_DumpSeq := SEQ_JUSTERROR;
        ELSIF BeltsDtch.Status<BLT_OPERATING THEN
            IF BeltsDtch.Arrived THEN
                (* Dumped *)
                vqRemn_X := NO_POS_UM; (* Rimanenza buttata nel cassone *)
                dlog( Txt:='fbShiftRemn*: Dumped', Lvl:=3 );
                (* Giù le cinghie *)
                vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_DTCH; (* BeltsDtch.Cmd.Activate := FALSE; *)
                (* Ora voglio portare lo stacco in parcheggio *)
                vbDtch_HoldGlassAlgn := FALSE;
                vnDtch_Cmd := CMD_PARK;
                vnShift_DumpSeq := DUMP_DTCHPARK_END; (* Aspetto movim stacco *)
            ELSE
                vnShift_DumpSeq := SEQ_JUSTERROR;
            END_IF;
        END_IF;

    (* ------------------------------------------- *)
    DUMP_DUMPING : (* Dumping *)
        IF NOT vbShift_DumpRemn THEN
            (* dlog( Txt:='fbShift: DUMP aborted', Lvl:=2 ); *)
            vnShift_DumpSeq := SEQ_JUSTERROR;
        ELSIF BeltsDtch.Status<BLT_OPERATING THEN
            (* IF BeltsDtch.Arrived THEN ELSE END_IF; *)
            vnShift_DumpSeq := SEQ_JUSTERROR;
        ELSIF fcDtchBegin.fall_delayed THEN
            (* Almost dumped! *)
            (* Ora serve solo che mi muovo della distanza tra fotocellula e bordo *)
            BeltsDtch.Cmd.Target := BeltsDtch.CurrPos - vqDump_AddMove; (* Distanza tra fotocellula e bordo *)
            (* Eh, quando il rifilo è molto stretto, incollato
               e oltre una certa altezza, il diradarsi delle
               cinghie sopra lo intraversano perché slittano
               di più di quelle sotto, creando una situazione
               molto pericolosa. In tal caso meglio muoversi
               molto anche dopo aver letto il sensore di caduta. *)
            IF vqCut_Length >= vqDump_TurnHeight THEN
                BeltsDtch.Cmd.Target := BeltsDtch.Cmd.Target - vqDump_MinSlip - MAX(0,vqDump_SlipCoeff * (vqDump_SlipWidth-vqRemn_Width)/1E3);
            END_IF;
            dlog( Txt:='fbShiftRemn*: Final dump=%ld mm at %ld', Lvl:=5, Val1:=(BeltsDtch.Cmd.Target-BeltsDtch.CurrPos)/1E3, Val2:=BeltsDtch.CurrPos/1E3 );
            vnShift_DumpSeq := DUMP_ENDING;
        END_IF;

    (* ------------------------------------------- *)
    DUMP_SHIFTING : (* Searching 'fcDtchBegin.q' or moving  *)
        IF NOT vbShift_DumpRemn THEN
            (* dlog( Txt:='fbShiftRemn*: Search aborted', Lvl:=2 ); *)
            vnShift_DumpSeq := SEQ_JUSTERROR;
        ELSIF BeltsDtch.Status<BLT_OPERATING THEN
            (* IF BeltsDtch.Arrived THEN ELSE END_IF; *)
            (* dlog( Txt:='fbShiftRemn*: moved to %ld', Lvl:=4, Val1:=BeltsDtch.CurrPos/1E3 ); *)
            (* vqRemn_X := ... *)
            vnShift_DumpSeq := SEQ_JUSTERROR;
        (* Controllo raggiungimento fotocellula, scarto latture spurie:
           devo essermi mosso di almeno... *)
        ELSIF fcDtchBegin.q AND BeltsDtch.CurrPos<(-vqDtch_Width/2) THEN
            dlog( Txt:='fbShiftRemn*: Read IFC_DTCH_BEGIN at %ld mm', Lvl:=5, Val1:=BeltsDtch.CurrPos/1E3 );
            (* Se non devo buttarla mi fermo, altrimenti proseguo *)
            vnShift_DumpSeq := SEL( vbRemn_Dumpable, SEQ_JUSTERROR, DUMP_DUMPING );
        END_IF;

    (* ------------------------------------------- *)
    DUMP_WAITBELTS : (* Waiting BeltsDtch *)
        IF Cs.Emulated OR NOT vbShift_DumpRemn THEN
            (* dlog( Txt:='fbShiftRemn*: Belts aborted', Lvl:=2 ); *)
            vnShift_DumpSeq := SEQ_JUSTERROR;
        ELSIF BeltsDtch.Status=BLT_OPERATING THEN
            vnShift_DumpSeq := DUMP_SHIFTING; (* Search fcDtchBegin *)
        END_IF;

    (* ------------------------------------------- *)
    SEQ_START, SEQ_DONE : (* Idle *)
        IF vbShift_DumpRemn THEN
            (* Attendo prerequisiti *)
            IF (Belts.ManagedBelts & BIT_BELTS_DTCH)=0 AND (* Cinghie stacco disponibili *)
               HoldPads.AtRest_Dtch THEN (* Tamponi stacco su *)

                (* Vediamo cosa fare *)
                IF vbRemn_Dumpable THEN
                    (* Dobbiamo scaricare la rimanenza nel cassone tra stacco e polmone *)
                    (* Già controllati: vqRemn_Width<=vqDump_MaxWidth AND (vqWorkSettings & BIT_SCRAPBIN)<>0 *)

                    (* Il vetro da buttare deve essere traslabile con le cinghie stacco: *)
                    Shiftable( iY:=ivqDtchBelts_Y, N:=vnDtchBelts_N, W:=vqDtchBelts_Size,
                               ybtm:=vqY_BtmEdge, ytop:=vqY_TopEdge );
                    IF Cs.Emulated OR NOT Shiftable.q THEN
                        dlog( Txt:='ShiftDump: ! Cannot dump y=%ld|%ld', Lvl:=2, Val1:=Shiftable.ybtm/1E3, Val2:=Shiftable.ytop/1E3 );
                        vbRemn_Dumpable := FALSE;
                        vnShift_DumpSeq := SEQ_JUSTERROR;
                        vnDtch_Cmd := CMD_PARK; (* Perché no? *)
                        RETURN;
                    END_IF;

                    (* Spazio tra stacco e polmone necessario all'espulsione
                       Nota: Lo spazio massimo è circa: (Xs.PosLim - Xs.NegLim) *)
                    delta := LIMIT(vqRemn_Width, 20E3, vq[ivqAx_PosLim+AX_XS-1] - MRGN_UM - vq[ivqAx_NegLim+AX_XS-1]);
                    (* Lo spazio effettivo tra polmone e stacco deve essere compatibile con il pezzo da buttare *)
                    IF (vqDtch_CurrX - vq[ivqAx_NegLim+AX_XS-1]) < (delta - MRGN_UM) THEN
                        (* Non c'è abbastanza spazio! *)
                        (* Abortisco
                        dlog( Txt:='fbShiftRemn*: !! Not enough space %ld', Lvl:=1, Val1:=delta/1E3 );
                        vbRemn_Dumpable := FALSE; *)
                        (* Creo lo spazio *)
                        vqDtch_Tgt := vq[ivqAx_NegLim+AX_XS-1] + delta;
                        vnDtch_Cmd := CMD_MOVETO;
                        dlog( Txt:='fbShiftRemn*: Xs %ld=>%ld for dump space %ld', Lvl:=1, Val1:=vqDtch_CurrX/1E3, Val2:=vqDtch_Tgt/1E3, Val3:=delta/1E3 );
                        vnShift_DumpSeq := DUMP_DTCHMOVE;
                    ELSE
                        (* C'è spazio, posso procedere *)
                        (* Quando abbiamo un rifilo stretto e lungo per scollarsi
                           può richiedere un certo movimento in più perché all'inizio
                           le cinghie slittano.
                           É vero che se è lungo ci sono anche più cinghie che tirano,
                           ma è anche vero che sopra le cinghie sono più rade e il
                           rifilo tende ad imbarcarsi facendo leggere il sensore
                           che è sotto, con risultato alquanto pericoloso *)
                        BeltsDtch.Cmd.MaxSpeed := vqBelts_DumpSpd;
                        BeltsDtch.Cmd.Accel := vnBelts_DumpAcc; (* [%] *)
                        BeltsDtch.Cmd.Target := -vqDtch_Width - (vqDump_MinSlip + MAX(0,vqDump_SlipCoeff * (vqDump_MinSlip-vqRemn_Width)/1E3) );

                        (* Procedo ad azionare le cinghie stacco *)
                        dlog( Txt:='fbShiftRemn*: Dumping Remn %ldx%ld', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3 );
                        vnBelts_Act := vnBelts_Act OR BIT_BELTS_DTCH; (* BeltsDtch.Cmd.Activate := TRUE; *)
                        vnShift_DumpSeq := DUMP_WAITBELTS;
                    END_IF;
                ELSE
                    (* Non scaricabile nel cassone, arretriamola in 'vqShift_RemnTakePos' *)
                    vbDtch_HoldGlassAlgn := FALSE;
                    vnDtch_Cmd := CMD_PARK; (* Parcheggio lo stacco *)

                    (* Nota: Voglio farlo comunque anche se teoricamente non trasportabile (NOT Shiftable.q) *)

                    (* Se non fosse leggibile dalla fotocellula stacco, richiedo che l'operatore
                       si assicuri che la rimanenza abbia liberato la zona taglio *)
                    IF vqY_BtmEdge>=vqYph_DtchLast OR vqY_TopEdge<=vqYph_DtchLast THEN
                        dlog( Txt:='fbShiftRemn*: !! Remn Y=%ld-%ld cannot be read by vqYph_DtchLast=%ld mm', Lvl:=2, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqYph_DtchLast/1E3 );
                        SET_MSG(REQ_BACK_REMN,'REQ_BACK_REMN',0);
                    END_IF;

                    (* Vediamo se è necessario usare le cinghie polmone
                                                 vqRemn_Width  vqRemn_DXdtch
                                     vqShift_RemnTakePos│ │←→│→│
                                                     ┌──┼─┼──┬─┐
                                                     │▒▒¦  ▒▒¦ │ vqDtch_CurrX
                                                     │▒▒¦  ▒▒¦ │
                                                     └──┼────┼─┘ ‒‒→ x
                                                        │←‒‒‒│
                                                     │←‒‒‒‒‒‒‒→│
                                                     vqDtch_Width      *)
                    IF (vqShift_RemnTakePos - vqRemn_Width) >= (vq[ivqAx_HomePos+AX_XS-1] - vqDtch_Width) THEN
                        (* É una rimanenza piuttosto stretta, quindi posso muoverla
                           indietro con le sole cinghie stacco mentre parcheggia *)
                        vqRemn_X := vq[ivqAx_HomePos+AX_XS-1] + vqRemn_DXdtch; (* Lo stacco si muoverà in park *)
                        dlog( Txt:='fbShiftRemn*: vqRemn_X=%ld vqRemn_DXdtch=%ld', Lvl:=4, Val1:=vqRemn_X/1E3, Val2:=vqRemn_DXdtch/1E3 );
                        BeltsDtch.Cmd.MaxSpeed := vqBelts_DumpSpd;
                        BeltsDtch.Cmd.Accel := vnBelts_DumpAcc; (* [%] *)
                        BeltsDtch.Cmd.Target := vqShift_RemnTakePos - vqRemn_X;
                        (* Voglio comunque assicurarmi di oscurare 'fcDtchBegin' per questioni di sicurezza *)
                        (* Occhio, non va bene con i rifili perché sembra che la loro posizione non sia ben stimata *)
                        (* IF vqRemn_Width > 50E3 THEN *)
                        (* Assumo un margine di ricoprimento fotocellula di 10E3 *)
                        BeltsDtch.Cmd.Target := MIN(vqDXph_DtchBegin - 10E3 + vqRemn_Width - vqRemn_DXdtch, BeltsDtch.Cmd.Target);
                        dlog( Txt:='fbShiftRemn*: Moving back Remn %ldx%ld of %ld mm', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=BeltsDtch.Cmd.Target/1E3 );
                        (* Procedo ad azionare le cinghie stacco *)
                        vnBelts_Act := vnBelts_Act OR BIT_BELTS_DTCH; (* BeltsDtch.Cmd.Activate := TRUE; *)
                        vnShift_DumpSeq := DUMP_WAITBELTS;
                    ELSE
                        (* Non bastano le cinghie stacco per arretrarla.
                           Procedo così: attendo stacco in parcheggio, per poi
                           richiedere al sistema di traslazione di spostarla in
                           posizione di prelievo (e liberare la fotocellula dello stacco *)
                        vnShift_DumpSeq := DUMP_DTCHPARK;
                        (* Se molto larga meglio accendere l'aria stacco *)
                        IF vqRemn_Width > (2*vqDtch_Width) THEN
                            vnVents_Cmd := vnVents_Cmd OR BIT_VENT_DTCH;
                        END_IF;
                    END_IF; (* (Non scaricabile) In base a larghezza rimanenza *)
                END_IF; (* Scaricabile o meno nel cassone *)
            END_IF; (* Attendo prerequisiti *)
        END_IF; (* Comando *)

    (* ------------------------------------------- *)
    SEQ_JUSTERROR :
        (* Per macchine semplici (StratoS), se la rimanenza non cade nel taglio
           e deve essere portata via a mano, è comodo accendere i ventilatori *)
        IF Cs.Emulated AND vqRemn_Width>400E3 OR
           (vqRemn_Width>100E3 AND vqRemn_X<>NO_POS_UM AND vqRemn_X>(vqDtch_CurrX+100E3)) THEN
            dlog( Txt:='fbShiftRemn*: Vent on for Remn %ldx%ld in %ld', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3, Val2:=vqRemn_X/1E3 );
            vnVents_Cmd := vnVents_Cmd OR MSK_VENT_REMN;
        END_IF;
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_DTCH;
        (* vnShift_DumpSeq := SEQ_ERROR; (* Passaggio inutile *)

    (* ------------------------------------------- *)
    (* ELSE (* SEQ_ERROR *)
        (* Segnala il fallimento *)
        dlog( Txt:='fbShiftRemn*: ! No dump', Lvl:=2 );
        IF vbAutoMode THEN
            IF vnRemn_Id=0 THEN SET_MSG(REQ_DUMP_REMN,'REQ_DUMP_REMN',0);
                           ELSE SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0); END_IF;
        END_IF;
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_DTCH; (* BeltsDtch.Cmd.Activate := FALSE; *)
        vbShift_DumpRemn := FALSE; (* Eat command *)
        vnShift_DumpSeq := SEQ_START; (* !Quindi va testato con SEQ_DONE e non con SEQ_ERROR! *)
END_CASE; (* -- Remn post cut movements sequences -- *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbShiftFeed

{ DE:"Sequenze parallelizzate delle cinghie su tavolo di carico" }

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vdPlcScanTime : LREAL; { DE:"Tempo di scansione del PLC [s]" }
	vqWorkSettings : DINT; { DE:"Selettori ritentivi di lavorazione" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	Ca : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo carico/Accumulo AX_CA" }
	Cb : fbM32Axis; { DE:"Asse cinghie/Conveyors modulo polmone AX_CB" }
	BeltsFeed : fbBeltsFeed; { DE:"Trasportatori su modulo di carico" }
	Belts : fbBelts; { DE:"Gestore movimentazione cinghie" }
	vnBelts_Act : INT; { DE:"Maschera forzatura attivazione cinghie" }
	I_SCU_POW_CA : BOOL; { DE:"Potenza gruppo assi movimentazione carico" }
	fcBufBegin : fbPhotoCell; { DE:"Fotocellula inizio zona polmone (IFC_BUF_BEGIN)" }
	fcFeedEnd : fbPhotoCell; { DE:"Fotocellula fine modulo di carico (IFC_FEED_END)" }
	fcFeedNearEnd : fbPhotoCell; { DE:"Fotocellula prossimità fine modulo di carico (IFC_FEED_NEAREND)" }
	fcFeedBegin : fbPhotoCell; { DE:"Fotocellula inizio modulo di carico (IFC_FEED_BEGIN)" }
	IFC_FEED2_BEGIN : BOOL; { DE:"Fotocellula inizio tavolo aggiuntivo carico alto" }
	vqXph_FeedEnd : DINT; { DE:"Ascissa fotocellula fine carico [um]" }
	vqXph_FeedNearEnd : DINT; { DE:"Ascissa fotocellula prossimità fine carico [um]" }
	vqXph_FeedBegin : DINT; { DE:"Ascissa fotocellula inizio carico [um]" }
	vbLdr_BlksOnUnload : BOOL; { DE:"Alza piedini di carico alla restituzione sfrido" }
	vqLdr_LoaderSheetX : DINT; { DE:"Posizione tipica bordo lastra sulla caricatrice [um]" }
	vqLdr_UnloadDx : DINT; { DE:"Movimento aggiuntivo restituzione sfrido [um]" }
	vqFeed_Width : DINT; { DE:"Dimensione orizzontale/longitudinale (X) modulo [um]" }
	vqFeed_Xend : DINT; { DE:"Posizione bordo avanti del tavolo di carico [um]" }
	vbShift_PhLatencyFix : BOOL; { DE:"Applica correzione latenza fotocellule" }
	vqH_SheetFeed : DINT; { DE:"Altezza tipica della lastra caricata [um]" }
	vqYo_SheetFeed : DINT; { DE:"Ordinata tipica della lastra in arrivo dal carico [um]" }
	vqBelts_SlowSpd : DINT; { DE:"Velocità cinghie per movimenti pericolosi [um/min]" }
	vqBelts_FwdSpd : DINT; { DE:"Velocità cinghie per chiamata lastra [um/min]" }
	vqBelts_BckSpd : DINT; { DE:"Velocità cinghie per parcheggio rimanenza [um/min]" }
	vnBelts_VelPPd : INT; { DE:"Profilo curva S decelerazione cinghie assunto nelle stime [%]" }
	vqBelts_LoadSpd : DINT; { DE:"Velocità caricatrice per carico lastra [um/min]" }
	vqBelts_UnloadSpd : DINT; { DE:"Velocità caricatrice per restituzione sfrido [um/min]" }
	vqBelts_ProbeSpd : DINT; { DE:"Velocità cinghie per ricerca/misura [um/min]" }
	vqBelts_StackDist : DINT; { DE:"Distanza lastre accodate sul carico [um]" }
	vqFeedLoad_TgtX : DINT; { DE:"Posizione desiderata del bordo avanti della lastra caricata [um]" }
	vnShiftFeed_Cmd : INT; { DE:"Comando a cinghie carico" }
	vnShiftFeed_Sts : INT; { DE:"Stato/risultato sequenze cinghie carico" }
	Loader : fbGenericLoader; { DE:"Caricatrice esterna (fbGenericLoader, ...)" }
	vnLoader_Type : INT; { DE:"Tipo caricatrice esterna 'ID_LOADER' (0:none 1:generic)" }
	vqLoadsCount : DINT; { DE:"Contatore lastre in arrivo dal sistema di caricamento" }
	vqUnloadsCount : DINT; { DE:"Contatore sfridi restituiti" }
	vqFeed_SheetX : DINT; { DE:"Posizione bordo lastra [um]" }
	vqFeed_SheetWidth : DINT; { DE:"Larghezza lastra rilevata [um]" }
	vqFeed_SheetEdge : DINT; { DE:"Cattura posizione su bordo avanti lastra [um]" }
	vqFeed_SheetEdge2 : DINT; { DE:"Cattura 2 posizione su bordo avanti lastra [um]" }
	FeedTilt : fbFeedTilt; { DE:"Basculamento del modulo di carico" }
	vbFeedTilt_Present : BOOL; { DE:"Presenza modulo di carico basculante" }
	IFC_FEED_END2 : BOOL; { DE:"Fotocellula fine modulo di carico posta in alto" }
	vqYph_FeedEnd : DINT; { DE:"Ordinata fotocellula fine carico [um]" }
	vqXph_FeedEnd2 : DINT; { DE:"Ascissa fotocellula fine carico alta [um]" }
	vqYph_FeedEnd2 : DINT; { DE:"Ordinata fotocellula fine carico alta [um]" }
	vdAngle_Hfwd : LREAL; { DE:"Misura angolo bordo avanti della lastra [rad]" }
	vqMeas_Hfwd_Dx : DINT; { DE:"Misura fuori squadra bordo avanti della lastra [um]" }
	vnFeedWheels_Type : INT; { DE:"Tipo di rotelle di squadratura modulo carico/accumulo" }
	vbFeedWheels_Cmd : BOOL; { DE:"Attiva le rotelle di squadratura del modulo di carico" }
	vbSheet_WasUpRight : BOOL; { DE:"La lastra caricata è stata squadrata con le rotelle" }
	vqShftOp_BeltsSpd : DINT; { DE:"Velocità cinghie per etichettatura [um/min]" }
	vqShftOp_SheetX : DINT; { DE:"Posizione bordo avanti lastra [um]" }
	vbShftOp_NoSynch : BOOL; { DE:"Servizio cinghie: Non sincronizzare con fotocellula" }
	vqShftOp_Tgt : DINT; { DE:"Servizio cinghie: Movimento a quota [um]" }
	vnShftOp_Seq : INT; { DE:"Risultato comando ShftOp" }
	END_VAR

	VAR
	StartedX : DINT; { DE:"Posizione inizio sequenze" }
	TargetX : DINT; { DE:"Ascissa obiettivo corrente bordo avanti [um]" }
	Delta : DINT; { DE:"Temporaneo per cambio obiettivo e compensazione latenze [um]" }
	fcFeedEnd2 : fbEdges; { DE:"Fronti di IFC_FEED_END2" }
	END_VAR

	{ CODE:ST }(*    fbShiftFeed (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Sequenze cinghie tavolo di carico:
        .Inserzione nel tavolo da valle
        .Carico lastra
        .Restituzione sfrido
        .Misura angolo lato verticale lastra
        .Movimenti per etichettatura
*)

(* Notify abort *)
IF vnShiftFeed_Sts>STS_STOPPING AND vnShiftFeed_Cmd=CMD_STOP THEN
    dlog( Txt:='fbShiftFeed: !! Abort Sts=%d', Lvl:=3, Val1:=TO_DINT(vnShiftFeed_Sts) );
END_IF;

CASE vnShiftFeed_Sts OF

    (* ------------------------------------------------------------------- *)
    STS_MOVEINIT : (* Wait belts positioning start *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd=CMD_STOP THEN
            SET_MSG(REQ_STACKBACK,'REQ_STACKBACK',0);
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo abort cinghie *)
        ELSIF NOT BeltsFeed.Cmd.Activate THEN
            dlog( Txt:='fbShiftFeed: !! MOVEINIT: Belts inactive', Lvl:=2 );
            SET_MSG(REQ_STACKBACK,'REQ_STACKBACK',0);
            vnShiftFeed_Sts := STS_ERROR;
        (* Attendi movimento partito *)
        ELSIF BeltsFeed.Status=BLT_OPERATING AND NOT BeltsFeed.Arrived THEN
            vnShiftFeed_Sts := SHF_FEED_INSPLACE;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_INSPLACE : (* Finalizing insertion *)
        (* Rilevo arrivo in quota *)
        IF BeltsFeed.Arrived THEN
            (* dlog( Txt:='fbShift: InsPlace: Done', Lvl:=4 ); *)
            (* vnShiftFeed_Seq := SEQ_DONE; *)
            vnShiftFeed_Cmd := CMD_STOP; (* Eat command done *)
            vnShiftFeed_Sts := STS_STOPPING;
        (* Rilevo condizioni abort sequenza *)
        ELSIF vnShiftFeed_Cmd=CMD_STOP THEN
            SET_MSG(REQ_STACKBACK,'REQ_STACKBACK',0);
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo condizioni abort sequenza *)
        ELSIF BeltsFeed.Status<BLT_OPERATING THEN
            dlog( Txt:='fbShiftFeed: !! INSPLACE: BeltsFeed not operating', Lvl:=2 );
            SET_MSG(REQ_STACKBACK,'REQ_STACKBACK',0);
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo raggiungimento del bordo indietro del tavolo di carico *)
        ELSIF fcFeedBegin.q OR IFC_FEED2_BEGIN THEN
            dlog( Txt:='fbShiftFeed: !! INSPLACE: reached IFC_FEED_BEGIN', Lvl:=2 );
            SET_MSG(REQ_STACKFULL,'REQ_STACKFULL',0);
            SET_MSG(REQ_STACKBACK,'REQ_STACKBACK',0);
            vnShiftFeed_Sts := STS_ERROR;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_LDGET : (* Getting incoming sheet from passive loader *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd=CMD_STOP THEN
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo arrivo in quota *)
        ELSIF BeltsFeed.Arrived AND BeltsFeed.Status>BLT_DISABLED THEN
            dlog( Txt:='fbShiftFeed: !! LDGET: No IFC_FEED_BEGIN after %ld mm', Lvl:=2, Val1:=BeltsFeed.CurrPos/1E3 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo abort cinghie *)
        ELSIF NOT I_SCU_POW_CA OR NOT BeltsFeed.Cmd.Activate THEN
            dlog( Txt:='fbShiftFeed: !! LDGET: Belts aborted', Lvl:=2 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Se cinghie in moto *)
        ELSIF BeltsFeed.Status=BLT_OPERATING THEN
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqFeed_SheetX := StartedX + BeltsFeed.CurrPos;

            (* Comando i trasportatori della caricatrice *)
            Loader.MoveSpd := BeltsFeed.Cmd.MaxSpeed; (* [um/min] *)

            (* Rilevo impegno della fotocellula di fine carico *)
            IF fcFeedEnd.q THEN
                dlog( Txt:='fbShiftFeed: !! LDGET: Sheet already on IFC_FEED_END', Lvl:=2 );
                vnShiftFeed_Sts := STS_ERROR;
            (* Rilevo impegno della fotocellula prossimità arrivo *)
            ELSIF fcFeedNearEnd.q THEN
                dlog( Txt:='fbShiftFeed: !! LDGET: Sheet already on IFC_FEED_NEAREND', Lvl:=2 );
                vnShiftFeed_Sts := STS_ERROR;
            (* Rilevo raggiungimento dell'inizio del tavolo di carico *)
            ELSIF fcFeedBegin.q THEN
                IF NOT fcFeedBegin.rise THEN
                    dlog( Txt:='fbShiftFeed: !! LDGET: Already on IFC_FEED_BEGIN', Lvl:=3 );
                END_IF;
                (* In ogni caso sincronizzo la posizione *)
                (* Posizione effettiva bordo avanti *)
                Delta := vqXph_FeedBegin;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(BeltsFeed.CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                dlog( Txt:='fbShiftFeed: LDGET: On IFC_FEED_BEGIN at %ld mm (dx=%ld)', Lvl:=4, Val1:=vqFeed_SheetX/1E3, Val2:=(Delta - vqFeed_SheetX)/1E3 );
                StartedX := StartedX + (Delta - vqFeed_SheetX);
                vqFeed_SheetX := Delta; (* Aggiorno subito posizione bordo avanti *)
                (* Cambio target *)
                Delta := TargetX - vqFeed_SheetX; (* Correction *)
                BeltsFeed.Cmd.Target := BeltsFeed.CurrPos + Delta;
                (* Misura lastra *)
                vqFeed_SheetEdge := BeltsFeed.CurrPos;
                vqFeed_SheetWidth := 0;
                vnShiftFeed_Sts := SHF_FEED_LDPASS; (* Procediamo *)
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_LDPASS, (* Transferring sheet from loader to feed *)
    SHF_FEED_LDPLACE : (* Placing loaded sheet on feed *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd=CMD_STOP THEN
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo arrivo in quota *)
        ELSIF BeltsFeed.Arrived THEN
            IF vnShiftFeed_Sts=SHF_FEED_LDPLACE THEN
                dlog( Txt:='fbShiftFeed: Loaded sheet w=%ld mm', Lvl:=4, Val1:=vqFeed_SheetWidth/1E3 );
                vqLoadsCount := vqLoadsCount + 1;
                (* vnShiftFeed_Seq := SEQ_DONE; *)
                vnShiftFeed_Cmd := CMD_STOP; (* Eat command done *)
                vnShiftFeed_Sts := STS_STOPPING;
                (* Potrei squadrarla con le rotelle 'ID_FEED_WHEELS' *)
                IF vnFeedWheels_Type>0 AND (vqWorkSettings & BIT_AUTOWHEELS)<>0 THEN
                    dlog( Txt:='! Auto wheels after load', Lvl:=3 );
                    vbFeedWheels_Cmd := TRUE;
                END_IF;
            ELSE
                (* Cavolo, durante la rampa discendente i rulli spingevano ancora! *)
                dlog( Txt:='fbShiftFeed: !! Load: IFC_FEED_BEGIN not released after %ld mm', Lvl:=4, Val1:=BeltsFeed.CurrPos/1E3 );
                vnShiftFeed_Sts := STS_ERROR;
            END_IF;
        (* Rilevo abort cinghie *)
        ELSIF NOT I_SCU_POW_CA OR BeltsFeed.Status<BLT_OPERATING THEN
            dlog( Txt:='fbShiftFeed: !! Load: Belts aborted', Lvl:=2 );
            vnShiftFeed_Sts := STS_ERROR;
        ELSE (* Cinghie in moto *)
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqFeed_SheetX := StartedX + BeltsFeed.CurrPos;

            (* Durante il passaggio: *)
            IF vnShiftFeed_Sts=SHF_FEED_LDPASS THEN

                (* Assicuro i trasportatori della caricatrice *)
                Loader.MoveSpd := BeltsFeed.Cmd.MaxSpeed; (* [um/min] *)

                (* Rilevo lastra completamente sul tavolo di carico *)
                IF NOT fcFeedBegin.q THEN
                    (* Misura lastra *)
                    vqFeed_SheetWidth := BeltsFeed.CurrPos - vqFeed_SheetEdge;
                    dlog( Txt:='fbShiftFeed: Load: Transferred sheet w=%ld mm', Lvl:=4, Val1:=vqFeed_SheetWidth/1E3 );
                    Loader.MoveSpd := 0; (* Non mi servono più i trasportatori della caricatrice *)
                    (* Cambio velocità se mi manca ancora tanto *)
                    IF (TargetX - vqFeed_SheetX) > 1500E3 THEN
                        BeltsFeed.Cmd.MaxSpeed := vqBelts_FwdSpd;
                    END_IF;
                    vnShiftFeed_Sts := SHF_FEED_LDPLACE; (* Procediamo *)
                (* Controllo che i trasportatori della caricatrice stiano andando avanti *)
                ELSIF vnLoader_Type>0 AND Loader.NotMovingFwd THEN
                    dlog( Txt:='fbShiftFeed: !! Load: Loader not shifting fwd', Lvl:=2 );
                    SET_MSG(MSG_LDR_CANT_FWD,'MSG_LDR_CANT_FWD',0);
                    vnShiftFeed_Sts := STS_ERROR;
                END_IF;
            END_IF;

            (* Rilevo impegno della fotocellula di fine carico *)
            IF fcFeedEnd.q THEN
                dlog( Txt:='fbShiftFeed: !! Load: Sheet reached IFC_FEED_END', Lvl:=2 );
                vnShiftFeed_Sts := STS_ERROR;
            (* Rilevo impegno della fotocellula prossimità arrivo *)
            ELSIF fcFeedNearEnd.rise THEN
                (* Posizione effettiva bordo avanti *)
                Delta := vqXph_FeedNearEnd;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(BeltsFeed.CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                dlog( Txt:='fbShiftFeed: Load: Reached FeedNearEnd at %ld mm (dx=%ld)', Lvl:=4, Val1:=vqFeed_SheetX/1E3, Val2:=(Delta - vqFeed_SheetX)/1E3 );
                StartedX := StartedX + (Delta - vqFeed_SheetX);
                vqFeed_SheetX := Delta; (* Aggiorno subito posizione bordo avanti *)
                (* Cambio target se fattibile *)
                Delta := TargetX - vqFeed_SheetX; (* Quanto mi manca ad arrivare *)
                IF Delta > vq[ivqAx_StopSpace+Ca.Idx-1] THEN (* Nota: sono tutti e due positivi, sto andando avanti *)
                    BeltsFeed.Cmd.Target := BeltsFeed.CurrPos + Delta;
                ELSE
                    dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=BeltsFeed.Cmd.Target/1E3, Val2:=(BeltsFeed.CurrPos + Delta)/1E3 );
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_UNLDPUT : (* Moving upstream with feed module - reaching feed begin *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd=CMD_STOP THEN
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo arrivo in quota *)
        ELSIF BeltsFeed.Arrived THEN
            dlog( Txt:='fbShiftFeed: !! UNLDPUT: IFC_FEED_BEGIN not reached after %ld mm', Lvl:=2, Val1:=BeltsFeed.CurrPos/1E3 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo abort cinghie *)
        ELSIF NOT BeltsFeed.Cmd.Activate THEN
            dlog( Txt:='fbShiftFeed: !! UNLDPUT: Belts aborted', Lvl:=2 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Se cinghie in moto *)
        ELSIF BeltsFeed.Status=BLT_OPERATING THEN
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqFeed_SheetX := StartedX + BeltsFeed.CurrPos;

            (* Controllo che i trasportatori della caricatrice stiano andando indietro *)
            IF Loader.NotMovingBck THEN
                dlog( Txt:='fbShiftFeed: !! UNLDPUT: Loader not shifting bck', Lvl:=2 );
                SET_MSG(MSG_LDR_CANT_BCK,'SHF_FEED_UNLDPUT',0);
                vnShiftFeed_Sts := STS_ERROR;
            END_IF;

            (* Rilevo raggiungimento del bordo indietro del tavolo di carico *)
            IF fcFeedBegin.q THEN
                (* Misura lastra *)
                vqFeed_SheetEdge := BeltsFeed.CurrPos;
                vqFeed_SheetWidth := 0;
                dlog( Txt:='fbShiftFeed: UNLDPUT: Reached IFC_FEED_BEGIN', Lvl:=4 );
                vnShiftFeed_Sts := SHF_FEED_UNLDPASS; (* Procediamo *)
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_UNLDPASS : (* Transferring sheet from feed to loader *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd=CMD_STOP THEN
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo arrivo in quota *)
        ELSIF BeltsFeed.Arrived THEN
            (* Cavolo, durante la rampa discendente i rulli spingevano ancora! *)
            dlog( Txt:='fbShiftFeed: !! UNLDPASS: IFC_FEED_BEGIN not released after %ld mm', Lvl:=4, Val1:=BeltsFeed.CurrPos/1E3 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo abort cinghie *)
        ELSIF BeltsFeed.Status<BLT_OPERATING THEN
            dlog( Txt:='fbShiftFeed: !! UNLDPASS: Belts aborted', Lvl:=2 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Controllo che i trasportatori della caricatrice stiano andando indietro *)
        ELSIF Loader.NotMovingBck THEN
            dlog( Txt:='fbShiftFeed: !! UNLDPASS: Loader not shifting bck', Lvl:=2 );
            SET_MSG(MSG_LDR_CANT_BCK,'SHF_FEED_UNLDPASS',0);
            vnShiftFeed_Sts := STS_ERROR;
        ELSE (* Cinghie in moto *)
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqFeed_SheetX := StartedX + BeltsFeed.CurrPos;

            (* Rilevo lastra uscita dal tavolo di carico *)
            IF NOT fcFeedBegin.q THEN
                (* Misura lastra *)
                vqFeed_SheetWidth := BeltsFeed.CurrPos - vqFeed_SheetEdge;
                dlog( Txt:='fbShiftFeed: UNLDPASS: Transferred sheet w=%ld mm', Lvl:=4, Val1:=vqFeed_SheetWidth/1E3 );
                (* Movimento aggiuntivo dopo perdita fotocellula *)
                BeltsFeed.Cmd.Target := BeltsFeed.CurrPos - vqLdr_UnloadDx;
                vnShiftFeed_Sts := SHF_FEED_UNLDEND; (* Procediamo *)
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_UNLDEND : (* Finalizing unload *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd=CMD_STOP THEN
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo arrivo in quota *)
        ELSIF BeltsFeed.Arrived THEN
            dlog( Txt:='fbShiftFeed: Unloaded sheet w=%ld mm', Lvl:=4, Val1:=vqFeed_SheetWidth/1E3 );
            vqUnloadsCount := vqUnloadsCount + 1;
            (* vnShiftFeed_Seq := SEQ_DONE; *)
            vnShiftFeed_Cmd := CMD_STOP; (* Eat command done *)
            Loader.MoveSpd := 0; (* Fermo i trasportatori della caricatrice *)
            vnShiftFeed_Sts := STS_STOPPING;
        (* Rilevo abort cinghie *)
        ELSIF BeltsFeed.Status<BLT_OPERATING THEN
            dlog( Txt:='fbShiftFeed: !! UNLDEND: Belts aborted', Lvl:=2 );
            vnShiftFeed_Sts := STS_ERROR;
        ELSE (* Cinghie in moto *)
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqFeed_SheetX := StartedX + BeltsFeed.CurrPos;

            (* Durante il movimento finale: *)
            (* Rilevo una seconda lastra che era sul tavolo di carico? *)
            IF fcFeedBegin.q THEN
                (* Misura lastra *)
                dlog( Txt:='fbShiftFeed: !! UNLDEND: Another sheet after %ld mm', Lvl:=4, Val1:=BeltsFeed.CurrPos/1E3 );
                vnShiftFeed_Sts := STS_ERROR;
            (* Controllo che i trasportatori della caricatrice stiano andando indietro *)
            ELSIF Loader.NotMovingBck THEN
                dlog( Txt:='fbShift: !! UNLDEND: Loader not shifting bck', Lvl:=2 );
                vnShiftFeed_Sts := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_MEASFWD : (* Movimento avanti di ricerca fotocellule *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd=CMD_STOP THEN
            vnShiftFeed_Sts := STS_ERROR;
        (* Se posizionamento cinghie terminato *)
        ELSIF BeltsFeed.Cmd.Target=0 THEN
            (* Notifica se non sono arrivato *)
            IF NOT BeltsFeed.Arrived THEN
                dlog( Txt:='fbShiftFeed: ! MEASFWD: Stopped at %ld != %ld', Lvl:=2, Val1:=vqFeed_SheetX/1E3, Val2:=TargetX/1E3 );
            END_IF;
            (* Vediamo se ho le due letture *)
            IF vqFeed_SheetEdge<>NO_POS_UM AND vqFeed_SheetEdge2<>NO_POS_UM THEN
                (* Assumendo che il bordo sia una retta,                  Dx          y
                   l'angolo rispetto la verticale è           +----------|  |         ^
                     a = atan( Dx / Dy )                      |          x - - -      |
                   Il fuorisquadra riportato sull'altezza   H |           \|     Dy   |
                   lastra:                                    |            x - -      |
                     Dxtot = H * tg(a) = H * Dx / Dy          +-------------          +----> x
                *)
                (* Se è negativo manca vetro in alto, se positivo troppo vetro in alto *)
                vqMeas_Hfwd_Dx := (vqFeed_SheetEdge - vqXph_FeedEnd) - (vqFeed_SheetEdge2 - vqXph_FeedEnd2);
                (* vdAngle_Hfwd := ATAN2(vqMeas_Hfwd_Dx, vqYph_FeedEnd2-vqYph_FeedEnd); (* [rad] *)
                vdAngle_Hfwd := ATAN( TO_LREAL(vqMeas_Hfwd_Dx) / TO_LREAL(vqYph_FeedEnd2-vqYph_FeedEnd) ); (* [rad] *) (* DANGER_DIVISION_BY_ZERO *)
                (* Nota: in CheckMachPars si assicura (vqYph_FeedEnd2-vqYph_FeedEnd)>0 *)
                (* Calcolo fuorisquadra sull'altezza della lastra *)
                vqMeas_Hfwd_Dx := TO_DINT( TO_LREAL(vqH_SheetFeed) * TAN(vdAngle_Hfwd) );
                dlog( Txt:='fbShiftFeed: MEASFWD: Xbtm=%ld Xtop=%ld Dx=%ld um', Lvl:=2, Val1:=vqFeed_SheetEdge/1E3, Val2:=vqFeed_SheetEdge2/1E3, Val3:=vqMeas_Hfwd_Dx );
            ELSE
                dlog( Txt:='fbShiftFeed: ! MEASFWD: Missing measure: Xbtm=%ld Xtop=%ld', Lvl:=2, Val1:=vqFeed_SheetEdge/1E3, Val2:=vqFeed_SheetEdge2/1E3 );
                vnShiftFeed_Sts := STS_ERROR; (* Abortisci? *)
            END_IF;
            (* In ogni caso torniamo indietro *)
            StartedX := vqFeed_SheetX;
            TargetX := vqXph_FeedEnd - vqBelts_StackDist; (* vqFeedLoad_TgtX *)
            BeltsFeed.Cmd.Accel := 100; (* [%] *)
            BeltsFeed.Cmd.MaxSpeed := vqBelts_ProbeSpd;
            Ca.Incremental := TRUE; (* Movimento incrementale *)
            BeltsFeed.Cmd.Target := TargetX - StartedX;
            (* Inizializzo una ulteriore misura: *)
            vqFeed_SheetEdge := NO_POS_UM;
            vqFeed_SheetEdge2 := NO_POS_UM;
            (* Procedo ad alzare le cinghie carico *)
            vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED; (* BeltsFeed.Cmd.Activate := TRUE; *)
            vnShiftFeed_Sts := SHF_FEED_MEASBCK;
        (* Intercetta arrivo su polmone senza lettura *)
        ELSIF fcBufBegin.q AND NOT Cb.Emulated THEN
            dlog( Txt:='fbShiftFeed: !! MEASFWD: Reached IFC_BUF_BEGIN after %ld mm', Lvl:=2, Val1:=BeltsFeed.CurrPos/1E3 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo abort cinghie *)
        ELSIF NOT BeltsFeed.Cmd.Activate THEN
            dlog( Txt:='fbShiftFeed: !! MEASFWD: Belts aborted', Lvl:=2 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Se cinghie in moto *)
        ELSIF BeltsFeed.Status=BLT_OPERATING THEN
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqFeed_SheetX := StartedX + BeltsFeed.CurrPos;

            (* Rilevo letture fotocellula bassa 'IFC_FEED_END' *)
            IF fcFeedEnd.rise THEN
                (* Posizione effettiva bordo avanti *)
                Delta := vqXph_FeedEnd;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(BeltsFeed.CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                StartedX := StartedX + (Delta - vqFeed_SheetX);
                vqFeed_SheetX := Delta; (* Aggiorno subito posizione bordo avanti *)
                (* Cambio target se fattibile *)
                Delta := TargetX - vqFeed_SheetX; (* Quanto mi manca ad arrivare *)
                IF Delta > vq[ivqAx_StopSpace+Ca.Idx-1] THEN (* Nota: sono tutti e due positivi, sto andando avanti *)
                    BeltsFeed.Cmd.Target := BeltsFeed.CurrPos + Delta;
                END_IF;

                (* Metto via la lettura *)
                IF vqFeed_SheetEdge=NO_POS_UM THEN
                    (* Nota: non uso 'vqFeed_SheetX' perché deve essere confrontabile *)
                    vqFeed_SheetEdge := BeltsFeed.CurrPos;
                    dlog( Txt:='fbShiftFeed: MEASFWD: IFC_FEED_END at %ld mm', Lvl:=4, Val1:=vqFeed_SheetEdge/1E3 );
                END_IF;
                IF vqFeed_SheetEdge2<>NO_POS_UM THEN (* Ho l'altra lettura? *)
                    (* Ho entrambe le letture: anziché fermarmi subito proseguo fino
                       a destinazione, in questo modo ho una ripetibilità del movimento *)
                    BeltsFeed.Cmd.MaxSpeed := vqBelts_FwdSpd;
                END_IF;

            END_IF;

            (* Rilevo letture fotocellula alta 'IFC_FEED_END2' *)
            fcFeedEnd2( in:=IFC_FEED_END2 ); (* Fotocellula alta fine modulo di carico *)
            IF fcFeedEnd2.rise THEN
                (* Posizione effettiva bordo avanti *)
                Delta := vqXph_FeedEnd2;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(BeltsFeed.CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                StartedX := StartedX + (Delta - vqFeed_SheetX);
                vqFeed_SheetX := Delta; (* Aggiorno subito posizione bordo avanti *)
                (* Cambio target se fattibile *)
                Delta := TargetX - vqFeed_SheetX; (* Quanto mi manca ad arrivare *)
                IF Delta > vq[ivqAx_StopSpace+Ca.Idx-1] THEN (* Nota: sono tutti e due positivi, sto andando avanti *)
                    BeltsFeed.Cmd.Target := BeltsFeed.CurrPos + Delta;
                END_IF;

                (* Metto via la lettura *)
                IF vqFeed_SheetEdge2=NO_POS_UM THEN
                    (* Nota: non uso 'vqFeed_SheetX' perché deve essere confrontabile *)
                    vqFeed_SheetEdge2 := BeltsFeed.CurrPos;
                    dlog( Txt:='fbShiftFeed: MEASFWD: IFC_FEED_END2 at %ld mm', Lvl:=4, Val1:=vqFeed_SheetEdge2/1E3 );
                END_IF;
                IF vqFeed_SheetEdge<>NO_POS_UM THEN (* Ho l'altra lettura? *)
                    (* Ho entrambe le letture: anziché fermarmi subito proseguo fino
                       a destinazione, in questo modo ho una ripetibilità del movimento *)
                    BeltsFeed.Cmd.MaxSpeed := vqBelts_FwdSpd;
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_MEASBCK : (* Movimento indietro dopo misura *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd=CMD_STOP THEN
            vnShiftFeed_Sts := STS_ERROR;
        (* Se posizionamento cinghie terminato *)
        ELSIF BeltsFeed.Cmd.Target=0 THEN
            (* Notifica se non sono arrivato *)
            IF NOT BeltsFeed.Arrived THEN
                dlog( Txt:='fbShiftFeed: ! MEASBCK: Stopped at %ld != %ld', Lvl:=2, Val1:=vqFeed_SheetX/1E3, Val2:=TargetX/1E3 );
            END_IF;
            (* Vediamo se ho le due letture *)
            IF vqFeed_SheetEdge<>NO_POS_UM AND vqFeed_SheetEdge2<>NO_POS_UM THEN
                dlog( Txt:='fbShiftFeed: MEASBCK: Xbtm=%ld Xtop=%ld', Lvl:=2, Val1:=vqFeed_SheetEdge/1E3, Val2:=vqFeed_SheetEdge2/1E3 );
            ELSE
                dlog( Txt:='fbShiftFeed: ! MEASBCK: Missing measure: Xbtm=%ld Xtop=%ld', Lvl:=2, Val1:=vqFeed_SheetEdge/1E3, Val2:=vqFeed_SheetEdge2/1E3 );
            END_IF;
            (* Ok, basta così *)
            vnShiftFeed_Sts := STS_STOPPING;
        (* Intercetta uscita da tavolo di carico *)
        ELSIF fcFeedBegin.q OR IFC_FEED2_BEGIN THEN
            dlog( Txt:='fbShiftFeed: !! MEASBCK: Reached IFC_FEED_BEGIN after %ld mm', Lvl:=2, Val1:=BeltsFeed.CurrPos/1E3 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Rilevo abort cinghie *)
        ELSIF NOT BeltsFeed.Cmd.Activate THEN
            dlog( Txt:='fbShiftFeed: !! MEASBCK: Belts aborted', Lvl:=2 );
            vnShiftFeed_Sts := STS_ERROR;
        (* Se cinghie in moto *)
        ELSIF BeltsFeed.Status=BLT_OPERATING THEN
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqFeed_SheetX := StartedX + BeltsFeed.CurrPos;

            (* Rilevo letture fotocellula bassa 'IFC_FEED_END' *)
            IF fcFeedEnd.fall_delayed THEN
                (* Posizione effettiva bordo avanti *)
                Delta := vqXph_FeedEnd;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(BeltsFeed.CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                StartedX := StartedX + (Delta - vqFeed_SheetX);
                vqFeed_SheetX := Delta; (* Aggiorno subito posizione bordo avanti *)
                (* Cambio target se fattibile *)
                Delta := TargetX - vqFeed_SheetX; (* Quanto mi manca ad arrivare *)
                IF Delta < vq[ivqAx_StopSpace+Ca.Idx-1] THEN (* Nota: sono tutti e due negativi, sto andando indietro *)
                    BeltsFeed.Cmd.Target := BeltsFeed.CurrPos + Delta;
                END_IF;

                (* Metto via la lettura *)
                IF vqFeed_SheetEdge=NO_POS_UM THEN
                    (* Nota: non uso 'vqFeed_SheetX' perché deve essere confrontabile *)
                    vqFeed_SheetEdge := BeltsFeed.CurrPos;
                    dlog( Txt:='fbShiftFeed: MEASBCK: IFC_FEED_END at %ld mm', Lvl:=4, Val1:=vqFeed_SheetEdge/1E3 );
                END_IF;
                IF vqFeed_SheetEdge2<>NO_POS_UM THEN
                    (* Ho entrambe le letture: proseguo fino alla posizione di accumulo *)
                    BeltsFeed.Cmd.MaxSpeed := vqBelts_BckSpd;
                END_IF;
            END_IF;

            (* Rilevo letture fotocellula alta 'IFC_FEED_END2' *)
            fcFeedEnd2( in:=IFC_FEED_END2 ); (* Fotocellula alta fine modulo di carico *)
            IF fcFeedEnd2.fall THEN
                (* Posizione effettiva bordo avanti *)
                Delta := vqXph_FeedEnd2;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(BeltsFeed.CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                StartedX := StartedX + (Delta - vqFeed_SheetX);
                vqFeed_SheetX := Delta; (* Aggiorno subito posizione bordo avanti *)
                (* Cambio target se fattibile *)
                Delta := TargetX - vqFeed_SheetX; (* Quanto mi manca ad arrivare *)
                IF Delta < vq[ivqAx_StopSpace+Ca.Idx-1] THEN (* Nota: sono tutti e due negativi, sto andando indietro *)
                    BeltsFeed.Cmd.Target := BeltsFeed.CurrPos + Delta;
                END_IF;

                (* Metto via la lettura *)
                IF vqFeed_SheetEdge2=NO_POS_UM THEN
                    (* Nota: non uso 'vqFeed_SheetX' perché deve essere confrontabile *)
                    vqFeed_SheetEdge2 := BeltsFeed.CurrPos;
                    dlog( Txt:='fbShiftFeed: MEASBCK: IFC_FEED_END2 at %ld mm', Lvl:=4, Val1:=vqFeed_SheetEdge2/1E3 );
                END_IF;
                IF vqFeed_SheetEdge<>NO_POS_UM THEN
                    (* Ho entrambe le letture: proseguo fino alla posizione di accumulo *)
                    BeltsFeed.Cmd.MaxSpeed := vqBelts_BckSpd;
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_OP_INIT : (* Inizializzando modalità spostamenti assoluti *)
        (* Attendo cinghie alte e trasportatori caricatrice in inseguimento *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd<>SHFCMD_FEED_SHFTOP OR NOT BeltsFeed.Cmd.Activate THEN
            dlog( Txt:='fbShiftFeed: !! ShftOp: Abort on init', Lvl:=2 );
            IF NOT BeltsFeed.Cmd.Activate THEN vnShiftFeed_Cmd := CMD_STOP; END_IF;
            vnShiftFeed_Sts := SHF_FEED_OP_END;
        (* Attendo cinghie carico pronte e caricatrice in inseguimento *)
        ELSIF BeltsFeed.Status=BLT_ENABLED AND (Loader.Following OR vnLoader_Type=0) THEN
            Ca.KeepEnabled := TRUE; (* Voglio mantenere l'asse abilitato *)

            (* Ok, siamo pronti, inizializzo dati misura *)
            vbShftOp_NoSynch := FALSE; (* Default: Sincronizza la posizione *)
            (* Posizione di partenza *)
            (* StartedX := SEL( fcFeedBegin.q, vqLdr_LoaderSheetX, vqShftOp_SheetX ); *)
            IF fcFeedBegin.q THEN
                (* TODO 1: Ripresa lavorazione? Prendo la posizione dal registro *)
                StartedX := vqShftOp_SheetX;
            ELSE
                (* Inizializzo dati misura *)
                StartedX := vqLdr_LoaderSheetX;
            END_IF;
            (* Posizione bordo avanti *)
            vqFeed_SheetX := StartedX;
            vqShftOp_SheetX := StartedX;
            TargetX := vqFeedLoad_TgtX; (* Posizione Finale? *)

            dlog( Txt:='fbShiftFeed: ShftOp: Started at %ld mm', Lvl:=2, Val1:=vqShftOp_SheetX/1E3 );

            RST_MSG(MSG_SHFTOP_INIT);
            vnShiftFeed_Sts := SHF_FEED_OP_IDLE;
        ELSIF NOT IS_MSG(MSG_SHFTOP_INIT) THEN
            SET_MSG(MSG_SHFTOP_INIT,'MSG_SHFTOP_INIT',0);
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_OP_IDLE : (* Modalità spostamenti assoluti attesa comando *)
        (* Attendo cinghie alte e trasportatori caricatrice in inseguimento *)
        (* vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED; *)
        (* Rilevo condizioni abort *)
        IF vnShiftFeed_Cmd<>SHFCMD_FEED_SHFTOP OR NOT BeltsFeed.Cmd.Activate THEN
            IF NOT BeltsFeed.Cmd.Activate THEN
                dlog( Txt:='fbShiftFeed: !! ShftOp: Abort at %ld mm', Lvl:=2, Val1:=vqShftOp_SheetX/1E3 );
                vnShiftFeed_Cmd := CMD_STOP;
            END_IF;
            vnShiftFeed_Sts := SHF_FEED_OP_END;
        ELSIF vqShftOp_Tgt<>0 THEN
            vnShftOp_Seq := SEQ_START; (* Inizializzo risultato *)

            (* Comando traslazione *)
            BeltsFeed.Cmd.Accel := 100; (* [%] *)
            BeltsFeed.Cmd.MaxSpeed := vqShftOp_BeltsSpd;

            IF NOT fcFeedBegin.q AND NOT vbShftOp_NoSynch AND vqFeed_SheetWidth=0 THEN
                (* Dobbiamo sincronizzare la posizione (se lastra non ancora trasferita) *)
                Ca.Incremental := TRUE; (* Movimento relativo di ricerca *)
                BeltsFeed.Cmd.Target := vqFeed_Width/2; (* Nota: assumo senso positivo *)
                dlog( Txt:='fbShiftFeed: ShftOp: Search movement (%ld mm)', Lvl:=5, Val1:=BeltsFeed.Cmd.Target/1E3 );
                vnShiftFeed_Sts := SHF_FEED_OP_SRCH;
            ELSE
                (* Assumo posizione lastra già nota *)
                Ca.Incremental := FALSE; (* D'ora in poi movimenti assoluti *)
                (* Nota: Devo usare la posizione teorica, non BeltsFeed.CurrPos *)
                BeltsFeed.Cmd.Target := (Ca.CurrPos + Ca.CurrPosErr) + (vqShftOp_Tgt - vqShftOp_SheetX);
                dlog( Txt:='fbShiftFeed: ShftOp: Move to %ld = %ld + %ld - %ld)', Lvl:=5, Val1:=BeltsFeed.Cmd.Target/1E3, Val2:=BeltsFeed.CurrPos/1E3, Val3:=vqShftOp_Tgt/1E3, Val4:=vqShftOp_SheetX/1E3 );
                vnShiftFeed_Sts := SHF_FEED_OP_MOVE;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_OP_SRCH, SHF_FEED_OP_MOVE : (* Spostamento in corso *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftFeed_Cmd=CMD_STOP OR NOT BeltsFeed.Cmd.Activate OR BeltsFeed.Status<BLT_ENABLED THEN
            dlog( Txt:='fbShiftFeed: !! ShftOp: Abort (Status=%d Activate=%d)', Lvl:=2, Val1:=TO_DINT(BeltsFeed.Status), Val2:=TO_DINT(BeltsFeed.Cmd.Activate) );
            vnShiftFeed_Cmd := CMD_STOP;
            vnShiftFeed_Sts := SHF_FEED_OP_END;
        (* Rilevo arrivo in quota *)
        ELSIF BeltsFeed.Arrived THEN
            IF vnShiftFeed_Sts=SHF_FEED_OP_SRCH THEN
                dlog( Txt:='fbShiftFeed: !! ShftOp: IFC_FEED_BEGIN not found after %ld mm', Lvl:=2, Val1:=BeltsFeed.CurrPos/1E3 );
                vnShiftFeed_Cmd := CMD_STOP;
                vnShiftFeed_Sts := SHF_FEED_OP_END;
            ELSE
                dlog( Txt:='fbShiftFeed: ShftOp: Arrived to %ld mm', Lvl:=5, Val1:=vqShftOp_SheetX/1E3 );
                vqShftOp_Tgt := 0; (* Eat command *)
                vnShftOp_Seq := SEQ_DONE;
                vnShiftFeed_Sts := SHF_FEED_OP_IDLE;
            END_IF;
        (* Quando cinghie in moto *)
        ELSIF BeltsFeed.Status=BLT_OPERATING THEN
            (* Tengo traccia della posizione corrente del bordo lastra avanti *)
            vqFeed_SheetX := StartedX + BeltsFeed.CurrPos;
            vqShftOp_SheetX := vqFeed_SheetX;
            (* Rilevo impegno della fotocellula di fine carico *)
            IF fcFeedEnd.q THEN
                dlog( Txt:='fbShiftFeed: !! ShftOp: Sheet reached IFC_FEED_END', Lvl:=2 );
                vnShiftFeed_Sts := SHF_FEED_OP_END;
            (* Rilevo impegno della fotocellula prossimità arrivo *)
            ELSIF fcFeedNearEnd.rise THEN
                IF vnShiftFeed_Sts<>SHF_FEED_OP_SRCH THEN
                    (* Posizione effettiva bordo avanti *)
                    Delta := vqXph_FeedNearEnd;
                    IF vbShift_PhLatencyFix THEN
                        (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                        Delta := Delta + TO_DINT(TO_LREAL(BeltsFeed.CurrSpd) * vdPlcScanTime * 8.333E-3);
                    END_IF;
                    dlog( Txt:='fbShiftFeed: ShftOp: Reached FeedNearEnd at %ld (dx=%ld)', Lvl:=4, Val1:=vqShftOp_SheetX/1E3, Val2:=(Delta - vqShftOp_SheetX)/1E3 );
                    StartedX := StartedX + (Delta - vqShftOp_SheetX);
                    vqShftOp_SheetX := Delta; (* Aggiorno subito posizione bordo avanti *)
                    (* Cambio target se fattibile *)
                    Delta := vqShftOp_Tgt - vqShftOp_SheetX; (* Quanto mi manca ad arrivare *)
                    IF ABS(Delta) > ABS(vq[ivqAx_StopSpace+Ca.Idx-1]) THEN
                        BeltsFeed.Cmd.Target := BeltsFeed.CurrPos + Delta;
                    ELSE
                        dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=BeltsFeed.Cmd.Target/1E3, Val2:=(BeltsFeed.CurrPos + Delta)/1E3 );
                    END_IF;
                ELSE
                    dlog( Txt:='fbShiftFeed: !! ShftOp: Sheet reached IFC_FEED_NEAREND', Lvl:=2 );
                    vnShiftFeed_Cmd := CMD_STOP;
                    vnShiftFeed_Sts := SHF_FEED_OP_END;
                END_IF;
            (* Rilevo fotocellula inizio tavolo di carico (synch) *)
            ELSIF fcFeedBegin.rise AND BeltsFeed.CurrSpd>10 AND vnShiftFeed_Sts=SHF_FEED_OP_SRCH THEN
                (* Posizione effettiva bordo avanti *)
                Delta := vqXph_FeedBegin;
                IF vbShift_PhLatencyFix THEN
                    (* Correzione latenza: ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                    Delta := Delta + TO_DINT(TO_LREAL(BeltsFeed.CurrSpd) * vdPlcScanTime * 8.333E-3);
                END_IF;
                dlog( Txt:='fbShiftFeed: ShftOp: On IFC_FEED_BEGIN at %ld mm (dx=%ld)', Lvl:=4, Val1:=vqShftOp_SheetX/1E3, Val2:=(Delta - vqShftOp_SheetX)/1E3 );
                StartedX := StartedX + (Delta - vqShftOp_SheetX);
                vqShftOp_SheetX := Delta; (* Aggiorno subito posizione bordo avanti *)
                (* Cambio target *)
                BeltsFeed.Cmd.Target := BeltsFeed.CurrPos + (vqShftOp_Tgt - vqShftOp_SheetX);

                (* Misura lastra in caricamento *)
                vqFeed_SheetEdge := BeltsFeed.CurrPos;
                vqFeed_SheetWidth := 0;

                Ca.Incremental := FALSE; (* D'ora in poi movimenti assoluti *)
                vnShiftFeed_Sts := SHF_FEED_OP_MOVE; (* Sincronizzazione fatta *)
            END_IF;

            (* Quando caricatrice ancora coinvolta (lastra a cavallo) *)
            IF Loader.MoveSpd<>0 THEN
                (* Rilevo lastra completamente sul tavolo di carico *)
                IF fcFeedBegin.fall_delayed AND BeltsFeed.CurrSpd>10 AND vnShiftFeed_Sts>SHF_FEED_OP_SRCH THEN
                    (* Misura lastra in caricamento *)
                    vqFeed_SheetWidth := BeltsFeed.CurrPos - vqFeed_SheetEdge;
                    dlog( Txt:='fbShiftFeed: ShftOp: Transferred sheet w=%ld mm', Lvl:=4, Val1:=vqFeed_SheetWidth/1E3 );
                    Loader.MoveSpd := 0; (* Non mi servono più i trasportatori della caricatrice *)
                (* Controllo che i trasportatori della caricatrice siano agganciati *)
                ELSIF vnLoader_Type>0 AND NOT Loader.Following THEN
                    dlog( Txt:='fbShiftFeed: !! ShftOp: Loader not following', Lvl:=2 );
                    SET_MSG(MSG_LDR_CANT_FWD,'MSG_LDR_CANT_FWD',0);
                    vnShiftFeed_Cmd := CMD_STOP;
                    vnShiftFeed_Sts := SHF_FEED_OP_END;
                END_IF;
            END_IF;

        END_IF;


    (* ------------------------------------------------------------------- *)
    SHF_FEED_OP_END : (* Uscendo da modalità spostamenti assoluti *)
        (* Assicura comandi di disattivazione *)
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_FEED; (* BeltsFeed.Cmd.Activate := FALSE; *)
        BeltsFeed.Cmd.Target := 0;
        Loader.MoveSpd := 0; (* Sgancio i trasportatori della caricatrice *)
        (* Attendo che sia le cinghie che la caricatrice siano a riposo *)
        IF BeltsFeed.Status=STS_IDLE AND (NOT Loader.Following OR vnLoader_Type=0) THEN
            dlog( Txt:='fbShiftFeed: ShftOp: Ending', Lvl:=5 );
            vqShftOp_Tgt := 0; (* Eat command *)
            Ca.Incremental := TRUE; (* Ripristino modalità normale (incrementale) *)
            Ca.KeepEnabled := FALSE; (* Normalmente lo tengo disabilitato *)
            vnShftOp_Seq := SEQ_ERROR;
            vnShiftFeed_Sts := STS_IDLE;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_STOPPING : (* Wait feed belts stopped and down *)
        (* Assicura comando di disattivazione *)
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_FEED;
        BeltsFeed.Cmd.Target := 0;
        IF BeltsFeed.Status=STS_IDLE THEN
            vnShiftFeed_Cmd := CMD_STOP; (* No queued commands *)
            vnShiftFeed_Sts := STS_IDLE;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_IDLE : (* Doing nothing *)
        (* Rispondi ai comandi *)
        IF vnShiftFeed_Cmd<>0 THEN

            IF (Belts.ManagedBelts & BIT_BELTS_FEED)<>0 THEN
                (* Prerequisito generale: cinghie del carico non usate dal sistema complessivo *)
                dlog( Txt:='fbShiftFeed: !! Already used (Cmd=%d)', Lvl:=2, Val1:=TO_DINT(vnShiftFeed_Cmd) );
                SET_MSG(MSG_BELTSFEED_BUSY,'MSG_BELTSFEED_BUSY',0);
                vnShiftFeed_Cmd := CMD_STOP; (* Eat *)
            (* Consenso cinghie? No, a seconda del comando
            ELSIF NOT BeltsFeed.Allow THEN
                SET_MSG(MSG_SHIFT_LOCKED,'MSG_SHIFT_LOCKED',0);
                dlog( Txt:='fbShiftFeed: !! Not allowed for Cmd=%d', Lvl:=1, Val1:=TO_DINT(vnShiftFeed_Cmd) );
                vnShiftFeed_Cmd := CMD_STOP; (* Eat
                vnShiftFeed_Sts := STS_ERROR; *)

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            (* Posizionamento dopo inserzione per allontanare lastra accumulata *)
            ELSIF vnShiftFeed_Cmd=SHFCMD_FEED_INSPLACE THEN
                (* Controllo requisiti *)
                IF NOT BeltsFeed.Allow THEN
                    SET_MSG(MSG_SHIFT_LOCKED,'MSG_SHIFT_LOCKED',0);
                    dlog( Txt:='fbShiftFeed: !! Not allowed for InsPlace', Lvl:=1 );
                    vnShiftFeed_Sts := STS_ERROR;
                ELSE
                    (* Comando il movimento di aggiustamento all'estrazione: *)
                    BeltsFeed.Cmd.Accel := 100; (* [%] *)
                    BeltsFeed.Cmd.MaxSpeed := vqBelts_SlowSpd;
                    Ca.Incremental := TRUE; (* Movimento incrementale *)
                    (* Scelgo di quanto andare indietro in modo intelligente:
                       Assicuro che la prossima lastra non possa collidere *)
                    (*                                Spazio tipico di stop indietro delle cinghie (è positivo) *)
                    BeltsFeed.Cmd.Target := -( 10E3 + fnRampSpace(V:=vqBelts_BckSpd, ta:=vq[ivqAx_DecTime+AX_CS-1], p:=vnBelts_VelPPd) );
                    BeltsFeed.Cmd.Activate := TRUE; (* Questo può essere importante se BeltsFeed è in corso di disattivazione! *)
                    (* Se sento la fotocellula, assicuro anche lo spazio tra le lastre *)
                    IF fcFeedEnd.q THEN
                        BeltsFeed.Cmd.Target := BeltsFeed.Cmd.Target - vqBelts_StackDist;
                    END_IF;
                    dlog( Txt:='fbShiftFeed: InsPlace (%ld mm)', Lvl:=3, Val1:=BeltsFeed.Cmd.Target/1E3 );

                    (* Nota: È fondamentale che questo movimentino si completi,
                       altrimenti avremo collisioni alla successiva inserzione! *)
                    vnShiftFeed_Sts := STS_MOVEINIT;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            (* Carico lastra da caricatrice/Movimenti etichettatura durante carico *)
            ELSIF vnShiftFeed_Cmd=SHFCMD_FEED_LOAD OR vnShiftFeed_Cmd=SHFCMD_FEED_SHFTOP THEN
                (* Controllo requisiti *)
                IF NOT BeltsFeed.Allow THEN
                    SET_MSG(MSG_SHIFT_LOCKED,'MSG_SHIFT_LOCKED',0);
                    dlog( Txt:='fbShiftFeed: !! Not allowed for Load', Lvl:=1 );
                    vnShiftFeed_Sts := STS_ERROR;
                ELSIF vnLoader_Type>0 AND NOT Loader.SheetReady THEN
                    SET_MSG(MSG_LDR_CANT_FWD,'MSG_LDR_CANT_FWD',0);
                    dlog( Txt:='fbShiftFeed: !! Loader not ready to give', Lvl:=1 );
                    vnShiftFeed_Sts := STS_ERROR;
                ELSIF BeltsFeed.Status=BLT_OPERATING THEN
                    dlog( Txt:='fbShiftFeed: !! Not ready for Load (Status=%d)', Lvl:=1, Val1:=TO_DINT(BeltsFeed.Status) );
                    vnShiftFeed_Sts := STS_ERROR;
                ELSIF fcFeedNearEnd.q OR fcFeedEnd.q THEN
                    SET_MSG(MSG_SHIFT_FEEDBUSY,'MSG_SHIFT_FEEDBUSY',0);
                    dlog( Txt:='fbShiftFeed: !! There is glass on Feed module', Lvl:=1 );
                    vnShiftFeed_Sts := STS_ERROR;
                ELSE
                    (* Ok, ci sono tutti i requisiti per caricare una lastra *)
                    (* Comando le cinghie carico 'BeltsFeed', BIT_BELTS_FEED, Ca.Idx
                         BeltsFeed.Cmd.MaxSpeed === Belts.MasterSpd
                           BeltsFeed.Cmd.Target === Belts.MasterTgt
                         BeltsFeed.Cmd.Activate === Belts.Cmd
                               BeltsFeed.Status === Belts.Status
                              BeltsFeed.Arrived === Belts.Master_Arrived *)
                    (* Procedo ad alzare le cinghie carico *)
                    vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED; (* BeltsFeed.Cmd.Activate := TRUE; *)

                    (* Inizializzazioni comuni: misura e altro *)
                    vqFeed_SheetEdge := 0;
                    vqFeed_SheetWidth := 0;
                    vbSheet_WasUpRight := FALSE; (* Invalido lastra squadrata *)

                    IF vnShiftFeed_Cmd=SHFCMD_FEED_LOAD THEN
                        (* Inizializzo dati misura *)
                        StartedX := vqLdr_LoaderSheetX; (* Posizione di partenza *)
                        TargetX := vqFeedLoad_TgtX; (* Posizione di arrivo *)
                        vqFeed_SheetX := StartedX; (* Posizione bordo avanti *)

                        (* Movimento traslazione: Movimento incrementale verso la posizione di carico *)
                        BeltsFeed.Cmd.Accel := 100; (* [%] *)
                        BeltsFeed.Cmd.MaxSpeed := vqBelts_LoadSpd;
                        Ca.Incremental := TRUE; (* Movimento incrementale *)
                        BeltsFeed.Cmd.Target := TargetX - StartedX;
                        BeltsFeed.Cmd.Activate := TRUE; (* Anticipo un po' le cose per resettare 'Arrived' *)
                        dlog( Txt:='fbShiftFeed: Load sheet from %ld to %ld mm spd=%ld m/min', Lvl:=4, Val1:=StartedX/1E3, Val2:=TargetX/1E3, Val3:=BeltsFeed.Cmd.MaxSpeed/1E6 );
                        (* Nota: Aziono i rulli della caricatrice quando sono pronto *)
                        vnShiftFeed_Sts := SHF_FEED_LDGET;
                    ELSIF vnShiftFeed_Cmd=SHFCMD_FEED_SHFTOP THEN
                        (* Servizio di movimentazione cinghie con 'vqShftOp_Tgt' per etichettatura su ponte *)

                        (* Se c'è la caricatrice richiedo i suoi trasportatori
                           agganciati al mio movimento *)
                        IF vnLoader_Type>0 THEN
                            (* Nota: Questo è inteso come comando di inseguimento,
                                     non marcia in velocità! I trasportatori della
                                     caricatrice devono inseguire un encoder esterno *)
                            Loader.MoveSpd := 1; (* Follow me *)
                        END_IF;

                        vnShftOp_Seq := SEQ_START; (* Inizializzo risultato *)
                        vnShiftFeed_Sts := SHF_FEED_OP_INIT;
                    END_IF;

                END_IF; (* Requisiti per SHFCMD_FEED_LOAD/SHFCMD_FEED_SHFTOP *)

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            (* Restituzione sfrido a caricatrice *)
            ELSIF vnShiftFeed_Cmd=SHFCMD_FEED_UNLOAD THEN
                (* Controllo requisiti *)
                IF BeltsFeed.Status=BLT_OPERATING THEN
                    dlog( Txt:='fbShiftFeed: !! Not ready for Unload (Status=%d)', Lvl:=1, Val1:=TO_DINT(BeltsFeed.Status) );
                    vnShiftFeed_Sts := STS_ERROR;
                ELSE
                    (* Ok, ci sono tutti i requisiti per restituire una lastra *)
                    (* Richiedo all'operatore di allineare opportunamente in Y
                       la lastra da restituire.
                       Come stato uso la richiesta stessa: *)
                    IF vbLdr_BlksOnUnload AND NOT IS_MSG(REQ_PREPARE_UNLOAD) THEN
                        SET_MSG(REQ_PREPARE_UNLOAD,'REQ_PREPARE_UNLOAD',0);
                        (* Qui dò una mano all'operatore per squadrare la lastra,
                           vediamo cosa posso usare *)
                        IF vnFeedWheels_Type>0 THEN (* AND (vqWorkSettings & BIT_AUTOWHEELS)<>0 *)
                            (* Ci sono le rotelle 'ID_FEED_WHEELS': squadro la lastra con quelle *)
                            dlog( Txt:='fbShiftFeed: UNLOAD: Auto wheels', Lvl:=3 );
                            vbFeedWheels_Cmd := TRUE;
                        ELSE
                            (* Se presenti, sfrutto i piedini di carico di 'ID_FEED_TILT' *)
                            FeedTilt.LoadBlocksCmd := vbFeedTilt_Present;
                        END_IF;
                        (* Ok, ora esci dal comando, procederemo con la seconda pressione *)
                        vnShiftFeed_Cmd := CMD_STOP;
                    (* Abbassiamo i piedini di carico (e aspettiamo che si abbassino) *)
                    ELSIF FeedTilt.LoadBlocksCmd OR FeedTilt.LoadBlocksOut THEN
                        FeedTilt.LoadBlocksCmd := FALSE;
                    (* Assicura le rotelle di squadratura via *)
                    ELSIF vbFeedWheels_Cmd OR NOT vb[ivbAtRest+ID_FEED_WHEELS] THEN
                        vbFeedWheels_Cmd := FALSE;
                    ELSIF NOT Loader.CanReceive THEN
                        SET_MSG(MSG_LDR_CANT_BCK,'MSG_LDR_CANT_BCK',0);
                        dlog( Txt:='fbShiftFeed: !! Loader not ready to receive', Lvl:=1 );
                        vnShiftFeed_Sts := STS_ERROR;
                    ELSIF NOT BeltsFeed.Allow THEN
                        SET_MSG(MSG_SHIFT_LOCKED,'MSG_SHIFT_LOCKED',0);
                        dlog( Txt:='fbShiftFeed: !! Not allowed for Unload', Lvl:=1 );
                        vnShiftFeed_Sts := STS_ERROR;
                    ELSE (* Procediamo *)
                        RST_MSG(REQ_PREPARE_UNLOAD);
                        (* Inizializzo dati misura *)
                        StartedX := vqFeedLoad_TgtX; (* Posizione di partenza *)
                        TargetX := vqLdr_LoaderSheetX; (* Posizione di arrivo *)
                        vqFeed_SheetX := StartedX; (* Posizione bordo avanti *)
                        vqFeed_SheetEdge := 0;
                        vqFeed_SheetWidth := 0;
                        (* Comando solo le cinghie carico 'BeltsFeed', BIT_BELTS_FEED, Ca.Idx *)
                        (* Spostamento della traslazione: Movimento incrementale verso la caricatrice *)
                        BeltsFeed.Cmd.Accel := 100; (* [%] *)
                        BeltsFeed.Cmd.MaxSpeed := vqBelts_UnloadSpd;
                        Ca.Incremental := TRUE; (* Movimento incrementale *)
                        BeltsFeed.Cmd.Target := TargetX - StartedX;
                        BeltsFeed.Cmd.Activate := TRUE; (* Anticipo un po' le cose per resettare 'Arrived' *)
                        (* Procedo ad alzare le cinghie carico *)
                        vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED; (* BeltsFeed.Cmd.Activate := TRUE; *)
                        (* ...Unitamente ai trasportatori della caricatrice *)
                        Loader.MoveSpd := -BeltsFeed.Cmd.MaxSpeed; (* [um/min] *)
                        dlog( Txt:='fbShiftFeed: Unload sheet from %ld to %ld mm spd=%ld m/min', Lvl:=4, Val1:=StartedX/1E3, Val2:=TargetX/1E3, Val3:=BeltsFeed.Cmd.MaxSpeed/1E6 );

                        vnShiftFeed_Sts := SHF_FEED_UNLDPUT;
                    END_IF;
                END_IF; (* Requisiti per SHFCMD_FEED_UNLOAD *)

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            (* Misura fuorisquadra bordo avanti della lastra con fotocellule a fine tavolo *)
            ELSIF vnShiftFeed_Cmd=SHFCMD_FEED_MEASHANGLE THEN
                (* Controllo requisiti *)
                IF BeltsFeed.Status=BLT_OPERATING THEN
                    dlog( Txt:='fbShiftFeed: !! Not ready for MeasAngle (Status=%d)', Lvl:=2, Val1:=TO_DINT(BeltsFeed.Status) );
                    vnShiftFeed_Sts := STS_ERROR;
                (* ELSIF fcFeedEnd.q OR IFC_FEED_END2 THEN
                    dlog( Txt:='fbShiftFeed: !! Meas sensors already engaged', Lvl:=2 );
                    vnShiftFeed_Sts := STS_ERROR; *)
                ELSE
                    (* Questa è la sequenza per misurare angolo fuorisquadra
                       del bordo avanti della lastra caricata: la muovo verso
                       fine tavolo fino a far leggere entrambe le fotocellule
                       'IFC_FEED_END' e 'IFC_FEED_END2' *)
                    (* Inizializzo dati misura *)
                    vdAngle_Hfwd := 0.0; (* Nota: il valore 0 è assurdo *)
                    vqMeas_Hfwd_Dx := 0; (* Nota: questo è plausibile, ma si guarda il precedente *)
                    vqFeed_SheetEdge := NO_POS_UM;
                    vqFeed_SheetEdge2 := NO_POS_UM;

                    IF fcFeedEnd.q OR IFC_FEED_END2 THEN
                        (* Movimento ricerca fotocellule indietro *)
                        StartedX := vqFeed_Xend; (* Posizione bordo avanti iniziale stimata *)
                        TargetX := vqXph_FeedEnd - vqBelts_StackDist; (* vqFeedLoad_TgtX Minima posizione di ricerca *)
                        vnShiftFeed_Sts := SHF_FEED_MEASBCK;
                    ELSE
                        (* Movimento ricerca fotocellule avanti *)
                        StartedX := vqXph_FeedEnd - vqBelts_StackDist - 300E3; (* vqFeedLoad_TgtX Posizione bordo avanti iniziale stimata *)
                        TargetX := vqFeed_Xend; (* Massima posizione di ricerca *)
                        vnShiftFeed_Sts := SHF_FEED_MEASFWD;
                    END_IF;
                    dlog( Txt:='fbShiftFeed: MeasAngle from %ld to %ld mm spd=%ld m/min', Lvl:=4, Val1:=StartedX/1E3, Val2:=TargetX/1E3, Val3:=BeltsFeed.Cmd.MaxSpeed/1E6 );

                    BeltsFeed.Cmd.Accel := 100; (* [%] *)
                    BeltsFeed.Cmd.MaxSpeed := vqBelts_ProbeSpd;
                    Ca.Incremental := TRUE; (* Movimento incrementale *)
                    BeltsFeed.Cmd.Target := TargetX - StartedX;
                    BeltsFeed.Cmd.Activate := TRUE; (* Anticipo un po' le cose per resettare 'Arrived' *)
                    (* Procedo ad alzare le cinghie carico *)
                    vnBelts_Act := vnBelts_Act OR BIT_BELTS_FEED;
                END_IF; (* Requisiti per SHFCMD_FEED_MEASHANGLE *)

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ELSE
                dlog( Txt:='fbShiftFeed: !! Unknown cmd=%d', Lvl:=1, Val1:=TO_DINT(vnShiftFeed_Cmd));
                vnShiftFeed_Sts := STS_ERROR;
            END_IF; (* -- See command *)
        END_IF; (* -- Comando attivo *)


    (* ------------------------------------------------------------------- *)
    ELSE (* Errore sequenza (STS_ERROR) *)
        (* vnShiftFeed_Seq := SEQ_ERROR; (* Risultato di errore *)
        vnShiftFeed_Cmd := CMD_STOP; (* Eat command *)
        (* Assicuro cinghie carico disabilitate *)
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_FEED; (* BeltsFeed.Cmd.Activate := FALSE; *)
        BeltsFeed.Cmd.Target := 0;
        (* Ferma richiesta a caricatrice *)
        Loader.MoveSpd := 0;
        vnShiftFeed_Sts := STS_STOPPING;

END_CASE; (* -- Feed belts sequences *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbShiftAlgn

{ DE:"Sequenze delle cinghie su riscontri" }

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vdPlcScanTime : LREAL; { DE:"Tempo di scansione del PLC [s]" }
	vbShift_PhLatencyFix : BOOL; { DE:"Applica correzione latenza fotocellule" }
	vqAx_StopSpaceTol : DINT; { DE:"Tolleranza sul calcolo dello spazio di stop [um]" }
	vqAlgnDlvr_Xbck : DINT; { DE:"Posizione bordo indietro vetro da consegnare [um]" }
	vqAlgnDlvr_Tgt : DINT; { DE:"Posizione bordo avanti dove consegnare [um]" }
	vqAlgnDlvr_Width : DINT; { DE:"Larghezza vetro da consegnare [um]" }
	vqAlgnDlvr_Ybtm : DINT; { DE:"Posizione Y basso vetro da consegnare [um]" }
	vqAlgnDlvr_Ytop : DINT; { DE:"Posizione Y alto vetro da consegnare [um]" }
	vqAlgnDlvr_PausePos : DINT; { DE:"Richiesta pausa consegna pezzo (posizione bordo indietro) [um]" }
	vnShiftAlgn_Cmd : INT; { DE:"Comando a cinghie riscontri" }
	vnShiftAlgn_Sts : INT; { DE:"Stato/Risultato sequenze cinghie riscontri" }
	Co : fbM32Axis; { DE:"Asse cinghie/Conveyors zona fine linea/uscita pezzi (Output) AX_CO" }
	Cr : fbM32Axis; { DE:"Asse rulli modulo riscontro AX_CR" }
	OutZone : fbOutZone; { DE:"Zona fine linea" }
	BeltsOutZone : fbBeltsOutZone; { DE:"Cinghie a fine linea" }
	RollsAlgn : fbRollsAlgn; { DE:"Rulli/Cinghie di trasporto su modulo riscontri" }
	Belts : fbBelts; { DE:"Gestore movimentazione cinghie" }
	vnBelts_Act : INT; { DE:"Maschera forzatura attivazione cinghie" }
	Shiftable : fbShiftable; { DE:"Controllo trasportabilità con cinghie" }
	vnBeltsAlgn_N : INT; { DE:"Numero delle cinghie riscontro" }
	vqBeltsAlgn_Size : DINT; { DE:"Larghezza banda gommmata cinghie riscontro [um]" }
	fcOutzoneEnd : fbPhotoCell; { DE:"Fotocellula a fine linea (IFC_OUTZONE_END)" }
	fcOutzoneNearEnd : fbPhotoCell; { DE:"Fotocellula prossimità fine linea (IFC_OUTZONE_NEAREND)" }
	fcOutzoneBegin : fbPhotoCell; { DE:"Fotocellula fine zona cinghie riscontro e inizio zona uscita pezzi a fine linea (IFC_OUTZONE_BEGIN)" }
	vqXph_OutZoneBegin : DINT; { DE:"Ascissa fotocellula inizio zona fine linea [um]" }
	vqXph_OutZoneNearEnd : DINT; { DE:"Ascissa fotocellula prossimità fine zona fine linea [um]" }
	vqXph_OutZoneEnd : DINT; { DE:"Ascissa fotocellula fine zona fine linea [um]" }
	vqYph_OutZoneEnd : DINT; { DE:"Ordinata fotocellula fine zona fine linea [um]" }
	vbShiftAlgn_MoreChecks : BOOL; { DE:"Abilita controlli sicurezza aggiuntivi nella consegna con cinghie" }
	vqShiftAlgn_PassMinWidth : DINT; { DE:"Larghezza minima per trasferimento tra cinghie riscontro e fine linea [um]" }
	vqShiftAlgn_DeliverSpd : DINT; { DE:"Velocità consegna pezzo [um/min]" }
	vqX_AlgnBeltsBegin : DINT; { DE:"Ascissa inizio rulli/cinghie sui riscontri [um]" }
	vqX_AlgnBeltsEnd : DINT; { DE:"Ascissa fine rulli/cinghie sui riscontri [um]" }
	vbAlgnDlvr_BringEarly : BOOL; { DE:"Comincia subito a portare il pezzo al limite della zona occupata" }
	vqX_AlgnTableEnd : DINT; { DE:"Ascissa legno fine tavolo riscontri [um]" }
	vnClampAlgn_Cmd : INT; { DE:"Comando discesa premilastra lato riscontri" }
	vbDtch_HoldGlassAlgn : BOOL; { DE:"Tieni fermo vetro su riscontri" }
	vnAlgnBlocks_Sts : INT; { DE:"Stato dei piedini di riscontro" }
	vqAlgn_XroomP : DINT; { DE:"Ingombro avanti dei piedini riscontri selezionati [um]" }
	vnAlgn_Cmd : INT; { DE:"Comando generale riscontri" }
	END_VAR

	VAR
	Result : BOOL; { DE:"Risultato sequenze" }
	Delta : DINT; { DE:"Temporaneo calcoli" }
	StartedXbck : DINT; { DE:"Posizione inizio sequenze" }
	TargetXfwd : DINT; { DE:"Quota obiettivo corrente del bordo avanti" }
	WaitRollsIdle : BOOL; { DE:"Stato interno per sapere se attendere i rulli/cinghie riscontro" }
	Xbck_CheckEnd : DINT; { DE:"Limite quota del bordo indietro per cui dare errore se si incontra IFC_OUTZONE_END" }
	MetFtc : INT; { DE:"Indice ultima fotocellula incontrata" }
	END_VAR

	{ CODE:ST }(*    fbShiftAlgn (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Sequenze traslazione su modulo riscontri
        .Estrazione/Evacuazione a fine linea

      DETAILS
      ----------------------------------------------
      Le cinghie a fine linea sono sempre il master
      del movimento, mentre quelle dei riscontri
      inseguono.
*)

(* -- Align belts sequences (for delivering) --
   Qui parallelizzo le sequenze di movimentazione con le
   sole cinghie riscontro: evacuazione pezzo *)
CASE vnShiftAlgn_Sts OF

    (* ------------------------------------------------------------------- *)
    STS_MOVEINIT : (* Commanding movement *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftAlgn_Cmd=CMD_STOP THEN
            (* dlog( Txt:='fbShiftAlgn: !! MOVEINIT: Abort', Lvl:=2 ); *)
            vnShiftAlgn_Sts := STS_ERROR;
        ELSE
            (* Attivazione cinghie master *)
            IF BeltsOutZone.Allow AND OutZone.Free THEN
                vnBelts_Act := vnBelts_Act OR BIT_BELTS_OUTZONE;
            END_IF;
            (* Attivazione eventuale inseguimento delle cinghie riscontro *)
            IF vnShiftAlgn_Cmd=CMD_FULLMOVETO AND RollsAlgn.Allow AND OutZone.Free THEN
                RollsAlgn.Cmd.Follow := Co.Idx;
                RollsAlgn.Cmd.Target := 0;
            END_IF;

            (* Voglio il premilastra riscontro alto! *)
            IF NOT vb[ivbAtRest+ID_CLAMP_ALGN] THEN
                vbDtch_HoldGlassAlgn := FALSE; (* Visto che alzo il vetro, questo non è necessario *)
                vnClampAlgn_Cmd := CMD_STOP;
            (* Se intralceranno il moto voglio piedini riscontro bassi *)
            (* Assumo che debba andare in avanti, altrimenti dovrei vedere il segno
               di: vqAlgnDlvr_Tgt - (vqAlgnDlvr_Xbck + vqAlgnDlvr_Width) *)
            ELSIF vnAlgnBlocks_Sts>=TS_GOINGON AND vqAlgn_XroomP>vqAlgnDlvr_Xbck THEN
                IF vnAlgn_Cmd=CMD_STOP THEN
                    dlog( Txt:='fbShiftAlgn: ! Reset AlgnBlocks (%ld)', Lvl:=3, Val1:=vqAlgn_XroomP/1E3 );
                    vnAlgn_Cmd := CMD_PARK;
                END_IF;
            (* Se andrò ad occuparla voglio zona fine linea libera *)
            ELSIF NOT OutZone.Free AND
                  (vqAlgnDlvr_Xbck+vqAlgnDlvr_Width)<OutZone.Xbusy AND
                  vqAlgnDlvr_Tgt>OutZone.Xbusy THEN
                SET_MSG(MSG_OUTZONE_BUSY,'MSG_OUTZONE_BUSY',0); (* Deliver service *)
                (* Potrei portare il pezzo fin dove riesco
                   Comincio a portare avanti il pezzo con le sole
                   cinghie riscontro fino al loro limite *)
                IF vbAlgnDlvr_BringEarly AND
                   vqAlgnDlvr_PausePos<=0 AND OutZone.Xbusy>vqX_AlgnBeltsEnd AND
                   vqX_AlgnBeltsEnd > (vqAlgnDlvr_Xbck + vqAlgnDlvr_Width) AND
                   RollsAlgn.Allow AND RollsAlgn.Status<BLT_STOPPING THEN
                    RollsAlgn.Cmd.Accel := 100;
                    RollsAlgn.Cmd.MaxSpeed := vqShiftAlgn_DeliverSpd;
                    Cr.Incremental := TRUE;
                    StartedXbck := vqAlgnDlvr_Xbck;
                    RollsAlgn.Cmd.Target := vqX_AlgnBeltsEnd - (vqAlgnDlvr_Xbck + vqAlgnDlvr_Width);
                    dlog( Txt:='fbShiftAlgn: Approaching (%ld)', Lvl:=4, Val1:=RollsAlgn.Cmd.Target/1E3 );
                    vnShiftAlgn_Sts := SHIFTALGN_APPRCHINIT;
                END_IF;
            (* Controllo condizioni di start movimento *)
            ELSIF BeltsOutZone.Status=BLT_ENABLED AND
                  (vnShiftAlgn_Cmd<>CMD_FULLMOVETO OR (RollsAlgn.Cmd.Follow=Co.Idx AND RollsAlgn.Status=BLT_OPERATING)) THEN
                (* Comando movimento master *)
                BeltsOutZone.Cmd.Accel := 100; (* [%] *)
                BeltsOutZone.Cmd.MaxSpeed := vqShiftAlgn_DeliverSpd;
                StartedXbck := vqAlgnDlvr_Xbck;

                (* Dove devo andare? *)
                (* IF vqAlgnDlvr_PausePos>0 THEN
                    (* È richiesta una fermata temporanea intermedia (probabilmente per applicare una etichetta) * )
                    IF vqAlgnDlvr_PausePos < vqAlgnDlvr_Xbck THEN
                        (* Ho già superato la posizione dove dovrei fermarmi! * )
                        dlog( Txt:='fbShiftAlgn: Pause: Reached %ld > %ld mm', Lvl:=3, Val1:=vqAlgnDrag_Xbck/1E3, Val2:=vqAlgnDlvr_PausePos/1E3 );
                        vnShiftAlgn_Sts := SHIFTALGN_PAUSED;
                        RETURN;
                    ELSE
                        (* Procedo verso la posizione di pausa * )
                        dlog( Txt:='fbShiftAlgn: Going to pause in %ld mm', Lvl:=3, Val1:=vqAlgnDlvr_PausePos/1E3 );
                        TargetXfwd := vqAlgnDlvr_PausePos + vqAlgnDlvr_Width;
                    END_IF;
                ELSE *)
                TargetXfwd := vqAlgnDlvr_Tgt;
                Delta := MIN(100E3,vqAlgnDlvr_Width/2); (* Tolleranza posizione nei controlli *)
                Xbck_CheckEnd := vqXph_OutZoneEnd - vqAlgnDlvr_Width - Delta;
                (* Xbck_CheckNearEnd := vqXph_OutZoneNearEnd - vqAlgnDlvr_Width - Delta; *)
                (* Xbck_CheckBegin := vqXph_OutZoneBegin - vqAlgnDlvr_Width - Delta; *)

                Co.Incremental := TRUE; (* Movimento incrementale *)
                BeltsOutZone.Cmd.Target := vqAlgnDlvr_Tgt - (vqAlgnDlvr_Xbck + vqAlgnDlvr_Width);
                dlog( Txt:='fbShiftAlgn: Moving from %ld to %ld mm (%ld)', Lvl:=4, Val1:=(vqAlgnDlvr_Xbck + vqAlgnDlvr_Width)/1E3, Val2:=TargetXfwd/1E3, Val3:=BeltsOutZone.Cmd.Target/1E3 );

                vnShiftAlgn_Sts := STS_WAITMOVE;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_WAITMOVE : (* Wait belts movement start *)
        (* Rilevo condizioni abort sequenza *)
        IF vnShiftAlgn_Cmd=CMD_STOP OR NOT BeltsOutZone.Cmd.Activate THEN
            (* dlog( Txt:='fbShiftAlgn: !! WAITMOVE: Abort', Lvl:=2 ); *)
            vnShiftAlgn_Sts := STS_ERROR;
        (* Attendi movimento partito *)
        ELSIF BeltsOutZone.Status=BLT_OPERATING AND NOT BeltsOutZone.Arrived THEN

            (* Un controllo di sicurezza sullo stato delle fotocellule: Non voglio vetri avanti *)
            Delta := vqAlgnDlvr_Xbck + vqAlgnDlvr_Width; (* Posizione presunta del bordo avanti *)
            IF fcOutzoneEnd.q THEN
                MetFtc := IDX_FC_OUTZONE_END;
                IF vbShiftAlgn_MoreChecks AND Delta<vqXph_OutZoneEnd THEN (* vqAlgnDlvr_Xbck<Xbck_CheckEnd *)
                    dlog( Txt:='fbShiftAlgn: !! IFC_OUTZONE_END (Xo=%ld<%ld)', Lvl:=2, Val1:=Delta/1E3, Val2:=(Xbck_CheckEnd+vqAlgnDlvr_Width)/1E3 );
                    vnShiftAlgn_Sts := STS_ERROR;
                END_IF;
            ELSIF fcOutzoneNearEnd.q THEN
                MetFtc := IDX_FC_OUTZONE_NEAREND;
                IF vbShiftAlgn_MoreChecks AND Delta<vqXph_OutZoneNearEnd THEN (* vqAlgnDlvr_Xbck<Xbck_CheckNearEnd *)
                    dlog( Txt:='fbShiftAlgn: !! IFC_OUTZONE_NEAREND (Xo=%ld<%ld)', Lvl:=2, Val1:=Delta/1E3, Val2:=vqXph_OutZoneNearEnd/1E3 );
                    vnShiftAlgn_Sts := STS_ERROR;
                END_IF;
            ELSIF fcOutzoneBegin.q THEN
                MetFtc := IDX_FC_OUTZONE_BEGIN;
                IF vbShiftAlgn_MoreChecks AND Delta<vqXph_OutZoneBegin THEN (* vqAlgnDlvr_Xbck<Xbck_CheckBegin *)
                    dlog( Txt:='fbShiftAlgn: !! IFC_OUTZONE_BEGIN (Xo=%ld<%ld)', Lvl:=2, Val1:=Delta/1E3, Val2:=vqXph_OutZoneBegin/1E3 );
                    vnShiftAlgn_Sts := STS_ERROR;
                END_IF;
            ELSE
                MetFtc := INT#0;
            END_IF;

            IF vnShiftAlgn_Sts=STS_WAITMOVE THEN
                vnShiftAlgn_Sts := SEL(RollsAlgn.Cmd.Follow=Co.Idx, STS_MOVING, STS_FULLMOVING);
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_MOVING, (* Shifting just with BeltsOutZone *)
    STS_FULLMOVING : (* Shifting with also RollsAlign *)
        (* Rilevo arrivo in quota *)
        IF BeltsOutZone.Arrived THEN
            dlog( Txt:='fbShiftAlgn: Done at %ld mm (%ld)', Lvl:=3, Val1:=vqAlgnDlvr_Xbck/1E3, Val2:=BeltsOutZone.CurrPos/1E3 );
            IF TargetXfwd=vqAlgnDlvr_Tgt THEN
                Result := TRUE;
                vnShiftAlgn_Sts := STS_STOPPING;
            (* ELSIF vqAlgnDlvr_PausePos>0 AND TargetXfwd=(vqAlgnDlvr_PausePos+vqAlgnDlvr_Width) THEN
                (* Ho raggiunto la posizione di pausa * )
                (* dlog( Txt:='fbShiftAlgn: Paused at %ld mm (%ld)', Lvl:=3, Val1:=vqAlgnDlvr_Xbck/1E3, Val2:=BeltsOutZone.CurrPos/1E3 ); * )
                vnShiftAlgn_Sts := SHIFTALGN_PAUSED; *)
            ELSE
                (* Devo proseguire fino al target finale! *)
                vnShiftAlgn_Sts := STS_IDLE;
            END_IF;
        (* Rilevo condizioni abort sequenza *)
        ELSIF vnShiftAlgn_Cmd=CMD_STOP OR BeltsOutZone.Status<BLT_OPERATING THEN
            dlog( Txt:='fbShiftAlgn: !! Aborted', Lvl:=2 );
            vnShiftAlgn_Sts := STS_ERROR;
        (* ELSIF vnShiftAlgn_Sts=STS_FULLMOVING AND (RollsAlgn.Cmd.Follow<>Co.Idx OR RollsAlgn.Status<>BLT_OPERATING) THEN
            dlog( Txt:='fbShiftAlgn: !! RollsAlgn not following', Lvl:=2 );
            vnShiftAlgn_Sts := STS_ERROR; *)
        ELSE
            (* Tengo traccia della posizione corrente del bordo lastra indietro *)
            vqAlgnDlvr_Xbck := StartedXbck + BeltsOutZone.CurrPos;

            (* Rileva se è stata raggiunta una fermata temporanea intermedia *)
            IF vqAlgnDlvr_PausePos>0 AND (StartedXbck+Co.StopPos)>=vqAlgnDlvr_PausePos THEN
                (* dlog( Txt:='fbShiftAlgn: Paused at %ld mm (%ld)', Lvl:=3, Val1:=vqAlgnDlvr_Xbck/1E3, Val2:=BeltsOutZone.CurrPos/1E3 ); *)
                BeltsOutZone.Cmd.Target := 0; (* Stop con cinghie alte *)
                vnShiftAlgn_Sts := SHIFTALGN_PAUSING;
            END_IF;

            (* Sicurezze fotocellule e cambi target *)
            (* Nota: I cambi target li faccio solo sul bordo avanti *)
            (* Sicurezza per non buttare fuori vetro da modulo riscontri *)
            IF fcOutzoneEnd.q THEN
                MetFtc := IDX_FC_OUTZONE_END;
                (* Niente cambi target su questa per ora; se un domani dovrò buttare su un tavolo a valle...
                IF TargetXfwd>vqX_AlgnTableEnd AND vqX_OutTableEnd>vqX_AlgnTableEnd THEN *)
                IF vqAlgnDlvr_Xbck<Xbck_CheckEnd THEN
                   (* AND (vqX_OutTableEnd-vqX_AlgnTableEnd)<vqAlgnDlvr_Width (* Escludi se c'è un tavolo a fine linea? *)
                    dlog( Txt:='fbShiftAlgn: !! IFC_OUTZONE_END (Xfwd=%ld<%ld)', Lvl:=2, Val1:=(vqAlgnDlvr_Xbck+vqAlgnDlvr_Width)/1E3, Val2:=(Xbck_CheckEnd+vqAlgnDlvr_Width)/1E3 );
                    vnShiftAlgn_Sts := STS_ERROR;
                (* Se dovesse mancarmi ancora tanto ad arrivare, c'è qualcosa che non va! *)
                ELSIF (BeltsOutZone.Cmd.Target-BeltsOutZone.CurrPos) > (vqX_AlgnTableEnd-vqXph_OutZoneEnd) THEN
                    dlog( Txt:='fbShiftAlgn: !! IFC_OUTZONE_END (D=%ld)', Lvl:=2, Val1:=(BeltsOutZone.Cmd.Target-BeltsOutZone.CurrPos)/1E3 );
                    vnShiftAlgn_Sts := STS_ERROR;
                END_IF;
            END_IF;

            IF fcOutzoneNearEnd.rise THEN
                dlog( Txt:='fbShiftAlgn: Reached IFC_OUTZONE_NEAREND at %ld xfwd=%ld', Lvl:=4, Val1:=BeltsOutZone.CurrPos/1E3, Val2:=(vqAlgnDlvr_Xbck+vqAlgnDlvr_Width)/1E3 );
                (* Considero la lettura solo se: *)
                IF vqAlgnDlvr_Ybtm<vqYph_OutZoneEnd AND vqAlgnDlvr_Ytop>vqYph_OutZoneEnd (* Il vetro può essere letto *)
                   AND MetFtc<IDX_FC_OUTZONE_NEAREND THEN (* È la prima volta che la incontro *)
                    MetFtc := IDX_FC_OUTZONE_NEAREND;
                    Delta := vqXph_OutZoneNearEnd - vqAlgnDlvr_Width; (* Posizione effettiva bordo indietro *)
                    IF vbShift_PhLatencyFix THEN
                        (* Correzione latenza: Ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                        Delta := Delta + TO_DINT(TO_LREAL(BeltsOutZone.CurrSpd) * vdPlcScanTime * 8.333E-3);
                    END_IF;

                    (* Correggo solo se non ho un avanzamento eccessivo della posizione di arrivo *)
                    IF (vqAlgnDlvr_Xbck-Delta)<MIN(300E3,vqAlgnDlvr_Width/3) THEN
                        dlog( Txt:='xfwd=>%ld (%ld)', Lvl:=4, Val1:=(Delta+vqAlgnDlvr_Width)/1E3, Val2:=(Delta - vqAlgnDlvr_Xbck)/1E3 );
                        vqAlgnDlvr_Xbck := Delta; (* Aggiorno posizione bordo indietro *)
                        StartedXbck := vqAlgnDlvr_Xbck - BeltsOutZone.CurrPos;
                        (* Cambio target se fattibile *)
                        Delta := TargetXfwd - (vqAlgnDlvr_Xbck+vqAlgnDlvr_Width); (* Quanto mi manca ad arrivare *)
                        IF Delta > (Co.StopPos+vqAx_StopSpaceTol) (* Nota: Sono tutti e due positivi, sto andando avanti *)
                           AND Co.PosPhase<AFS_POS_DEC THEN
                            BeltsOutZone.Cmd.Target := BeltsOutZone.CurrPos + Delta;
                        ELSE
                            dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=BeltsOutZone.Cmd.Target/1E3, Val2:=(BeltsOutZone.CurrPos + Delta)/1E3 );
                        END_IF;
                    END_IF;
                END_IF;

            ELSIF fcOutzoneBegin.rise THEN
                dlog( Txt:='fbShiftAlgn: Reached IFC_OUTZONE_BEGIN at %ld xfwd=%ld', Lvl:=4, Val1:=BeltsOutZone.CurrPos/1E3, Val2:=(vqAlgnDlvr_Xbck+vqAlgnDlvr_Width)/1E3 );
                (* Considero la lettura solo se: *)
                IF vqAlgnDlvr_Ybtm<vqYph_OutZoneEnd AND vqAlgnDlvr_Ytop>vqYph_OutZoneEnd (* Il vetro può essere letto *)
                   AND MetFtc<IDX_FC_OUTZONE_BEGIN THEN (* È la prima volta che la incontro *)
                    MetFtc := IDX_FC_OUTZONE_BEGIN;
                    Delta := vqXph_OutZoneBegin - vqAlgnDlvr_Width; (* Posizione effettiva bordo indietro *)
                    IF vbShift_PhLatencyFix THEN
                        (* Correzione latenza: Ipotizzo che sia passato mezzo ciclo PLC: ∆ = dt/2 · v = dt · v [um/min] · ½/60 *)
                        Delta := Delta + TO_DINT(TO_LREAL(BeltsOutZone.CurrSpd) * vdPlcScanTime * 8.333E-3);
                    END_IF;

                    (* Correggo solo se non ho un avanzamento eccessivo della posizione di arrivo *)
                    IF (vqAlgnDlvr_Xbck-Delta)<MIN(300E3,vqAlgnDlvr_Width/3) THEN
                        dlog( Txt:='xfwd=>%ld (%ld)', Lvl:=4, Val1:=(Delta+vqAlgnDlvr_Width)/1E3, Val2:=(Delta - vqAlgnDlvr_Xbck)/1E3 );
                        vqAlgnDlvr_Xbck := Delta; (* Aggiorno posizione bordo indietro *)
                        StartedXbck := vqAlgnDlvr_Xbck - BeltsOutZone.CurrPos;
                        (* Cambio target se fattibile *)
                        Delta := TargetXfwd - (vqAlgnDlvr_Xbck+vqAlgnDlvr_Width); (* Quanto mi manca ad arrivare *)
                        IF Delta > (Co.StopPos+vqAx_StopSpaceTol) (* Nota: Sono tutti e due positivi, sto andando avanti *)
                           AND Co.PosPhase<AFS_POS_DEC THEN
                            BeltsOutZone.Cmd.Target := BeltsOutZone.CurrPos + Delta;
                        ELSE
                            dlog( Txt:='! Skip ChgTgt %ld=>%ld', Lvl:=2, Val1:=BeltsOutZone.Cmd.Target/1E3, Val2:=(BeltsOutZone.CurrPos + Delta)/1E3 );
                        END_IF;
                    END_IF;
                END_IF;
            END_IF;

            (* Libera le cinghie/rulli riscontri quando non servono più
               e controlla la condizione di passaggio *)
            IF RollsAlgn.Cmd.Follow=Co.Idx AND vqAlgnDlvr_Xbck>vqX_AlgnBeltsEnd AND NOT fcOutzoneBegin.q AND Co.MovingFwd THEN
                (* dlog( Txt:='fbShiftAlgn: Releasing RollsAlgn', Lvl:=6 ); *)
                IF vqAlgnDlvr_Width<vqShiftAlgn_PassMinWidth THEN
                    (* Questo vetro non può passare *)
                    dlog( Txt:='fbShiftAlgn: !! W=%ld < %ld mm', Lvl:=2, Val1:=vqAlgnDlvr_Width/1E3, Val2:=vqShiftAlgn_PassMinWidth/1E3 );
                    vnShiftAlgn_Sts := STS_ERROR;
                ELSE
                    (* Libera le cinghie/rulli riscontri e prosegui *)
                    dlog( Txt:='fbShiftAlgn: Freeing Cr at %ld > %ld mm', Lvl:=2, Val1:=vqAlgnDlvr_Xbck/1E3, Val2:=vqX_AlgnBeltsEnd/1E3 );
                    RollsAlgn.Cmd.Follow := 0;
                    vnBelts_Act := vnBelts_Act & NOT BIT_ROLLS_ALGN; (* RollsAlgn.Cmd.Activate := FALSE; *)
                    (* vbAlgnDlvr_AlmostDone := TRUE; (* Lo gestisco qui? *)
                    vnShiftAlgn_Sts := STS_MOVING;
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_STOPPING : (* Wait belts stopped and down *)
        (* Assicura comando di stop/disattivazione *)
        vnBelts_Act := vnBelts_Act & NOT BIT_BELTS_OUTZONE; (* BIT_ROLLS_ALGN *)
        BeltsOutZone.Cmd.Target := 0;
        (* Sgancio eventuale inseguimento quando il master è fermo *)
        IF BeltsOutZone.Status<BLT_STOPPING AND RollsAlgn.Cmd.Follow=Co.Idx THEN
            WaitRollsIdle := TRUE;
            RollsAlgn.Cmd.Follow := 0;
            vnBelts_Act := vnBelts_Act & NOT BIT_ROLLS_ALGN; (* RollsAlgn.Cmd.Activate := FALSE; *)
        END_IF;
        (* Rilevo stop e discesa completati *)
        IF BeltsOutZone.Status=STS_IDLE AND (RollsAlgn.Status=STS_IDLE OR NOT WaitRollsIdle) THEN
            WaitRollsIdle := FALSE;
            vqAlgnDlvr_Xbck := StartedXbck + BeltsOutZone.CurrPos; (* Aggiorno posizione *)
            vnShiftAlgn_Cmd := CMD_STOP; (* Eat, no queued commands *)
            vnShiftAlgn_Sts := SEL(Result,STS_IDLE,STS_DONE);
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHIFTALGN_APPRCHINIT : (* Inizio avvicinamento alla zona fine linea *)
        IF vnShiftAlgn_Cmd=CMD_STOP OR NOT RollsAlgn.Allow OR RollsAlgn.Cmd.Target=0 THEN
            vnShiftAlgn_Sts := STS_MOVEINIT;
        ELSIF RollsAlgn.Status=BLT_OPERATING THEN
            vnShiftAlgn_Sts := SHIFTALGN_APPRCH;
        END_IF;

    (* ------------------------------------------------------------------- *)
    SHIFTALGN_APPRCH : (* Avvicinando il pezzo alla zona fine linea *)
        (* Tengo traccia della posizione corrente del bordo lastra indietro *)
        vqAlgnDlvr_Xbck := StartedXbck + RollsAlgn.CurrPos;
        (* Rilevo movimento non più in esecuzione *)
        IF RollsAlgn.Arrived OR RollsAlgn.Status<BLT_OPERATING OR vnShiftAlgn_Cmd=CMD_STOP THEN
            dlog( Txt:='fbShiftAlgn: Approached at %ld mm (%ld)', Lvl:=3, Val1:=vqAlgnDlvr_Xbck/1E3, Val2:=RollsAlgn.CurrPos/1E3 );
            (* Torno a preparare il movimento che mi serve *)
            vnShiftAlgn_Sts := STS_MOVEINIT;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHIFTALGN_PAUSING : (* Fermandomi con cinghie alte *)
        (* BeltsOutZone.Cmd.Target := 0; (* Assicura comando di stop *)
        IF vnShiftAlgn_Cmd=CMD_STOP THEN (* Abort sequence *)
            (* dlog( Txt:='fbShiftAlgn: !! Abort', Lvl:=2 ); *)
            vnShiftAlgn_Sts := SEQ_ERROR;
        (* Rilevo stop completato *)
        ELSIF BeltsOutZone.Status<BLT_STOPPING THEN
            vqAlgnDlvr_Xbck := StartedXbck + BeltsOutZone.CurrPos; (* Aggiorno posizione *)
            vnShiftAlgn_Sts := SHIFTALGN_PAUSED;
        END_IF;


    (* ------------------------------------------------------------------- *)
    SHIFTALGN_PAUSED : (* Attendendo etichettatura *)
        IF vnShiftAlgn_Cmd=CMD_STOP THEN (* Abort sequence *)
            (* dlog( Txt:='fbShiftAlgn: !! Abort', Lvl:=2 ); *)
            vnShiftAlgn_Sts := SEQ_ERROR;
        ELSIF vqAlgnDlvr_PausePos=0 THEN
            (* dlog( Txt:='fbShiftAlgn: Prosecuting', Lvl:=5 ); *)
            vnShiftAlgn_Sts := STS_IDLE; (* Prosegui *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_ERROR : (* Errore sequenza *)
        (* Result := FALSE; (* Non necessario *)
        vnShiftAlgn_Sts := STS_STOPPING;


    (* ------------------------------------------------------------------- *)
    ELSE (* Idle: STS_IDLE, STS_DONE *)

        (* Rispondi ai comandi *)
        IF vnShiftAlgn_Cmd<>0 THEN
            Result := FALSE; (* Default: Non eseguito *)
            vnShiftAlgn_Sts := STS_IDLE;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            (* Comando spostamento 'BeltsOutZone/Co' con o senza cinghie riscontro *)
            IF vnShiftAlgn_Cmd=CMD_MOVETO OR vnShiftAlgn_Cmd=CMD_FULLMOVETO THEN
                (* Attendo qui cinghie disponibili se già in uso da qualcun'altro *)
                IF (BeltsOutZone.Status=BLT_OPERATING OR (Belts.ManagedBelts & BIT_BELTS_OUTZONE)<>0) OR
                   ( (RollsAlgn.Status=BLT_OPERATING OR (Belts.ManagedBelts & BIT_ROLLS_ALGN)<>0) AND vnShiftAlgn_Cmd=CMD_FULLMOVETO) THEN
                    SET_MSG(MSG_ROLLSALGN_BUSY,'MSG_ROLLSALGN_BUSY',0);
                    (* Però se stanno andando spostano il pezzo in vqAlgnDlvr_Xbck!! *)
                    IF NOT Cr.Still THEN
                        dlog( Txt:='fbShiftAlgn: !! AlgnBelts not still', Lvl:=2 );
                        vnShiftAlgn_Cmd := CMD_STOP;
                    END_IF;
                ELSE
                    RST_MSG(MSG_ROLLSALGN_BUSY);
                    (* Argomenti del movimento: vqAlgnDlvr_Xbck, vqAlgnDlvr_Tgt, vqAlgnDlvr_Width, vqAlgnDlvr_Ybtm, vqAlgnDlvr_Ytop *)
                    dlog( Txt:='fbShiftAlgn: Moving %ldx(%ld|%ld) of %ld', Lvl:=3, Val1:=vqAlgnDlvr_Width/1E3, Val2:=vqAlgnDlvr_Ybtm/1E3, Val3:=vqAlgnDlvr_Ytop/1E3, Val4:=(vqAlgnDlvr_Tgt-vqAlgnDlvr_Xbck-vqAlgnDlvr_Width)/1E3 );

                    (* Controllo trasportabilità *)
                    Shiftable( iY:=ivqBeltsAlgn_Y, N:=vnBeltsAlgn_N, W:=vqBeltsAlgn_Size,
                               ybtm:=vqAlgnDlvr_Ybtm, ytop:=vqAlgnDlvr_Ytop );
                    IF Shiftable.q THEN (* AND vqAlgnDlvr_Width>=vqShiftAlgn_PassMinWidth *)
                        vnShiftAlgn_Sts := STS_MOVEINIT;
                    ELSE
                        dlog( Txt:='!! Cant move y=%ld|%ld', Lvl:=2, Val1:=Shiftable.ybtm/1E3, Val2:=Shiftable.ytop/1E3 );
                        vnShiftAlgn_Cmd := CMD_STOP; (* Eat command and abort *)
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ELSE
                dlog( Txt:='fbShiftAlgn: !! Unknown vnShiftAlgn_Cmd=%d', Lvl:=1, Val1:=TO_DINT(vnShiftAlgn_Cmd));
                vnShiftAlgn_Cmd := CMD_STOP; (* Eat command and abort *)
            END_IF; (* -- See command *)
        END_IF; (* -- Comando attivo *)

END_CASE; (* -- Align belts sequences *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbAlgnDeliver

{ DE:"Servizio generico di estrazione/consegna pezzo a valle dei riscontri" }

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	vbFeat_AlgnCanDragFwd : BOOL; { DE:"I riscontri possono agganciare un pezzo a zero e trascinarlo avanti" }
	vbFeat_AlgnHasBelts : BOOL; { DE:"Riscontri provvisti di cinghie (non i rulli)" }
	vbProd_WouldFall : BOOL; { DE:"Il prodotto cade dopo la separazione se non si prendono accorgimenti" }
	vqNextProcArea_Xmax : DINT; { DE:"Prossima area processazione vetro: X massimo [um]" }
	OutZone : fbOutZone; { DE:"Zona fine linea" }
	fcOutzoneEnd : fbPhotoCell; { DE:"Fotocellula a fine linea (IFC_OUTZONE_END)" }
	vqXph_OutZoneEnd : DINT; { DE:"Ascissa fotocellula fine zona fine linea [um]" }
	vbOutTable_Present : BOOL; { DE:"Presenza di un tavolo a valle" }
	vqX_OutZoneBegin : DINT; { DE:"Ascissa inizio zona fine linea [um]" }
	vqX_OutZoneEnd : DINT; { DE:"Ascissa fine zona fine linea/consegna pezzi [um]" }
	vqX_OutTableEnd : DINT; { DE:"Ascissa legno fine tavolo a valle [um]" }
	vbScu_WaitReleaseDelay : BOOL; { DE:"Attendi ritardo ripristino sicurezze prima di proseguire" }
	O_SCU_OUTZONE_BUSY : BOOL; { DE:"Segnalazione operatore in zona fine linea" }
	vqXph_OutZoneBegin : DINT; { DE:"Ascissa fotocellula inizio zona fine linea [um]" }
	vbDeliver_FastNotify : BOOL; { DE:"Notifica subito il nuovo pezzo in uscita" }
	vnPieceDelivering : INT; { DE:"Identificativo pezzo in consegna" }
	vqDeliver_PrescoredXc : DINT; { DE:"Posizione centraggio rilascio pezzi da aprire [um]" }
	vnAlgn_DeliverCmd : INT; { DE:"Servizio generico estrazione pezzo" }
	vnAlgn_DeliverSeq : INT; { DE:"Stato/risultato sequenza di estrazione pezzo a valle" }
	vbAlgnDlvr_Prescored : BOOL; { DE:"Il pezzo da consegnare contiene preincisioni" }
	vnAlgnDlvr_Id : INT; { DE:"Identificativo vetro da portare a fine linea" }
	vqAlgnDlvr_Xbck : DINT; { DE:"Posizione bordo indietro vetro da consegnare [um]" }
	vqAlgnDlvr_Tgt : DINT; { DE:"Posizione bordo avanti dove consegnare [um]" }
	vqAlgnDlvr_Width : DINT; { DE:"Larghezza vetro da consegnare [um]" }
	vqAlgnDlvr_Ybtm : DINT; { DE:"Posizione Y basso vetro da consegnare [um]" }
	vqAlgnDlvr_Ytop : DINT; { DE:"Posizione Y alto vetro da consegnare [um]" }
	vqAlgnDlvr_PausePos : DINT; { DE:"Richiesta pausa consegna pezzo (posizione bordo indietro) [um]" }
	vbAlgnDlvr_AlmostDone : BOOL; { DE:"Sequenza di consegna a buon punto" }
	vnAlgn_DragCmd : INT; { DE:"Comando trascinamento avanti con riscontri" }
	vqAlgnDrag_Xbck : DINT; { DE:"Posizione bordo indietro vetro trascinato avanti [um]" }
	vqAlgnDrag_Tgt : DINT; { DE:"Posizione di arrivo del bordo avanti nel trascinamento avanti [um]" }
	vqAlgnDrag_Width : DINT; { DE:"Larghezza vetro da trascinare avanti [um]" }
	vqAlgnDrag_Ybtm : DINT; { DE:"Posizione Y basso vetro da trascinare avanti [um]" }
	vqAlgnDrag_Ytop : DINT; { DE:"Posizione Y alto vetro da trascinare avanti [um]" }
	vnAlgn_DragSeq : INT; { DE:"Stato/risultato sequenza di trascinamento con riscontri" }
	vbAlgnEvac_Scheduled : BOOL; { DE:"Prenotazione evacuazione fuori" }
	vqAlgnEvac_Xbck : DINT; { DE:"Posizione bordo indietro vetro da evacuare fuori [um]" }
	vnShiftAlgn_Cmd : INT; { DE:"Comando a cinghie riscontri" }
	vnShiftAlgn_Sts : INT; { DE:"Stato/Risultato sequenze cinghie riscontri" }
	vqBeltsAlgn_MinGripDX : DINT; { DE:"Minimo contatto X cinghie riscontro-vetro [um]" }
	vqX_AlgnBeltsBegin : DINT; { DE:"Ascissa inizio rulli/cinghie modulo riscontri [um]" }
	vqX_AlgnBeltsEnd : DINT; { DE:"Ascissa fine rulli/cinghie modulo riscontri [um]" }
	vqX_CutZoneP : DINT; { DE:"Ascissa inizio piano di appoggio/premilastra riscontri [um]" }
	vnBelts_Act : INT; { DE:"Maschera attivazione cinghie" }
	BeltsOutZone : fbBeltsOutZone; { DE:"Cinghie a fine linea" }
	RollsAlgn : fbRollsAlgn; { DE:"Rulli/Cinghie di trasporto su modulo riscontri" }
	Shiftable : fbShiftable; { DE:"Controllo trasportabilità con cinghie" }
	vnBeltsAlgn_N : INT; { DE:"Numero delle cinghie riscontro" }
	vqBeltsAlgn_Size : DINT; { DE:"Larghezza banda gommmata cinghie riscontro [um]" }
	vnVents_Cmd : INT; { DE:"Maschera comando gruppi ventilatori cuscino aria" }
	vqDtch_CurrX : DINT; { DE:"Posizione attuale del modulo di stacco [um]" }
	LabelerOut : fbLabelerOut; { DE:"Etichettatura pezzi in uscita" }
	vqWorkSettings : DINT; { DE:"Selettori ritentivi di lavorazione" }
	vnLabeler_Type : INT; { DE:"Tipo sistema di etichettatura 'ID_LABELER' (0:none 1:reserved 2:feed-bridge 3:align)" }
	END_VAR

	VAR
	HookForBelts : BOOL; { DE:"Sequenza di agganciamento coi riscontri per poi usare le cinghie" }
	Notified : BOOL; { DE:"Ricordati se hai già notificato il vetro in arrivo a fine linea" }
	END_VAR

	{ CODE:ST }(*    fbAlgnDeliver (Project M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Servizio di estrazione/consegna pezzo a fine
      linea,  a valle dei riscontri, usato tipicamente
      nelle sequenze post-taglio.

      DETAILS
      ----------------------------------------------
      Può usare il trascinamento coi piedini (StratoW)
      oppure le cinghie dei riscontri (ActiveHP).
      Chiaramente nel primo caso i riscontri devono
      poter agganciare il vetro.
*)

(* -- State machine -- *)
CASE vnAlgn_DeliverSeq OF

    (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
    DLVSEQ_DRAG_START : (* Attesa sistema pronto *)
        IF vnAlgn_DragCmd=CMD_STOP
           AND NOT (vbScu_WaitReleaseDelay AND O_SCU_OUTZONE_BUSY AND vqAlgnDlvr_Tgt>=vqXph_OutZoneBegin) (* Visto che SCU dà errore se fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY *)
           AND NOT ( vbOutTable_Present AND IS_MSG(REQ_FREE_OUTZONE) ) (* ...E nessuna evacuazione da fare *)
           AND NOT vbAlgnEvac_Scheduled THEN (* ...E nessuna evacuazione programmata *)
            (* Servizio disponibile *)
            (* Nota: L'attesa zona fine linea libera (OutZone.Free) è gestita in fbAlgn *)

            (* dlog( Txt:='-> fbAlgnDeliver: Starting %d 0x%lX', Lvl:=2, Val1:=TO_DINT(vnLabeler_Type), Val2:=vqWorkSettings ); *)
            (* Servizio etichettatura pezzi in uscita *)
            IF vnLabeler_Type=3 AND (vqWorkSettings & BIT_LABELING)<>0 THEN
                LabelerOut( LabelId:=vnAlgnDlvr_Id,
                            Piece_Width:=vqAlgnDlvr_Width,
                            Piece_Ybtm:=vqAlgnDlvr_Ybtm,
                            Piece_Ytop:=vqAlgnDlvr_Ytop );
            END_IF;

            vqAlgnDrag_Xbck  := vqAlgnDlvr_Xbck;
            vqAlgnDrag_Width := vqAlgnDlvr_Width;
            vqAlgnDrag_Ybtm  := vqAlgnDlvr_Ybtm;
            vqAlgnDrag_Ytop  := vqAlgnDlvr_Ytop;
            (* Intercetto situazione *)
            IF HookForBelts THEN
                (* Trascino avanti per portarlo sopra le cinghie *)
                vqAlgnDrag_Tgt := vqX_AlgnBeltsBegin + vqAlgnDrag_Width;
                vnAlgn_DragCmd := ALCMD_DRAGFWD;
            ELSE
                (* Consegna con trascinamento riscontri *)
                vqAlgnDrag_Tgt := vqAlgnDlvr_Tgt;
                vnAlgn_DragCmd := SEL(vnAlgn_DeliverCmd=DLVCMD_MOVE, ALCMD_DRAGEND, ALCMD_DRAGFWD);
            END_IF;
            vnAlgn_DeliverSeq := DLVSEQ_DRAGGING;
        ELSIF vnAlgn_DeliverCmd=CMD_STOP THEN
            vnAlgn_DeliverSeq := SEQ_JUSTERROR;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
    DLVSEQ_SHIFT_START : (* Attesa sistema pronto *)
        IF vnShiftAlgn_Cmd=CMD_STOP
           AND NOT (vbScu_WaitReleaseDelay AND O_SCU_OUTZONE_BUSY) THEN (* Visto che SCU dà errore se fcOutzoneBegin.q AND O_SCU_OUTZONE_BUSY *)
            (* Servizio disponibile *)
            (* Nota: Cinghie disponibili sono attese in fbShiftAlign
                     L'attesa zona fine linea libera (OutZone.Free) è gestita in fbShiftAlign *)

            (* Servizio etichettatura pezzi in uscita *)
            IF vnLabeler_Type=3 AND (vqWorkSettings & BIT_LABELING)<>0 THEN
                LabelerOut( LabelId:=vnAlgnDlvr_Id,
                            Piece_Width:=vqAlgnDlvr_Width,
                            Piece_Ybtm:=vqAlgnDlvr_Ybtm,
                            Piece_Ytop:=vqAlgnDlvr_Ytop );
            END_IF;

            (* Dove devo andare? *)
            (* Se devo evacuare decido io dove andare *)
            IF vnAlgn_DeliverCmd=DLVCMD_OUT THEN
                vqAlgnDlvr_Tgt := vqX_OutTableEnd;
            (* ELSIF vnAlgn_DeliverCmd=DLVCMD_END THEN
                vqAlgnDlvr_Tgt := vqX_OutZoneEnd; *)
            END_IF;

            (* Il target deve essere tale da non far uscire il vetro dal tavolo a valle? * )
            IF vqAlgnDlvr_Tgt > vqX_OutTableEnd THEN
                vqAlgnDlvr_Tgt := vqX_OutTableEnd;
            END_IF; *)

            vnShiftAlgn_Cmd := SEL(vqAlgnDlvr_Xbck<vqX_AlgnBeltsEnd, CMD_MOVETO, CMD_FULLMOVETO);
            vnAlgn_DeliverSeq := DLVSEQ_SHIFTING;
        ELSIF vnAlgn_DeliverCmd=CMD_STOP THEN
            vnAlgn_DeliverSeq := SEQ_JUSTERROR;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
    DLVSEQ_DRAGGING : (* Trascinamento in corso *)
        (* Monitor operazione quasi terminata per prosecuzione passo *)
        vqAlgnDlvr_Xbck := vqAlgnDrag_Xbck;
        vbAlgnDlvr_AlmostDone := vqAlgnDlvr_Xbck>vqX_AlgnBeltsEnd AND vqAlgnDlvr_PausePos=0;

        (* Assicuro segnalazione id pezzo in uscita *)
        IF vnAlgn_DeliverCmd>=DLVCMD_END AND vnAlgn_DragSeq>=ALSEQ_DRAG_FORE THEN
            vnPieceDelivering := vnAlgnDlvr_Id;
            (* Notifico il pezzo in arrivo alla zona fine linea *)
            IF NOT Notified THEN
                Notified := TRUE;
                OutZone.Ybtm := vqAlgnDlvr_Ybtm;
                OutZone.Ytop := vqAlgnDlvr_Ytop;
                OutZone.Xbck := vqAlgnDlvr_Xbck;
                OutZone.Xfwd := vqAlgnDlvr_Xbck + vqAlgnDlvr_Width;
                OutZone.Prescored := vbAlgnDlvr_Prescored;
                (* OutZone.Id := vnAlgnDlvr_Id; *)
                OutZone.NewPiece := OZ_NOTIFY; (* Just notify incoming piece *)
            END_IF;
        END_IF;

        IF vnAlgn_DragCmd=CMD_STOP THEN
            (* Sequenza terminata *)
            (* Intercetto sequenza agganciamento riscontri + cinghie *)
            IF HookForBelts THEN
                HookForBelts := FALSE; (* Eat *)
                IF vnAlgn_DragSeq=SEQ_DONE THEN
                    (* Se sono riuscito a portarlo sopra le cinghie, procedo con esse *)
                    vnAlgn_DeliverSeq := DLVSEQ_SHIFT_START;
                ELSE
                    (* In caso di errore, annulla anticipo salita cinghie *)
                    vnBelts_Act := vnBelts_Act & NOT (BIT_BELTS_OUTZONE OR BIT_ROLLS_ALGN);
                    vnAlgn_DeliverSeq := SEQ_JUSTERROR;
                END_IF;
            ELSE
                (* Riporto il risultato del comando *)
                vnAlgn_DeliverSeq := SEL( vnAlgn_DragSeq=SEQ_DONE, SEQ_JUSTERROR, DLVSEQ_ENDING );
            END_IF;
        ELSIF vnAlgn_DeliverCmd=CMD_STOP THEN
            (* Comando abortito: Ferma il servizio chiamato *)
            vnAlgn_DragCmd := CMD_STOP;
        ELSE
            (* Anticipo salita cinghie dopo aggancio coi riscontri *)
            IF HookForBelts AND vnAlgn_DragSeq=ALSEQ_DRAG_FORE_DWN AND OutZone.Free THEN
                IF BeltsOutZone.Allow AND RollsAlgn.Allow THEN
                    vnBelts_Act := vnBelts_Act OR (BIT_BELTS_OUTZONE OR BIT_ROLLS_ALGN);
                END_IF;
            END_IF;

            (* Servizio etichettatura pezzi in uscita *)
            IF vnLabeler_Type=3 THEN
                LabelerOut( Placing_Aborted:=(vnAlgn_DragCmd=CMD_STOP),
                            Placing_Done:=(vnAlgn_DragSeq=ALSEQ_DRAG_PAUSED) );
            END_IF;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
    DLVSEQ_SHIFTING : (* Traslazione in corso *)
        (* Monitor operazione quasi terminata per prosecuzione passo *)
        IF NOT vbAlgnDlvr_AlmostDone THEN
            vbAlgnDlvr_AlmostDone := (vnShiftAlgn_Sts=STS_MOVING) AND vqAlgnDlvr_PausePos=0; (* vqAlgnDlvr_Xbck>vqX_AlgnBeltsEnd *)
            (* Nota: Se 'STS_MOVING' ha liberato le cinghie riscontro *)
        END_IF;

        (* Assicuro segnalazione id pezzo in uscita *)
        IF vnAlgn_DeliverCmd>=DLVCMD_END AND (vnShiftAlgn_Sts=STS_FULLMOVING OR vnShiftAlgn_Sts=STS_MOVING) THEN
            vnPieceDelivering := vnAlgnDlvr_Id;
            (* Notifico il pezzo in arrivo alla zona fine linea *)
            IF NOT Notified THEN
                Notified := TRUE;
                OutZone.Ybtm := vqAlgnDlvr_Ybtm;
                OutZone.Ytop := vqAlgnDlvr_Ytop;
                OutZone.Xbck := vqAlgnDlvr_Xbck;
                OutZone.Xfwd := vqAlgnDlvr_Xbck + vqAlgnDlvr_Width;
                OutZone.Prescored := vbAlgnDlvr_Prescored;
                (* OutZone.Id := vnAlgnDlvr_Id; *)
                OutZone.NewPiece := OZ_NOTIFY; (* Just notify incoming piece *)
            END_IF;
        END_IF;

        IF vnShiftAlgn_Cmd=CMD_STOP THEN
            (* Sequenza terminata, riporto il risultato del comando *)
            vnAlgn_DeliverSeq := SEL(vnShiftAlgn_Sts=STS_DONE, SEQ_JUSTERROR, DLVSEQ_ENDING);
        ELSIF vnAlgn_DeliverCmd=CMD_STOP THEN
            (* Comando abortito: Ferma il servizio chiamato *)
            vnShiftAlgn_Cmd := CMD_STOP;
        ELSE
            (* Servizio etichettatura pezzi in uscita *)
            IF vnLabeler_Type=3 THEN
                LabelerOut( Placing_Aborted:=(vnShiftAlgn_Cmd=CMD_STOP),
                            Placing_Done:=(vnShiftAlgn_Sts=SHIFTALGN_PAUSED) );
            END_IF;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
    DLVSEQ_ENDING : (* Sequence is ending successfully *)
        dlog( Txt:='fbAlgnDeliver: Done, Xbck at %ld mm', Lvl:=5, Val1:=vqAlgnDlvr_Xbck/1E3);
        (* Basing on command *)
        CASE vnAlgn_DeliverCmd OF
            DLVCMD_END : (* Pezzo portato a fine linea *)
                (* Dai in carico il pezzo alla zona fine linea *)
                OutZone.Ybtm := vqAlgnDlvr_Ybtm;
                OutZone.Ytop := vqAlgnDlvr_Ytop;
                OutZone.Xbck := vqAlgnDlvr_Xbck;
                OutZone.Xfwd := vqAlgnDlvr_Xbck + vqAlgnDlvr_Width;
                OutZone.Prescored := vbAlgnDlvr_Prescored;
                (* OutZone.Id := vnAlgnDlvr_Id; *)
                OutZone.NewPiece := OZ_TAKE; (* Process piece *)
                (* Effettuare la chiamata?
                OutZone(
                        Ybtm := vqAlgnDlvr_Ybtm,
                        Ytop := vqAlgnDlvr_Ytop,
                        Xbck := vqAlgnDlvr_Xbck,
                        Xfwd := vqAlgnDlvr_Xbck + vqAlgnDlvr_Width,
                        Prescored := vbAlgnDlvr_Prescored,
                        Id := vnAlgnDlvr_Id,
                        NewPiece := OZ_TAKE
                       ); *)
                (* Dovrebbe essere attiva la fotocellula? *)
                IF NOT fcOutzoneEnd.q AND (vqAlgnDlvr_Xbck + vqAlgnDlvr_Width)>vqXph_OutZoneEnd THEN
                    dlog( Txt:='fbAlgnDeliver: ! No IFC_OUTZONE_END', Lvl:=3 );
                END_IF;

            DLVCMD_OUT : (* Pezzo evacuato *)
                vqAlgnEvac_Xbck := NO_POS_UM; (* Eat *)
                (* Segnala pezzo evacuato (se sono riuscito a portarlo fuori) *)
                IF vqAlgnDlvr_Xbck > (vqX_OutZoneEnd + 10E3) THEN
                    (* Sono riuscito a portarlo tutto fuori *)
                    OutZone.TryFreeZone := TRUE; (* Prova a liberare la zona *)
                ELSE
                    (* Probabilmente non può essere evacuato completamente *)
                    dlog( Txt:='fbAlgnDeliver: ! Cannot Evac Xbck=%ld<=%ld mm', Lvl:=3, Val1:=vqAlgnDlvr_Xbck/1E3, Val2:=vqX_OutZoneEnd/1E3 );
                    (* ...Aggiorna la zona occupata a fine linea *)
                    OutZone.Ybtm := vqAlgnDlvr_Ybtm;
                    OutZone.Ytop := vqAlgnDlvr_Ytop;
                    OutZone.Xbck := vqAlgnDlvr_Xbck;
                    OutZone.Xfwd := vqAlgnDlvr_Xbck + vqAlgnDlvr_Width;
                    OutZone.Prescored := vbAlgnDlvr_Prescored;
                    (* OutZone.Id := vnAlgnDlvr_Id; *)
                    OutZone.NewPiece := OZ_UPDATE; (* Just update zone, do not take care of piece *)
                    (* Richiedi che prenda il pezzo *)
                    SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',0); (* Deliver end *)
                END_IF;
        END_CASE;
        vnAlgn_DeliverCmd := CMD_STOP; (* Eat command *)
        vbAlgnDlvr_Prescored := FALSE; (* Eat flags *)
        vbAlgnDlvr_AlmostDone := FALSE;
        vnAlgn_DeliverSeq := SEQ_DONE;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
    SEQ_JUSTERROR : (* Handle error *)
        (* Servizi utilizzati *)
        vnAlgn_DragCmd := CMD_STOP;
        vnShiftAlgn_Cmd := CMD_STOP;
        IF vnLabeler_Type=3 THEN
            LabelerOut( Placing_Aborted:=TRUE, Placing_Done:=FALSE );
        END_IF;
        (* Assicura reset stato *)
        vbAlgnDlvr_AlmostDone := FALSE;
        (* Basing on command *)
        CASE vnAlgn_DeliverCmd OF
            DLVCMD_END : (* Errore durante estrazione a fine linea *)
                IF vnAlgnDlvr_Id=0 THEN SET_MSG(REQ_DUMP_PROD,'REQ_DUMP_PROD',0);
                                   ELSE SET_MSG(REQ_TAKE_PROD,'REQ_TAKE_PROD',0); END_IF;
            (* DLVCMD_MOVE : (* Errore durante movimentazione *)
            DLVCMD_OUT : (* Errore durante evacuazione *)
                vqAlgnEvac_Xbck := NO_POS_UM;
                (* ...Aggiorna la zona occupata a fine linea *)
                OutZone.Ybtm := vqAlgnDlvr_Ybtm;
                OutZone.Ytop := vqAlgnDlvr_Ytop;
                OutZone.Xbck := vqAlgnDlvr_Xbck;
                OutZone.Xfwd := vqAlgnDlvr_Xbck + vqAlgnDlvr_Width;
                OutZone.Prescored := vbAlgnDlvr_Prescored;
                (* OutZone.Id := vnAlgnDlvr_Id; *)
                OutZone.NewPiece := OZ_UPDATE; (* Just update zone, do not take care of piece *)
                (* Richiedi che prenda il pezzo *)
                SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',0); (* Expulsion error *)
            (* ELSE (* Altri casi? *)
        END_CASE;
        vnAlgn_DeliverCmd := CMD_STOP; (* Eat command *)
        vbAlgnDlvr_Prescored := FALSE; (* Eat flags *)
        vnAlgn_DeliverSeq := SEQ_ERROR;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
    ELSE (* SEQ_ERROR, SEQ_START, SEQ_DONE *)
        IF vnAlgn_DeliverCmd<>CMD_STOP THEN
            vnAlgn_DeliverSeq := SEQ_JUSTERROR; (* Default: errore *)
            vbAlgnDlvr_AlmostDone := FALSE;
            HookForBelts := FALSE;
            Notified := FALSE;

            (* Nel caso di tagli da aprire, può essere comodo rilasciare i
               pezzi in una posizione che precede la fine linea se possibile,
               soprattutto con macchine dotate di lampada *)
            IF vnAlgn_DeliverCmd=DLVCMD_END AND vbAlgnDlvr_Prescored AND vqDeliver_PrescoredXc>0 THEN
                (* Cerco di centrare il pezzo alla quota indicata ma assicurando:
                   -Di essere oltre la zona fine linea/zona occupata dal taglio successivo
                   -Di non superare la quota di consegna iniziale *)
                vqAlgnDlvr_Tgt := MIN(vqAlgnDlvr_Tgt,
                                      MAX(vqDeliver_PrescoredXc + vqAlgnDlvr_Width/2,
                                          vqAlgnDlvr_Width + MAX(vqX_OutZoneBegin, vqNextProcArea_Xmax)));
                dlog( Txt:='fbAlgnDeliver: Centering prescored in %ld|%ld (Amax=%ld)', Lvl:=3, Val1:=(vqAlgnDlvr_Tgt-vqAlgnDlvr_Width)/1E3, Val2:=vqAlgnDlvr_Tgt/1E3, Val3:=vqNextProcArea_Xmax/1E3 );
            END_IF;

            dlog( Txt:='fbAlgnDeliver: id=%d Xbck %ld -> %ld (w=%ld)', Lvl:=3, Val1:=TO_DINT(vnAlgnDlvr_Id), Val2:=vqAlgnDlvr_Xbck/1E3, Val3:=(vqAlgnDlvr_Tgt-vqAlgnDlvr_Width)/1E3, Val4:=vqAlgnDlvr_Width/1E3 );

            (* Scelgo se usare i riscontri o le cinghie *)
            Shiftable( iY:=ivqBeltsAlgn_Y, N:=vnBeltsAlgn_N, W:=vqBeltsAlgn_Size,
                       ybtm:=vqAlgnDlvr_Ybtm, ytop:=vqAlgnDlvr_Ytop );
            IF vbFeat_AlgnHasBelts AND Shiftable.q THEN
                (* IF (vqAlgnDlvr_Xbck+vqAlgnDlvr_Width-vqX_AlgnBeltsBegin)>vqBeltsAlgn_MinGripDX AND *)
                (* Meglio avere anche la risultante del peso sulle cinghie *)
                IF (vqAlgnDlvr_Xbck+vqAlgnDlvr_Width-vqX_AlgnBeltsBegin)>=MAX(vqBeltsAlgn_MinGripDX,vqAlgnDlvr_Width/2) AND
                   (* vqAlgnDlvr_Width>=2*(vqX_AlgnBeltsBegin-vqX_CutZoneP) AND *)
                   NOT vbProd_WouldFall THEN
                    (* Posso muovere direttamente con le cinghie *)
                    vnAlgn_DeliverSeq := DLVSEQ_SHIFT_START;
                ELSIF vbFeat_AlgnCanDragFwd THEN
                    (* Devo agganciare il pezzo coi riscontri *)
                    vnAlgn_DeliverSeq := DLVSEQ_DRAG_START;
                    (* Se il movimento (in avanti) è lungo trascino giusto sopra le cinghie per poi usare loro *)
                    HookForBelts := (vqAlgnDlvr_Tgt-vqAlgnDlvr_Xbck-vqAlgnDlvr_Width) > 1000E3;
                END_IF;
            ELSIF vbFeat_AlgnCanDragFwd THEN
                IF vnAlgn_DeliverCmd=DLVCMD_OUT THEN
                    (* È un'evacuazione mediante spinta riscontri *)
                    dlog( Txt:='fbAlgnDeliver: Evac', Lvl:=3 );
                    vnAlgn_DeliverCmd := CMD_STOP; (* Eat *)
                    (* vnAlgn_DeliverSeq := SEQ_DONE; (* Questo non dovrebbe essere controllato *)
                    vbAlgnEvac_Scheduled := TRUE; (* Questo verrà gestito in fbAlgn *)
                ELSE
                    (* Procedo con un comando di trascinamento avanti con i riscontri *)
                    vnAlgn_DeliverSeq := DLVSEQ_DRAG_START;
                END_IF;
            END_IF;
            (* -Apply command- *)
            IF vnAlgn_DeliverSeq<>SEQ_JUSTERROR THEN
                (* Se sto portando a fine linea... *)
                IF vnAlgn_DeliverCmd>=DLVCMD_END THEN
                    (* ...Segnalo subito id pezzo in uscita? *)
                    IF vbDeliver_FastNotify THEN
                        vnPieceDelivering := vnAlgnDlvr_Id;
                    END_IF;
                END_IF;
            ELSE
                (* Non ho modo di portare fuori il pezzo *)
                (* Accendo i ventilatori riscontri? *)
                IF vqAlgnDlvr_Xbck>vqDtch_CurrX THEN (* AND NOT vbFeat_FullAuto *)
                    vnVents_Cmd := vnVents_Cmd OR MSK_VENT_PROD;
                END_IF;
            END_IF;

        END_IF; (* Comando attivo *)

END_CASE; (* -- state machine *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbAlgnBlocks

{ DE:"Gestione piedini di riscontro" }

	VAR_IN_OUT
	Cmd : INT; { DE:"Comando (0:none 1:set-fore 2:set-rear 3:sel-reset 4:act-reset ›4:full-reset)" }
	END_VAR

	VAR_INPUT
	Sel : INT; { DE:"Selettore piedini a bit (bit0:p1, bit1:p2, ..., bit15:sel-rear)" }
	Allow : BOOL; { DE:"Permesso salita piedini" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato dei piedini comandati" }
	AtRest : BOOL; { DE:"Tutti i piedini sono bassi, nessun comando in corso" }
	Rising : BOOL; { DE:"Piedini in fase di salita (per controllo sotto il vetro)" }
	ForeUp : BOOL; { DE:"Piedini anteriori in salita o già alti" }
	RearUp : BOOL; { DE:"Piedini posteriori in salita o già alti" }
	Buf_Sel : INT; { DE:"Piedini selezionati - valore nel buffer" }
	Buf_Rear : BOOL; { DE:"Selettore posteriore - valore nel buffer" }
	IforeUp : INT := 0; { DE:"Maschera sensori piedini anteriori alti" }
	IrearUp : INT := 0; { DE:"Maschera sensori piedini posteriori alti" }
	IforeGlass : INT := 0; { DE:"Maschera sensori presenza vetro piedini anteriori" }
	IrearGlass : INT := 0; { DE:"Maschera sensori presenza vetro piedini posteriori" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	Scu : fbSafety; { DE:"Safety unit" }
	vnAlgn_Type : INT; { DE:"Tipo riscontri" }
	vnAlgnBlks_N : INT; { DE:"Numero dei piedini di riscontro !max=10!" }
	vqAlgnBlk_UpDownDelay : DINT; { DE:"Attesa garantita bistabile piedini di riscontro [ms]" }
	vbAlgnBlks_KeepSet : BOOL; { DE:"Mantieni l'uscita di set delle bistabili" }
	vbAlgnBlks_RefreshRst : BOOL; { DE:"Rinfresca il reset delle bistabili" }
	vbAlgnBlocks_SelRear : BOOL; { DE:"Selezionati piedini di riscontro posteriori" }
	vnAlgnBlocks_Sts : INT; { DE:"Stato del sistema piedini di riscontro" }
	vnAlgnBlocks_Msk : INT; { DE:"Maschera dei piedini comandati" }
	vnAlgnBlocks_Glass : INT; { DE:"Maschera stato sensori presenza vetro sui piedini" }
	iIFC_REF : INT; { DE:"Accesso sensori piedini riscontro vb[iIFC_REF+4*(Idx-1)]" }
	IFC_REF1_FORE_UP : BOOL; { DE:"Sensore piedino di riscontro 1 anteriore fuori" }
	IFC_REF1_REAR_UP : BOOL; { DE:"Sensore piedino di riscontro 1 posteriore fuori" }
	IFC_REF2_FORE_UP : BOOL; { DE:"Sensore piedino di riscontro 2 anteriore fuori" }
	IFC_REF2_REAR_UP : BOOL; { DE:"Sensore piedino di riscontro 2 posteriore fuori" }
	iO_REF : INT; { DE:"Accesso uscite piedini riscontro vb[iO_REF+4*(Idx-1)]" }
	O_REF1_FORE_UP_SET : BOOL; { DE:"Set salita piedino di riscontro 1 anteriore" }
	O_REF1_FORE_UP_RST : BOOL; { DE:"Reset salita piedino di riscontro 1 anteriore" }
	O_REF1_REAR_UP_SET : BOOL; { DE:"Set salita piedino di riscontro 1 posteriore" }
	O_REF1_REAR_UP_RST : BOOL; { DE:"Reset salita piedino di riscontro 1 posteriore" }
	O_REF2_FORE_UP_SET : BOOL; { DE:"Set salita piedino di riscontro 2 anteriore" }
	O_REF2_FORE_UP_RST : BOOL; { DE:"Reset salita piedino di riscontro 2 anteriore" }
	O_REF2_REAR_UP_SET : BOOL; { DE:"Set salita piedino di riscontro 2 posteriore" }
	O_REF2_REAR_UP_RST : BOOL; { DE:"Reset salita piedino di riscontro 2 posteriore" }
	END_VAR

	VAR
	TDelay : Ton; { DE:"Timer attesa bistabile salita/discesa" }
	i : INT; { DE:"Iteratore indice piedini" }
	mask : INT; { DE:"Maschera piedino corrente" }
	OforeUpSet : INT; { DE:"Word bit comandi set salita piedini anteriori" }
	OforeUpRst : INT; { DE:"Word bit comandi reset salita piedini anteriori" }
	OrearUpSet : INT; { DE:"Word bit comandi set salita piedini posteriori" }
	OrearUpRst : INT; { DE:"Word bit comandi reset salita piedini posteriori" }
	END_VAR

	{ CODE:ST }(*    fbAlgnBlocks (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Servizi relativi ai piedini di riscontro.
      Supporta sia quelli "svincolati" che quelli
      "fissi" (StratoS).
      Supporta la possibilità di dotare alcuni piedini
      con sensori presenza vetro.

      LIMITS
      ----------------------------------------------
      Il comando è una WORD a bit, questo significa
      che si possono pilotare singolarmente fino a
      16 piedini; controllare 'iomap.h' per vedere
      se ci sono le risorse.
      Una volta dato il comando non è più possibile
      variarlo, va rimesso a zero e reimpostato
      (questo facilita il controllo dei consensi e
      la gestione del transitorio).

      DETAILS
      ----------------------------------------------
      L'attuazione di ogni piedino consta di due
      cilindri in cascata, comandati da due valvole
      bistabili:
       +---------------------+
       | cilindro | cilindro |
       | sotto    | sopra    |
       +-----------------------------------------------+
       |  RESET   |  RESET   | Riposo                  |
       +-----------------------------------------------+
       |   SET    |  RESET   | Piedino anteriore alto  |
       +-----------------------------------------------+
       |  RESET   |   SET    | Piedino posteriore alto |
       +-----------------------------------------------+
       |   SET    |   SET    | Non definito            |
       +-----------------------------------------------+

      GLASS SENSORS
      ----------------------------------------------
      I sensori presenza vetro non si montano su
      tutti i piedini, di solito sono solo quattro:
      vb[iIFC_REF+4*(vnAlgnBlk_Bsense-1)+2] sensore su piedino basso anteriore
      vb[iIFC_REF+4*(vnAlgnBlk_Bsense-1)+3] sensore su piedino basso posteriore
      vb[iIFC_REF+4*(vnAlgnBlk_Tsense-1)+2] sensore su piedino alto anteriore
      vb[iIFC_REF+4*(vnAlgnBlk_Tsense-1)+3] sensore su piedino alto posteriore
      Corrispondenti alle ordinate:
      vq[ivqAlgnBlks_Y+vnAlgnBlk_Bsense]
      vq[ivqAlgnBlks_Y+vnAlgnBlk_Tsense]
      Meglio non abbassare i piedini anteriori se essi sono a contatto col vetro
*)

(* A seconda del tipo di riscontri *)
CASE vnAlgn_Type OF
    (* --------------------------------------------------------------------- *)
    3 : (* Full independent blocks *)
        (* Ogni singolo piedino ha sensori ed elettrovalvole *)
        (* - Traduzione dei bit alle risorse I/O effettive - *)
        IforeUp := INT#0;
        IrearUp := INT#0;
        IforeGlass := INT#0;
        IrearGlass := INT#0;
        FOR i:=0 TO vnAlgnBlks_N-1 DO
            mask := SHL(1,i);

            (* Sensori piedini alti - ingressi => words *)
            IF vb[iIFC_REF+4*i]   THEN IforeUp := IforeUp OR mask; END_IF; (* 0:fore-up =IFC_REF#_FORE_UP *)
            IF vb[iIFC_REF+4*i+1] THEN IrearUp := IrearUp OR mask; END_IF; (* 1:rear-up =IFC_REF#_REAR_UP *)

            (* Sensori presenza vetro - ingressi => words *)
            IF vb[iIFC_REF+4*i+2] THEN IforeGlass := IforeGlass OR mask; END_IF; (* 2:fore-glass =IFC_REF#_FORE_GLASS *)
            IF vb[iIFC_REF+4*i+3] THEN IrearGlass := IrearGlass OR mask; END_IF; (* 3:rear-glass =IFC_REF#_REAR_GLASS *)

            (* Elettrovalvole dei cilindri salita/discesa *)
            (* sarebbe bello farle dopo, ma voglio sfruttare questo loop *)
            (* -- Comandi a bit -> uscite -- *)
            vb[iO_REF+4*i]   := (OforeUpSet & mask)<>INT#0; (* 0:fore-up-set =O_REF#_FORE_UP_SET *)
            vb[iO_REF+4*i+1] := (OforeUpRst & mask)<>INT#0; (* 1:fore-up-rst =O_REF#_FORE_UP_RST *)
            vb[iO_REF+4*i+2] := (OrearUpSet & mask)<>INT#0; (* 2:rear-up-set =O_REF#_REAR_UP_SET *)
            vb[iO_REF+4*i+3] := (OrearUpRst & mask)<>INT#0; (* 3:rear-up-rst =O_REF#_REAR_UP_RST *)
        END_FOR;

    (* --------------------------------------------------------------------- *)
    2 : (* First independent block *)
        (* Il primo piedino è indipendente, gli altri sono insieme *)

        (* Sensori piedini alti del primo piedino *)
        IforeUp := SEL(IFC_REF1_FORE_UP, INT#16#0, INT#16#0001); (* =vb[iIFC_REF] *)
        IrearUp := SEL(IFC_REF1_REAR_UP, INT#16#0, INT#16#0001); (* =vb[iIFC_REF+1] *)

        (* Sensori piedini alti dei restanti: Guardo quelli del secondo piedino *)
        IF IFC_REF2_FORE_UP THEN IforeUp := IforeUp OR INT#16#FFFE; END_IF; (* =vb[iIFC_REF+4] *)
        IF IFC_REF2_REAR_UP THEN IrearUp := IrearUp OR INT#16#FFFE; END_IF; (* =vb[iIFC_REF+4+1] *)

        (* Sensori presenza vetro: Non previsti *)

        (* Salita/discesa del primo piedino *)
        O_REF1_FORE_UP_SET := (OforeUpSet & INT#16#0001)<>INT#0; (* =vb[iO_REF]   *)
        O_REF1_FORE_UP_RST := (OforeUpRst & INT#16#0001)<>INT#0; (* =vb[iO_REF+1] *)
        O_REF1_REAR_UP_SET := (OrearUpSet & INT#16#0001)<>INT#0; (* =vb[iO_REF+2] *)
        O_REF1_REAR_UP_RST := (OrearUpRst & INT#16#0001)<>INT#0; (* =vb[iO_REF+3] *)
        (* Salita/discesa dei restanti piedini: Uso uscite del piedino 2 *)
        O_REF2_FORE_UP_SET := (OforeUpSet & INT#16#FFFE)<>INT#0; (* =vb[iO_REF+4]   *)
        O_REF2_FORE_UP_RST := (OforeUpRst & INT#16#FFFE)<>INT#0; (* =vb[iO_REF+4+1] *)
        O_REF2_REAR_UP_SET := (OrearUpSet & INT#16#FFFE)<>INT#0; (* =vb[iO_REF+4+2] *)
        O_REF2_REAR_UP_RST := (OrearUpRst & INT#16#FFFE)<>INT#0; (* =vb[iO_REF+4+3] *)

    (* --------------------------------------------------------------------- *)
    1 : (* Fixed blocks *)
        (* Piedini tutti uniti, sensori e attuazioni solo su uno *)

        (* Sensori piedini alti: Guardo quelli del primo piedino *)
        IforeUp := SEL(IFC_REF1_FORE_UP, INT#16#0, INT#16#FFFF); (* =vb[iIFC_REF] *)
        IrearUp := SEL(IFC_REF1_REAR_UP, INT#16#0, INT#16#FFFF); (* =vb[iIFC_REF+1] *)

        (* Sensori presenza vetro: Non previsti * )
        IforeGlass := INT#0;
        IrearGlass := INT#0;
        IF vnAlgnBlk_Bsense>0 THEN
            IF vb[iIFC_REF+4*(vnAlgnBlk_Bsense-1)+2] THEN IforeGlass := IforeGlass OR SHL(1,vnAlgnBlk_Bsense-1); END_IF; (* 2:fore-glass =IFC_REF2_FORE_GLASS * )
            IF vb[iIFC_REF+4*(vnAlgnBlk_Bsense-1)+3] THEN IrearGlass := IrearGlass OR SHL(1,vnAlgnBlk_Bsense-1); END_IF; (* 3:rear-glass =IFC_REF2_REAR_GLASS * )
        END_IF;
        IF vnAlgnBlk_Tsense>0 THEN
            IF vb[iIFC_REF+4*(vnAlgnBlk_Tsense-1)+2] THEN IforeGlass := IforeGlass OR SHL(1,vnAlgnBlk_Tsense-1); END_IF; (* 2:fore-glass =IFC_REF6_FORE_GLASS * )
            IF vb[iIFC_REF+4*(vnAlgnBlk_Tsense-1)+3] THEN IrearGlass := IrearGlass OR SHL(1,vnAlgnBlk_Tsense-1); END_IF; (* 3:rear-glass =IFC_REF6_REAR_GLASS * )
        END_IF; *)

        (* Elettrovalvole dei cilindri salita/discesa: Aziono quelle del primo piedino *)
        O_REF1_FORE_UP_SET := OforeUpSet<>INT#0; (* =vb[iO_REF]   *)
        O_REF1_FORE_UP_RST := OforeUpRst<>INT#0; (* =vb[iO_REF+1] *)
        O_REF1_REAR_UP_SET := OrearUpSet<>INT#0; (* =vb[iO_REF+2] *)
        O_REF1_REAR_UP_RST := OrearUpRst<>INT#0; (* =vb[iO_REF+3] *)
END_CASE;



(* -- State machine -- *)
TDelay( in:=Scu.PneumActReady AND (Status=TS_WAITOFF OR Status=TS_WAITON), pt:=TO_UDINT(vqAlgnBlk_UpDownDelay) );
CASE Status OF

    TS_ON : (* Piedini fuori *)
        IF Cmd>=3 THEN (* Abbassa i piedini, sempre possibile anche se Allow=FALSE *)
            Status := TS_GOINGOFF;
        ELSIF Scu.PneumActReady AND IforeUp=0 AND IrearUp=0 THEN (* Intercetta stato piedini bassi *)
            dlog( Txt:='fbAlgnBlocks: ! Not up', Lvl:=2 );
            Status := TS_OFF;
        (* ELSE (* Controlla perdita sensori piedini alti
            IF Buf_Rear THEN
                IF IrearUp<>Buf_Sel THEN
                    dlog( Txt:='fbAlgnBlocks: !! Lost rear up sensor while up (0x%lX)', Lvl:=3, Val1:=TO_DINT(IrearUp));
                END_IF;
            ELSE
                IF IforeUp<>Buf_Sel THEN
                    dlog( Txt:='fbAlgnBlocks: !! Lost fore up sensor while up (0x%lX)', Lvl:=3, Val1:=TO_DINT(IforeUp));
                END_IF;
            END_IF; *)
        END_IF;


    TS_WAITON : (* Attendi salita piedini selezionati *)
        IF NOT Allow THEN
            (* dlog( Txt:='fbAlgnBlocks: !! Rise aborted', Lvl:=3 ); *)
            Cmd := 5; (* Butta giù i piedini *)
            Status := TS_GOINGOFF;
        ELSIF Cmd>=3 THEN
            Status := TS_GOINGOFF;
        ELSE
            IF Buf_Rear THEN
                (* Piedini posteriori *)
                IF ( (IrearUp=Buf_Sel AND vnAlgn_Type=3) OR (* Piedini svincolati: controllo stringente *)
                     (IrearUp<>0 AND vnAlgn_Type<3) ) AND   (* Piedini uniti: controllo generico *)
                   TDelay.q THEN (* Tempo minimo garantito comando bistabile *)
                    dlog( Txt:='fbAlgnBlocks: Rear up (0x%lX)', Lvl:=5, Val1:=TO_DINT(IrearUp));
                    (* Tolgo le uscite *)
                    OforeUpRst := INT#0;
                    OrearUpRst := INT#0;
                    IF NOT vbAlgnBlks_KeepSet THEN OrearUpSet := INT#0; END_IF;
                    Cmd := 0; (* Resetto il comando *)
                    Status := TS_ON;
                END_IF;
            ELSE
                (* Piedini anteriori *)
                IF ( (IforeUp=Buf_Sel AND vnAlgn_Type=3) OR (* Piedini svincolati: controllo stringente *)
                     (IforeUp<>0 AND vnAlgn_Type<3) ) AND   (* Piedini uniti: controllo generico *)
                   TDelay.q THEN (* Tempo minimo garantito comando bistabile *)
                    dlog( Txt:='fbAlgnBlocks: Fore up (0x%lX)', Lvl:=5, Val1:=TO_DINT(IforeUp));
                    (* Tolgo le uscite *)
                    OforeUpRst := INT#0;
                    OrearUpRst := INT#0;
                    IF NOT vbAlgnBlks_KeepSet THEN OforeUpSet := INT#0; END_IF;
                    Cmd := 0; (* Resetto il comando *)
                    Status := TS_ON;
                END_IF;
            END_IF;
        END_IF;


    TS_GOINGOFF : (* Prepara discesa piedini *)
        (* Assicura le uscite di set a zero *)
        OforeUpSet := INT#0;
        OrearUpSet := INT#0;
        (* Impartisci il comando di reset desiderato *)
        IF Cmd=3 AND Buf_Sel<>0 THEN
            (* Solo quelli che ho alzato *)
            OforeUpRst := Buf_Sel;
            OrearUpRst := Buf_Sel;
        ELSIF Cmd=4 THEN
            (* Guardando i sensori *)
            OforeUpRst := IforeUp;
            OrearUpRst := IrearUp;
        ELSE
            (* Tutti indiscriminatamente *)
            OforeUpRst := INT#16#FFFF;
            OrearUpRst := INT#16#FFFF;
        END_IF;
        (* Nota: Se i piedini anteriori toccano il vetro, sarebbe meglio prima indietreggiare! *)
        (* IF NOT Buf_Rear AND IforeGlass<>0 AND OforeUpRst<>0 THEN dlog( Txt:='fbAlgnBlocks: ! Fore down sensing glass (0x%lX)', Lvl:=2, Val1:=TO_DINT(IforeGlass)); END_IF; *)
        Buf_Sel := 0;
        Status := TS_WAITOFF;


    TS_WAITOFF : (* Attendi discesa di tutti i piedini e del comando *)
        IF TDelay.q AND IforeUp=0 AND IrearUp=0 THEN
            OforeUpSet := INT#0;
            OrearUpSet := INT#0;
            OforeUpRst := INT#0;
            OrearUpRst := INT#0;
            Cmd := 0; (* Resetto il comando *)
            Status := TS_OFF;
        END_IF;


    TS_OFF : (* Piedini bassi *)
        IF IforeUp<>0 AND Scu.PneumActReady THEN
            dlog( Txt:='fbAlgnBlocks: ! Fore up sensor at rest (0x%lX)', Lvl:=2, Val1:=TO_DINT(IforeUp));
            Status := TS_ON;
            Buf_Sel := IforeUp;
            Buf_Rear := FALSE;
        ELSIF IrearUp<>0 AND Scu.PneumActReady THEN
            (* Senza aria è abbastanza normale che accada *)
            dlog( Txt:='fbAlgnBlocks: ! Rear up sensor at rest (0x%lX)', Lvl:=2, Val1:=TO_DINT(IrearUp));
            Status := TS_ON;
            Buf_Sel := IrearUp;
            Buf_Rear := TRUE;
        ELSIF Cmd>=3 THEN
            (* dlog( Txt:='fbAlgnBlocks: ! Resetting blocks at rest', Lvl:=2 ); *)
            Status := TS_GOINGOFF;
        ELSIF Cmd>0 AND Allow THEN
            (* Bufferizzo e depuro il comando dai piedini non presenti,
               importante per sapere quali effettivamente devono salire *)
            Buf_Sel := Sel & (SHL(INT#1, vnAlgnBlks_N) - 1);
            (* Se nullo, seleziona tutti i piedini *)
            IF Buf_Sel=0 THEN Buf_Sel := SHL(INT#1, vnAlgnBlks_N) - 1; END_IF;
            Buf_Rear := Cmd=2; (* Mi ricordo del selettore piedini posteriori *)
            (* Imposto le uscite di set *)
            IF Buf_Rear THEN
                OforeUpSet := INT#0;
                OrearUpSet := Buf_Sel;
                (* Rinfresco i reset? *)
                IF vbAlgnBlks_RefreshRst THEN
                    OforeUpRst := INT#16#FFFF;
                    OrearUpRst := NOT Buf_Sel;
                ELSE
                    OforeUpRst := INT#0;
                    OrearUpRst := INT#0;
                END_IF;
            ELSE
                OforeUpSet := Buf_Sel;
                OrearUpSet := INT#0;
                (* Rinfresco i reset? *)
                IF vbAlgnBlks_RefreshRst THEN
                    OforeUpRst := NOT Buf_Sel;
                    OrearUpRst := INT#16#FFFF;
                ELSE
                    OforeUpRst := INT#0;
                    OrearUpRst := INT#0;
                END_IF;
            END_IF;
            Status := TS_WAITON;
        END_IF;

END_CASE; (* -- State machine *)

(* -- Monitors -- *)
AtRest := Status=TS_OFF;
vnAlgnBlocks_Sts := Status;
vbAlgnBlocks_SelRear := Buf_Rear;
vnAlgnBlocks_Msk := SEL( Status=TS_ON, INT#0, Buf_Sel );
vnAlgnBlocks_Glass := SEL( Buf_Rear, IforeGlass, IrearGlass );
(* vnAlgnBlocks_Up := SEL( Buf_Rear, IforeUp, IrearUp ); *)

Rising := Status=TS_WAITON; (* Piedini in fase di salita (per controllo sotto il vetro) *)
ForeUp := Status>=TS_WAITON AND NOT Buf_Rear; (* OR IforeUp<>0 *)
RearUp := Status>=TS_WAITON AND     Buf_Rear; (* OR IrearUp<>0 *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbAlgn

{ DE:"Gestione ponte riscontri" }

	VAR_IN_OUT
	Blocks : fbAlgnBlocks; { DE:"Attuazione salita/discesa piedini di riscontro" }
	END_VAR

	VAR_INPUT
	Allow : BOOL; { DE:"Consenso alle operazioni dei riscontri" }
	Abort : BOOL; { DE:"Segnale di stop/annullamento sequenza" }
	Suspend : BOOL; { DE:"Segnale di sospensione sequenza" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato principale del sistema" }
	AtRest : BOOL; { DE:"Fermo, piedini bassi, fuori da zona taglio" }
	InCutZone : BOOL; { DE:"Riscontri in zona taglio" }
	UnderClamp : BOOL; { DE:"Riscontri sotto premilastra o in zona taglio" }
	FixedOffVents : INT; { DE:"Zone aria spente fisse durante operazione" }
	FixedOnVents : INT; { DE:"Zone aria accese fisse durante operazione" }
	DrivenVents : INT; { DE:"Zone aria pilotate durante operazione" }
	DriveVents : BOOL; { DE:"Pilotaggio zone aria durante operazione" }
	NeedAir : BOOL; { DE:"Il trascinamento necessita del cuscino d'aria" }
	RearBlocks : BOOL; { DE:"Memorizza scelta piedini nel riscontro/spinta" }
	ID : INT := ID_ALGN; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	vd : ARRAY[ 0..255 ] OF LREAL; { DE:"VD[]" }
	vbHeartBeat : BOOL; { DE:"Battito di vita 1s" }
	vbHomingDone : BOOL; { DE:"Homing was successfully executed" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vbSloppyManual : BOOL; { DE:"Modalità manuale senza inserire dimensioni lastra" }
	vbAlgn_DontDriveVents : BOOL; { DE:"Non pilotare i ventilatori nel riscontro con operatore" }
	vbAlgn_VentsOnAtAlign : BOOL; { DE:"Accendi i ventilatori al riscontro se non pilotati" }
	vbSelAlgnLessAir : BOOL; { DE:"Meno aria nel riscontro (vetri che fluttuano)" }
	LowerCutZone_Algn : INT; { DE:"Spazio sotto il piano nell'area di taglio lato risc" }
	LowerCutZone_Dtch : INT; { DE:"Spazio sotto il piano nell'area di taglio lato stacco" }
	vbFeat_AlgnCanDragFwd : BOOL; { DE:"I riscontri possono agganciare un pezzo a zero e trascinarlo avanti" }
	vbFeat_AlgnHasBelts : BOOL; { DE:"Riscontri provvisti di cinghie (non i rulli)" }
	SelectProdVents : fbSelectProdVents; { DE:"Seleziona zone cuscino aria zona riscontro" }
	SelectRemnVents : fbSelectRemnVents; { DE:"Seleziona zone cuscino aria zona rimanenza" }
	vnVents_Cmd : INT; { DE:"Comando gruppi ventilatori cuscino aria a bit" }
	vbVents_MotorsOn : BOOL; { DE:"Avvia motori senza aprire le serrande" }
	vbVent_JoinedAlgnCT : BOOL; { DE:"Zone aria riscontri banda alta e premilastra sono unite" }
	vbAirCushionReady : BOOL; { DE:"Stato complessivo del cuscino d'aria" }
	vnHoldPads_Cmd : INT; { DE:"Comando discesa tamponi fermavetro" }
	vnClampAlgn_Cmd : INT; { DE:"Comando discesa premilastra lato riscontri" }
	vnClampDtch_Cmd : INT; { DE:"Comando discesa premilastra lato stacco" }
	vbClampAlgn_AlmostUp : BOOL; { DE:"Segnale per anticipo attesa premilastra alto" }
	vbClampDtch_AlmostUp : BOOL; { DE:"Segnale per anticipo attesa premilastra alto" }
	OutZone : fbOutZone; { DE:"Zona fine linea" }
	vbAlgn_IgnoreDragCmds : BOOL; { DE:"Prenota riscontri, postponi comandi di trascinamento avanti" }
	vbAlgnEvac_Scheduled : BOOL; { DE:"Prenotazione evacuazione fuori" }
	vqAlgnEvac_Xbck : DINT; { DE:"Posizione bordo indietro vetro da evacuare fuori [um]" }
	vqProd_Width : DINT; { DE:"Dimensione longitudinale prodotto del taglio [um]" }
	vqProcArea_Xmax : DINT; { DE:"Zona occupata da sottolastra in arrivo [um]" }
	vnAlgn_Cmd : INT; { DE:"Comando riscontri (vedi 'ALC_*')" }
	vqAlgn_Tgt : DINT; { DE:"Quota di riscontro [um] (neg:invalid)" }
	vqAlgnSheet_X : DINT; { DE:"Posizione bordo avanti lastra riscontranda [um]" }
	vqAlgnSheet_Width : DINT; { DE:"Larghezza lastra riscontranda [um]" }
	vqAlgnSheet_Height : DINT; { DE:"Altezza lastra riscontranda [um]" }
	vbAlgn_FastPush : BOOL; { DE:"Seleziona velocità nella spinta" }
	vbAlgn_UserAlign : BOOL; { DE:"Sequenza di riscontro con operatore" }
	vbAlgn_FreezeToPlace : BOOL; { DE:"Fermati con piedini alti per permettere di posizionare il vetro" }
	vnAlgn_Seq : INT; { DE:"Stato della sequenza di riscontro/reset dei riscontri" }
	vnAlgn_DragCmd : INT; { DE:"Comando trascinamento avanti con riscontri" }
	Alignable : fbAlignable; { DE:"Controllo riscontrabilità/agganciabilità" }
	vnAlgnDlvr_Id : INT; { DE:"Identificativo vetro da portare a fine linea" }
	vbAlgnDrag_WasOnFtc : BOOL; { DE:"Il vetro è stato lasciato sopra la fotocellula" }
	vqAlgnDrag_Tgt : DINT; { DE:"Posizione di arrivo del bordo avanti nel trascinamento avanti [um]" }
	vqAlgnDrag_Width : DINT; { DE:"Larghezza vetro da trascinare a fine linea [um]" }
	vqAlgnDrag_Xbck : DINT; { DE:"Posizione bordo indietro vetro trascinato avanti [um]" }
	vqAlgnDrag_Ybtm : DINT; { DE:"Posizione Y basso vetro da trascinare avanti [um]" }
	vqAlgnDrag_Ytop : DINT; { DE:"Posizione Y alto vetro da trascinare avanti [um]" }
	vqAlgnDrag_Mass : DINT; { DE:"Massa vetro da trascinare avanti [g]" }
	vnAlgn_DragSeq : INT; { DE:"Stato/risultato sequenza di trascinamento con riscontri" }
	vqAlgnDlvr_PausePos : DINT; { DE:"Richiesta pausa consegna pezzo (posizione bordo indietro) [um]" }
	vqDeliver_DefaultXbck : DINT; { DE:"Posizione rilascio bordo indietro se non si porta a fine linea [um]" }
	vbAlgn_DragMoveToNext : BOOL; { DE:"Dopo il trascinamento preposiziona verso quota più probabile" }
	vqNextStep_FirstAlgn : DINT; { DE:"Prossima quota riscontri (per rotazione o processazione) [um]" }
	vbFeed_Accessible : BOOL; { DE:"Tavolo di carico accessibile" }
	vqFeed_Xend : DINT; { DE:"Ascissa bordo avanti del tavolo di carico [um]" }
	vnShift_Cmd : INT; { DE:"Comando a sistema di trasporto vetro" }
	vnRemn_PostSts : INT; { DE:"Stato post-movimentazioni rimanenza" }
	vnProd_Id : INT; { DE:"Identificativo prodotto" }
	vnProd_Rot : INT; { DE:"Rotazione prodotto (multipli di 90°)" }
	vqAlgn_CurrX : DINT; { DE:"Posizione attuale dei piedini riscontri selezionati [um]" }
	vqAlgn_XroomP : DINT; { DE:"Ingombro X avanti dei piedini riscontri selezionati [um]" }
	vbShift_AlmostThere : BOOL; { DE:"Chiamata Lastra: quasi arrivata per riscontro" }
	vqSubSheet_X : DINT; { DE:"Posizione X bordo avanti della lastra in arrivo [um]" }
	vqXph_OutZoneEnd : DINT; { DE:"Ascissa fotocellula fine zona fine linea [um]" }
	vqX_OutZoneBegin : DINT; { DE:"Ascissa inizio zona fine linea [um]" }
	vqX_OutZoneEnd : DINT; { DE:"Quota X fine linea [um]" }
	vqX_OutTableEnd : DINT; { DE:"Ascissa legno fine tavolo a valle [um]" }
	vbOutTable_Present : BOOL; { DE:"Presenza di un tavolo a valle" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqAlgn_VentOffM1 : DINT; { DE:"Soglia massa minima anticipo spegnimento aria [g]" }
	vqAlgn_VentOffM2 : DINT; { DE:"Soglia massa massima anticipo spegnimento aria [g]" }
	vqAlgn_VentOffD1 : DINT; { DE:"Anticipo spegnimento aria massimo [um]" }
	vqAlgn_VentOffD2 : DINT; { DE:"Anticipo spegnimento aria minimo [um]" }
	vqAlgn_VentOffAlgnAdd : DINT; { DE:"Aumento anticipo chiusura cuscino aria con lastre tutte sui riscontri [um]" }
	vqX_AlgnBandC : DINT; { DE:"Ascissa fine zona cuscino aria riscontri taglio [um]" }
	vqY_AlgnBandB : DINT; { DE:"Ordinata fine zona cuscino aria riscontri banda bassa [um]" }
	vqY_AlgnBandM : DINT; { DE:"Ordinata fine zona cuscino aria riscontri banda mediana [um]" }
	vqVent_AirDelay : DINT; { DE:"Latenza apertura/chiusura flusso aria [ms]" }
	vbAlgn_VentOffOnImpact : BOOL; { DE:"Spegni cuscino aria all'urto col vetro" }
	vqAlgn_WidthNoAir : DINT; { DE:"Soglia larghezza riscontro senza aria [um]" }
	vqAlgn_MassNoVents : DINT; { DE:"Soglia massa per partenza con ventilatori spenti [Kg]" }
	vqAlgn_ThcknTopAir : DINT; { DE:"Spessore massimo per banda alta sempre spenta [um]" }
	vqAlgn_ThcknDtchAir : DINT; { DE:"Spessore massimo per zona stacco sempre spenta [um]" }
	vnAlgnBlocks_Cmd : INT; { DE:"Comando piedini di riscontro (0:none 1:set-fore 2:set-rear 3:sel-reset 4:act-reset ›4:full-reset)" }
	vnAlgnBlocks_Sel : INT; { DE:"Selezione piedini di riscontro (bit0:p1, ..., bit15:sel-rear)" }
	vnAlgnBlocks_Glass : INT; { DE:"Maschera stato sensori presenza vetro sui piedini" }
	vbAlgn_SuspendOnSafety : BOOL; { DE:"Sospendi movimento all'attivazione sicurezze" }
	vqAlgn_BlocksUpSpdMax : DINT; { DE:"Velocità massima con piedini alti [um/min]" }
	vbAlgn_NoGlassOnUp : BOOL; { DE:"Abortisci salita piedini se leggono i sensori vetro" }
	vqAlgn_XminCheckOnUp : DINT; { DE:"Soglia posizione minima per controllo piedini sotto il vetro [um]" }
	vbAlgn_MoveOnReset : BOOL; { DE:"Sposta sempre i piedini prima del reset indipendentemente dai sensori" }
	vqAlgn_MeetForce : DINT; { DE:"Limite forza nella fase di incontro vetro [mN]" }
	vqAlgn_MeetPosErr : DINT; { DE:"Errore inseguimento per rilevazione incontro con vetro [um]" }
	vbAlgn_ModulateSpeed : BOOL; { DE:"Modula la velocità durante il riscontro" }
	vqAlgn_MeetSpd : DINT; { DE:"Velocità riscontro per incontrare il vetro [um/min]" }
	vnAlgn_PushAccel : INT; { DE:"Parzializzazione accelerazione durante fase di spinta [%]" }
	vqAlgn_PushSpd : DINT; { DE:"Velocità riscontro al contatto vetro [um/min]" }
	vbAlgn_AlignWaitXr : BOOL; { DE:"Attendi asse Xr pronto all'inizio del riscontro" }
	vnAlgnBlks_N : INT; { DE:"Numero dei piedini di riscontro !max=10!" }
	ivqAlgnBlks_Y : INT; { DE:"Accesso alle ordinate dei piedini" }
	vnAlgnBlk_Bsense : INT; { DE:"Indice piedino su cui è montato il sensore vetro su banda bassa" }
	vnAlgnBlk_Tsense : INT; { DE:"Indice piedino su cui è montato il sensore vetro su banda alta" }
	vnAlgnBlk_AuxRot : INT; { DE:"Indice piedino per ausilio rotazioni lato riscontro" }
	vqAlgnBlks_R : DINT; { DE:"Raggio dei piedini di riscontro [um]" }
	vqAlgnBlk_RearDist : DINT; { DE:"Distanza tra piedini anteriori e posteriori [um]" }
	vqAlgnBlk_ForeOppDist : DINT; { DE:"Distanza del punto di appoggio opposto dei piedini anteriori [um]" }
	vqAlgnBlk_RearOppDist : DINT; { DE:"Distanza del punto di appoggio opposto dei piedini posteriori [um]" }
	vqAlgnBlks_DY1_2 : DINT; { DE:"Distanza tra piedino di riscontro 1 e 2 [um]" }
	vqAlgnBlk_YMargin : DINT; { DE:"Margine per uso piedini di riscontro [um]" }
	vqAlgn_UpMargin : DINT; { DE:"Margine per salita piedini al riscontro [um]" }
	vqAlgn_MinUpMargin : DINT; { DE:"Margine minimo garantito per salita piedini al riscontro [um]" }
	vqShift_MaxTurn : DINT; { DE:"Massimo fuori squadra ammesso dopo traslazione [deg]" }
	vqAlgn_DxForeAdjust : DINT; { DE:"Correzione quota riscontro piedini anteriori [um]" }
	vqAlgn_DxRearAdjust : DINT; { DE:"Correzione quota riscontro piedini posteriori [um]" }
	vqAlgn_DxReset : DINT; { DE:"Spostamento prima di abbassare i piedini [um]" }
	vqX_AlgnRearM : DINT; { DE:"Quota minima per cui è possibile alzare i piedini posteriori [um]" }
	vqX_AlgnForeM : DINT; { DE:"Quota minima per cui è possibile abbassare i piedini anteriori [um]" }
	vqX_AlgnForeP : DINT; { DE:"Quota massima per cui è possibile alzare i piedini anteriori [um]" }
	vqFall_MaxMargin : DINT; { DE:"Margine massimo sui controlli caduta vetro [um]" }
	vqAlgn_XforeMax : DINT; { DE:"Massima quota per uso piedini anteriori [um]" }
	vqX_CutZoneP : DINT; { DE:"Quota Xr al di sotto della quale si entra in zona taglio [um]" }
	vqX_ClampAlgnP : DINT; { DE:"Quota X fine premilastra riscontri [um]" }
	vqAlgn_XrClampAlgnM : DINT; { DE:"Quota Xr di inizio premilastra riscontro per condizione UnderClamp [um]" }
	vqAlgn_XrMinSafe : DINT; { DE:"Quota Xr limite rischio collisione riscontri-carrello inferiore [um]" }
	vqAlgn_XrAcqDtch : DINT; { DE:"Quota Xr limite per acquisizione risorsa zona stacco [um]" }
	Carriages : fbCarriages; { DE:"Carrelli" }
	vnGrab_RotStatus : INT; { DE:"Tipo rotazione in corso" }
	vqCarr_StillSpd : DINT; { DE:"Soglia velocità carrello quasi fermo [um/min]" }
	vnCarrInf_Cmd : INT; { DE:"Comando carrello inferiore" }
	vnCarriages_Cmd : INT; { DE:"Comando carrelli coordinati" }
	vbAlgn_EnableDrag : BOOL; { DE:"Abilita il trascinamento avanti" }
	vbAlgn_MinBlocksDrag : BOOL; { DE:"Nel trascinamento alza solo i piedini necessari" }
	vbAlgn_DragWaitXr : BOOL; { DE:"Attendi asse Xr pronto all'inizio del trascinamento" }
	vnAlgnBlocks_DragMsk : INT; { DE:"Maschera piedini coinvolti nel trascinamento" }
	vqAlgn_DragSpd : DINT; { DE:"Velocità trascinamento vetro [um/min]" }
	vqAlgn_DragMinForce : DINT; { DE:"Limite minimo forza nel trascinamento del vetro [mN]" }
	vqAlgn_DragMaxForce : DINT; { DE:"Limite massimo forza nel trascinamento del vetro [mN]" }
	vnAlgn_DragAccel : INT; { DE:"Parzializzazione accelerazione durante trascinamento [%]" }
	vqAlgn_DragMinDisp : DINT; { DE:"Movimento minimo per cui vale la pena spostare il pezzo [um]" }
	vqAlgn_DragVentOffDx : DINT; { DE:"Anticipo spegnimento aria nel trascinamento avanti [um]" }
	vqAlgn_DragForeMargin : DINT; { DE:"Margine di aggancio con piedini anteriori [um]" }
	vqAlgn_DragRearMargin : DINT; { DE:"Margine di inizio spinta con piedini posteriori [um]" }
	vnDeliver_ProcPriority : INT; { DE:"Priorità della processazione su consegna pezzi" }
	vqDtch_CurrX : DINT; { DE:"Posizione attuale del modulo di stacco [um]" }
	vqRotBlk_MaxErr : DINT; { DE:"Errore inseguimento ammesso del piedino durante rotazione [um]" }
	vqRemn_X : DINT; { DE:"Posizione bordo avanti della rimanenza [um]" }
	vqYo_SheetFeed : DINT; { DE:"Ordinata ideale/tipica della lastra in arrivo dal carico [um]" }
	vqYmax : DINT; { DE:"Ordinata massima del bordo vetro (limite del ponte di taglio) [um]" }
	Xr : fbM32Axis; { DE:"Asse riscontri AX_XR" }
	fcDtchLast : fbPhotoCell; { DE:"Ultima fotocellula su modulo stacco (IFC_DTCH_LAST)" }
	fcOutzoneEnd : fbPhotoCell; { DE:"Fotocellula a fine linea (IFC_OUTZONE_END)" }
	fcOutzoneNearEnd : fbPhotoCell; { DE:"Fotocellula prossimità fine linea (IFC_OUTZONE_NEAREND)" }
	ICM_OUTZONE_PEDAL : BOOL; { DE:"Pedaliera blu a fine linea" }
	ICM_ACKNOWLEDGE : BOOL; { DE:"Conferma richieste, intervento manuale effettuato" }
	END_VAR

	VAR
	MoveTo : EN_AXIS_MV_CMD := MV_DONE; { DE:"Servizio movimentazione asse Xr" }
	CanMoveTo : BOOL; { DE:"Possibile procedere col movimento" }
	GlassDetectable : BOOL; { DE:"Vetro rilevabile dai sensori sui piedini di riscontro" }
	DragForeBlocks : BOOL; { DE:"Memorizza scelta piedini nel trascinamento" }
	Delta : DINT; { DE:"Appoggio per calcoli [um]" }
	Dx_VentOff : DINT; { DE:"Anticipo spegnimento aria [um]" }
	Move_LimM : DINT; { DE:"Limite negativo movimento [um]" }
	Move_LimP : DINT; { DE:"Limite positivo movimento [um]" }
	Algn_Mass : LREAL; { DE:"Massa della lastra riscontranda [Kg]" }
	Drag_Mass : LREAL; { DE:"Massa della lastra in trascinamento avanti [Kg]" }
	AirReadyDelayed : fbDelayedRise; { DE:"Filtro segnale aria pronta per modulazione velocità" }
	END_VAR

	{ CODE:ST }(*    fbAlgn (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa le sequenze di riscontro:
         .Reset dei piedini
         .Riscontro ad una quota
         .Indicatore riscontri
         .Evacuazione pezzo con riscontri
      Risorse che può occupare:
         .'UpperCutZone' (zona taglio alta - collisione carr sup)
         .'LowerCutZone_Dtch' (zona taglio bassa lato stacco - collisione carr inf)
         .'LowerCutZone_Algn' (zona taglio bassa lato risc - collisione lampada)

      DETAILS
      ----------------------------------------------
      I piedini anteriori e posteriori sono su un
      sistema a bilancere, quando uno si alza,
      l'altro si abbassa.
      C'è una quota minima per cui è bene non
      abbassare i piedini anteriori (alzare i
      posteriori) e una quota massima in cui è
      bene non abbassare i piedini posteriori
      (alzare gli anteriori).
      Le quote si riferiscono alla parte estrema
      dei piedini anteriori rispetto l'asse di
      taglio.

      NOTES
      ----------------------------------------------
      Essendo questo un servizio finale rispondo
      direttamente al comando 'vnAlgn_Cmd' in modo
      da poterlo resettare e dare un feedback
      immediato.

      USAGE
      ----------------------------------------------
      vnAlgnBlocks_Sel = 0 // Select all blocks
      vqAlgn_Tgt = 500
      vqAlgnSheet_X = 510
      vqAlgnSheet_Width = 2000
      vqAlgnSheet_Height = 900
      vbAlgn_UserAlign = 0
      vnAlgn_Cmd = ALCMD_ALIGN
      WaitCond( vnAlgn_Cmd==CMD_STOP ) // vn[ivnStatus+ID_ALGN]==STS_IDLE
      //vnAlgn_Seq==SEQ_DONE // Riscontro completato con successo
      //vnAlgn_Seq==ALSEQ_ALGN_NOCONTACT // Riscontro senza contatto vetro
      //vnAlgn_Seq!=SEQ_DONE // Riscontro non completato
*)

(* -- Manage stop signal --
   Typically Abort:=vbStopSignal *)
IF Abort THEN
    vnAlgn_Cmd := CMD_STOP;
    vnAlgn_DragCmd := CMD_STOP;
    vbAlgnEvac_Scheduled := FALSE;
    Xr.Cmd := AXC_STOP_ENAB;
(* ELSIF Suspend THEN (* Could suspend? servirebbe fermare l'asse e partire dallo step precedente *)
END_IF;
(* Notify abort *)
IF (Status>STS_STOPPING AND Status<>ALSTS_DRIVEN AND MoveTo>MV_WAITSTOP) AND vnAlgn_Cmd=CMD_STOP AND vnAlgn_DragCmd=CMD_STOP THEN
    dlog( Txt:='fbAlgn: !! Abort Sts=%d Seq=%d,%d MoveTo=%ld', Lvl:=3, Val1:=TO_DINT(Status), Val2:=TO_DINT(vnAlgn_Seq), Val3:=TO_DINT(vnAlgn_DragSeq), Val4:=MoveTo );
END_IF;

(* Per evitare commutazioni troppo frequenti *)
AirReadyDelayed( in:=vbAirCushionReady, pt:=500 );


(* -- State machine -- *)
CASE Status OF

    (* =================================================================== *)
    STS_STOPPING : (* Attendo stop asse *)
        IF MoveTo<MV_WAITSTOP AND Xr.Status<=AXS_READY THEN
            Status := STS_IDLE;
        END_IF;
            
    
    (* =================================================================== *)
    STS_MOVING : (* Movimento generico in corso *)
        IF vnAlgn_Cmd=CMD_STOP THEN
            Status := STS_STOPPING;
        ELSIF MoveTo<MV_WAITSTOP THEN
            (* Movimento terminato *)
            vnAlgn_Cmd := CMD_STOP;
            IF MoveTo=MV_DONE THEN
                dlog( Txt:='fbAlgn: Movement to %ld done', Lvl:=5, Val1:=Xr.TgtPos/1E3 );
                vnAlgn_Seq := SEQ_DONE;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbAlgn: !! Movement to %ld not completed', Lvl:=2, Val1:=Xr.TgtPos/1E3 );
                vnAlgn_Seq := SEQ_ERROR;
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* =================================================================== *)
    ALSTS_RESETTING : (* Discesa piedini + quota riposo *)

        (* -- Reset sequence -- *)
        CASE vnAlgn_Seq OF

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            SEQ_START : (* Inizio della sequenza di reset piedini *)
                (* Vediamo la situazione *)
                (* Dato il movimento a bilancere dei piedini, meglio allontanarsi
                   prima di abbassarli in questi casi:
                   .Anteriori in contatto con vetro verso zero (posso controllare sensore)
                   .Posteriori in contatto con vetro verso fine linea (evacuazione lastra fermata) *)
                IF Blocks.AtRest THEN
                    (* Piedini già bassi *)
                    (* dlog( Txt:='fbAlgn: RESET: Blocks already down', Lvl:=5 ); *)
                    vnAlgn_Seq := ALSEQ_RESET_DWN;
                ELSIF (Blocks.IforeGlass<>0 OR vbAlgn_MoveOnReset) AND NOT Blocks.Buf_Rear THEN
                    (* Piedini anteriori alti in contatto con vetro verso taglio:
                       Mi sposto un po' verso fine linea prima di abbassarli *)
                    dlog( Txt:='fbAlgn: RESET: Move away fore blks', Lvl:=5 );
                    (* Spostamento in avanti prima di abbassare piedini anteriori *)
                    Xr.TgtPos := MAX(Xr.CurrPos+vqAlgn_DxReset, vqX_AlgnForeM+1E3); (* [um] *)
                    (* Se c'è tanto spostamento vai un po' più veloce *)
                    Xr.TgtSpd := SEL((Xr.TgtPos-Xr.CurrPos)>50E3, vqAlgn_PushSpd, vqAlgn_BlocksUpSpdMax ); (* [um/min] *)
                    vnAlgn_Seq := ALSEQ_RESET_GODWN;
                ELSIF vnAlgn_DragSeq=ALSEQ_DRAG_REAR AND Blocks.Buf_Rear THEN
                    (* Piedini posteriori alti in contatto con vetro verso fine linea:
                       Mi sposto un po' verso il taglio prima di abbassarli *)
                    dlog( Txt:='fbAlgn: RESET: Move away rear blks', Lvl:=5 );
                    (* Spostamento indietro prima di abbassare piedini posteriori *)
                    Xr.TgtPos := Xr.CurrPos - vqAlgn_DxReset; (* [um] *)
                    Xr.TgtSpd := vqAlgn_PushSpd; (* slow [um/min] *)
                    vnAlgn_Seq := ALSEQ_RESET_GODWN;
                ELSE
                    (* In questa situazione non serve spostarmi per abbassare i piedini *)
                    (* dlog( Txt:='fbAlgn: RESET: Lowering blocks at %ld mm', Lvl:=5, Val1:=Xr.CurrPos/1E3 ); *)
                    vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_Seq := ALSEQ_RESET_DWN;
                END_IF;
                (* - Comando l'eventuale movimento che precede il reset piedini - *)
                IF vnAlgn_Seq=ALSEQ_RESET_GODWN THEN
                    (* Controllo prerequisiti *)
                    IF Xr.TgtPos<Xr.CurrPos AND Xr.TgtPos<vqAlgn_XrMinSafe THEN
                        (* Se l'allontanamento dal vetro comporta entrare nella zona taglio, lo salto *)
                        dlog( Txt:='fbAlgn: RESET: ! Would go in cut zone (%ld)', Lvl:=2, Val1:=vqAlgn_XrMinSafe/1E3 );
                        vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini comunque *)
                        vnAlgn_Seq := ALSEQ_RESET_DWN;
                    ELSE
                        Xr.AccPerc := 100; (* max [%] *)
                        Xr.DecPerc := 100; (* max [%] *)
                        Xr.OutFrc := 0; (* just move *)
                        Xr.MaxPosErr := WTR_HITDET;
                        MoveTo := MV_TOOLMOVE;
                        (* vnAlgn_Seq := ALSEQ_RESET_GODWN; (* É già così *)
                    END_IF;
                END_IF; (* Comando il movimento che precede il reset piedini *)


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_RESET_GODWN : (* Spostamento con piedini alti verso quota discesa *)
                IF MoveTo=MV_DONE THEN
                    (* dlog( Txt:='fbAlgn: RESET: Lowering blocks at %ld mm', Lvl:=5, Val1:=Xr.CurrPos/1E3 ); *)
                    vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_Seq := ALSEQ_RESET_DWN;
                ELSIF MoveTo=MV_ERROR THEN (* Abort sequence *)
                    dlog( Txt:='fbAlgn: !! RESET_GODWN: Error', Lvl:=2 );
                    vnAlgn_Seq := SEQ_ERROR;
                (* ELSE wait movement *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_RESET_DWN : (* Attesa discesa piedini *)
                IF vnAlgn_Cmd=CMD_STOP THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF Blocks.AtRest THEN
                    dlog( Txt:='fbAlgn: RESET: Blocks lowered at %ld mm', Lvl:=5, Val1:=Xr.CurrPos/1E3 );
                    (* Eat possible temporary flags *)
                    vbAlgn_IgnoreDragCmds := FALSE;
                    (* Se ho lanciato il reset prima di un riscontro, prosegui con la seq *)
                    IF vnAlgn_Cmd=ALCMD_ALIGN THEN
                        dlog( Txt:='fbAlgn: RESET: Done, prosecute to align', Lvl:=5 );
                        Status := ALSTS_ALIGNING; (* Prosecute with aligning *)
                        vnAlgn_Seq := SEQ_START;
                    (* Se ho lanciato il reset prima di trascinare a fine linea, prosegui con la seq *)
                    ELSIF vnAlgn_DragSeq=ALSEQ_DRAG_INIT OR vnAlgn_DragSeq=ALSEQ_DRAG_SUSPENDED THEN
                        dlog( Txt:='fbAlgn: RESET: Done, prosecute to drag', Lvl:=5 );
                        vnAlgn_Cmd := CMD_STOP; (* Resetto il comando *)
                        Status := ALSTS_DRAGFWD;
                    (* Era solo un reset, vedi se bisogna liberare zona taglio *)
                    ELSIF Xr.CurrPos<vqX_ClampAlgnP THEN
                        dlog( Txt:='fbAlgn: RESET: Better free cut-clamp zone', Lvl:=5 );
                        Xr.TgtPos := vqX_ClampAlgnP + 50E3; (* [um] *)
                        MoveTo := MV_FREEMOVE;
                        vnAlgn_Seq := ALSEQ_RESET_HOME;
                    ELSE
                        (* Altrimenti abbiamo finito *)
                        vnAlgn_Seq := SEQ_DONE;
                    END_IF;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_RESET_HOME : (* Movimento di allontanamento da zona taglio *)
                IF MoveTo<MV_WAITSTOP THEN
                    (* Movimento terminato *)
                    IF MoveTo=MV_DONE THEN
                        dlog( Txt:='fbAlgn: Cut zone freed', Lvl:=5 );
                        vnAlgn_Seq := SEQ_DONE;
                    ELSE
                        vnAlgn_Seq := SEQ_ERROR;
                    END_IF;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            SEQ_DONE : (* Reset piedini terminato *)
                dlog( Txt:='fbAlgn: RESET: Done', Lvl:=5 );
                vnAlgn_Cmd := CMD_STOP; (* Resetto il comando *)
                (* RearBlocks := FALSE; *)
                Status := STS_IDLE;
                (* Free possible acquired resources *)
                IF LowerCutZone_Algn=ID AND Xr.CurrPos>=vqAlgn_XrMinSafe THEN LowerCutZone_Algn:=0; END_IF;
                IF LowerCutZone_Dtch=ID AND Xr.CurrPos>=vqAlgn_XrAcqDtch THEN LowerCutZone_Dtch:=0; END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ELSE (* SEQ_ERROR : (* Reset piedini non terminato *)
                vnAlgn_Cmd := CMD_STOP; (* Resetto il comando *)
                (* Se ho lanciato il reset durante la sequenza di trascinam
                   a fine linea, faccio gestire l'errore a lei *)
                IF vnAlgn_DragSeq=ALSEQ_DRAG_INIT OR vnAlgn_DragSeq=ALSEQ_DRAG_SUSPENDED THEN
                    dlog( Txt:='fbAlgn: !! DRAG: Blocks reset failed', Lvl:=2 );
                    vnAlgn_DragSeq := SEQ_ERROR;
                    Status := ALSTS_DRAGFWD;
                ELSE
                    (* Fallimento normale *)
                    (* Free possible acquired resources *)
                    IF LowerCutZone_Algn=ID AND Xr.CurrPos>=vqAlgn_XrMinSafe THEN LowerCutZone_Algn:=0; END_IF;
                    IF LowerCutZone_Dtch=ID AND Xr.CurrPos>=vqAlgn_XrAcqDtch THEN LowerCutZone_Dtch:=0; END_IF;
                    Status := STS_IDLE;
                END_IF;

        END_CASE; (* -- Reset sequence *)


    (* =================================================================== *)
    ALSTS_ALIGNING : (* Sequenza di riscontro in corso *)

        (* Nota: questa sequenza non viene mai sospesa
        IF vnAlgn_Cmd<>ALCMD_ALIGN THEN Status:=STS_IDLE; END_IF; *)

        (* -- Normal align sequence -- *)
        CASE vnAlgn_Seq OF

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            SEQ_START : (* Inizio della sequenza di riscontro *)
                IF vnAlgn_Cmd<>ALCMD_ALIGN THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Attendi un eventuale posizionamento precedente *)
                ELSIF vbAlgn_AlignWaitXr AND MoveTo=MV_WAITMOVE (* OR NOT Xr.Ready *) THEN
                    (* Waiting previous Xr movement... *)
                (* Se dovrò entrare in area taglio, attendi aventuali attività del carrello inferiore in corso... *)
                ELSIF vqAlgn_Tgt<vqAlgn_XrMinSafe AND (vnCarrInf_Cmd<>CMD_STOP OR vnCarriages_Cmd<>CMD_STOP) THEN
                    (* Waiting CarrInf... *)
                ELSE
                    dlog( Txt:='fbAlgn: Aligning %ldx%ld in %ld to %ld mm', Lvl:=5, Val1:=vqAlgnSheet_Width/1E3, Val2:=vqAlgnSheet_Height/1E3, Val3:=vqAlgnSheet_X/1E3, Val4:=vqAlgn_Tgt/1E3 );
                    (* -- Check inputs -- *)
                    (* Non ha senso riscontrare a una quota negativa *)
                    IF vqAlgn_Tgt<0 THEN
                        dlog( Txt:='!! Invalid target %ld mm', Lvl:=2, Val1:=vqAlgn_Tgt/1E3 );
                        SET_MSG(MSG_BAD_ALGNARGS,'MSG_BAD_ALGNARGS',vqAlgn_Tgt);
                        vnAlgn_Seq := SEQ_ERROR;
                    (* Il riscontro può solo spingere indietro la lastra, non può tirare avanti *)
                    ELSIF vqAlgnSheet_X<vqAlgn_Tgt THEN
                        (* Tipicamente: vqAlgnSheet_X = vqAlgn_Tgt + vqProc_AlgnDelta; *)
                        dlog( Txt:='!! Sheet in %ld cannot be pulled to %ld mm', Lvl:=2, Val1:=vqAlgnSheet_X/1E3, Val2:=vqAlgn_Tgt/1E3 );
                        SET_MSG(MSG_BAD_ALGNARGS,'MSG_BAD_ALGNARGS',vqAlgn_Tgt);
                        vnAlgn_Seq := SEQ_ERROR;
                    (* Dimensioni insensate *)
                    ELSIF vqAlgnSheet_Width<=0 OR vqAlgnSheet_Height<=0 THEN
                        dlog( Txt:='!! Bad sheet size %ldx%ld', Lvl:=2, Val1:=vqAlgnSheet_Width/1E3, Val2:=vqAlgnSheet_Height/1E3 );
                        SET_MSG(MSG_BAD_ALGNARGS,'MSG_BAD_ALGNARGS',0);
                        vnAlgn_Seq := SEQ_ERROR;
                    (* Controllo invasione tavolo di carico non accessibile *)
                    ELSIF (vqAlgn_Tgt-vqAlgnSheet_Width)<vqFeed_Xend AND NOT vbFeed_Accessible THEN
                        dlog( Txt:='!! Cannot invade feed (%ld<%ld)', Lvl:=2, Val1:=(vqAlgn_Tgt-vqAlgnSheet_Width)/1E3, Val2:=vqFeed_Xend/1E3 );
                        SET_MSG(MSG_FEED_NOT_READY,'MSG_FEED_NOT_READY',0);
                        vnAlgn_Seq := SEQ_ERROR;
                    ELSE
                        (* dlog( Txt:='Delta = %ld+%ld', Lvl:=6, Val1:=vqAlgn_UpMargin/1E3, Val2:=(vqAlgnSheet_X-vqAlgn_Tgt)/1E3 ); *)

                        (* -- Calcolo la quota dove far salire i piedini -- *)
                        (* Determino a che distanza far salire i piedini rispetto la lastra
                           (uso temporaneamente 'Delta' ) *)
                        IF vbAlgn_UserAlign AND (NOT vbAutoMode AND vbSloppyManual) THEN
                            (* Niente margine se comando esplicitamente il riscontro in modalità manuale "pigra" *)
                            Delta := 0; (* [um] *)
                        ELSE
                            (* Riscontro normale *)
                            Delta := vqAlgn_UpMargin; (* [um] *)

                            (* In automatico potrei tenere conto della rotazione per non andare sotto il vetro *)
                            IF vbAutoMode THEN
                                Delta := Delta + TO_DINT( TO_LREAL(vqAlgnSheet_Height/2) * SIN(MDEG2RAD * TO_LREAL(vqShift_MaxTurn)) );
                            END_IF;
                        END_IF;

                        (* Quota di salita piedini
                           Nota: Assegnando direttamente 'TgtPos' causo un cambio target di un
                                 eventuale movimento precedente! Per evitarlo vedi 'vbAlgn_AlignWaitXr' *)
                        Xr.TgtPos := vqAlgnSheet_X + Delta; (* [um] *)

                        (* Determina che piedini utilizzare
                           Di norma si preferisce usare i piedini anteriori perché
                           più regolati e meccanicamente più affidabili, quindi
                           fissiamo una soglia di cambio fissa più grande possibile
                           data dal limite software positivo: con i piedini posteriori
                           posso riscontrare quote più grandi di questa soglia fino a
                           Xr.PosLim + vqAlgnBlk_RearDist *)
                        RearBlocks := Xr.TgtPos >= (vqAlgn_XforeMax - Xr.InPosDelta);
                        IF RearBlocks THEN
                            (* Devo usare i piedini posteriori *)
                            dlog( Txt:='Using rear blocks (up in %ld-%ld)', Lvl:=5, Val1:=Xr.TgtPos/1E3, Val2:=vqAlgnBlk_RearDist/1E3 );
                            Xr.TgtPos := Xr.TgtPos - vqAlgnBlk_RearDist;
                            (* Verifico che sia possibile avere i piedini posteriori alti alla quota di arrivo *)
                            IF vqAlgn_Tgt < vqX_AlgnRearM THEN
                                dlog( Txt:='!! Rear blocks cant be at x=%ld<%ld', Lvl:=2, Val1:=vqAlgn_Tgt/1E3, Val2:=vqX_AlgnRearM/1E3 );
                                vnAlgn_Seq := SEQ_ERROR;
                            END_IF;
                            (* Se sforassi comunque al limite positivo, pur di
                               provare a riscontrare lo stesso rinuncio al margine salita piedini *)
                            IF Xr.TgtPos>Xr.PosLim AND Delta>vqAlgn_MinUpMargin THEN
                                dlog( Txt:='! Decreasing UpMargin to %ld to align near limit %ld', Lvl:=2, Val1:=vqAlgn_MinUpMargin/1E3, Val2:=(Xr.PosLim+vqAlgnBlk_RearDist)/1E3 );
                                Xr.TgtPos := Xr.TgtPos - (Delta - vqAlgn_MinUpMargin);
                            END_IF;
                            (* Il range dei movimenti con piedini posteriori alti: *)
                            Move_LimM := MAX(Xr.NegLim,vqX_AlgnRearM);
                            Move_LimP := Xr.PosLim;
                        ELSE
                            (* Devo usare i piedini anteriori *)
                            dlog( Txt:='Using fore blocks (up in %ld)', Lvl:=5, Val1:=Xr.TgtPos/1E3);

                            (* Il range dei movimenti con piedini anteriori alti: *)
                            Move_LimM := Xr.NegLim;
                            Move_LimP := MIN(Xr.PosLim,vqX_AlgnForeP);
                        END_IF;

                        (* La quota di salita deve essere raggiungibile coi piedini bassi! *)
                        (* MAX(Xr.NegLim,vqX_AlgnForeM) -- Xr.PosLim *)
                        (* La limito nel servizio movimento *)

                        (* -- Verifica delle condizioni di riscontrabilità -- *)

                        (* >> Controllo quota di salita piedini nel range X dei riscontri *)
                        IF Xr.TgtPos<Move_LimM OR Xr.TgtPos>Move_LimP THEN
                            dlog( Txt:='!! Up pos %ld outside %ld|%ld', Lvl:=2, Val1:=Xr.TgtPos/1E3, Val2:=Move_LimM/1E3, Val3:=Move_LimP/1E3);
                            vnAlgn_Seq := SEQ_ERROR;
                        END_IF;

                        (* Controlli in caso di assenza operatore (comando riscontro non esplicito) *)
                        IF NOT vbAlgn_UserAlign THEN

                            (* >> Controllo lastra molto bassa (non riscontrabile) *)
                            (* Nota: Se conoscessi già la posizione Y potrei verificare:
                               Alignable( ybtm:=vqYo_SheetFeed, ytop:=vqYo_SheetFeed+vqAlgnSheet_Height ); *)
                            Delta := vqAlgnBlks_DY1_2 + 2*vqAlgnBlk_YMargin;
                            IF vqAlgnSheet_Height<Delta THEN
                                dlog( Txt:='!! Wont align H=%ld<%ld mm', Lvl:=2, Val1:=vqAlgnSheet_Height/1E3, Val2:=Delta/1E3);
                                vnAlgn_Seq := SEQ_ERROR;
                            END_IF;

                            (* >> Controllo spazio di riscontro insufficiente * )
                            IF (vqAlgnSheet_X-vqAlgn_Tgt)<vqAlgn_MinDelta AND vbAutoMode AND NOT vbLastra_Dritta THEN
                                (* In automatico voglio garantire lo spazio di riscontro minimo
                                   se la lastra non partiva già dritta.
                                   Questo può essere utile nel caso di riscontro alla quota limite,
                                   dove pur di riscontrare rinuncio allo spazio di riscontro * )
                                dlog( Txt:='fbAlgn: !! Unsafe align space %ld < %ld mm', Lvl:=2, Val1:=(vqAlgnSheet_X-vqAlgn_Tgt)/1E3, Val2:=vqAlgn_MinDelta/1E3 );
                            END_IF; *)

                            (* >> Controllo rischio caduta vetro in zona taglio *)
                            (* Il criterio è questo: se ho una lastra che potenzialmente può cadere,
                               visto che si riscontra spingendo la lastra verso lo stacco,
                               non cade solo se:
                                 ● Nella posizione finale è ben appoggiata sul tavolo riscontri
                                 ● Nella posizione iniziale è ben appoggiata sullo stacco *)
                            (* La larghezza minima per cui c'è pericolo di caduta è il doppio del salto:
                                               ◂−−−−−−−−−−−−−−−−−−▸
                                               ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄╠════
                                      ▒▒▒▒▒▒▒▒◂−−−−−−−−−▸▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  *)
                            (* Nota: potrei usare 'vqFallWidth' ma voglio considerare la posizione effettiva dello stacco *)
                            Delta := (2*(vqX_CutZoneP-vqDtch_CurrX)) + vqFall_MaxMargin;
                            IF vqAlgnSheet_Width < Delta THEN
                                (* Questo vetro è stretto e può potenzialmente cadere.
                                   Assumo di usare i piedini anteriori con questo vetro stretto.
                                   La dimensione minima di appoggio per cui non cade è: *)
                                Delta := vqAlgnSheet_Width/2 + vqFall_MaxMargin;
                                IF (vqAlgn_Tgt-vqX_CutZoneP) >= Delta THEN
                                    (* Il vetro appoggia bene sui riscontri nella posizione finale
                                                         ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄╠════
                                      ▒▒▒▒▒▒▒▒▒▒▒▒             ▒▒▒▒▒▒▒▒▒▒▒▒ *)
                                    dlog( Txt:='W=%ld leans on algn %ld mm', Lvl:=5, Val1:=vqAlgnSheet_Width/1E3, Val2:=(vqAlgn_Tgt-vqX_CutZoneP)/1E3 );
                                ELSIF (vqDtch_CurrX - (vqAlgnSheet_X - vqAlgnSheet_Width)) >= Delta THEN
                                    (* Il vetro appoggia bene sullo stacco nella posizione iniziale
                                        ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄╠════
                                      ▒▒▒▒▒▒▒▒▒▒▒▒             ▒▒▒▒▒▒▒▒▒▒▒▒ *)
                                    dlog( Txt:='W=%ld leans on dtch %ld mm', Lvl:=5, Val1:=vqAlgnSheet_Width/1E3, Val2:=(vqDtch_CurrX-vqAlgnSheet_X+vqAlgnSheet_Width)/1E3 );
                                ELSE
                                    (* O nella posizione finale cade dai riscontri:
                                                    ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄╠════
                                      ▒▒▒▒▒▒▒▒▒▒▒▒   ↓         ▒▒▒▒▒▒▒▒▒▒▒▒
                                       O nella posizione iniziale cade dallo stacco:
                                            ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄╠════
                                      ▒▒▒▒▒▒▒▒▒▒▒▒         ↓   ▒▒▒▒▒▒▒▒▒▒▒▒  *)
                                    dlog( Txt:='!! W=%ld fall in hole %ld mm', Lvl:=2, Val1:=vqAlgnSheet_Width/1E3, Val2:=(vqX_CutZoneP-vqDtch_CurrX)/1E3 );
                                    SET_MSG(MSG_FALLINCUTZONE,'MSG_FALLINCUTZONE',vqAlgnSheet_Width);
                                    vnAlgn_Seq := SEQ_ERROR;
                                END_IF;
                            END_IF; (* -- rischio caduta *)
                        END_IF; (* Controlli senza operatore *)

                        (* -- Se tutto ok, procedi -- *)
                        IF vnAlgn_Seq<>SEQ_ERROR THEN

                            (* Calcolo la massa della lastra riscontranda.
                               Se volessi considerare solo la massa sui riscontri: vqAlgn_Tgt *)
                            Algn_Mass := fnGlassMass(vqAlgnSheet_Width,vqAlgnSheet_Height,vqGlass_Thckn);

                            (* Il vetro è rilevabile con i sensori sui piedini di riscontro? *)
                            GlassDetectable := (vnAlgnBlk_Bsense>0 AND vqAlgnSheet_Height>vq[ivqAlgnBlks_Y+vnAlgnBlk_Bsense]) OR
                                               (vnAlgnBlk_Tsense>0 AND vqAlgnSheet_Height>vq[ivqAlgnBlks_Y+vnAlgnBlk_Tsense]);

                            (* La zona fine linea è effettivamente occupata?
                               Il bordo avanti della lastra si trova in vqAlgnSheet_X *)
                            OutZone.XcheckIfBusy := vqAlgnSheet_X; (* Tra un ciclo PLC sono pronti 'Xbusy' e 'Free' *)

                            (* -- Ora vediamo cosa dobbiamo fare -- *)
                            (* Se i piedini corretti sono già su alla quota di
                               inizio riscontro, passo direttamente al movimento... *)
                            IF ((Blocks.ForeUp AND NOT RearBlocks) OR (Blocks.RearUp AND RearBlocks)) (* Piedini "giusti" alti... *)
                               AND ABS(vqAlgn_CurrX-vqAlgnSheet_X)<20E3 (* ...Piedini circa al bordo lastra *)
                               AND Xr.Status<=AXS_READY THEN (* ...Piedini fermi... *)
                                (* Ok, salto direttamente all'incontro vetro *)
                                dlog( Txt:='! Blocks already up at %ld mm', Lvl:=3, Val1:=vqAlgn_CurrX/1E3 );
                                vnAlgn_Seq := ALSEQ_ALGN_PREPAREMEET;
                            (* ...Altrimenti mi assicuro di abbassarli *)
                            ELSIF NOT Blocks.AtRest THEN
                                (* Ho i piedini su, li abbasso prima di proseguire *)
                                dlog( Txt:='! Lowering blocks up at %ld mm', Lvl:=3, Val1:=vqAlgn_CurrX/1E3 );
                                Status := ALSTS_RESETTING;
                                vnAlgn_Seq := SEQ_START;
                            ELSE
                                (* Comanda spostamento verso quota salita piedini *)
                                (* dlog( Txt:='fbAlgn: Move to up pos %ld', Lvl:=5, Val1:=Xr.TgtPos/1E3 ); *)
                                (* Se non sono già in moto, dò il comando per partire *)
                                IF MoveTo<>MV_WAITMOVE THEN MoveTo := MV_FREEMOVE; END_IF;
                                vnAlgn_Seq := ALSEQ_ALGN_GOUP;
                            END_IF;
                        END_IF;
                    END_IF; (* Checking prerequisites *)
                END_IF; (* Waiting conditions *)


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_GOUP : (* Spostamento con piedini bassi verso quota salita *)
                IF vnAlgn_Cmd<>ALCMD_ALIGN THEN (* Abort sequence *)
                    (* vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_ERROR THEN
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_DONE THEN
                    (* Movimento terminato *)
                    (* Se devo salire in zona fine linea meglio attendere che si liberi *)
                    IF NOT OutZone.Free AND (vqAlgn_CurrX+vqAlgnBlk_RearOppDist) >= OutZone.Xbusy THEN
                        IF NOT IS_MSG(REQ_FREE_OUTZONE) AND NOT ICM_ACKNOWLEDGE THEN
                            dlog( Txt:='fbAlgn: Requesting REQ_FREE_OUTZONE', Lvl:=4 );
                            SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE:',0); (* Aligning *)
                        END_IF;
                    (* Attendi premilastra riscontro via se sono sotto *)
                    ELSIF vqAlgn_CurrX<vqX_ClampAlgnP AND NOT vbClampAlgn_AlmostUp THEN (* See also Algn.UnderClamp *)
                        (* Attendo premilastra riscontro su... *)
                    (* Se sta arrivando la lastra, attendi che sia arrivata (vedi: vbStep_StartAlgnOnCall) *)
                    ELSIF vnShift_Cmd=SHFCMD_PLACE_SHEET THEN
                        (* Attendo arrivo lastra... *)
                    (* Eventuali richieste bloccanti *)
                    ELSIF IS_MSG(REQ_GET_SHEET) THEN
                        dlog( Txt:='fbAlgn: !! Must acknowledge REQ_GET_SHEET', Lvl:=2 );
                        vnAlgn_Seq := SEQ_ERROR;
                    ELSE
                        (* Comando piedini alti
                           Nota: i piedini sono selezionati dal chiamante con 'vnAlgnBlocks_Sel' *)
                        vnAlgnBlocks_Cmd := SEL( RearBlocks, INT#1, INT#2 );
                        (* Procedi *)
                        vnAlgn_Seq := ALSEQ_ALGN_UP;
                        vbVents_MotorsOn := TRUE; (* Assicuro motori ventilatori in moto *)
                    END_IF;
                (* ELSE wait movement *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_UP : (* Attendi salita piedini *)
                IF vnAlgn_Cmd<>ALCMD_ALIGN THEN (* Abort sequence *)
                    (* vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Controllo salita piedini sotto il vetro *)
                ELSIF vqAlgn_CurrX>vqAlgn_XminCheckOnUp AND vbAlgn_NoGlassOnUp AND Blocks.Rising AND vnAlgnBlocks_Glass<>0 THEN
                    dlog( Txt:='fbAlgn: !! Blocks under glass', Lvl:=2 );
                    SET_MSG(MSG_ALGN_UNDERGLASS,'ALSEQ_ALGN_UP',0);
                    vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Intercetta abort salita piedini *)
                ELSIF Blocks.Status<TS_GOINGON THEN
                    dlog( Txt:='fbAlgn: !! Raising blocks aborted', Lvl:=2 );
                    (* vnAlgnBlocks_Cmd := 3; (* Assicura piedini bassi? *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Attendo piedini alti *)
                ELSIF Blocks.Status=TS_ON THEN
                    vnAlgn_Seq := ALSEQ_ALGN_PREPAREMEET;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_PREPAREMEET : (* Preparazione movimento incontro vetro *)
                IF vnAlgn_Cmd<>ALCMD_ALIGN THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Se sta arrivando la lastra, attendi che sia arrivata (vedi: vbStep_StartAlgnOnCall) *)
                ELSIF vnShift_Cmd=SHFCMD_PLACE_SHEET THEN
                    (* Attendendo arrivo lastra... *)
                (* Se dovrò entrare in area taglio, attendi aventuali attività del carrello inferiore in corso... *)
                ELSIF vqAlgn_Tgt<vqAlgn_XrMinSafe AND (vnCarrInf_Cmd<>CMD_STOP OR vnCarriages_Cmd<>CMD_STOP) THEN
                    (* Waiting CarrInf... *)
                ELSE
                    (* Determinazione delle zone cuscino d'aria durante riscontro:
                       Quali sono le zone accese, spente e da pilotare?
                                                  +-------++---+ +---+-----------+
                                                  |       || D |=| A |   AlgnT   |
                                                  |   B   || t |=| l  -----------|
                                                  |   u   || c |=| g |   AlgnM   |
                                                  |   f   || h |=| n  -----------|
                                                  |       ||   |=| C |   AlgnB   |
                                                  +-------++---+ +---+-----------+  *)

                    (* Questo è un punto focale per la buona riuscita del riscontro:
                       Ci vuole sempre un po' di frizione perché se no il vetro
                       rimbalza all'incontro con i piedini di riferimento, ma non
                       troppa per non bloccare il movimento dei riscontri.
                       Abbassando la forza erogata dal motore riscontri potrebbe aiutare,
                       ma non troppo perché c'è sempre l'inerzia meccanica.
                       Modulare l'attrito vetro-tavolo non è semplice, esso dipende da molti fattori:
                         .Posizione della lastra (quindi quota riscontri)
                         .Dimensione della lastra
                         .Peso della lastra (quindi spessore)
                         .Imbarcamento della lastra

                       Conosciamo le seguenti cose:
                         'vqAlgn_Tgt' Quota arrivo riscontri/frazione lastra che appoggia ai riscontri [um]
                         'Dx_VentOff' Delta anticipo spegnimento totale aria [um]
                         'vqAlgnSheet_Width' Larghezza lastra riscontranda [um]
                         'vqAlgnSheet_Height' Altezza lastra riscontranda [um]
                         'Algn_Mass' Massa della lastra riscontranda [Kg]
                         'vqGlass_Thckn' Spessore complessivo lastra riscontranda [um]
                         'vqYo_SheetFeed' Posizione tipica Y della lastra riscontranda [um]
                         'vqX_AlgnBandC' Ascissa fine zona cuscino aria riscontri taglio [um]
                         'vqY_AlgnBandB' Ordinata fine zona cuscino aria riscontri banda bassa [um]
                         'vqY_AlgnBandM' Ordinata fine zona cuscino aria riscontri banda mediana [um]
                         'vqX_ClampAlgnP' Ascissa fine premilastra riscontri [um]
                    *)

                    (* Approcciamo la cosa con un insieme di regole generali, che potremmo
                       dividere in regole fisse validi per tutti i vetri e regole aggiuntive
                       dipendenti dallo spessore complessivo 'vqGlass_Thckn' *)

                    (* Anzitutto dividiamo il cuscino aria complessivo in tre zone: *)
                    FixedOffVents := 0; (* Zona spenta fissa *)
                    (* FixedOnVents := 0; (* Zona accesa fissa *)
                    (* DrivenVents := 0; (* Zona pilotata col comando 'DriveVents' *)
                    DriveVents := FALSE;

                    (* -Per prima cosa seleziono tutte le zone coinvolte dal vetro- *)
                    (* Zona pilotata sui riscontri (a valle del taglio) *)
                    SelectProdVents( Xfwd:=vqAlgn_Tgt, Ytop:=vqYo_SheetFeed+vqAlgnSheet_Height );
                    DrivenVents := SelectProdVents.Mask;

                    (* Zona accesa fissa (a monte del taglio)
                       Dato il bordo indietro del vetro (che non è detto che sia '-vqRemn_Width') *)
                    SelectRemnVents( Xbck:=vqAlgn_Tgt - vqAlgnSheet_Width );
                    FixedOnVents := SelectRemnVents.Mask;

                    (* -Ora vediamo che zone togliere del tutto-
                        Per creare una frizione fissa, indipendente dal pilotaggio
                        Per vetri grossi e spessi c'è meno necessità di spegnere,
                        mentre è bene farlo con vetri piccoli e leggeri *)

                    (* Una possibile regola generale: Niente aria per pezzi stretti (sotto un certo spessore) *)
                    IF vqAlgnSheet_Width<=vqAlgn_WidthNoAir AND vqGlass_Thckn<20E3 THEN
                        dlog( Txt:='fbAlgn: ! No air for narrow sheet %ld<%ld', Lvl:=4, Val1:=vqAlgnSheet_Width/1E3, Val2:=vqAlgn_WidthNoAir/1E3 );
                        FixedOffVents := MSK_VENT_PROC;
                        FixedOnVents := 0;
                        DrivenVents := 0;
                    END_IF;

                    (* Una possibile regola generale: Niente banda bassa per bassi spessori *)
                    IF vqGlass_Thckn < 10E3 THEN
                        FixedOffVents := FixedOffVents OR BIT_VENT_ALGN_B;
                    END_IF;

                    (* Una possibile regola generale: fascia premilastra riscontro sempre spenta per spessori non troppo alti
                    IF vqGlass_Thckn < 20E3 THEN
                        FixedOffVents := FixedOffVents OR BIT_VENT_ALGN_C;
                    END_IF; *)

                    (* Lastre grosse completamente sui riscontri scappano, non piloto premilastra/banda alta *)
                    IF (vqAlgnSheet_Width - vqAlgn_Tgt)<500E3 AND vqGlass_Thckn<vqAlgn_ThcknTopAir (* AND vqAlgnSheet_Height > vqY_AlgnBandM *) THEN
                        FixedOffVents := FixedOffVents OR (BIT_VENT_ALGN_C OR BIT_VENT_ALGN_T);
                    END_IF;

                    (* Una possibile regola generale: Tenere sempre spenti quelli del premilastra,
                       se la zona non è unita alla banda alta
                    IF NOT vbVent_JoinedAlgnCT THEN
                        FixedOffVents := FixedOffVents OR BIT_VENT_ALGN_C;
                    END_IF; *)

                    (* Una possibile regola generale: Tenere spenta la zona stacco sotto a un certo spessore *)
                    IF vqGlass_Thckn<vqAlgn_ThcknDtchAir THEN
                        FixedOffVents := FixedOffVents OR BIT_VENT_DTCH;
                        (* FixedOnVents := FixedOnVents & NOT BIT_VENT_DTCH; (* Giusto per chiarezza? No, voglio vedere le aree coinvolte a monte *)
                    END_IF;

                    (* Una possibile regola generale: Zona stacco spenta se lastra non appoggia ai riscontri
                    IF vqAlgn_Tgt < vqX_ClampAlgnP THEN
                        FixedOffVents := FixedOffVents OR BIT_VENT_DTCH;
                    END_IF; *)

                    (* Calcolo dell'anticipo spegnimento aria
                       Criterio: con lastre leggere spengo prima possibile
                        D^
                      D1 |-----.                 Esempi masse
                         |     ·`.               1m x 1m 3+3 = 1*1*6 * 2.6 = 15 Kg
                         |     ·  `.             6m x 3.21m 3+3 = 6*3.21*6 * 2.6 = 300 Kg
                      D2 |     ·    `-----       6m x 3.21m 6+6 = 6*3.21*12 * 2.6 = 600 Kg
                        -+-----+-----+-----> Kg  6m x 3.21m 8+8 = 6*3.21*16 * 2.6 = 800 Kg
                         |    M1     M2                                     *)
                    Dx_VentOff := TO_DINT( fnLinterp( x := Algn_Mass,
                                                      x1 := 1.0E-3 * TO_LREAL(vqAlgn_VentOffM1),
                                                      y1 := TO_LREAL(vqAlgn_VentOffD1),
                                                      x2 := 1.0E-3 * TO_LREAL(vqAlgn_VentOffM2),
                                                      y2 := TO_LREAL(vqAlgn_VentOffD2) ) );
                    (* Compensazione ritardo chiusura aria  *)
                    Dx_VentOff := Dx_VentOff + fnTravel_um( um_min:=vqAlgn_PushSpd, ms:=vqVent_AirDelay );

                    (* Lastra tutta sui riscontri tende a scappare, spengo prima *)
                    IF (vqAlgn_Tgt - vqAlgnSheet_Width) > -100E3 THEN (* Posizione bordo indietro all'arrivo *)
                        Dx_VentOff := Dx_VentOff + vqAlgn_VentOffAlgnAdd;
                    END_IF;
                    (* dlog( Txt:='fbAlgn: Vents off space %ld mm (%ld Kg)', Lvl:=5, Val1:=Dx_VentOff/1E3, Val2:=TO_DINT(Algn_Mass) ); *)


                    (* Ora attivo i ventilatori *)
                    (* A riguardo del pilotaggio dei ventilatori:
                        .Non urtare il vetro con tutta l'aria accesa, scappa via!
                        .Opzione per non accendere aria fino all'incontro vetro
                        .Impulso di spegnimento aria ai picchi dell'errore di inseguimento

                       In ogni caso è importante rilevare quando i piedini di
                       riscontro incontrano il vetro: vedi sotto 'ALSEQ_ALGN_MEET'
                       per la rilevazione incontro/urto col vetro *)

                    (* Se c'è l'opzione per lasciare che sia l'operatore a gestirli,
                       non pilotarli se il riscontro è stato lanciato col pulsante
                       o se siamo in manuale "pigro" *)
                    IF vbAlgn_DontDriveVents AND
                       ( vbAlgn_UserAlign OR (NOT vbAutoMode AND vbSloppyManual) ) THEN
                        dlog( Txt:='fbAlgn: ! Air driven by user', Lvl:=3 );
                        FixedOffVents := 0;
                        FixedOnVents := 0;
                        DrivenVents := 0;
                        DriveVents:= FALSE;
                        IF vbAlgn_VentsOnAtAlign THEN
                            vnVents_Cmd := vnVents_Cmd OR MSK_VENT_LAMI; (* & NOT BIT_VENT_DTCH *)
                        END_IF;
                    ELSE
                        DrivenVents := DrivenVents & NOT FixedOffVents; (* Non pilotare le aree disabilitate *)
                        dlog( Txt:='fbAlgn: Air zones: Driven=0x%X (off %ld mm) On=0x%X Off=0x%X', Lvl:=3, Val1:=TO_DINT(DrivenVents), Val2:=Dx_VentOff/1E3, Val3:=TO_DINT(FixedOnVents), Val4:=TO_DINT(FixedOffVents) );

                        (* Partiamo con aria chiusa se:
                           .Lastra leggera e non c'è operatore
                           .L'anticipo spegnimento è tale da praticamente non usarli *)
                        IF (TO_DINT(1.0E3 * Algn_Mass) <= vqAlgn_MassNoVents AND NOT vbAlgn_UserAlign) OR
                           (Dx_VentOff+5E3)>(vqAlgnSheet_X-vqAlgn_Tgt) THEN
                            (* dlog( Txt:='fbAlgn: Starting with no air (%ld Kg)', Lvl:=4, Val1:=TO_DINT(Algn_Mass) ); *)
                            (* vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_ALGN; (* Assicuro aria riscontri chiusa *)
                            DriveVents := FALSE;
                        ELSE
                            (* Assicuro i motori in moto di tutti i ventilatori interessati *)
                            DriveVents := TRUE;
                        END_IF;
                    END_IF;

                    (* -- Vai incontro al vetro -- *)

                    (* Comanda posizionamento con piedini alti verso quota di arrivo *)
                    IF vqAlgn_CurrX > (vqAlgnSheet_X+vqAlgn_UpMargin+5E3) THEN
                        (* Se sono molto lontano dalla lastra vado più veloce *)
                        Xr.TgtSpd := MIN(vqAlgn_BlocksUpSpdMax, 2*vqAlgn_MeetSpd);
                    ELSE
                        (* Altrimenti uso la velocità normale di incontro vetro *)
                        Xr.TgtSpd := SEL(AirReadyDelayed.q, vqAlgn_MeetSpd/2, vqAlgn_MeetSpd ); (* Occhio che se balla troppo sono guai! *)
                    END_IF;
                    Xr.AccPerc := 100; (* max [%] *)
                    Xr.DecPerc := 100; (* max [%] *)
                    Xr.OutFrc := vqAlgn_MeetForce; (* [mN] *)
                    Xr.MaxPosErr := WTR_DISABLE;

                    (* Arrivo della spinta
                       Se devo permettere di appoggiare la lastra mi muoverò solo del
                       margine di salita per poi fermarmi con piedini alti,
                       altrimenti muovo direttamente alla quota di riscontro finale *)
                    Xr.TgtPos := SEL( vbAlgn_FreezeToPlace, vqAlgn_Tgt, vqAlgnSheet_X );
                    (* dlog( Txt:='fbAlgn: ALIGN: Aligning to %ld', Lvl:=5, Val1:=Xr.TgtPos/1E3); *)

                    (* Applico gli opportuni offset a seconda dei piedini *)
                    Xr.TgtPos := Xr.TgtPos + SEL(Blocks.Buf_Rear, vqAlgn_DxForeAdjust, vqAlgn_DxRearAdjust-vqAlgnBlk_RearDist);

                    MoveTo := MV_TOOLMOVE;
                    vnAlgn_Seq := ALSEQ_ALGN_MEET;

                    dlog( Txt:='fbAlgn: Meeting glass', Lvl:=5 );
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_SUSPENDED : (* Fermo con piedini alti a inizio riscontro *)
                IF vnAlgn_Cmd<>ALCMD_ALIGN THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Qui aspetto il comando per proseguire *)
                ELSIF NOT vbAlgn_FreezeToPlace THEN
                    (* Ok, proseguiamo col riscontro *)

                    IF NOT vbAlgn_DontDriveVents THEN
                        (* Chiudo i ventilatori che ho acceso,
                           ci penserà poi il pilotaggio ad accenderli eventualmente  *)
                        vnVents_Cmd := vnVents_Cmd & NOT (MSK_VENT_ALGN OR FixedOnVents);
                    END_IF;

                    (* Comanda posizionamento con piedini alti verso quota riscontro *)
                    Xr.TgtSpd := SEL(AirReadyDelayed.q, vqAlgn_MeetSpd/2, vqAlgn_MeetSpd ); (* [um/min] *)
                    Xr.AccPerc := 100; (* max [%] *)
                    Xr.DecPerc := 100; (* max [%] *)
                    Xr.OutFrc := vqAlgn_MeetForce; (* [mN] *)
                    Xr.MaxPosErr := WTR_DISABLE;
                    (* Imposto quota finale di riscontro,
                       applicando gli opportuni offset a seconda dei piedini *)
                    Xr.TgtPos := vqAlgn_Tgt + SEL(Blocks.Buf_Rear, vqAlgn_DxForeAdjust, vqAlgn_DxRearAdjust-vqAlgnBlk_RearDist);
                    (* dlog( Txt:='fbAlgn: ALIGN: Prosecuting to final %ld mm', Lvl:=5, Val1:=Xr.TgtPos/1E3); *)
                    MoveTo := MV_TOOLMOVE;
                    vnAlgn_Seq := ALSEQ_ALGN_MEET;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_MEET : (* Movimento verso lo zero con piedini alti per incontrare il vetro *)
                (* Mi aspetto di incontrare il vetro prima di arrivare *)
                IF vnAlgn_Cmd<>ALCMD_ALIGN THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_ERROR THEN
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_DONE THEN
                    (* Vetro non incontrato *)
                    IF vbAlgn_FreezeToPlace THEN
                        (* Infatti, era solo un movimentino per portare i piedini alla quota di inizio riscontro *)
                        (* L'operatore deve piazzare il vetro, quindi gli accendo tutti
                           i ventilatori che servono per posizionare la lastra *)
                        vnVents_Cmd := vnVents_Cmd OR (MSK_VENT_ALGN OR FixedOnVents);
                        (* Mi serve anche la zona a fine linea? *)
                        IF vqAlgn_CurrX>vqX_OutZoneBegin THEN
                            vnVents_Cmd := vnVents_Cmd OR BIT_VENT_OUTZONE;
                        END_IF;
                        vnAlgn_Seq := ALSEQ_ALGN_SUSPENDED;
                    ELSE
                        (* Avrei dovuto incontrare il vetro! *)
                        vnAlgn_Seq := ALSEQ_ALGN_NOCONTACT;
                    END_IF;
                (* Sulla rilevazione dell'incontro/urto col vetro
                     .I sensori sui piedini generalmente si accendono dopo l'urto: sono solo due
                     .Se si tiene un limite di coppia basso, è possibile monitorare l'errore di posizione
                     .L'energia dell'urto è prevedibile in base a massa lastra, ferma, e velocità riscontri
                      Algn_Mass, Xr.CurrSpd *)
                ELSIF ABS(Xr.CurrPosErr) >= vqAlgn_MeetPosErr  (* Urto rilevato, v. anche 'Xr.CurrFrc' *)
                      OR vnAlgnBlocks_Glass<>0  (* Vetro rilevato dai sensori *)
                      OR (vqAlgn_CurrX<=vqAlgnSheet_X AND NOT GlassDetectable) THEN (* Se non rilevabile, assumo l'impatto in 'vqAlgnSheet_X' *)
                    (* Vetro incontrato, vario velocità e coppia *)
                    dlog( Txt:='fbAlgn: Glass met at %ld err=%ld um spd=%ld mm/min', Lvl:=5, Val1:=Xr.CurrPos/1E3, Val2:=Xr.CurrPosErr, Val3:=Xr.CurrSpd/1E3 );

                    (* Assicuro di pilotare i ventilatori/Potrei spegnere l'aria in questa fase *)
                    DriveVents := NOT vbAlgn_VentOffOnImpact;

                    (* Se c'è errore di inseguimento, devo azzerarlo (per toglierlo, aumenta 'vqAlgn_MeetForce') *)
                    (* IF ABS(Xr.CurrPosErr) >= 500 THEN
                        (* Meglio resettare l'errore di inseguimento, altrimenti prendo colpi *)
                    (* Tanto vale, devo comunque dare uno stop per ricomandare un nuovo movimento! *)
                    Xr.Cmd := AXC_RESET; (* Nota: L'asse si fermerà con limite di coppia impostato
                                                  e tornerà ready dopo non meno di tre cicli PLC *)
                    IF GlassDetectable THEN
                        (* Poichè ho rilevato il vetro completo il riscontro, non ha senso fermarmi *)
                        vbAlgn_FreezeToPlace := FALSE;
                    END_IF;
                    vnAlgn_Seq := ALSEQ_ALGN_IMPACT;
                ELSE
                    (* Movimento avvicinamento in corso *)
                    (* Modulo la velocità di incontro vetro
                       Attenzione: se svolta troppo frequentemente causa:
                         .GetFVincStruct: no free struct available
                         .FUN_SPDCHG: (err 999)
                         .Tk21437 CNC RTC FULL *)
                    IF vbAlgn_ModulateSpeed THEN
                        IF vqAlgn_CurrX > (vqAlgnSheet_X+vqAlgn_UpMargin+5E3) THEN
                            (* Se sono molto lontano dalla lastra vado più veloce *)
                            Xr.TgtSpd := MIN(vqAlgn_BlocksUpSpdMax, 2*vqAlgn_MeetSpd);
                        ELSE
                            (* Altrimenti uso la velocità normale di incontro vetro *)
                            Xr.TgtSpd := SEL(AirReadyDelayed.q, vqAlgn_MeetSpd/2, vqAlgn_MeetSpd ); (* Occhio che se balla troppo sono guai! *)
                        END_IF;
                    END_IF;

                    (* Assicuro che premilastra e tamponi siano su?
                       No, dopo: potrebbe esserci la manovra di indietreggiamento stacco * )
                    IF vnHoldPads_Cmd<>CMD_STOP OR vnClampAlgn_Cmd<>CMD_STOP OR vnClampDtch_Cmd<>CMD_STOP THEN
                        dlog( Txt:='fbAlgn: ! Clamps up', Lvl:=2 );
                        vnHoldPads_Cmd := CMD_STOP;
                        vnClampAlgn_Cmd := CMD_STOP;
                        vnClampDtch_Cmd := CMD_STOP;
                    END_IF; *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_IMPACT : (* Incontro vetro *)
                IF vnAlgn_Cmd<>ALCMD_ALIGN THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Attendo stacco fermo *)
                ELSIF vn[ivnStatus+ID_DTCH]<>STS_IDLE THEN (* vnDtch_Cmd=CMD_STOP *)
                    (* ...Potrebbe essere in corso la manovra di indietreggiamento stacco *)
                (* Assicuro premilastra e tamponi su *)
                ELSIF vnHoldPads_Cmd<>CMD_STOP OR vnClampAlgn_Cmd<>CMD_STOP OR vnClampDtch_Cmd<>CMD_STOP THEN
                    dlog( Txt:='fbAlgn: ! Clamps up', Lvl:=2 );
                    vnHoldPads_Cmd := CMD_STOP;
                    vnClampAlgn_Cmd := CMD_STOP;
                    vnClampDtch_Cmd := CMD_STOP;
                (* Attendo asse pronto (stavo resettando errore inseguimento), cuscino aria e altre precondizioni *)
                ELSIF Xr.Status=AXS_READY AND NOT Xr.Positioning AND Xr.Cmd=AXC_STOP_ENAB AND Xr.Still
                      AND AirReadyDelayed.q (* Cuscino aria pronto *)
                      AND vb[ivbAtRest+ID_BELTS_DTCH] AND vb[ivbAtRest+ID_ROLLS_ALGN] (* Cinghie stacco e rulli bassi *)
                      (* AND vb[ivbAtRest+ID_CLAMP_ALGN] AND vb[ivbAtRest+ID_CLAMP_DTCH] (* Premilastra alti *)
                      AND vbClampAlgn_AlmostUp AND vbClampDtch_AlmostUp (* Premilastra alti *)
                      AND vb[ivbAtRest+ID_HOLDPADS] THEN (* Tamponi via *)
                    dlog( Txt:='fbAlgn: Align push at %ld err=%ld um spd=%ld mm/min', Lvl:=5, Val1:=Xr.CurrPos/1E3, Val2:=Xr.CurrPosErr, Val3:=Xr.CurrSpd/1E3 );
                    (* Imposto i parametri del movimento di spinta *)
                    Xr.TgtSpd := vqAlgn_PushSpd; (* [um/min] *)
                    Xr.AccPerc := vnAlgn_PushAccel; (* [%] *)
                    Xr.DecPerc := vnAlgn_PushAccel; (* [%] *)
                    Xr.OutFrc := vqAlgn_DragMaxForce; (* [mN] Spingo forte *)
                    Xr.MaxPosErr := WTR_DISABLE;
                    (* Imposto quota finale di riscontro,
                       applicando gli opportuni offset a seconda dei piedini *)
                    Xr.TgtPos := vqAlgn_Tgt + SEL(Blocks.Buf_Rear, vqAlgn_DxForeAdjust, vqAlgn_DxRearAdjust-vqAlgnBlk_RearDist);
                    MoveTo := MV_TOOLMOVE;
                    DriveVents := TRUE; (* Assicuro di pilotare i ventilatori *)
                    vnAlgn_Seq := ALSEQ_ALGN_PUSHING;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_PUSHING : (* Spingendo vetro per riscontrare *)
                (* Mi aspetto di arrivare vicino alla quota di riscontro *)
                (* Rilevo quasi arrivato *)
                IF vnAlgn_Cmd<>ALCMD_ALIGN THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_ERROR THEN
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_DONE THEN
                    (* Mah, strano! *)
                    dlog( Txt:='fbAlgn: !! Early arrive at %ld mm (err=%ld um)', Lvl:=3, Val1:=Xr.CurrPos/1E3, Val2:=Xr.CurrPosErr );
                    vnAlgn_Seq := ALSEQ_ALGN_ENDING;
                ELSIF (Xr.CurrPos-Xr.TgtPos) <= Dx_VentOff THEN
                    (* Wow, sto finendo il riscontro *)
                    dlog( Txt:='fbAlgn: Almost aligned at %ld err=%ld um spd=%ld mm/min', Lvl:=5, Val1:=Xr.CurrPos/1E3, Val2:=Xr.CurrPosErr, Val3:=Xr.CurrSpd/1E3 );
                    (* Rallento ulteriormente? * )
                    IF vbAlgn_ModulateSpeed THEN Xr.TgtSpd := vqAlgn_PushSpd/2; END_IF; *)
                    Xr.OutFrc := vqAlgn_DragMaxForce; (* [mN] Spingo forte *)
                    Xr.MaxPosErr := WTR_DEFAULT; (* Ora per sicurezza voglio ripristinare controllo inseguimento *)

                    (* Se sento il vetro spengo l'aria delle zone pilotate *)
                    IF DriveVents AND DrivenVents<>0 AND (* Se ho zone pilotate *)
                       ( vnAlgnBlocks_Glass<>0 OR NOT GlassDetectable ) THEN
                        dlog( Txt:='fbAlgn: Vent off (%ld mm=%ld-%ld)', Lvl:=5, Val1:=(Xr.CurrPos-Xr.TgtPos)/1E3, Val2:=Xr.CurrPos/1E3, Val3:=Xr.TgtPos/1E3 );
                        (* Nota: L'anticipo spegnimento coinvolge solo le zone pilotate 'DrivenVents' *)
                        DriveVents := FALSE;
                    END_IF;

                    vnAlgn_Seq := ALSEQ_ALGN_ENDING;
                (* Potrei controllare se perdo il vetro perché "scappa" e nel caso modulare l'aria per frenarlo
                ELSIF GlassDetectable AND vnAlgnBlocks_Glass=0 THEN
                    dlog( Txt:='fbAlgn: ALIGN: Glass lost at %ld mm spd=%ld m/min', Lvl:=5, Val1:=Xr.CurrPos/1E3, Val2:=Xr.CurrSpd/1E6 );
                    DriveVents := FALSE; *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_ENDING : (* Quasi arrivato a quota di riscontro *)
                (* Mi aspetto di arrivare in quota *)
                IF vnAlgn_Cmd<>ALCMD_ALIGN THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo<MV_WAITSTOP THEN
                    (* Movimento terminato, vediamo risultato *)
                    IF MoveTo=MV_DONE THEN
                        (* Arrivato in quota *)
                        (* Per notificare eventuali aggiustamenti sulla quota: *)
                        Delta := SEL(Blocks.Buf_Rear, vqAlgn_DxForeAdjust, vqAlgn_DxRearAdjust);
                        (* IF Delta<>0 THEN dlog( Txt:='fbAlgn: ! Adjusted by %ld um', Lvl:=5, Val1:=Delta ); END_IF; *)
                        dlog( Txt:='fbAlgn: Xr arrived in %ld to align %ld um (adjust: %ld)', Lvl:=5, Val1:=Xr.TgtPos, Val2:=vqAlgn_Tgt, Val3:=Delta );
                        vnAlgn_Seq := SEQ_DONE;
                        (* Controllo vetro a contatto dei piedini, ben riscontrato
                           Solo in modalità automatica o manuale "preciso" *)
                        IF GlassDetectable AND (vbAutoMode OR NOT vbSloppyManual) THEN (* vbAlgn_UserAlign *)
                            (* Notifico eventuale mancanza di contatto con piedini *)
                            (* IF vnAlgnBlocks_Glass=0 THEN
                                dlog( Txt:='fbAlgn: ALGN_ENDING: ! No contact', Lvl:=2 );
                                vnAlgn_Seq := ALSEQ_ALGN_NOCONTACT;
                            END_IF; *)
                            IF vnAlgnBlk_Bsense>0 AND
                               vqAlgnSheet_Height > vq[ivqAlgnBlks_Y+vnAlgnBlk_Bsense] AND
                               (vnAlgnBlocks_Glass & SHL(INT#1, vnAlgnBlk_Bsense-1))=0 THEN
                                dlog( Txt:='! No contact with btm block', Lvl:=2 );
                                vnAlgn_Seq := ALSEQ_ALGN_NOCONTACT;
                            END_IF;
                            IF vnAlgnBlk_Tsense>0 AND
                               vqAlgnSheet_Height > vq[ivqAlgnBlks_Y+vnAlgnBlk_Tsense] AND
                               (vnAlgnBlocks_Glass & SHL(INT#1, vnAlgnBlk_Tsense-1))=0 THEN
                                dlog( Txt:='! No contact with top block', Lvl:=2 );
                                vnAlgn_Seq := ALSEQ_ALGN_NOCONTACT;
                            END_IF;
                        END_IF; (* Controllo sensori piedini *)
                    ELSE
                        vnAlgn_Seq := SEQ_ERROR;
                    END_IF;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            SEQ_DONE : (* Vetro riscontrato correttamente, piedini alti *)
                (* Spengo cuscino aria *)
                (* vnVents_Cmd := vnVents_Cmd & NOT (FixedOnVents OR DrivenVents); (* Solo quella pilotata *)
                vnVents_Cmd := vnVents_Cmd & (BIT_VENT_OUTZONE OR BIT_VENT_LOAD); (* Spengo tutta l'aria a parte le zone non interessate *)
                DriveVents := FALSE;
                FixedOnVents := 0;
                FixedOffVents := 0;
                vnAlgn_Cmd := CMD_STOP; (* Resetto il comando *)
                vbAlgn_UserAlign := FALSE;
                Status := STS_IDLE;
                (* Se stavo emettendo il pezzo a fine linea, finisci sequenza *)
                IF vnAlgn_DragSeq=ALSEQ_DRAG_SUSPENDED THEN
                    dlog( Txt:='fbAlgn: ALIGN: Done, back to drag fwd', Lvl:=5 );
                    Status := ALSTS_DRAGFWD;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_NOCONTACT : (* Vetro non trovato o non ben riscontrato, piedini alti *)
                SET_MSG(MSG_ALGN_NOGLASS,'MSG_ALGN_NOGLASS',0);
                (* Nota: Ora sono accese le zone aria per riscontro, che fare? *)
                IF vbAutoMode AND NOT vbAlgn_UserAlign THEN
                    (* Senza operatore mi assicuro di spegnere cuscino aria acceso per riscontro *)
                    vnVents_Cmd := vnVents_Cmd & NOT (FixedOnVents OR DrivenVents); (* Solo quella pilotata *)
                ELSIF NOT vbAlgn_DontDriveVents THEN
                    (* Con operatore accendo tutti i ventilatori che servono per posizionare la lastra *)
                    vnVents_Cmd := vnVents_Cmd OR (MSK_VENT_ALGN OR FixedOnVents);
                    (* Mi serve anche la zona a fine linea? *)
                    IF vqAlgn_CurrX>vqX_OutZoneBegin THEN
                        vnVents_Cmd := vnVents_Cmd OR BIT_VENT_OUTZONE;
                    END_IF;
                END_IF;
                vnAlgn_Cmd := CMD_STOP; (* Resetto il comando *)
                vbAlgn_UserAlign := FALSE;
                Status := STS_IDLE;
                (* Bah, se stavo emettendo il pezzo a fine linea, finisci sequenza *)
                IF vnAlgn_DragSeq=ALSEQ_DRAG_SUSPENDED THEN
                    dlog( Txt:='fbAlgn: Back to drag fwd', Lvl:=5 );
                    Status := ALSTS_DRAGFWD;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ELSE (* SEQ_ERROR : (* Riscontro non terminato *)
                vnAlgn_Cmd := CMD_STOP; (* Resetto il comando *)
                vbAlgn_UserAlign := FALSE;
                Status := STS_IDLE;
                (* Spengo cuscino aria *)
                vnVents_Cmd := vnVents_Cmd & NOT (FixedOnVents OR DrivenVents); (* Solo quella pilotata *)
                DriveVents := FALSE;
                FixedOnVents := 0;
                FixedOffVents := 0;
                (* Free possible acquired resources *)
                IF LowerCutZone_Algn=ID AND Xr.CurrPos>=vqAlgn_XrMinSafe THEN LowerCutZone_Algn:=0; END_IF;
                IF LowerCutZone_Dtch=ID AND Xr.CurrPos>=vqAlgn_XrAcqDtch THEN LowerCutZone_Dtch:=0; END_IF;

        END_CASE; (* -- Normal align sequence *)

        (* -- Pilotaggio cuscino aria durante fase di riscontro -- *)
        IF vnAlgn_Seq>=ALSEQ_ALGN_MEET THEN
            (* Zona pilotata *)
            IF DriveVents THEN vnVents_Cmd := vnVents_Cmd OR DrivenVents;
                          ELSE vnVents_Cmd := vnVents_Cmd & NOT DrivenVents; END_IF;
            (* Zone fisse accese e spente *)
            vnVents_Cmd := (vnVents_Cmd OR FixedOnVents) & NOT FixedOffVents;
            (* Se opzione temporanea di "meno aria" *)
            IF vbSelAlgnLessAir THEN
                (* Escludo banda mediana? *)
                vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_ALGN_M;
            END_IF;
        END_IF;



    (* =================================================================== *)
    ALSTS_DRAGFWD : (* Sequenza di trascinamento in avanti/a fine linea *)
        (* Porta il bordo avanti del vetro a 'vqAlgnDrag_Tgt' *)
        CASE vnAlgn_DragSeq OF

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            SEQ_START, ALSEQ_DRAG_SUSPENDED : (* Inizio della sequenza di trascinamento *)
                (* Richiedo sempre un controllo se la zona fine linea
                   è effettivamente occupata, il bordo avanti è in: *)
                OutZone.XcheckIfBusy := vqAlgnDrag_Xbck + vqAlgnDrag_Width; (* Tra un ciclo PLC sono pronti 'Xbusy' e 'Free' *)
                (* Se i piedini sono su... *)
                IF NOT Blocks.AtRest THEN
                    (* ...Li resetto prima di proseguire *)
                    vnAlgn_Cmd := CMD_PARK;
                    Status := ALSTS_RESETTING;
                    vnAlgn_Seq := SEQ_START;
                    (* dlog( Txt:='fbAlgn: Resetting blocks before drag', Lvl:=3 ); *)
                (* ELSIF vnAlgn_DragCmd=ALCMD_DRAGOUT AND NOT vbOutTable_Present THEN
                    dlog( Txt:='fbAlgn: !! DRAG: Cannot evac to nothing', Lvl:=2 );
                    vnAlgn_DragSeq := SEQ_ERROR; *)
                END_IF;
                (* In ogni caso, il prossimo stato è questo: *)
                vnAlgn_DragSeq := ALSEQ_DRAG_INIT;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_INIT : (* Inizio sequenza *)
                (* Controllo argomenti e scelgo i piedini da usare *)
                IF vnAlgn_DragCmd=CMD_STOP THEN (* Abort sequence *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                (* Attendi un eventuale posizionamento precedente *)
                ELSIF vbAlgn_DragWaitXr AND MoveTo=MV_WAITMOVE (* OR NOT Xr.Ready *) THEN
                    (* Waiting previous Xr movement *)
                (* Se asse Xr in movimento e quasi arrivato, aspettiamo che finisca
                   Ho visto che a volte il cambio target fallisce con:
                   fbM32Axis 1: !! FUN_TGTCHG: (err 2) Ax not moving *)
                ELSIF Xr.Status=AXS_STOPPING OR Xr.Status=AXS_CHNG_TGTPOS OR (Xr.Status=AXS_MOVING_POS AND ABS(Xr.CurrPos-Xr.TgtPos)<200E3) THEN
                    (* Wait axis Xr not moving *)
                (* Attendi stacco in parcheggio se devo agganciare in zona taglio *)
                ELSIF vqAlgnDrag_Xbck<vqX_CutZoneP AND NOT vb[ivbAtRest+ID_DTCH] THEN
                    IF NOT IS_MSG(MSG_DTCH_WAITATHOME) THEN
                        SET_MSG(MSG_DTCH_WAITATHOME,'MSG_DTCH_WAITATHOME: Hook',0);
                        (* Nota: Questo messaggio è resettato dallo stacco stesso *)
                    END_IF;
                ELSE
                    dlog( Txt:='fbAlgn: Drag %ldx%ld bck:%ld fwdtgt:%ld', Lvl:=4, Val1:=vqAlgnDrag_Width/1E3, Val2:=(vqAlgnDrag_Ytop-vqAlgnDrag_Ybtm)/1E3, Val3:=vqAlgnDrag_Xbck/1E3, Val4:=vqAlgnDrag_Tgt/1E3 );
                    (* Ricontrollo i piedini... *)
                    IF NOT Blocks.AtRest THEN
                        (* ...Nah abortisco *)
                        dlog( Txt:='!! Drag blocks still up', Lvl:=2 );
                        vnAlgn_DragSeq := SEQ_ERROR;
                    (* Se devo portare a fine linea e rilevo pezzo già prelevato a mano,
                       salto il secondo movimento e considero tutto fatto *)
                    ELSIF vnAlgn_DragCmd=ALCMD_DRAGEND AND vbAlgnDrag_WasOnFtc AND NOT fcOutzoneNearEnd.q THEN
                        dlog( Txt:='! Piece already taken, drag skipped', Lvl:=2 );
                        (* Concludi - evito di segnalare pezzo a fine linea *)
                        vnAlgn_DragSeq := SEQ_DONE;
                        vnAlgn_DragCmd := CMD_STOP; (* Resetto il comando *)
                        Status := STS_IDLE;
                    (* Check inputs *)
                    ELSIF NOT vbAlgn_EnableDrag OR NOT vbFeat_AlgnCanDragFwd THEN
                        dlog( Txt:='!! Drag not enabled', Lvl:=2 );
                        vnAlgn_DragSeq := SEQ_ERROR;
                    (* Sono già praticamente arrivato? *)
                    ELSIF ABS(vqAlgnDrag_Xbck+vqAlgnDrag_Width-vqAlgnDrag_Tgt)<vqAlgn_DragMinDisp AND
                          (vnAlgn_DragCmd=ALCMD_DRAGFWD OR (vnAlgn_DragCmd=ALCMD_DRAGEND AND fcOutzoneEnd.q)) THEN
                        dlog( Txt:='! Drag already in %ld ~ %ld', Lvl:=2, Val1:=(vqAlgnDrag_Xbck+vqAlgnDrag_Width)/1E3, Val2:=vqAlgnDrag_Tgt/1E3 );
                        vnAlgn_DragSeq := ALSEQ_DRAG_ENDING; (* Concludi *)
                    (* Le dimensioni sono corrette? *)
                    ELSIF vqAlgnDrag_Width<=0 THEN
                        dlog( Txt:='!! Drag width not given', Lvl:=2 );
                        vnAlgn_DragSeq := SEQ_ERROR;
                    (* Il bordo indietro di partenza è agganciabile? *)
                    ELSIF vqAlgnDrag_Xbck<(Xr.NegLim + vqAlgnBlk_ForeOppDist) OR vqAlgnDrag_Xbck>vqX_OutZoneEnd THEN
                        dlog( Txt:='!! Invalid vqAlgnDrag_Xbck=%ld', Lvl:=2, Val1:=vqAlgnDrag_Xbck/1E3 );
                        vnAlgn_DragSeq := SEQ_ERROR;
                    (* Non è possibile trascinare indietro, solo avanti *)
                    ELSIF (vqAlgnDrag_Xbck+vqAlgnDrag_Width)>vqAlgnDrag_Tgt THEN
                        dlog( Txt:='!! Cannot drag back from %ld to %ld', Lvl:=2, Val1:=(vqAlgnDrag_Xbck+vqAlgnDrag_Width)/1E3, Val2:=vqAlgnDrag_Tgt/1E3 );
                        vnAlgn_DragSeq := SEQ_ERROR;
                    (* L'obiettivo è raggiungibile?
                    ELSIF Xr.PosLim < (vqAlgnDrag_Tgt - vqAlgnDrag_Width - vqAlgnBlk_RearDist - vqAlgnBlk_RearOppDist) THEN
                        dlog( Txt:='!! fwdtgt=%ld not reachable (poslim=%ld)', Lvl:=2, Val1:=vqAlgnDrag_Tgt/1E3, Val2:=Xr.PosLim/1E3 );
                        vnAlgn_DragSeq := SEQ_ERROR; *)
                    (* La Rimanenza deve essere leggibile dalla fotocellula sullo stacco?
                    ELSIF vqAlgnDrag_Ybtm>=vqYph_DtchLast OR vqAlgnDrag_Ytop<=vqYph_DtchLast THEN
                        dlog( Txt:='! Glass at %ld-%ld outside dtch ftc at %ld mm', Lvl:=2, Val1:=vqShift_GlassYbtm/1E3, Val2:=vqShift_GlassYtop/1E3, Val3:=vqYph_DtchLast/1E3 );
                        vnAlgn_DragSeq := SEQ_ERROR; *)
                    ELSE
                        Drag_Mass := fnGlassMass(vqAlgnDrag_Width, vqAlgnDrag_Ytop-vqAlgnDrag_Ybtm, vqGlass_Thckn);
                        NeedAir := Drag_Mass > 50.0; (* Kg *) (* OR vqAlgnDrag_Width>vqAlgn_WidthNoAir *)
                        (* dlog( Txt:='DRAG %ldx%ld in %ld m=%ld Kg', Lvl:=4, Val1:=vqAlgnDrag_Width/1E3, Val2:=(vqAlgnDrag_Ytop-vqAlgnDrag_Ybtm)/1E3, Val3:=vqAlgnDrag_Xbck/1E3, Val4:=TO_DINT(Drag_Mass) ); *)

                        (* Reset messaggi lanciati *)
                        RST_MSG_IF_ON(REQ_TAKE_PROD);
                        RST_MSG_IF_ON(REQ_DUMP_PROD);

                        (* Controllo agganciabilità coi riscontri *)
                        Alignable( ybtm:=vqAlgnDrag_Ybtm, ytop:=vqAlgnDrag_Ytop );
                        IF Alignable.ok THEN
                            dlog( Txt:='Hook with blocks %d and %d', Lvl:=4, Val1:=TO_DINT(Alignable.idx_btm), Val2:=TO_DINT(Alignable.idx_top) );
                            (* Potrei alzare solo i piedini interessati in 'vnAlgnBlocks_Sel' *)
                            vnAlgnBlocks_DragMsk := fnBitMask(Alignable.idx_btm-1, Alignable.idx_top-1);
                        ELSE
                            dlog( Txt:='!! Cannot hook y=%ld|%ld', Lvl:=1, Val1:=Alignable.ybtm/1E3, Val2:=Alignable.ytop/1E3 );
                            vnAlgn_DragSeq := SEQ_ERROR;
                        END_IF;

                        (* Se l'obiettivo non è raggiungibile... *)
                        IF Xr.PosLim < (vqAlgnDrag_Tgt - vqAlgnDrag_Width - vqAlgnBlk_RearDist - vqAlgnBlk_RearOppDist) THEN
                            dlog( Txt:='!! Cant drag fwd to %ld (poslim=%ld)', Lvl:=2, Val1:=vqAlgnDrag_Tgt/1E3, Val2:=Xr.PosLim/1E3 );
                            IF (vqAlgnDrag_Xbck+vqAlgnDrag_Width)<vqDeliver_DefaultXbck THEN
                                (* ...Porto il pezzo in posizione di prelievo manuale *)
                                (* vnAlgn_DragCmd := ALCMD_DRAGFWD; (* Nah, lasciamo il comando inalterato per dare un eventuale errore *)
                                vqAlgnDrag_Tgt := MIN(vqDeliver_DefaultXbck + vqAlgnDrag_Width, vqX_OutZoneEnd);
                            ELSE
                                vnAlgn_DragSeq := SEQ_ERROR;
                            END_IF;
                        END_IF;

                        (* -- Se tutto ok, procedi -- *)
                        IF vnAlgn_DragSeq<>SEQ_ERROR THEN
                            (* Devo posizionare per agganciare il bordo indietro in 'vqAlgnDrag_Xbck',
                               scelgo i piedini da usare in base a questi criteri:
                                 .Prediligo gli anteriori perché hanno i gommini di frenata
                                 .Uso subito i posteriori solo se posso evitare il doppio movimento
                                  e per usarli non devo entrare in zona taglio *)
                            DragForeBlocks := (vqAlgnDrag_Tgt - vqAlgnDrag_Width - vqAlgnBlk_ForeOppDist) < vqAlgn_XforeMax (* Con gli anteriori riesco a fare un solo movimento o... *)
                                              OR ( (vqAlgnDrag_Xbck - vqAlgnBlk_ForeOppDist) < vqAlgn_XforeMax AND (* Con gli anteriori si riesce perlomeno ad iniziare e... *)
                                                   (vqAlgnDrag_Xbck - vqAlgnBlk_RearDist - vqAlgnBlk_RearOppDist) < vqAlgn_XrMinSafe ); (* ...Con i posteriori invaderei la zona taglio *)

                            (* Comanda spostamento con piedini bassi verso quota salita
                               Nota: se c'è un posizionamento precedente, qui fa un cambio target,
                                     ma se sta andando nel verso opposto di quello per arrivare da
                                     Xr.CurrPos a Xr.TgtPos, il cambio target fallisce, forse meglio
                                     attendere, vedi 'vbAlgn_DragWaitXr' sopra *)
                            IF DragForeBlocks THEN
                                (* Aggancio con i piedini anteriori *)
                                (* Occhio al margine di aggancio 'vqAlgn_DragForeMargin':
                                   gli anteriori hanno dei gommini che appoggiano sotto
                                   per poter frenare il vetro, se aggancio troppo indietro
                                   non hanno appoggio *)
                                Xr.TgtPos := vqAlgnDrag_Xbck - vqAlgnBlk_ForeOppDist - vqAlgn_DragForeMargin;
                                vnAlgn_DragSeq := ALSEQ_DRAG_FORE_GOUP;
                                dlog( Txt:='Fore to %ld to hook bck=%ld', Lvl:=5, Val1:=Xr.TgtPos/1E3, Val2:=vqAlgnDrag_Xbck/1E3 );
                            ELSE
                                (* Spingo con i piedini posteriori *)
                                (* Con i posteriori posso mettere un bel margine di "aggancio" *)
                                Xr.TgtPos := vqAlgnDrag_Xbck - vqAlgnBlk_RearDist - vqAlgnBlk_RearOppDist - vqAlgn_DragRearMargin;
                                vnAlgn_DragSeq := ALSEQ_DRAG_REAR_GOUP;
                                dlog( Txt:='Rear to %ld to push bck=%ld', Lvl:=5, Val1:=Xr.TgtPos/1E3, Val2:=vqAlgnDrag_Xbck/1E3 );
                            END_IF;

                            (* ASSERT( Xr.TgtPos>Xr.NegLim AND Xr.TgtPos<Xr.PosLim, '(!!) Xr target out of bounds!') *)
                            (* Notifico un eventuale sforamento indietro *)
                            IF Xr.TgtPos < Xr.NegLim THEN
                                Xr.TgtPos := Xr.NegLim;
                                dlog( Txt:='! Smaller hook margin %ld', Lvl:=2, Val1:=(vqAlgnDrag_Xbck - Xr.TgtPos)/1E3 );
                            END_IF;

                            (* Se non sono già in moto, dò il comando per partire *)
                            IF MoveTo<>MV_WAITMOVE THEN
                                MoveTo := MV_FREEMOVE;
                            (* ELSE (* Se sono già in moto va bene così, sarà un cambio target *)
                            END_IF;

                        END_IF; (* Non in errore *)
                    END_IF; (* Argomenti Ok *)
                END_IF; (* Attesa prerequisiti *)


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_FORE_GOUP : (* Spostamento verso quota salita piedini anteriori *)
                IF vnAlgn_DragCmd=CMD_STOP THEN (* Abort sequence *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                ELSIF MoveTo=MV_ERROR THEN
                    vnAlgn_DragSeq := SEQ_ERROR;
                ELSIF MoveTo=MV_DONE THEN
                    (* Movimento terminato: salgo per agganciare *)

                    (* Se devo alzarmi in zona taglio, aspetta che la rimanenza
                       si sia allontanata: infatti se lascio dov'è potrei andarle
                       addosso, voglio fotocellula dello stacco libera o comunque
                       completare un movimento cinghie *)
                    IF Xr.CurrPos<vqAlgn_XrMinSafe
                       AND ( fcDtchLast.q
                             OR IS_MSG(REQ_BACK_REMN)
                             OR (vnShift_Cmd=SHFCMD_BACK_REMN AND vqRemn_X<>NO_POS_UM AND vqRemn_X>vq[ivqAx_HomePos+AX_XS-1]) ) THEN
                                (* vnShift_Cmd=SHFCMD_BACK_REMN, vn[ivnStatus+ID_SHIFT]=SHF_BCK_OFFDTCH, vnRemn_PostSts=POST_BACK_LITTLE *)
                        (* Attendo rimanenza via da zona taglio lato stacco *)
                        (* Nota: La lettura di IFC_DTCH_LAST non è sempre attendibile,
                           ad es. deve essere vqAlgnDrag_Ybtm<vqYph_DtchLast AND vqAlgnDrag_Ytop>vqYph_DtchLast *)
                    ELSE
                        (* dlog( Txt:='fbAlgn: Hook: Xr.CurrPos=%ld IFC_DTCH_LAST=%d vqRemn_X=%ld', Lvl:=6, Val1:=Xr.CurrPos/1E3, Val2:=TO_DINT(IFC_DTCH_LAST), Val3:=vqRemn_X/1E3 ); *)
                        vnAlgnBlocks_Sel := SEL( vbAlgn_MinBlocksDrag, 16#FFFF, vnAlgnBlocks_DragMsk );
                        vnAlgnBlocks_Cmd := 1; (* Comando salita piedini anteriori *)
                        vnAlgn_DragSeq := ALSEQ_DRAG_FORE_UP; (* Procedi *)

                        (* Se sto agganciando in zona premilastra lo assicuro alto,
                           tanto ora il vetro non cade, ci sono sotto io *)
                        IF vnClampAlgn_Cmd<>CMD_STOP AND Xr.CurrPos<vqX_ClampAlgnP THEN (* vb[ivbAtRest+ID_CLAMP_ALGN] *)
                            dlog( Txt:='fbAlgn: Hook: ClampAlgn off', Lvl:=2 );
                            vnClampAlgn_Cmd := CMD_STOP;
                        END_IF;
                    END_IF;
                (* ELSE wait movement *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_FORE_UP : (* Attendi salita piedini anteriori, cuscino aria, zona fine linea *)
                (* Controllo che non si attivino i sensori vetro? *)
                IF vbAlgn_NoGlassOnUp AND Blocks.Rising AND Blocks.IforeGlass<>0 THEN
                    dlog( Txt:='fbAlgn: !! Hook under Remn', Lvl:=2 );
                    SET_MSG(MSG_ALGN_UNDERGLASS,'MSG_ALGN_UNDERGLASS',0);
                    vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                END_IF;

                IF vnAlgn_DragCmd=CMD_STOP THEN (* Abort sequence *)
                    (* vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                (* Intercetta abort salita piedini *)
                ELSIF Blocks.Status<TS_GOINGON THEN
                    dlog( Txt:='fbAlgn: !! Blocks dead', Lvl:=2 );
                    vnAlgn_DragSeq := SEQ_ERROR;
                (* Se sono sotto od oltre il premilastra riscontro lo voglio alto! *)
                ELSIF Xr.CurrPos<vqX_ClampAlgnP AND NOT vb[ivbAtRest+ID_CLAMP_ALGN] THEN
                    vnClampAlgn_Cmd := CMD_STOP;
                (* Se andrò ad occuparla voglio zona fine linea libera *)
                ELSIF NOT OutZone.Free AND
                      (vqAlgnDrag_Xbck+vqAlgnDrag_Width)<OutZone.Xbusy AND
                      vqAlgnDrag_Tgt>=(OutZone.Xbusy+100E3) THEN
                    SET_MSG(MSG_OUTZONE_BUSY,'MSG_OUTZONE_BUSY',0); (* Align Drag *)
                    (* TODO 2: vbAlgnDlvr_BringEarly: Potrei portare il pezzo fin dove riesco!
                       Non aspettare ribaltina bassa per far partire l'evac,
                       vai inizialmente al limite OutZone.Xbusy + 200E3
                       e poi fermati o cambio tgt *)
                (* Per cominciare a trascinare attendo piedini su e aria *)
                ELSIF Blocks.Status=TS_ON AND AirReadyDelayed.q THEN
                    (* Adesso trasciniamo il vetro con i piedini anteriori *)
                    Xr.TgtSpd := vqAlgn_DragSpd; (* [um/min] *)
                    Xr.AccPerc := vnAlgn_DragAccel; (* [%] *)
                    Xr.DecPerc := vnAlgn_DragAccel / 2; (* [%] *)
                    (* Modulo il limite forza con la massa del vetro *)
                    Xr.OutFrc := TO_DINT( fnLinterp(  x := Drag_Mass,
                                                      x1 := 0.0, (* [Kg] Massa minima *)
                                                      y1 := TO_LREAL(vqAlgn_DragMinForce), (* [mN] *)
                                                      x2 := 100.0, (* [Kg] Massa con forza massima *)
                                                      y2 := TO_LREAL(vqAlgn_DragMaxForce) ) ); (* [mN] *)
                    Xr.MaxPosErr := WTR_DEFAULT; (* WTR_DISABLE *)

                    (* Ora vediamo dove devo andare con i piedini anteriori *)
                    IF vqAlgnDlvr_PausePos>0 THEN
                        (* È richiesta una fermata temporanea intermedia (probabilmente per applicare una etichetta) *)
                        IF vqAlgnDlvr_PausePos < vqAlgnDrag_Xbck THEN
                            (* Ho già superato la posizione dove dovrei fermarmi! *)
                            dlog( Txt:='fbAlgn: Pause: Reached %ld > %ld mm', Lvl:=3, Val1:=vqAlgnDrag_Xbck/1E3, Val2:=vqAlgnDlvr_PausePos/1E3 );
                            vnAlgn_DragSeq := ALSEQ_DRAG_PAUSED;
                            RETURN;
                        ELSE
                            (* Procedo a trascinare verso la posizione di pausa *)
                            Xr.TgtPos := vqAlgnDlvr_PausePos - vqAlgnBlk_ForeOppDist;
                            dlog( Txt:='fbAlgn: Going to pause in %ld mm', Lvl:=3, Val1:=vqAlgnDlvr_PausePos/1E3 );
                            vnAlgn_DragSeq := ALSEQ_DRAG_TOPAUSEPOS;
                        END_IF;
                    ELSE
                        (* Procedo a trascinare verso la quota di arrivo *)
                        Xr.TgtPos := vqAlgnDrag_Tgt - vqAlgnDrag_Width - vqAlgnBlk_ForeOppDist;
                        vnAlgn_DragSeq := ALSEQ_DRAG_FORE;
                    END_IF;

                    (* -Limitazione movimento piedini anteriori-
                       I piedini anteriori alti possono arrivare solo fino ad
                       un certo punto 'vqAlgn_XforeMax'.
                       Se l'obiettivo del bordo avanti 'vqAlgnDrag_Tgt' è oltre,
                       avrò bisogno di un secondo movimento con i piedini posteriori *)
                    IF Xr.TgtPos >= (vqAlgn_XforeMax - Xr.InPosDelta) THEN
                        (* Non riesco con un unico movimento, lo trascino fin dove posso *)
                        Xr.TgtPos := vqAlgn_XforeMax - 1E3; (* ...Con un piccolo margine *)
                        dlog( Txt:='fbAlgn: Drag to partial %ld (%ld) (F=%ld N)', Lvl:=5, Val1:=Xr.TgtPos/1E3, Val2:=vqAlgnDrag_Tgt/1E3, Val3:=Xr.OutFrc/1E3 );
                    ELSE (* Riesco in un solo movimento *)
                        dlog( Txt:='fbAlgn: Drag to final %ld (%ld) (F=%ld N)', Lvl:=5, Val1:=Xr.TgtPos/1E3, Val2:=vqAlgnDrag_Tgt/1E3, Val3:=Xr.OutFrc/1E3 );
                    END_IF;

                    MoveTo := MV_TOOLMOVE;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_FORE : (* Trascinando vetro avanti con i piedini anteriori *)
                vqAlgnDrag_Xbck := Xr.CurrPos + vqAlgnBlk_ForeOppDist;
                IF MoveTo=MV_DONE THEN
                    (* Movimento terminato *)

                    (* Se stavo portando un pezzo a fine linea... *)
                    IF vnAlgn_DragCmd=ALCMD_DRAGEND THEN
                        (* ...Aggiorna la zona occupata a fine linea *)
                        OutZone.Ybtm := vqAlgnDrag_Ybtm;
                        OutZone.Ytop := vqAlgnDrag_Ytop;
                        OutZone.Xbck := vqAlgnDrag_Xbck;
                        OutZone.Xfwd := vqAlgnDrag_Xbck + vqAlgnDrag_Width;
                        (* OutZone.Prescored := vbAlgnDlvr_Prescored; *)
                        (* OutZone.Id := vnAlgnDlvr_Id; *)
                        OutZone.NewPiece := OZ_UPDATE; (* Just update zone, do not take care of piece *)
                    END_IF;

                    (* Comando abbassamento piedini anteriori *)
                    (* Se dovessi spostarmi un po' prima di abbassare i piedini:
                    dlog( Txt:='fbAlgn: DRAG: Move before fore blocks down', Lvl:=5 );
                    Xr.TgtPos := Xr.CurrPos - vqAlgn_DxReset;
                    Xr.TgtSpd := vqAlgn_PushSpd;
                    MoveTo := MV_FREEMOVE;
                    vnAlgn_DragSeq := ALSEQ_DRAG_FORE_GODWN; *)
                    (* ...Ma non ne ho bisogno perchè il movimento a bilancere va già indietro *)
                    vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_DragSeq := ALSEQ_DRAG_FORE_DWN;
                ELSIF MoveTo=MV_ERROR THEN
                    dlog( Txt:='fbAlgn: !! DRAG_FORE: Move error', Lvl:=2 );
                    vnAlgnBlocks_Cmd := 3; (* Posso abbassare subito i piedini *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                ELSE (* During movement *)
                    (* Se voglio parallelizzare il più possibile il taglio con l'evacuazione
                       appena si libera la zona per riscontrare, mollo e vado a farlo; lo spazio
                       di stop dà un margine ulteriore *)
                    IF vnDeliver_ProcPriority>1
                       AND vbShift_AlmostThere AND vn[ivnStatus+ID_SHIFT]<>SHF_FWD_WAITOUTZ
                       AND vqAlgnDrag_Xbck > vqProcArea_Xmax
                       AND vnAlgn_Cmd=ALCMD_ALIGN THEN
                        dlog( Txt:='fbAlgn: DRAG_FORE: ! Stopping at %ld', Lvl:=5, Val1:=vqAlgnDrag_Xbck/1E3 );
                        Xr.Cmd := AXC_STOP_ENAB;
                        vnAlgn_DragSeq := ALSEQ_DRAG_FORE_STOP;
                    END_IF;

                    (* Rileva larghezza lastra errata:
                    se fcOutzoneEnd.q e improvviso incremento forza erogata/errore di posizione
                    vq[ivqAx_CurrFrc+AX_XR-1], vq[ivqAx_CurrErr+AX_XR-1]
                    Xr.CurrFrc, Xr.CurrPosErr *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_FORE_STOP : (* Fermando trascinamento con i piedini anteriori *)
                vqAlgnDrag_Xbck := Xr.CurrPos + vqAlgnBlk_ForeOppDist;
                IF Xr.Status<=AXS_READY THEN
                    IF vnAlgn_Cmd=ALCMD_ALIGN THEN
                        (* Assumo di dover andare a riscontrare, vedi 'vnDeliver_ProcPriority' *)
                        dlog( Txt:='fbAlgn: Leaving drag at %ld to align %ld', Lvl:=5, Val1:=vqAlgnDrag_Xbck/1E3, Val2:=vqAlgn_Tgt/1E3 );
                        Status := ALSTS_ALIGNING;
                        vnAlgn_Seq := SEQ_START;
                        vnAlgn_DragSeq := ALSEQ_DRAG_SUSPENDED;
                    ELSE
                        vnAlgn_DragSeq := SEQ_ERROR;
                    END_IF;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            (* ALSEQ_DRAG_FORE_GODWN : (* Spostamento verso quota discesa piedini anteriori *)
            (* Non è necessario, questa volta il movimento a bilancere mi aiuta *)


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_FORE_DWN : (* Discesa piedini anteriori *)
                IF vnAlgn_DragCmd=CMD_STOP THEN (* Abort sequence *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                ELSIF Blocks.AtRest THEN
                    (* dlog( Txt:='fbAlgn: DRAG: fore blocks are down', Lvl:=5 ); *)

                    (* Controlla se sono arrivato a destinazione oppure serve
                       un ulteriore movimento, che deve essere maggiore di un
                       certo limite per cui ne vale la pena 'vqAlgn_DragMinDisp'
                       Se sto portando a fine linea, devo però assicurare che
                       la fotocellula 'IFC_OUTZONE_END' legga, quindi meglio
                       considerare anche (vqX_OutZoneEnd - vqXph_OutZoneEnd) *)
                    Delta := vqAlgnDrag_Tgt - (vqAlgnDrag_Xbck + vqAlgnDrag_Width); (* Quanto manca *)
                    (* Delta dovrebbe essere sempre positivo, se è negativo sono avanti e quindi arrivato *)
                    IF (Delta>vqAlgn_DragMinDisp) OR ( vnAlgn_DragCmd=ALCMD_DRAGEND AND Delta>(vqX_OutZoneEnd - vqXph_OutZoneEnd) ) THEN
                        (* Devo concludere con un secondo movimento con i piedini posteriori *)
                        dlog( Txt:='fbAlgn: DRAG_FORE_DWN: fwd=%ld must go to %ld (e=%ld um)', Lvl:=5, Val1:=(vqAlgnDrag_Xbck + vqAlgnDrag_Width)/1E3, Val2:=vqAlgnDrag_Tgt/1E3, Val3:=Delta);
                        (* Se devo riscontrare vado a fare quello, riprenderò dopo.
                           Solo se la lastra sta davvero arrivando
                           Nota: in 'SHF_PLACE_FWD' c'è il controllo se non bloccherà l'evacuazione *)
                        IF vnDeliver_ProcPriority>0
                           AND vbShift_AlmostThere AND vn[ivnStatus+ID_SHIFT]<>SHF_FWD_WAITOUTZ
                           AND vnAlgn_Cmd=ALCMD_ALIGN THEN
                            dlog( Txt:='fbAlgn: DRAG_FORE_DWN: ...Align to %ld mm', Lvl:=5, Val1:=vqAlgn_Tgt/1E3 );
                            Status := ALSTS_ALIGNING;
                            vnAlgn_Seq := SEQ_START;
                            vnAlgn_DragSeq := ALSEQ_DRAG_SUSPENDED;
                            (* Certe volte l'operatore prende il pezzo a mano,
                               soprattutto se è piccolo e quasi arrivato.
                               Voglio ricordarmi qui se c'era la fotocellula impegnata
                               per rilevare se pezzo tolto a mano e non fare il secondo
                               movimento *)
                            vbAlgnDrag_WasOnFtc := fcOutzoneNearEnd.q; (* fcOutzoneEnd.q *)
                        ELSE
                            (* Procederò subito col secondo movimento (non è necessario controllare i piedini bassi) *)
                            vnAlgn_DragSeq := ALSEQ_DRAG_INIT;
                        END_IF;
                    ELSE
                        (* Sono arrivato *)
                        vnAlgn_DragSeq := ALSEQ_DRAG_ENDING;
                    END_IF; (* Vedi se devo fare due movimenti o no *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_TOPAUSEPOS : (* Trascinando vetro avanti alla posizione di etichettatura *)
                vqAlgnDrag_Xbck := Xr.CurrPos + vqAlgnBlk_ForeOppDist;
                IF MoveTo=MV_DONE THEN
                    (* Arrivato alla quota di etichettatura *)
                    vnAlgn_DragSeq := ALSEQ_DRAG_PAUSED;
                ELSIF MoveTo=MV_ERROR THEN
                    vnAlgnBlocks_Cmd := 3; (* Posso abbassare subito i piedini *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_PAUSED : (* Attendendo etichettatura *)
                IF vnAlgn_DragCmd=CMD_STOP THEN (* Abort sequence *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                ELSIF vqAlgnDlvr_PausePos=0 THEN
                    (* dlog( Txt:='fbAlgn: DRAG_PAUSED: Prosecuting', Lvl:=5 ); *)
                    vnAlgn_DragSeq := ALSEQ_DRAG_FORE_UP; (* Prosegui *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_REAR_GOUP : (* Spostamento verso quota salita piedini posteriori *)
                IF MoveTo=MV_DONE THEN
                    (* Movimento terminato: salgo per spingere *)
                    (* Chiaramente la lastra in arrivo dovrebbe essersi fermata ben prima *)
                    vnAlgnBlocks_Sel := SEL( vbAlgn_MinBlocksDrag, 16#FFFF, vnAlgnBlocks_DragMsk );
                    vnAlgnBlocks_Cmd := 2; (* Comando salita piedini posteriori *)
                    vnAlgn_DragSeq := ALSEQ_DRAG_REAR_UP; (* Procedi *)
                ELSIF MoveTo=MV_ERROR THEN
                    vnAlgn_DragSeq := SEQ_ERROR;
                (* ELSE wait movement *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_REAR_UP : (* Salita piedini posteriori *)
                (* Controllo che non si attivino i sensori vetro? *)
                IF vbAlgn_NoGlassOnUp AND Blocks.Rising AND Blocks.IrearGlass<>0 THEN
                    dlog( Txt:='fbAlgn: !! Rear under glass', Lvl:=2 );
                    vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                    SET_MSG(MSG_ALGN_UNDERGLASS,'MSG_ALGN_UNDERGLASS',0);
                END_IF;

                IF vnAlgn_DragCmd=CMD_STOP THEN (* Abort sequence *)
                    (* vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                (* Niente richieste in corso *)
                (* Evitiamo però il deadlock per cui la richiesta 'REQ_FREE_OUTZONE'
                   è causata dall'avere il vetro che sto trascinando sulle fotocellule! *)
                ELSIF (IS_MSG(REQ_FREE_OUTZONE) AND (vqAlgnDrag_Xbck + vqAlgnDrag_Width)<OutZone.Xbusy)
                      OR IS_MSG(REQ_TAKE_PROD) OR IS_MSG(REQ_DUMP_PROD) THEN
                    (* Da qui se ne esce con Acknowledge richieste *)
                (* Voglio zona fine linea libera? Nah, se sto usando i posteriori la zona è già occupata dal mio pezzo! *)
                (* ELSIF NOT OutZone.Free THEN *)
                (* Intercetta abort salita piedini *)
                ELSIF Blocks.Status<TS_GOINGON THEN
                    dlog( Txt:='fbAlgn: !! Blocks dead', Lvl:=2 );
                    vnAlgn_DragSeq := SEQ_ERROR;
                (* Per cominciare a trascinare attendo piedini su e aria *)
                ELSIF Blocks.Status=TS_ON AND AirReadyDelayed.q THEN
                    (* Adesso spingiamo il vetro con i piedini posteriori *)
                    (* Visto che è un ultimo movimentino voglio andare piano *)
                    Xr.TgtSpd := vqAlgn_DragSpd / 2; (* [um/min] *)
                    Xr.AccPerc := vnAlgn_DragAccel; (* [%] *)
                    Xr.DecPerc := vnAlgn_DragAccel / 2; (* [%] *)
                    (* Modulo il limite forza con la massa del vetro *)
                    Xr.OutFrc := TO_DINT( fnLinterp(  x := Drag_Mass,
                                                      x1 := 0.0, (* [Kg] Massa minima *)
                                                      y1 := TO_LREAL(vqAlgn_DragMinForce), (* [mN] *)
                                                      x2 := 100.0, (* [Kg] Massa con forza massima *)
                                                      y2 := TO_LREAL(vqAlgn_DragMaxForce) ) ); (* [mN] *)
                    Xr.MaxPosErr := WTR_DEFAULT;
                    (* Ora vediamo dove devo andare *)
                    (* Nota: Non applico 'vqAlgnDlvr_PausePos' perchè questo è l'ultimo movimentino per portare i pezzi piccoli *)
                    (* IF vqAlgnDlvr_PausePos>0 THEN
                        vqAlgnDlvr_PausePos := 0;
                    END_IF; *)
                    Xr.TgtPos := vqAlgnDrag_Tgt - vqAlgnDrag_Width - (vqAlgnBlk_RearDist + vqAlgnBlk_RearOppDist);

                    dlog( Txt:='fbAlgn: Rear push to %ld (Xbck=%ld mm) (F=%ld N)', Lvl:=5, Val1:=Xr.TgtPos/1E3, Val2:=(vqAlgnDrag_Tgt - vqAlgnDrag_Width)/1E3, Val3:=Xr.OutFrc/1E3 );

                    MoveTo := MV_TOOLMOVE;
                    vnAlgn_DragSeq := ALSEQ_DRAG_REAR;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_REAR : (* Spingendo vetro avanti con i piedini posteriori *)
                vqAlgnDrag_Xbck := Xr.CurrPos + vqAlgnBlk_RearDist + vqAlgnBlk_RearOppDist;
                IF MoveTo=MV_DONE THEN
                    (* Movimento terminato *)
                    (* Prima di abbassare i piedini mi devo spostare un po' indietro *)
                    dlog( Txt:='fbAlgn: Move back for rear blocks down', Lvl:=5 );
                    (* Spostamento indietro prima di abbassare piedini posteriori *)
                    Xr.TgtPos := Xr.CurrPos - vqAlgn_DxReset; (* [um] *)
                    IF Xr.TgtPos > Xr.NegLim THEN
                        Xr.TgtSpd := vqAlgn_PushSpd; (* slow [um/min] *)
                        Xr.AccPerc := 100; (* max [%] *)
                        Xr.DecPerc := 100; (* max [%] *)
                        Xr.OutFrc := 0; (* just move *)
                        Xr.MaxPosErr := WTR_HITDET;
                        MoveTo := MV_TOOLMOVE;
                        vnAlgn_DragSeq := ALSEQ_DRAG_REAR_GODWN;
                    ELSE
                        dlog( Txt:='!! Rear blocks NegLim %ld>%ld', Lvl:=2, Val1:=Xr.NegLim/1E3, Val2:=Xr.TgtPos/1E3 );
                        vnAlgn_DragSeq := SEQ_ERROR;
                    END_IF;
                ELSIF MoveTo=MV_ERROR THEN
                    (* Nota: Non posso abbassare subito i piedini, devo muovermi un po' verso il taglio *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                (* ELSE wait movement *)
                (* TODO 3: Rileva larghezza lastra errata:
                   se fcOutzoneEnd.q e incremento forza erogata/errore di posizione
                    vq[ivqAx_CurrFrc+AX_XR-1], vq[ivqAx_CurrErr+AX_XR-1]
                    Xr.CurrFrc, Xr.CurrPosErr
                *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_REAR_GODWN : (* Spostamento verso quota discesa piedini posteriori *)
                IF MoveTo=MV_DONE THEN
                    (* Movimento terminato *)
                    vnAlgnBlocks_Cmd := 3; (* Abbassa i piedini *)
                    vnAlgn_DragSeq := ALSEQ_DRAG_REAR_DWN;
                ELSIF MoveTo=MV_ERROR THEN
                    vnAlgn_DragSeq := SEQ_ERROR;
                (* ELSE wait movement *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_REAR_DWN : (* Discesa piedini posteriori *)
                IF vnAlgn_DragCmd=CMD_STOP THEN (* Abort sequence *)
                    vnAlgn_DragSeq := SEQ_ERROR;
                ELSIF Blocks.AtRest THEN
                    (* dlog( Txt:='fbAlgn: DRAG: rear blocks are down', Lvl:=5 ); *)
                    vnAlgn_DragSeq := ALSEQ_DRAG_ENDING;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_DRAG_ENDING : (* Finalizzazione trascinamento *)
                (* Notifica e resetta eventuali richieste pendenti *)
                IF vqAlgnDlvr_PausePos>0 THEN
                    dlog( Txt:='fbAlgn: ! Ignored vqAlgnDlvr_PausePos=%ld', Lvl:=3, Val1:=vqAlgnDlvr_PausePos/1E3 );
                    vqAlgnDlvr_PausePos := 0;
                END_IF;
                (* === In base al comando eseguito === *)
                (* ___ Trascinamento a fine linea ___ *)
                IF vnAlgn_DragCmd=ALCMD_DRAGEND THEN
                    (* Se ho un tavolo a valle di solito questa operazione si
                       completa con l'evacuazione in esso, operazione che necessita
                       di una conferma esplicita da parte dell'operatore per evitare
                       collisioni con altri vetri in apertura.
                       Per velocizzare, se qui trovo la conferma (pedale) già attivata,
                       procedo subito con l'evacuazione *)
                    IF vbOutTable_Present AND ICM_OUTZONE_PEDAL THEN
                        vbAlgnEvac_Scheduled := TRUE; (* Prenota evacuazione *)
                    (* Porto i riscontri nella quota più probabile per la prossima operazione?
                        -Solo se non li sto già comandando da qui
                        -Solo se non sto tagliando: Voglio evitare conflitti con i programmi *)
                    ELSIF vbAlgn_DragMoveToNext AND MoveTo<>MV_WAITMOVE AND vb[ivbAtRest+ID_PROCSEQ] THEN
                        (* A riguardo del taglio precedente, se ho la rimanenza da evacuare *)
                        IF (vnRemn_PostSts=POST_SHIFT_TOALGN OR vnRemn_PostSts=POST_WAIT_DELIVER) AND NOT vbFeat_AlgnHasBelts THEN
                            (* Se ho un secondo pezzo da portare fine linea, devo andare verso lo zero *)
                            (* Avviciniamoci alla zona taglio per essere pronti ad agganciare la rimanenza *)
                            Xr.TgtPos := vqAlgn_XrMinSafe + 10E3; (* [um] *)
                            MoveTo := MV_FREEMOVE;
                        ELSE
                            (* Mah, mi porto al riscontro successivo *)
                            (* Però non li voglio in zona taglio (o sotto il premilastra) *)
                            Xr.TgtPos := MAX(vqNextStep_FirstAlgn, vqX_ClampAlgnP); (* [um] *) (* vqProc_Algn *)
                            (* Cerco di capire se userò i posteriori *)
                            IF Xr.TgtPos>Xr.PosLim THEN Xr.TgtPos := Xr.TgtPos - vqAlgnBlk_RearDist; END_IF;
                            Xr.TgtPos := LIMIT( IN:=Xr.TgtPos, MN:=vqAlgn_XrMinSafe, MX:=Xr.PosLim );
                            MoveTo := MV_FREEMOVE;
                        END_IF;
                    END_IF;
                    (* - Risultato trascinamento a fine linea - *)
                    vnAlgn_DragSeq := SEL(vqAlgnDrag_Tgt<>vqDeliver_DefaultXbck, SEQ_ERROR, SEQ_DONE);

                (* ___ Evacuazione ___ *)
                ELSIF vnAlgn_DragCmd=ALCMD_DRAGOUT THEN
                    (* Annulla prenotazioni evacuazione *)
                    vbAlgnEvac_Scheduled := FALSE;
                    vqAlgnEvac_Xbck := NO_POS_UM; (* Eat *)
                    (* Segnala pezzo evacuato (se sono riuscito a portarlo fuori) *)
                    IF vqAlgnDrag_Xbck > (vqX_OutZoneEnd + 10E3) THEN
                        dlog( Txt:='fbAlgn: Evac done at %ld', Lvl:=3, Val1:=vqAlgnDrag_Xbck/1E3);
                        OutZone.TryFreeZone := TRUE; (* Prova a liberare la zona *)
                    ELSE
                        (* Se il pezzo è grosso ed uscirebbe dal tavolo a valle
                           non può essere evacuato completamente, mi arrendo e chiedo
                           di liberare la zona a fine linea *)
                        dlog( Txt:='fbAlgn: ! Cannot Evac Xbck=%ld<=%ld', Lvl:=3, Val1:=vqAlgnDrag_Xbck/1E3, Val2:=vqX_OutZoneEnd/1E3 );
                        (* ...Aggiorna la zona occupata a fine linea *)
                        OutZone.Ybtm := vqAlgnDrag_Ybtm;
                        OutZone.Ytop := vqAlgnDrag_Ytop;
                        OutZone.Xbck := vqAlgnDrag_Xbck;
                        OutZone.Xfwd := vqAlgnDrag_Xbck + vqAlgnDrag_Width;
                        (* OutZone.Prescored := vbAlgnDlvr_Prescored; *)
                        (* OutZone.Id := vnAlgnDlvr_Id; *)
                        OutZone.NewPiece := OZ_UPDATE; (* Just update zone, do not take care of piece *)
                        (* Richiedi che prenda il pezzo *)
                        SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',0); (* Align blocks expulsion error *)
                    END_IF;
                    (* - Risultato evacuazione a valle - *)
                    vnAlgn_DragSeq := SEQ_DONE;
                (* ___ Generico trascinamento avanti ___ *)
                ELSE (* ELSIF vnAlgn_DragCmd=ALCMD_DRAGFWD THEN *)
                    (* - Risultato trascinamento avanti - *)
                    vnAlgn_DragSeq := SEQ_DONE;
                END_IF; (* In base al comando *)

                (* - Operazioni finali comuni - *)
                vnAlgn_DragCmd := CMD_STOP; (* Resetto il comando *)
                Status := STS_IDLE;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ELSE (* SEQ_ERROR : (* Trascinamento a fine linea non terminato *)
                vnAlgn_DragCmd := CMD_STOP; (* Resetto il comando *)
                vnAlgn_Cmd := CMD_STOP; (* Resetto eventuale riscontro accodato *)
                vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_PROD; (* Devo evitare che slitti! *)
                Status := STS_IDLE;
                vqAlgnDlvr_PausePos := 0; (* Resetta richieste pendenti *)
                (* Free possible acquired resources *)
                IF LowerCutZone_Algn=ID AND Xr.CurrPos>=vqAlgn_XrMinSafe THEN LowerCutZone_Algn:=0; END_IF;
                IF LowerCutZone_Dtch=ID AND Xr.CurrPos>=vqAlgn_XrAcqDtch THEN LowerCutZone_Dtch:=0; END_IF;
                (* Signal the fail *)
                IF vnAlgnDlvr_Id=0 THEN SET_MSG(REQ_DUMP_PROD,'REQ_DUMP_PROD',0);
                                   ELSE SET_MSG(REQ_TAKE_PROD,'REQ_TAKE_PROD',0); END_IF;

        END_CASE; (* -- Drag to end sequence *)

        (* -- Servizio cuscino aria durante trascinamento avanti -- *)
        (* TODO 2: gestisci caso di stop asse per intervento sicurezze e ripresa della sequenza
          IF Suspended THEN ... *)
        (* Se sta trascinando con i piedini anteriori *)
        IF vnAlgn_DragSeq=ALSEQ_DRAG_FORE (* OR vnAlgn_DragSeq=ALSEQ_DRAG_FORE_UP (* Non subito *) THEN
            (* Accensione aria / spegnimento se quasi arrivato *)
            (* IF (vqAlgnDrag_Tgt - vqAlgnDrag_Width - vqAlgnDrag_Xbck)>vqAlgn_DragVentOffDx AND NeedAir THEN *)
            IF ABS(Xr.TgtPos - Xr.CurrPos)>vqAlgn_DragVentOffDx AND NeedAir THEN
                vnVents_Cmd := vnVents_Cmd OR MSK_VENT_ALGNDRAG;
            ELSE
                vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_PROD; (* Devo evitare che slitti! *)
            END_IF;
        (* Se sta trascinando con i piedini posteriori *)
        ELSIF vnAlgn_DragSeq=ALSEQ_DRAG_REAR OR vnAlgn_DragSeq=ALSEQ_DRAG_REAR_UP THEN
            (* Accensione aria / spegnimento se quasi arrivato *)
            IF ABS(Xr.TgtPos - Xr.CurrPos)>vqAlgn_DragVentOffDx AND NeedAir THEN
                vnVents_Cmd := vnVents_Cmd OR BIT_VENT_ALGN_M; (* Solo banda mediana con i piedini posteriori *)
            ELSE
                vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_PROD; (* Devo evitare che slitti! *)
            END_IF;
        (* Se ha agganciato e sta attendendo fine linea *)
        ELSIF vnAlgn_DragSeq=ALSEQ_DRAG_FORE_UP THEN
            (* Niente: permetto comando manuale *)
        ELSE (* Altrimenti... *)
            vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_ALGN; (* Assicuro aria riscontri spenta *)
        END_IF;


    (* =================================================================== *)
    ALSTS_PUSHING : (* Sequenza di spinta semplice *)
        CASE vnAlgn_Seq OF

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            SEQ_START : (* Inizio della sequenza di spinta semplice *)
                (* I piedini sono bassi, scelgo quali piedini usare
                   a seconda delle quote date 'vqAlgnSheet_X' e 'vqAlgn_Tgt' *)
                (* Controlli *)
                IF vqAlgn_Tgt>vqAlgnSheet_X THEN
                    dlog( Txt:='fbAlgn: !! Cannot pull', Lvl:=2 );
                    vnAlgn_Seq := SEQ_ERROR;
                ELSE
                    RearBlocks := vqAlgnSheet_X >= (vqAlgn_XforeMax - Xr.InPosDelta);
                    IF RearBlocks THEN
                        (* Poiché non supporto spinte così grosse da dover essere svolte in due tempi,
                           verifico che sia possibile alzare i piedini posteriori alla quota di arrivo *)
                        IF vqAlgn_Tgt < vqX_AlgnRearM THEN
                            dlog( Txt:='fbAlgn: !! PUSH: Rear blocks cant go to tgt=%ld<%ld', Lvl:=2, Val1:=vqAlgn_Tgt/1E3, Val2:=vqX_AlgnRearM/1E3);
                            vnAlgn_Seq := SEQ_ERROR;
                        END_IF;
                    END_IF;

                    IF vnAlgn_Seq<>SEQ_ERROR THEN
                        (* Free movement to 'vqAlgnSheet_X' with blocks down (margin already included) *)

                        (* Quota di salita *)
                        (* Applico gli opportuni offset a seconda dei piedini *)
                        IF RearBlocks THEN
                            Xr.TgtPos := vqAlgnSheet_X + vqAlgn_DxRearAdjust - vqAlgnBlk_RearDist;
                        ELSE
                            Xr.TgtPos := vqAlgnSheet_X + vqAlgn_DxForeAdjust;
                        END_IF;
                        dlog( Txt:='fbAlgn: PUSH: Blocks to %ld', Lvl:=4, Val1:=Xr.TgtPos/1E3 );

                        IF MoveTo<>MV_WAITMOVE THEN
                            MoveTo := MV_FREEMOVE;
                        (* ELSE (* Se sono già in moto va bene così, sarà un cambio target *)
                        END_IF;
                        vnAlgn_Seq := ALSEQ_ALGN_GOUP;
                    END_IF;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_GOUP : (* Spostamento con piedini bassi verso quota salita *)
                IF vnAlgn_Cmd<>ALCMD_PUSHTO THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_ERROR THEN
                    (* dlog( Txt:='fbAlgn: !! PUSH: Xr move error going to blocks up pos', Lvl:=2 ); *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_DONE THEN
                    (* dlog( Txt:='fbAlgn: PUSH: Arrived to %ld', Lvl:=5, Val1:=Xr.TgtPos/1E3 ); *)
                    (* Comando piedini alti *)
                    (* Nota: i piedini sono selezionati dal chiamante con 'vnAlgnBlocks_Sel' *)
                    vnAlgnBlocks_Cmd := SEL( RearBlocks, INT#1, INT#2 );
                    vnAlgn_Seq := ALSEQ_ALGN_UP; (* Procedi *)
                (* ELSE wait movement *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_UP : (* Attesa salita piedini/o *)
                IF vnAlgn_Cmd<>ALCMD_PUSHTO THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Intercetta abort salita piedini *)
                ELSIF Blocks.Status<TS_GOINGON THEN
                    (* dlog( Txt:='fbAlgn: !! Raising blocks aborted', Lvl:=2 ); *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Attendo precondizioni *)
                ELSIF Blocks.Status=TS_ON THEN
                    (* dlog( Txt:='fbAlgn: PUSH: Start to push', Lvl:=5 ); *)
                    (* vnVents_Cmd := vnVents_Cmd OR MSK_VENT_ALGN; (* I ventilatori sono gestiti dal chiamante *)
                    (* Velocità: Differenzio tra piano e veloce a seconda di un flag *)
                    Xr.TgtSpd := SEL(vbAlgn_FastPush, vqAlgn_PushSpd, vqAlgn_DragSpd ); (* [um/min] *)
                    vbAlgn_FastPush := FALSE; (* Eat temporary flag *)
                    Xr.AccPerc := vnAlgn_PushAccel; (* [%] *)
                    Xr.DecPerc := vnAlgn_PushAccel; (* [%] *)
                    Xr.OutFrc := vqAlgn_DragMaxForce; (* [mN] Spingo forte *)
                    Xr.MaxPosErr := WTR_DEFAULT;

                    (* Arrivo della spinta
                       Applico gli opportuni offset a seconda dei piedini *)
                    Xr.TgtPos := vqAlgn_Tgt + SEL(Blocks.Buf_Rear, vqAlgn_DxForeAdjust, vqAlgn_DxRearAdjust-vqAlgnBlk_RearDist);

                    MoveTo := MV_TOOLMOVE;
                    vnAlgn_Seq := ALSEQ_ALGN_PUSHING;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ALGN_PUSHING : (* Spingendo vetro *)
                IF vnAlgn_Cmd<>ALCMD_PUSHTO THEN (* Abort sequence *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_ERROR THEN
                    (* dlog( Txt:='fbAlgn: !! PUSH: Xr move error while pushing', Lvl:=2 ); *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF MoveTo=MV_DONE THEN
                    (* dlog( Txt:='fbAlgn: PUSH: Pushed to %ld', Lvl:=5, Val1:=Xr.TgtPos/1E3 ); *)
                    vnAlgn_Seq := SEQ_DONE;
                    vnAlgn_Cmd := CMD_STOP; (* Resetto il comando *)
                    Status := STS_IDLE;
                (* ELSE wait movement *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ELSE (* SEQ_ERROR : (* Sequenza spinta non terminata *)
                vnAlgn_Cmd := CMD_STOP; (* Resetto il comando *)
                Xr.Cmd := AXC_STOP_ENAB; (* Assicuro uno stop *)
                Status := STS_IDLE;
                (* vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_ALGN; (* Assicuro aria riscontri spenta *)
                (* Free possible acquired resources *)
                IF LowerCutZone_Algn=ID AND Xr.CurrPos>=vqAlgn_XrMinSafe THEN LowerCutZone_Algn:=0; END_IF;
                IF LowerCutZone_Dtch=ID AND Xr.CurrPos>=vqAlgn_XrAcqDtch THEN LowerCutZone_Dtch:=0; END_IF;

        END_CASE; (* -- Pushing sequence *)



    (* =================================================================== *)
    ALSTS_DRIVEN : (* Inseguendo riferimento con piedino su *)
        CASE vnAlgn_Seq OF
            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            SEQ_START : (* Inizio della sequenza di aggancio in asse elettrico *)
                IF vnAlgn_Cmd=CMD_STOP THEN
                    vnAlgn_Seq := SEQ_ERROR;
                (* Attendo asse pronto ed eventualmente carrello inferiore fermo
                   Nota: 'vqCarr_StillSpd' è più tollerante di 'Yinf.MinLimSpeed' *)
                ELSIF Xr.Status<>AXS_READY AND (LowerCutZone_Algn<>ID_CARR_INF OR ABS(vq[ivqAx_CurrSpd+AX_YINF-1])<=vqCarr_StillSpd) THEN
                    (* dlog( Txt:='fbAlgn: !! Xr not ready (%d) for CMD_DRIVEN', Lvl:=2, Val1:=TO_DINT(Xr.Status));
                    vnAlgn_Seq := SEQ_ERROR; *)
                ELSE
                    (* Non uso il servizio 'MoveTo' perché voglio più diagnostica sui permessi *)
                    (* !SUPER-ATTENZIONE!
                       Qui si comanda un primo posizionamento a 'ivdXr_PosRef',
                       quindi qui deve essere già opportunamente valorizzato! *)
                    Xr.TgtPos := TO_DINT( 1000.0 * vd[ivdXr_PosRef] ); (* Posizione di aggancio *);
                    (* Controllo che possa raggiungere la quota di aggancio *)
                    Move_LimM := MAX(Xr.NegLim,vqX_AlgnForeM);
                    IF Xr.TgtPos<Move_LimM THEN
                        dlog( Txt:='fbAlgn: !! Cannot hook at %ld<%ld', Lvl:=2, Val1:=Xr.TgtPos/1E3, Val2:=Move_LimM/1E3);
                        vnAlgn_Seq := SEQ_ERROR;
                    (* Se devo entrare in zona taglio, meglio controllare condivisione risorse *)
                    ELSIF Xr.TgtPos<vqAlgn_XrMinSafe THEN
                        (* Posso entrare in zona taglio solo se essa è stata acquisita dal carrello inferiore *)
                        IF LowerCutZone_Algn<>ID_CARR_INF THEN
                            dlog( Txt:='fbAlgn: !! Cannot hook (cut zone owned by %d)', Lvl:=2, Val1:=TO_DINT(LowerCutZone_Algn));
                            vnAlgn_Seq := SEQ_ERROR;
                        (* Controllo che il carrello inferiore sia fermo? Già fatto sopra * )
                        ELSIF ABS(vq[ivqAx_CurrSpd+AX_YINF-1])>vqCarr_StillSpd THEN
                            dlog( Txt:='fbAlgn: !! Cannot hook, CarrInf spd=%ld mm/min', Lvl:=2, Val1:=vq[ivqAx_CurrSpd+AX_YINF-1]/1E3);
                            vnAlgn_Seq := SEQ_ERROR; *)
                        ELSE
                            (* ...Devo fare attenzione a non collidere! *)
                            (* Controllo che il carrello inferiore non collida coi piedini *)
                            Alignable( ybtm:=Carriages.Inf.YroomM - vqAlgnBlks_R,
                                       ytop:=Carriages.Inf.YroomP + vqAlgnBlks_R );
                            IF NOT Alignable.none THEN
                                dlog( Txt:='fbAlgn: !! Cannot hook, CarrInf %ld|%ld collides with Yblk%d=%ld', Lvl:=2, Val1:=Alignable.ybtm/1E3, Val2:=Alignable.ytop/1E3, Val3:=TO_DINT(Alignable.idx_btm), Val4:=vq[ivqAlgnBlks_Y+Alignable.idx_btm]/1E3 );
                                vnAlgn_Seq := SEQ_ERROR;
                            END_IF;
                        END_IF;
                    END_IF; (* Se deve entrare in zona taglio *)

                    (* Procedo se tutto ok *)
                    IF vnAlgn_Seq<>SEQ_ERROR THEN
                        (* Mi porto alla quota di aggancio camma !senza acquisire risorse! *)
                        Xr.TgtSpd := 0; (* max [um/min] *)
                        Xr.AccPerc := 100; (* max [%] *)
                        Xr.DecPerc := 100; (* max [%] *)
                        Xr.OutFrc := 0; (* just move [mN] *)
                        Xr.MaxPosErr := WTR_HITDET;
                        (* Xr.TgtPos (* Posizione di aggancio già assegnata *)
                        (* Essendo già la quota di contatto vetro potrei
                           portarmi un po' più indietro, magari però il
                           movimento a bilancere aiuta e non c'è bisogno *)
                        Xr.Cmd := AXC_START_POS;
                        vnAlgn_Seq := ALSEQ_ROTHOOK;
                    END_IF;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_ROTHOOK : (* Aggancio vetro con piedino ausiliario rotazione *)
                (* Movimento (senza controlli collisione) con piedini bassi verso la quota di aggancio *)
                IF vnAlgn_Cmd=CMD_STOP THEN
                    vnAlgn_Seq := SEQ_ERROR;
                (* Se devo alzarmi in zona taglio attendo liberazione della zona taglio lato stacco *)
                ELSIF Xr.TgtPos<vqAlgn_XrMinSafe
                       AND ( fcDtchLast.q
                             OR IS_MSG(REQ_BACK_REMN)
                             OR (vqRemn_X<>NO_POS_UM AND vqRemn_X>vq[ivqAx_HomePos+AX_XS-1] AND fcDtchLast.q) ) THEN
                    (* Attendo che si liberi lo stacco *)
                    (* Nota: la lettura di IFC_DTCH_LAST è attendibile solo se vqY_BtmEdge<vqYph_DtchLast AND vqY_TopEdge>vqYph_DtchLast *)
                ELSIF Xr.Arrived THEN
                    (* Ok, arrivato a destinazione e fotocellula stacco libera *)
                    dlog( Txt:='fbAlgn: Hooking at %ld', Lvl:=5, Val1:=Xr.TgtPos/1E3);

                    (* Alzo il piedino di aiuto rotazione per agganciare il vetro *)
                    vnAlgnBlocks_Sel := SHL(INT#1, vnAlgnBlk_AuxRot-1); (* Maschera del piedino ausiliario *)
                    vnAlgnBlocks_Cmd := 1;

                    (* Abilito l'inseguimento in camma *)
                    (* ASSERT(ABS(Xr.CurrPos-TO_DINT(1.0E3 * vd[ivdXr_PosRef]))<1000,'(!!) Xr non in pos per aggancio camma') *)
                    Xr.MasterIdx := ivdXr_PosRef;
                    (* TODO 5: Viste le possibili irregolarità vetro-piedino,
                               potrei ignorare l'errore di inseguimento e limitare la coppia *)
                    Xr.MaxPosErr := vqRotBlk_MaxErr; (* [um] *)
                    Xr.Cmd := AXC_START_FOL;

                    vnAlgn_Seq := ALSEQ_LOCKING;
                ELSIF Xr.Status<=AXS_READY THEN
                    (* Se comando esternamente uno stop entra qui *)
                    dlog( Txt:='fbAlgn: !! ROTHOOK: Xr stopped', Lvl:=2 );
                    vnAlgn_Seq := SEQ_ERROR;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_LOCKING : (* Inizializzando inseguimento *)
                (* Attendo camma elettronica e piedino su *)
                IF vnAlgn_Cmd=CMD_STOP THEN
                    vnAlgnBlocks_Cmd := 3; (* Abbasso subito piedino, non dovrei avere problemi *)
                    vnAlgn_Seq := SEQ_ERROR;
                (* Niente controllo sensore presenza vetro, non è nemmeno montato *)
                (* ELSIF vbAlgn_NoGlassOnUp AND Blocks.Rising AND vb[iIFC_REF+4*(vnAlgnBlk_AuxRot-1)+2] THEN
                    dlog( Txt:='fbAlgn: !! Raised under Remn while hooking', Lvl:=1 );
                    vnAlgnBlocks_Cmd := 3;
                    Status := STS_ERROR;
                    SET_MSG(MSG_ALGN_UNDERGLASS,'MSG_ALGN_UNDERGLASS',0); *)
                (* Intercetta abort salita piedini *)
                ELSIF Blocks.Status<TS_GOINGON THEN
                    dlog( Txt:='fbAlgn: !! LOCKING: Block dead', Lvl:=2 );
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF Blocks.Status=TS_ON THEN
                    (* Piedino su, controllo se asse in inseguimento *)
                    IF Xr.Status<=AXS_READY THEN
                        dlog( Txt:='fbAlgn: !! LOCKING: Xr stopped', Lvl:=2 );
                        vnAlgnBlocks_Cmd := 3; (* Abbasso subito piedino, non dovrei avere problemi *)
                        vnAlgn_Seq := SEQ_ERROR;
                    ELSIF Xr.Status=AXS_MOVING_FOL THEN
                        (* Ok, siamo pronti! *)
                        dlog( Txt:='fbAlgn: LOCKING: Ready to be driven', Lvl:=5 );
                        vnAlgn_Seq := ALSEQ_LOCKED;
                    END_IF;
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ALSEQ_LOCKED : (* In camma elettronica *)
                IF vnAlgn_Cmd=CMD_STOP THEN
                    dlog( Txt:='fbAlgn: LOCKED: Ended', Lvl:=4 );
                    vnAlgnBlocks_Cmd := 3; (* Abbasso subito piedino, non dovrei avere problemi *)
                    vnAlgn_Seq := SEQ_ERROR;
                ELSIF Xr.Status<=AXS_READY THEN
                    (* Se comando esternamente uno stop entra qui *)
                    dlog( Txt:='fbAlgn: !! LOCKED: Xr stopped', Lvl:=2 );
                    vnAlgnBlocks_Cmd := 3; (* Abbasso subito piedino, non dovrei avere problemi *)
                    vnAlgn_Seq := SEQ_ERROR;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            ELSE (* SEQ_ERROR : (* Sequenza spinta non terminata *)
                Xr.Cmd := AXC_STOP_ENAB; (* Assicuro uno stop all'asse *)
                vnAlgn_Cmd := CMD_STOP; (* Resetto il comando *)
                Status := STS_IDLE;
                (* vnVents_Cmd := vnVents_Cmd & NOT MSK_VENT_ALGN; (* Assicuro aria riscontri spenta *)
                (* Free possible acquired resources *)
                IF LowerCutZone_Algn=ID AND Xr.CurrPos>=vqAlgn_XrMinSafe THEN LowerCutZone_Algn:=0; END_IF;
                IF LowerCutZone_Dtch=ID AND Xr.CurrPos>=vqAlgn_XrAcqDtch THEN LowerCutZone_Dtch:=0; END_IF;

        END_CASE; (* -- Driven sequence *)


    (* =================================================================== *)
    STS_IDLE : (* Riscontri non attivi *)

        (* Dò una certa precedenza ai comandi di evacuazione, la cui sequenza può essere sospesa *)
        IF (vnAlgn_DragCmd=ALCMD_DRAGFWD OR vnAlgn_DragCmd=ALCMD_DRAGEND) AND NOT vbAlgn_IgnoreDragCmds THEN
            (* Bring piece to output zone, command arguments already valorized *)

            (* Reset messaggi/richieste *)
            RST_MSG_IF_ON(MSG_ALGN_UNDERGLASS);

            (* Mi assicuro di non uscire a fine tavolo (non sto evacuando) *)
            IF vqAlgnDrag_Tgt > vqX_OutZoneEnd THEN
                dlog( Txt:='fbAlgn: Drag: limiting tgt=%ld to %ld', Lvl:=4, Val1:=vqAlgnDrag_Tgt/1E3, Val2:=vqX_OutZoneEnd/1E3 );
                vqAlgnDrag_Tgt := vqX_OutZoneEnd;
            END_IF;
            vbAlgnDrag_WasOnFtc := FALSE; (* Sto iniziando la sequenza *)
            Status := ALSTS_DRAGFWD;
            vnAlgn_DragSeq := SEQ_START;
        ELSIF vbAlgnEvac_Scheduled AND vqAlgnEvac_Xbck<>NO_POS_UM AND vnAlgn_DragSeq<>ALSEQ_DRAG_SUSPENDED AND NOT vbAlgn_IgnoreDragCmds THEN
            (* Prenotata una evacuazione a valle: la faccio partire *)

            (* Reset messaggi/richieste *)
            RST_MSG_IF_ON(MSG_ALGN_UNDERGLASS);

            (* Contratto: assumo pezzo a fine linea ossia bordo avanti Xfwd=vqX_OutZoneEnd *)
            vqAlgnDrag_Ybtm := vqYo_SheetFeed; (* É sicuramente trascinabile, non mi interessa l'altezza *)
            vqAlgnDrag_Ytop := vqAlgnDrag_Ybtm + vqYmax;
            vqAlgnDrag_Width := vqX_OutZoneEnd - vqAlgnEvac_Xbck; (* Assumo sia a fine linea *)
            vqAlgnDrag_Xbck := vqAlgnEvac_Xbck;
            vqAlgnDrag_Tgt := MIN(vqX_OutTableEnd, Xr.PosLim - 1E3 + vqAlgnBlk_RearDist + vqAlgnBlk_RearOppDist + vqAlgnDrag_Width); (* Lo porto più fuori possibile *)
            (* Evito di evacuare sotto il prodotto in processazione! *)
            IF vqAlgnDrag_Xbck>(vqProd_Width+vqAlgnBlk_RearOppDist) OR vb[ivbAtRest+ID_PROCSEQ] THEN (* vn[ivnStatus+ID_PROCSEQ]<=TS_GOINGOFF *)
                dlog( Txt:='fbAlgn: Evac from Xbck=%ld to %ld', Lvl:=4, Val1:=vqAlgnDrag_Xbck/1E3, Val2:=(vqAlgnDrag_Tgt-vqAlgnDrag_Width)/1E3 );
                vnAlgn_DragSeq := SEQ_START;
                vnAlgn_DragCmd := ALCMD_DRAGOUT; (* Segnalo che sto evacuando fuori *)
                Status := ALSTS_DRAGFWD;
            ELSE
                dlog( Txt:='fbAlgn: !! Cannot evac under Prod %ld mm', Lvl:=2, Val1:=vqProd_Width/1E3 );
                (* vnAlgn_DragSeq := SEQ_ERROR; *)
                vnAlgn_DragCmd := CMD_STOP;
                vqAlgnEvac_Xbck := NO_POS_UM; (* Cancello possibilità di evacuare *)
                Status := STS_ERROR;
            END_IF;
            (* Finally *)
            vbAlgnDrag_WasOnFtc := FALSE; (* Per sicurezza *)
            vbAlgnEvac_Scheduled := FALSE; (* eat *)

        (* Altri comandi *)
        ELSIF vnAlgn_Cmd<>CMD_STOP THEN
            (* Reset messaggi/richieste *)
            RST_MSG_IF_ON(REQ_DOALIGN);
            RST_MSG_IF_ON(MSG_ALGN_NOGLASS);
            RST_MSG_IF_ON(MSG_ALGN_UNDERGLASS);
            RST_MSG_IF_ON(MSG_BAD_ALGNARGS);

            (* Rispondi ai comandi *)
            IF vnAlgn_Cmd=CMD_PARK THEN
                (* Sequenza per abbassare i piedini, in genere non muovo Xr in home *)
                Status := ALSTS_RESETTING;
                vnAlgn_Seq := SEQ_START;
            ELSIF vnAlgn_Cmd=ALCMD_ALIGN THEN
                (* Sequenza di riscontro *)
                Status := ALSTS_ALIGNING;
                vnAlgn_Seq := SEQ_START;
            ELSIF vnAlgn_Cmd=ALCMD_PUSHTO THEN
                (* Usato nella ciclica rifilo *)
                IF Blocks.AtRest THEN
                    (* Piedini bassi: .Muovo a 'vqAlgnSheet_X', alza piedini 'vnAlgnBlocks_Sel'
                                      .Spingo a 'vqAlgn_Tgt' *)
                    dlog( Txt:='fbAlgn: Move from %ld to %ld then push to %ld mm', Lvl:=4, Val1:=Xr.CurrPos/1E3, Val2:=vqAlgnSheet_X/1E3, Val3:=vqAlgn_Tgt/1E3 );
                    vnAlgn_Seq := SEQ_START;
                ELSE
                    (* Piedini già alti: spingo a 'vqAlgn_Tgt' *)
                    dlog( Txt:='fbAlgn: Pushing from %ld to %ld mm', Lvl:=4, Val1:=Xr.CurrPos/1E3, Val2:=vqAlgn_Tgt/1E3 );
                    vnAlgn_Seq := ALSEQ_ALGN_UP;
                END_IF;
                Status := ALSTS_PUSHING;
            ELSIF vnAlgn_Cmd=CMD_MOVETO THEN
                (* Free movement with blocks down to 'vqAlgn_Tgt' *)
                IF Blocks.AtRest THEN
                    Xr.TgtPos := vqAlgn_Tgt;
                    MoveTo := MV_FREEMOVE;
                    Status := STS_MOVING;
                ELSE
                    (* Prima meglio abbassare i piedini *)
                    dlog( Txt:='fbAlgn: Resetting blocks before free move', Lvl:=4 );
                    Status := ALSTS_RESETTING;
                    vnAlgn_Seq := SEQ_START;
                END_IF;
            ELSIF vnAlgn_Cmd=CMD_DRIVEN THEN
                (* -Modalità piedino di aiuto rotazione-
                     .Mi porto nella posizione iniziale di aggancio camma 'vdXr_PosRef'
                     .Alzo il piedino (singolo) che aggancia il vetro
                     .Aggancio camma *)
                IF NOT Blocks.AtRest THEN
                    (* Prima meglio abbassare i piedini *)
                    dlog( Txt:='fbAlgn: Resetting blocks before CMD_DRIVEN', Lvl:=4 );
                    Status := ALSTS_RESETTING;
                    vnAlgn_Seq := SEQ_START;
                ELSE
                    Status := ALSTS_DRIVEN;
                    vnAlgn_Seq := SEQ_START;
                END_IF;
            ELSE
                dlog( Txt:='fbAlgn: !! Unknown cmd=%d', Lvl:=2, Val1:=TO_DINT(vnAlgn_Cmd));
                vnAlgn_Cmd := CMD_STOP;
                Status := STS_ERROR;
            END_IF;
        END_IF; (* Command not null *)


    (* =================================================================== *)
    ELSE (* Errore richiesta (STS_ERROR) *)
        IF vnAlgn_Cmd=CMD_STOP AND vnAlgn_DragCmd=CMD_STOP THEN
            Status := STS_STOPPING;
        END_IF;

END_CASE; (* -- main state machine *)


(* - Servizio di movimentazione -
     visto che le sequenza sono tante, meglio separare il boilerplate
     della movimentazione, mi serve il movimento libero a piedini bassi
     e il movimento con piedini alti per trascinare il vetro *)
IF Status<>STS_IDLE THEN

    CASE MoveTo OF

        MV_SUSPENDED : (* Attendi ripresa *)
            IF Abort THEN
                (* dlog( Txt:='fbAlgn: MoveTo suspended aborted', Lvl:=2 ); *)
                MoveTo := MV_ERROR;
            ELSIF NOT Suspend THEN
                dlog( Txt:='fbAlgn: MoveTo resumed', Lvl:=2 );
                (* Ridai comando, assumendo che nessuno abbia modificato
                   gli argomenti del movimento 'TgtPos', ... *)
                Xr.Cmd := AXC_START_POS;
                MoveTo := MV_WAITMOVE;
            END_IF;


        MV_WAITMOVE : (* Attendi movimento verso quota obiettivo *)
            IF Xr.Arrived THEN
                (* Ok, arrivato a destinazione *)
                dlog( Txt:='fbAlgn: MoveTo arrived (%ld um)', Lvl:=6, Val1:=Xr.CurrPos );
                MoveTo := MV_DONE;
                (* Il controllo se posso liberare delle risorse lo faccio in modo continuativo su spostamenti positivi *)
            ELSIF Xr.Status<=AXS_READY THEN
                (* Se non arrivato o comando esternamente uno stop o non si attiva il bit in quota entra qui *)
                dlog( Txt:='fbAlgn: ! Xr move to %ld not arrived (%ld um)', Lvl:=2, Val1:=Xr.TgtPos, Val2:=Xr.CurrPos );
                MoveTo := MV_ERROR;
            ELSIF Abort THEN (* OR (vnAlgn_Cmd=CMD_STOP AND vnAlgn_DragCmd=CMD_STOP) *)
                dlog( Txt:='fbAlgn: ! MoveTo aborted', Lvl:=2 );
                Xr.Cmd := AXC_STOP_ENAB;
                MoveTo := MV_WAITSTOP;
            ELSIF Suspend THEN
                dlog( Txt:='fbAlgn: MoveTo suspended at %ld mm', Lvl:=2, Val1:=Xr.CurrPos/1E3 );
                Xr.Cmd := AXC_STOP_FREE;
                MoveTo := MV_SUSPENDED;
            END_IF;


        MV_WAITSTOP : (* Attendi stop asse *)
            IF Xr.Status<=AXS_READY THEN
                MoveTo := MV_ERROR; (* Comunque non sono arrivato *)
            END_IF;


        MV_FREEMOVE,  (* Prepara movimento libero con piedini bassi *)
        MV_TOOLMOVE : (* Prepara movimento con piedini alti *)
            IF Abort THEN (* OR (vnAlgn_Cmd=CMD_STOP AND vnAlgn_DragCmd=CMD_STOP) *)
                dlog( Txt:='fbAlgn: !! Move aborted', Lvl:=2 );
                MoveTo := MV_ERROR;
            ELSIF MoveTo=MV_FREEMOVE AND NOT Blocks.AtRest THEN
                dlog( Txt:='fbAlgn: !! Cannot free move with blocks up', Lvl:=2 );
                MoveTo := MV_ERROR;
            (* Controllo collisione con stacco (rilassabile) *)
            ELSIF Xr.TgtPos<vqDtch_CurrX THEN
                dlog( Txt:='fbAlgn: !! Move to %ld with dtch in %ld', Lvl:=2, Val1:=Xr.TgtPos/1E3, Val2:=vqDtch_CurrX/1E3 );
                MoveTo := MV_ERROR;
            ELSE
                (* Se devo impegnare delle risorse, cerca di acquisirle *)
                IF Xr.TgtPos<vqAlgn_XrMinSafe AND LowerCutZone_Algn<>ID THEN
                    IF LowerCutZone_Algn=0 THEN LowerCutZone_Algn:=ID; END_IF;
                END_IF;
                IF Xr.TgtPos<vqAlgn_XrAcqDtch AND LowerCutZone_Dtch<>ID THEN
                    IF LowerCutZone_Dtch=0 THEN LowerCutZone_Dtch:=ID; END_IF;
                END_IF;

                (* Posso procedere col movimento se ho acquisito le risorse necessarie *)
                CanMoveTo := (Xr.TgtPos>=vqAlgn_XrMinSafe OR LowerCutZone_Algn=ID) AND
                             (Xr.TgtPos>=vqAlgn_XrAcqDtch OR LowerCutZone_Dtch=ID);

                (* A volte però è necessario entrare in zona taglio con il carrello
                   inferiore che ha già impegnato le risorse che vorrei acquisire.
                   Es. -Riscontro per taglio/molatura di testa con carrello inferiore
                        non completamente a riposo (es. dopo rotazione con pinza)
                       -Aggancio vetro pinzato per aiuto rotazione
                   In questi casi posso entrare in zona taglio se carrello inferiore è fermo
                   e non collide. Tanto la risorse non potranno essere liberate da CarrInf
                   finantoché i riscontri non escono dalla zona taglio, quindi è sicuro *)
                IF NOT CanMoveTo THEN
                    (* Potrei entrare in zona taglio occupata dal carrello inferiore se... *)
                    IF LowerCutZone_Algn=ID_CARR_INF AND LowerCutZone_Dtch=ID_CARR_INF AND
                       (Carriages.Inf.Status=STS_IDLE OR vnGrab_RotStatus=1) AND (* Niente in corso se non rotazione *)
                       ABS(vq[ivqAx_CurrSpd+AX_YINF-1]) < vqCarr_StillSpd THEN (* CarrInf fermo *)
                        (* Se i piedini non ci collidono, entro in zona taglio senza acquisirne le risorse *)
                        Alignable( ybtm:=Carriages.Inf.YroomM - vqAlgnBlks_R,
                                   ytop:=Carriages.Inf.YroomP + vqAlgnBlks_R );
                        CanMoveTo := Alignable.none;
                    (* ELSE dlog( Txt:='fbAlgn: !! Zone if owned by %d', Lvl:=1, Val1:=TO_DINT(LowerCutZone_Algn)); *)
                    END_IF; (* Zona occupata dal carrello inferiore *)
                END_IF; (* Vedo se posso comunque entrare in zona taglio *)

                (* Se ho le condizioni per muovermi, procedo *)
                IF CanMoveTo AND Xr.Status<>AXS_STOPPING THEN
                    (* Posso comandare il movimento *)
                    dlog( Txt:='fbAlgn: Move from %ld to %ld mm (blks=%d)', Lvl:=6, Val1:=Xr.CurrPos/1E3, Val2:=Xr.TgtPos/1E3, Val3:=TO_DINT(Blocks.Status) );
                    IF Xr.Status=AXS_READY THEN
                        (* Calcolo il range consentito del movimento *)
                        IF Blocks.ForeUp THEN
                            (* Piedini anteriori alti: *)
                            Move_LimM := Xr.NegLim + 1E3;
                            Move_LimP := MIN(Xr.PosLim,vqX_AlgnForeP) - 1E3;
                        ELSIF Blocks.RearUp THEN
                            (* Piedini posteriori alti: *)
                            Move_LimM := MAX(Xr.NegLim,vqX_AlgnRearM) + 1E3;
                            Move_LimP := Xr.PosLim - 1E3;
                        ELSE (* Blocks.AtRest *)
                            (* Piedini bassi: *)
                            Move_LimM := MAX(Xr.NegLim,vqX_AlgnForeM) + 1E3;
                            Move_LimP := Xr.PosLim - 1E3; (* MIN(Xr.PosLim,vqX_AlgnRearP) *)
                        END_IF;
                        (* Forzo la quota obiettivo entro il range consentito *)
                        IF Xr.TgtPos>Move_LimP THEN
                            dlog( Txt:='fbAlgn: ! Forcing tgt %ld in %ld mm', Lvl:=2, Val1:=Xr.TgtPos/1E3, Val2:=Move_LimP/1E3 );
                            Xr.TgtPos := Move_LimP;
                        ELSIF Xr.TgtPos<Move_LimM THEN
                            dlog( Txt:='fbAlgn: ! Forcing tgt %ld in %ld mm', Lvl:=2, Val1:=Xr.TgtPos/1E3, Val2:=Move_LimM/1E3 );
                            Xr.TgtPos := Move_LimM;
                        END_IF;

                        (* Gli argomenti del posizionamento: *)
                        (* Xr.TgtPos := <Già definito>; (* [um] *)
                        IF MoveTo=MV_FREEMOVE THEN
                            Xr.TgtSpd := 0; (* max [um/min] *)
                            Xr.AccPerc := 100; (* max [%] *)
                            Xr.DecPerc := 100; (* max [%] *)
                            Xr.OutFrc := 0; (* just move [mN] *)
                            Xr.MaxPosErr := WTR_HITDET;
                        (* ELSE (* Altrimenti devono essere già definiti! *)
                        END_IF;
                        Xr.Cmd := AXC_START_POS;
                        MoveTo := MV_WAITMOVE;
                    ELSE
                        dlog( Txt:='fbAlgn: !! Xr not ready (%d) to move', Lvl:=2, Val1:=TO_DINT(Xr.Status) );
                        MoveTo := MV_ERROR;
                    END_IF;
                ELSE
                    (* Probabilmente non sono riuscito ad acquisire una o più risorse,
                       oppure l'asse non è ancora pronto: tenterò il prossimo giro *)
                    IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=0; END_IF;
                    IF LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=0; END_IF;
                END_IF;
            END_IF;

    END_CASE; (* -- servizio movimentazione *)
END_IF; (* -- sequenza in corso *)



(* -- Servizi relativi ai piedini di riscontro -- *)
Blocks( Cmd:=vnAlgnBlocks_Cmd, Sel:=vnAlgnBlocks_Sel );
vnAlgnBlocks_Cmd := Blocks.Cmd; (* Reflect command changes *)


(* -- Controllo continuativo liberazione/riacquisizione risorse -- *)
IF Xr.MovingFwd THEN
    (* Assicura di liberare risorse se non più occupate *)
    IF LowerCutZone_Algn=ID AND Xr.CurrPos>=vqAlgn_XrMinSafe THEN LowerCutZone_Algn:=0; END_IF;
    IF LowerCutZone_Dtch=ID AND Xr.CurrPos>=vqAlgn_XrAcqDtch THEN LowerCutZone_Dtch:=0; END_IF;
END_IF;
IF vbHomingDone THEN
    (* Assicura di rioccupare risorse se necessario *)
    IF LowerCutZone_Algn=0 AND Xr.CurrPos<vqAlgn_XrMinSafe THEN LowerCutZone_Algn:=ID; END_IF;
    IF LowerCutZone_Dtch=0 AND Xr.CurrPos<vqAlgn_XrAcqDtch THEN LowerCutZone_Dtch:=ID; END_IF;
END_IF;


(* -- Monitors -- *)
(* Posizione e ingombro correnti dei piedini selezionati *)
(* Piedini alti: vnAlgnBlocks_Sts>=TS_GOINGON OR vnAlgnBlocks_Cmd<>0 *)
IF Blocks.Cmd=2 OR Blocks.RearUp THEN (* vbAlgnBlocks_SelRear == Blocks.Buf_Rear *)
    (* Piedini posteriori *)
    vqAlgn_CurrX := Xr.CurrPos + vqAlgnBlk_RearDist;
    vqAlgn_XroomP := vqAlgn_CurrX + vqAlgnBlk_RearOppDist;
ELSE
    (* Piedini anteriori *)
    vqAlgn_CurrX := Xr.CurrPos;
    vqAlgn_XroomP := vqAlgn_CurrX + vqAlgnBlk_ForeOppDist - 500; (* Un piccolo margine per evitare blocchi, il movimento a bilancere aiuta *)
END_IF;

InCutZone := Xr.CurrPos<vqAlgn_XrMinSafe OR Xr.StopPos<vqAlgn_XrMinSafe; (* AND NOT IFC_XR_ZERO *)
UnderClamp := Xr.CurrPos>vqAlgn_XrClampAlgnM AND Xr.CurrPos<vqX_ClampAlgnP; (* Sotto premilastra-taglio (occhio a salire con gli anteriori) *)
 (* vbAx_NoStillChkAtRest: mah, non ho mai avuto problemi con i riscontri *)
AtRest := Blocks.AtRest AND Xr.Still AND NOT InCutZone; (* Xr.Status<AXS_STOPPING *)
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbHoldPads

{ DE:"Tamponi fermavetro del ponte di taglio" }

	VAR_INPUT
	Emulated : BOOL; { DE:"Operazione emulata" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato dei tamponi" }
	AtRest : BOOL; { DE:"Tamponi a riposo" }
	AtRest_Dtch : BOOL; { DE:"Tamponi lato stacco a riposo" }
	AtRest_Algn : BOOL; { DE:"Tamponi lato riscontro a riposo" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	ID : INT := ID_HOLDPADS; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vnHoldPads_Cmd : INT; { DE:"Comando tamponi fermavetro" }
	vqHoldPads_P : DINT; { DE:"Spinta desiderata tamponi fermavetro [mN]" }
	vbHoldPads_Indep : BOOL; { DE:"Tamponi fermavetro lato stacco/riscontro indipendenti" }
	vqHoldPads_CylArea : DINT; { DE:"Area cilindri attuatore pneumatico tamponi fermavetro (6xø25=2945) [um mm]" }
	vqHoldPads_DwnTime : DINT; { DE:"Tempo attesa discesa tamponi [ms]" }
	vqHoldPads_UpTime : DINT; { DE:"Tempo attesa salita tamponi [ms]" }
	O_HOLDPADS_DTCH : BOOL; { DE:"Aziona discesa tamponi ferma-vetro lato stacco" }
	O_HOLDPADS_ALGN : BOOL; { DE:"Aziona discesa tamponi ferma-vetro lato riscontri" }
	END_VAR

	VAR
	TUpDelay : Ton; { DE:"Timer attesa salita" }
	TDownDelay : Ton; { DE:"Timer attesa discesa" }
	Push : DINT; { DE:"Current pushing force [mN]" }
	curr_cmd : INT; { DE:"Comando correntemente attivo" }
	END_VAR

	{ CODE:ST }(*    fbHoldPads (Project M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Attuazione dei tamponi ferma vetro sul ponte
      di taglio 'ID_HOLDPADS'.
      Sono dei tamponi che scendono sia dalla parte
      riscontri che dalla parte stacco, si usano
      per tenere ferma la lastra in alternativa
      ai premilastra perché non rompono il vetro,
      tipicamente durante l'incisione.

      DETAILS
      ----------------------------------------------
      Nelle macchine più datate occhio che l'uscita
      tamponi pilotava anche la pressione del
      serbatoio dell'olio di lubrificazione taglio
      e l'aspirazione sulla testina inferiore.

      EXAMPLE OF USAGE
      ----------------------------------------------
      vqHoldPads_P = vqHoldPads_Phold
      vnHoldPads_Cmd = (BIT_DTCH_SIDE | BIT_ALGN_SIDE)
      WaitCond( vn[ivnStatus+ID_HOLDPADS]==TS_ON )
      vnHoldPads_Cmd = 0
      WaitCond( vn[ivnStatus+ID_HOLDPADS]==TS_OFF )
*)

(* -- State machine -- *)
TDownDelay( in:=Status=TS_GOINGON, pt:=TO_UDINT(vqHoldPads_DwnTime) );
TUpDelay( in:=Status=TS_GOINGOFF, pt:=TO_UDINT(vqHoldPads_UpTime) );
CASE Status OF

    TS_ON : (* Tamponi bassi *)
        IF vnHoldPads_Cmd=0 OR NOT Allow THEN
            (* dlog( Txt:='fbHoldPads: Aborting', Lvl:=3 ); *)
            Status := TS_GOINGOFF;
        ELSIF curr_cmd<>vnHoldPads_Cmd THEN
            dlog( Txt:='fbHoldPads: Cmd 0x%X => 0x%X', Lvl:=3, Val1:=TO_DINT(curr_cmd), Val2:=TO_DINT(vnHoldPads_Cmd) );
            Status := TS_GOINGON;
        ELSE
            Push := vqHoldPads_P; (* Spinta di tenuta *)
            O_HOLDPADS_DTCH := (curr_cmd & BIT_DTCH_SIDE)<>0 AND NOT Emulated;
            O_HOLDPADS_ALGN := (curr_cmd & BIT_ALGN_SIDE)<>0 AND NOT Emulated;
        END_IF;


    TS_GOINGON : (* Attendi tempo minimo per discesa tamponi *)
        IF vnHoldPads_Cmd=0 OR NOT Allow THEN
            (* dlog( Txt:='fbHoldPads: !! Abort on descend', Lvl:=3 ); *)
            Status := TS_GOINGOFF; (* Attendi rientro *)
        ELSIF TDownDelay.q AND (O_HOLDPADS_DTCH OR O_HOLDPADS_ALGN OR Emulated) THEN
            dlog( Txt:='fbHoldPads: Down (0x%X)', Lvl:=3, Val1:=TO_DINT(curr_cmd) );
            Push := vqHoldPads_P; (* Spinta di tenuta *)
            Status := TS_ON; (* Tamponi scesi *)
        ELSE
            Push := vqHoldPads_P; (* Spinta di discesa *)
            O_HOLDPADS_DTCH := (curr_cmd & BIT_DTCH_SIDE)<>0 AND NOT Emulated;
            O_HOLDPADS_ALGN := (curr_cmd & BIT_ALGN_SIDE)<>0 AND NOT Emulated;
        END_IF;


    TS_GOINGOFF : (* Attendo tempo minimo salita *)
        O_HOLDPADS_DTCH := FALSE;
        O_HOLDPADS_ALGN := FALSE;
        (* Se uso la proporzionale per salire: *)
        (* Push := -vqHoldPads_UpPush; (* Spinta di salita *)
        IF TUpDelay.q THEN
            dlog( Txt:='fbHoldPads: Up', Lvl:=3 );
            curr_cmd := 0;
            Status := TS_OFF; (* Tamponi saliti *)
        END_IF;


    TS_OFF : (* Tamponi alti *)
        IF vnHoldPads_Cmd<>0 THEN
            (* dlog( Txt:='fbHoldPads: Command 0x%X', Lvl:=5, Val1:=TO_DINT(vnHoldPads_Cmd) ); *)
            curr_cmd := vnHoldPads_Cmd;
            Status := TS_GOINGON;
        ELSE
            O_HOLDPADS_DTCH := FALSE;
            O_HOLDPADS_ALGN := FALSE;
            (* Push := -vqHoldPads_UpPush; (* Spinta di ritenuta *)
        END_IF;

END_CASE; (* -- state machine *)


(* -- Calcolo della pressione da dare alla proporzionale --
  Conversione da forza a pressione in base all'area cilindro
  P[bar] = (10 * F[N]) / A[mm²] *)
(* Qui il peso è positivo se concorde, ossia per utensili superiori; l'attrito si oppone sempre *)
(* Pressure := (100 * (MAX(0,Push-vqHoldPads_Weight) + vqHoldPads_CylFr)) / (vqHoldPads_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)
Pressure := (100 * Push) / (vqHoldPads_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)

(* Supporto pressione di salita data dalla proporzionale *)
IF NOT O_HOLDPADS_DTCH AND NOT O_HOLDPADS_ALGN THEN
    Pressure := P_TOOLUP;
ELSIF Pressure<0 THEN
    (* Se la pressione è negativa devo salire *)
    Pressure := -Pressure; (* Dovrei riapplicare peso e attriti cambiando segno *)
    O_HOLDPADS_DTCH := FALSE;
    O_HOLDPADS_ALGN := FALSE;
END_IF;

(* -- Supporta macchine con tamponi non indipendenti -- *)
IF NOT vbHoldPads_Indep THEN
    O_HOLDPADS_DTCH := O_HOLDPADS_DTCH OR O_HOLDPADS_ALGN;
    O_HOLDPADS_ALGN := O_HOLDPADS_DTCH;
END_IF;

(* -- Monitors -- *)
AtRest := Status=TS_OFF; (* AND NOT O_HOLDPADS_DTCH AND NOT O_HOLDPADS_ALGN; *)

AtRest_Dtch := AtRest OR (vbHoldPads_Indep AND NOT O_HOLDPADS_DTCH); (* AND (curr_cmd & BIT_DTCH_SIDE)=0 *)
AtRest_Algn := AtRest OR (vbHoldPads_Indep AND NOT O_HOLDPADS_ALGN); (* AND (curr_cmd & BIT_ALGN_SIDE)=0 *)

vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbClampPneum

{ DE:"Premilastra pneumatico" }

	VAR_INPUT
	ID : INT; { DE:"Identificativo componente" }
	Cmd : INT; { DE:"Comando attivazione" }
	ClampPush : DINT; { DE:"Forza richiesta quando giù [mN]" }
	TopCyl : BOOL; { DE:"Aziona cilindri addizionali dei premilastra (zona in alto)" }
	Weight : DINT; { DE:"Peso premilastra [mN]" }
	Fr : DINT; { DE:"Forza resistente statica attuatore [mN]" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del premilastra" }
	AtRest : BOOL; { DE:"Premilastra alto e a riposo" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	SelPv : BOOL; { DE:"Seleziona pressione premilastra (0:linea, 1:propvalv)" }
	DownOutput : BOOL; { DE:"Uscita discesa premilastra (0:up, 1:down)" }
	AlmostUp : BOOL; { DE:"Segnale premilastra alto o quasi per anticipo sequenze" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vqClamps_MechRatio : DINT; { DE:"Rapporto di trasmissione meccanico cilindri premilastra" }
	vqClamps_CylArea : DINT; { DE:"Area cilindri premilastra (ø63=3117) [um mm]" }
	vqClamps_Latency : DINT; { DE:"Latenza attuatore pneumatico premilastra [us/N]" }
	vqClamps_Tsettle : DINT; { DE:"Tempo minimo assestamento pressione premilastra [ms]" }
	vqClamps_PushMax : DINT; { DE:"Spinta massima ammessa dei premilastra [mN]" }
	vqClamps_PpulseDwn : DINT; { DE:"Spinta impulso discesa premilastra [mN]" }
	vqClamps_Pup : DINT; { DE:"Spinta salita dolce premilastra [mN]" }
	vqClamps_TpulseDwn : DINT; { DE:"Tempo impulso spinta discesa premilastra [ms]" }
	vqClamps_TfallDwn : DINT; { DE:"Tempo discesa senza spinta premilastra [ms]" }
	vqClamps_Tup : DINT; { DE:"Tempo spinta di salita premilastra [ms]" }
	vqClamps_TalmostUp : DINT; { DE:"Tempo per cui si considerano i premilastra quasi saliti [ms]" }
	vnClamps_NumBcyl : INT; { DE:"Numero cilindri banda bassa (fissi)" }
	vnClamps_NumCyl : INT; { DE:"Numero cilindri totali (fissi+opzionali)" }
	END_VAR

	VAR
	TDownPulse : Ton; { DE:"Timer per impulso discesa" }
	TDownFall : Ton; { DE:"Timer per discesa senza spinta" }
	TSettleDelay : Ton; { DE:"Timer assestamento pressione" }
	TUpDelay : Ton; { DE:"Timer attesa salita" }
	TAlmostUp : Ton; { DE:"Timer premilastra quasi alto" }
	Push : DINT; { DE:"Desired overall pushing force -with sign- [mN]" }
	Ncyl : DINT; { DE:"Total number of cylinders" }
	SettleTime : UDINT; { DE:"Tempo stabilizzazione pressione di lavoro" }
	END_VAR

	{ CODE:ST }(*    fbClampPneum (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Attuazione di un premilastra pneumatico.
      I premilastra fanno tre cose:
        .Grab (devono premere tanto per tirare o trascinare il vetro)
        .Hold (devono premere poco per assicurare che il vetro non si sposti)
        .Oppose (devono contrastare la barra di troncaggio o altro utensile)
      I premilastra sono nati con una attuazione pneumatica,
      quindi storicamente sono controllati con una pressione
      di spinta.

      DETAILS
      ----------------------------------------------
      L'attuazione è costituita da un gruppo di cilindri
      disposto sull'asse di taglio.
      'O_CLAMP' seleziona la camera do convogliare pressione
      'O_CLAMP_SELP' seleziona cosa convogliare (linea o valv prop)
      Quando i cilindri aggiuntivi sono attivati, la
      forza totale aumenta: potrebbe essere bene
      abbassare la pressione.
      I premilastra hanno una massa considerevole:
      se voglio spingere con una forza minore di quella
      del loro peso (~80Kgp per 4.0) devo convogliare
      pressione nella camera di salita, per compensare
      il peso in eccesso.
      La discesa è divisa in un impulso iniziale
      seguita da un tempo a pressione nulla
      (caduta).
      La salita ha in tempo iniziale con pressione
      controllata.
      Attenzione: c'è una leva, l'effetto della forza
      dei cilindri è circa raddoppiato.
      Il gruppo opzionale è sempre attivo in salita,
      il contributo in discesa si attiva con una uscita
      O_CLAMP_TCYL.

      NOTES
      ----------------------------------------------
      Poiché la medesima proporzionale è condivisa
      tra i due premilastra, potrebbero esserci
      problemi nel caso si sovrappongano comandi
      differenti (discesa/salita, ...).
      L'area dei cilindri non è simmetrica: da una
      parte c'è l'albero, il cui effetto è diminuire
      la forza.

      CONTRACT
      ----------------------------------------------
      Il comando 'CMD_PARK' non è suppoortato e va
      intercettato a monte
*)

TDownPulse( in:=(Status=CL_PULSEDOWN), pt:=TO_UDINT(vqClamps_TpulseDwn) );
TDownFall( in:=(Status=CL_FALLING), pt:=TO_UDINT(vqClamps_TfallDwn) );
TSettleDelay( in:=(Status=CL_SETTLE), pt:=SettleTime);
TUpDelay( in:=(Status=CL_RISING), pt:=TO_UDINT(vqClamps_Tup) );

CASE Status OF
    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_PRESS : (* Pressing down *)
        IF Cmd=CMD_STOP THEN
            dlog( Txt:='fbClampPneum %d: Rising', Lvl:=3, Val1:=TO_DINT(ID) );
            Status := CL_RISING;
        (* Follow commanded pressure *)
        (* ELSIF ClampPush<Push THEN
            (* Voglio diminuire la pressione, non attendo? In realtà ci mette un po' a scaricarsi! * )
            Push := ClampPush; *)
        ELSIF ClampPush<>Push THEN
            (* È cambiata la pressione, meglio tornare nello stato di stabilizzazione *)
            (* Il tempo di stabilizzazione dipende dal salto di pressione *)
            SettleTime := TO_UDINT(vqClamps_Tsettle + ((MAX(0,ClampPush-Push)/10) * (vqClamps_Latency/100))/1000); (* [mN] → [ms] *)
            (* dlog( Txt:='fbClampPneum %d: Settle %ld => %ld N = %ld s', Lvl:=7, Val1:=TO_DINT(ID), Val2:=Push/1E3, Val3:=ClampPush/1E3, Val4:=TO_DINT(SettleTime/1E3) ); *)
            Push := ClampPush;
            Status := CL_SETTLE;
        ELSE
            DownOutput := TRUE;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_SETTLE : (* Stabilizing pressure *)
        IF Cmd=CMD_STOP THEN
            (* dlog( Txt:='fbClampPneum %d: SETTLE: Abort', Lvl:=3, Val1:=TO_DINT(ID) ); *)
            Status := CL_RISING;
        ELSIF TSettleDelay.q THEN
            (* Settle time expired *)
            dlog( Txt:='fbClampPneum %d: Press (P=%ld N=%ld bar)', Lvl:=3, Val1:=TO_DINT(ID), Val2:=Push/1E3, Val3:=Pressure/1E3 );
            Status := CL_PRESS;
        ELSE
            DownOutput := TRUE;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_FALLING : (* Falling free *)
        IF Cmd=CMD_STOP THEN
            (* dlog( Txt:='fbClampPneum %d: FALLING: Abort', Lvl:=3, Val1:=TO_DINT(ID) ); *)
            Status := CL_RISING;
        ELSIF TDownFall.q OR vqClamps_TfallDwn<=0 THEN
            (* Calculate settle time basing on pressure jump
               Se devo impostare una pressione maggiore, aumento tempo di stabilizzazione in base a latenza *)
            SettleTime := TO_UDINT(vqClamps_Tsettle + ((MAX(0,ClampPush-Push)/10) * (vqClamps_Latency/100))/1000); (* [mN] → [ms] *)
            (* dlog( Txt:='fbClampPneum %d: Settle %ld => %ld N = %ld s', Lvl:=7, Val1:=TO_DINT(ID), Val2:=Push/1E3, Val3:=ClampPush/1E3, Val4:=TO_DINT(SettleTime/1E3) ); *)
            Push := ClampPush;
            Status := CL_SETTLE;
        ELSE
            DownOutput := TRUE;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_PULSEDOWN : (* First impulse to go down *)
        IF Cmd=CMD_STOP THEN
            (* dlog( Txt:='fbClampPneum %d: PULSEDOWN: Abort', Lvl:=3, Val1:=TO_DINT(ID) ); *)
            Status := CL_RISING;
        ELSIF TDownPulse.q THEN
            (* Initial impulse time expired *)
            IF vqClamps_TfallDwn > 0 THEN (* Ho anche fase di caduta libera *)
                (* Annullo la pressione sulla proporzionale solo se ho caduta libera *)
                Push := Weight;
            END_IF;
            Status := CL_FALLING;
        ELSE
            DownOutput := TRUE;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_RISING : (* Going up to idle position *)
        Push := -vqClamps_Pup;
        SelPv := TRUE; (* Salgo a pressione controllata *)
        DownOutput := FALSE;
        IF TUpDelay.q THEN
            (* dlog( Txt:='fbClampPneum %d: Up', Lvl:=3, Val1:=TO_DINT(ID) ); *)
            SelPv := FALSE; (* Usa la pressione di linea come ritenuta *)
            Status := STS_IDLE;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    STS_IDLE : (* Premilastra alto a riposo *)
        (* Mantengo sulla proporzionale la pressione di impulso discesa *)
        Push := vqClamps_PpulseDwn;
        IF Cmd<>CMD_STOP AND Cmd<>CMD_PARK THEN (* CLCMD_PRESS, CLCMD_HOLD, CLCMD_OPPOSE, CLCMD_CLOSE *)
            dlog( Txt:='fbClampPneum %d: Pulse down (P=%ld N=%ld bar)', Lvl:=3, Val1:=TO_DINT(ID), Val2:=Push/1E3, Val3:=Pressure/1E3 );
            SelPv := TRUE; (* Scendo a pressione controllata *)
            DownOutput := TRUE;
            Status := CL_PULSEDOWN;
        ELSE
            (* Mantengo la pressione di linea nelle camere di salita *)
            SelPv := FALSE;
            DownOutput := FALSE;
        END_IF;

END_CASE; (* --- Up/down sequences *)



(* -- Limite forza totale -- *)

(* -- Calcolo della pressione da dare alla proporzionale --
  Sul singolo cilindro c'è una forza:
  Fs[N] = P[bar] * A[mm²] / 10   (P[bar] = 10 * F[N] / A[mm²])
  Se n è il numero di cilindri e r è la trasmissione meccanica
  la forza totale è:
  Ftot[N] = n/r * Fs = n/r * 1/10 * P[bar] * A[mm²]
  E quindi la pressione da dare è:
  P[bar] = 10 * r/n * Ftot[N] / A[mm²]
  Che con i nostri valori in virgola fissa a tre decimali:
  P[mbar] = 1000 * (10 * R/1000 * 1/n * Ftot[mN]) / A[um mm]
  P[mbar] =  (R * 1/n * Ftot[mN]) / A[um mm]/10   *)
(* Push := LIMIT( Push, -vqClamps_PushMax, vqClamps_PushMax ); *)
IF Push > vqClamps_PushMax THEN
    dlog( Txt:='fbClampPneum %d: ! Limit P=%ld => %ld N', Lvl:=1, Val1:=TO_DINT(ID), Val2:=Push/1E3, Val3:=vqClamps_PushMax/1E3 );
    Push := vqClamps_PushMax;
(* ELSIF Push < -vqClamps_PushMax THEN (* Alquanto improbabile
    dlog( Txt:='fbClampPneum %d: ! Limit P=%ld => %ld N', Lvl:=1, Val1:=TO_DINT(ID), Val2:=Push/1E3, Val3:=-vqClamps_PushMax/1E3 );
    Push := -vqClamps_PushMax; *)
END_IF;

(* Calcolo la spinta netta che devono applicare i cilindri
   tenendo conto di peso e attriti
      .'Push' ha segno: positivo verso il basso
      .Il peso concorre verso il basso, quindi si toglie per avere la spinta netta
      .L'attrito è sempre opposto, quindi si "aggiunge" sempre *)
IF Push>0 THEN
    (* I cilindri addizionali sono attivi se 'TopCyl' e 'Push>Weight' *)
    Ncyl := TO_DINT( SEL((TopCyl AND Push>Weight), vnClamps_NumBcyl, vnClamps_NumCyl) );
    (* In realtà dovrei guardare 'DownOutput' *)

    (* Voglio spingere verso il basso: Il peso mi aiuta, attriti si oppongono *)
    Pressure := (vqClamps_MechRatio * ((Push - Weight + (Ncyl*Fr)) / (vqClamps_CylArea/100))) / (10*Ncyl); (* DANGER_DIVISION_BY_ZERO *)
    (* Se la pressione è negativa devo convogliarla nelle camere di salita *)
    IF Pressure<0 THEN
        Pressure := -Pressure;
        DownOutput := FALSE;
    END_IF;
ELSE
    (* I cilindri addizionali sono sempre attivi *)
    Ncyl := TO_DINT(vnClamps_NumCyl);

    (* Voglio spingere verso l'alto: Il peso si oppone insieme agli attriti *)
    Pressure := (vqClamps_MechRatio * ((Push - Weight - (Ncyl*Fr)) / (vqClamps_CylArea/100))) / (10*Ncyl); (* DANGER_DIVISION_BY_ZERO *)
    (* Qui la pressione è sicuramente negativa, cambio subito segno e forzo salita *)
    Pressure := -Pressure;
    DownOutput := FALSE;
END_IF;


(* Un vincolo importante è che non devo MAI scendere a pressione di linea!
Comunque qui è sempre rispettato, meglio implementarlo direttamente sulle uscite
IF DownOutput AND NOT SelPv THEN
    DownOutput := FALSE;
    Status := CL_RISING;
    dlog( Txt:='fbClampPneum %d: !! Descend with line press', Lvl:=1, Val1:=TO_DINT(ID) );
END_IF; *)

(* Segnale per anticipare il proseguimento delle sequenze *)
TAlmostUp( in:=Status<=CL_RISING, pt:=TO_UDINT(vqClamps_TalmostUp) );
AlmostUp := TAlmostUp.q;

AtRest := Status=STS_IDLE AND Cmd=CMD_STOP;

(* -- Monitors -- *)
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbClampMotAlgn

{ DE:"Premilastra motorizzato riscontro" }

	VAR_INPUT
	ClampPush : DINT; { DE:"Forza richiesta quando giù [mN]" }
	Weight : DINT; { DE:"Peso premilastra [mN]" }
	Hglass : DINT; { DE:"Altezza vetro [um]" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del premilastra" }
	Hrest : DINT; { DE:"Posizione di riposo [um]" }
	StrictHrest : BOOL; { DE:"Rispetta strettamente l'altezza indicata anche abbassandosi" }
	NoGlassOnRubber : BOOL; { DE:"Vetro stretto, non arriva alla sporgenza in gomma posteriore" }
	AtRest : BOOL; { DE:"Premilastra alto e a riposo" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	StepSeq : fbStepSeq; { DE:"Sequenza del passo di lavorazione" }
	vbShapeMode : BOOL; { DE:"Macchina in modalità sagomato curvilineo" }
	vbSlantMode : BOOL; { DE:"Macchina in modalità taglio fuori squadra" }
	vnProcPhase : INT; { DE:"Fase corrente della sequenza di processazione/taglio" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	Pr : fbM32Axis; { DE:"Motore primario premilastra motorizzato lato riscontro AX_PR" }
	Pr2 : fbM32Gantry; { DE:"Motore aggiuntivo premilastra motorizzato lato riscontro AX_PR2" }
	vqClamps_Htol : DINT; { DE:"Tolleranza posizione per deformabilità, planarità e spessore vetro [um]" }
	vqClamps_DHhold : DINT; { DE:"Distanza dal vetro per tenuta [um]" }
	vqClamps_DHbrk : DINT; { DE:"Distanza dal vetro per apertura con barra [um]" }
	vqClamps_DHbrk_more : DINT; { DE:"Distanza dal vetro per apertura con barra vetro stretto [um]" }
	vqClamps_Xrubber : DINT; { DE:"Soglia larghezza vetro stretto (vetro su gomma) [um]" }
	vqClamps_SettleTime : DINT; { DE:"Tempo stabilizzazione spinta premilastra [ms]" }
	vqPx_PressMinTrq : DINT; { DE:"Limite coppia minimo durante pressione su vetro [0.1%]" }
	vqPx_PressMaxTrq : DINT; { DE:"Limite coppia durante pressione su vetro [0.1%]" }
	vqPx_GantryMaxErr : DINT; { DE:"Massimo scostamento ammesso tra i motori [um]" }
	vnClampAlgn_Cmd : INT; { DE:"Comando premilastra lato riscontri" }
	vbClamps_HomeRest : BOOL; { DE:"Stai in home quando non si taglia" }
	vqClamps_Hover : DINT; { DE:"Altezza posizione di riposo rispetto il vetro [um]" }
	Xr : fbM32Axis; { DE:"Asse riscontri AX_XR" }
	Algn : fbAlgn; { DE:"Servizi riscontro vetro" }
	vqAlgnBlks_H : DINT; { DE:"Altezza piedini su rispetto il piano [um]" }
	vqX_ClampAlgnP : DINT; { DE:"Ascissa fine premilastra riscontri [um]" }
	vqProd_Width : DINT; { DE:"Dimensione longitudinale prodotto del taglio [um]" }
	vqClamps_Hsafe : DINT; { DE:"Altezza sicura per collisione carrsup/pinza alta [um]" }
	Grabber : fbGrabber; { DE:"Pinza girapezzi su carrello inferiore" }
	END_VAR

	VAR
	MoveTo : EN_AXIS_MV_CMD := MV_DONE; { DE:"Servizio movimentazione asse" }
	Htgt : DINT; { DE:"Quota obiettivo [um]" }
	F_lim_reached : fbDebounce; { DE:"Sto erogando la forza desiderata" }
	CmdBuf : INT; { DE:"Ricorda comando impartito" }
	Wait : BOOL; { DE:"Condizione esecuzione comando" }
	END_VAR

	{ CODE:ST }(*    fbClampMotAlgn (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Vedi descrizione in CLAMPMOT_SEQ

      DETAILS
      ----------------------------------------------
      Il carrello superiore (e i suoi utensili) sono
      solidali ad esso, quindi la sua posizione è
      importantissima!
*)

NoGlassOnRubber := vqProd_Width<vqClamps_Xrubber;
(* Durante il taglio voglio rispettare strettamente Hrest (anche abbassandomi) *)
StrictHrest := StepSeq.ProcSeq.Status>TS_GOINGOFF OR vbShapeMode OR vbSlantMode OR vnProcPhase<>0;

(* Prima di eseguire un nuovo comando attendi pinza chiusa *)
Wait := Grabber.Status<>GSTS_CLOSED;

(* La posizione di riposo del premilastra deve assicurare una certa
   distanza dal vetro per non interferire sulle movimentazioni con le cinghie *)
Hrest := SEL(vbClamps_HomeRest AND StepSeq.AtRest AND NOT StrictHrest, vqClamps_Hover+Hglass, Pr.HomePos);

(* Il premilastra lato riscontro deve inoltre
   assicurare di non collidere con i piedini di riscontro... *)
IF Xr.StopPos<vqX_ClampAlgnP OR (Algn.Blocks.ForeUp AND Xr.TgtPos<vqX_ClampAlgnP) THEN
    (* vnClampAlgn_Cmd := CMD_STOP; *)
    Hrest := MAX(Hrest, vqAlgnBlks_H);
END_IF;

(* ...E prevenire collisioni tra carrello superiore e pinza aperta *)
IF Grabber.Status<>GSTS_CLOSED THEN
    IF vnClampAlgn_Cmd>CMD_PARK THEN (* Status>CL_RISING *)
        dlog( Txt:='fbClampMotAlgn: ! Rising for Grabber (%d)', Lvl:=4, Val1:=TO_DINT(Grabber.Status) );
        vnClampAlgn_Cmd := CMD_STOP;
    END_IF;
    Hrest := MAX(Hrest, vqClamps_Hsafe);
END_IF;

CLAMPMOT_SEQ('fbClampMotAlgn',vnClampAlgn_Cmd,Pr,Pr2);

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbClampMotDtch

{ DE:"Premilastra motorizzato stacco" }

	VAR_INPUT
	ClampPush : DINT; { DE:"Forza richiesta quando giù [mN]" }
	Weight : DINT; { DE:"Peso premilastra [mN]" }
	Hglass : DINT; { DE:"Altezza vetro [um]" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del premilastra" }
	Hrest : DINT; { DE:"Posizione di riposo [um]" }
	StrictHrest : BOOL; { DE:"Rispetta strettamente l'altezza indicata anche abbassandosi" }
	NoGlassOnRubber : BOOL; { DE:"Vetro stretto, non arriva alla sporgenza in gomma posteriore" }
	AtRest : BOOL; { DE:"Premilastra alto e a riposo" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	StepSeq : fbStepSeq; { DE:"Sequenza del passo di lavorazione" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	Ps : fbM32Axis; { DE:"Motore primario premilastra motorizzato lato stacco AX_PS" }
	Ps2 : fbM32Gantry; { DE:"Motore aggiuntivo premilastra motorizzato lato stacco AX_PS2" }
	vqClamps_Htol : DINT; { DE:"Tolleranza posizione per deformabilità, planarità e spessore vetro [um]" }
	vqClamps_DHhold : DINT; { DE:"Distanza dal vetro per tenuta [um]" }
	vqClamps_DHbrk : DINT; { DE:"Distanza dal vetro per apertura con barra [um]" }
	vqClamps_DHbrk_more : DINT; { DE:"Distanza dal vetro per apertura con barra vetro stretto [um]" }
	vqClamps_Xrubber : DINT; { DE:"Soglia larghezza vetro stretto (vetro su gomma) [um]" }
	vqClamps_SettleTime : DINT; { DE:"Tempo stabilizzazione spinta premilastra [ms]" }
	vqPx_PressMinTrq : DINT; { DE:"Limite coppia minimo durante pressione su vetro [0.1%]" }
	vqPx_PressMaxTrq : DINT; { DE:"Limite coppia durante pressione su vetro [0.1%]" }
	vqPx_GantryMaxErr : DINT; { DE:"Massimo scostamento ammesso tra i motori [um]" }
	vnClampDtch_Cmd : INT; { DE:"Comando premilastra lato stacco" }
	vbClamps_HomeRest : BOOL; { DE:"Stai in home quando non si taglia" }
	vqClamps_Hover : DINT; { DE:"Altezza posizione di riposo rispetto il vetro [um]" }
	vqRemn_Width : DINT; { DE:"Larghezza vetro lato stacco [um]" }
	END_VAR

	VAR
	MoveTo : EN_AXIS_MV_CMD := MV_DONE; { DE:"Servizio movimentazione asse" }
	Htgt : DINT; { DE:"Quota obiettivo [um]" }
	F_lim_reached : fbDebounce; { DE:"Sto erogando la forza desiderata" }
	CmdBuf : INT; { DE:"Ricorda comando impartito" }
	Wait : BOOL := FALSE; { DE:"Condizione esecuzione comando" }
	END_VAR

	{ CODE:ST }(*    fbClampMotDtch (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Vedi descrizione in CLAMPMOT_SEQ
*)
NoGlassOnRubber := vqRemn_Width<vqClamps_Xrubber; (* È un'approssimazione! Dovrei considerare vqDtch_CurrX *)
(* Durante il taglio voglio rispettare strettamente Hrest (anche abbassandomi) *)
StrictHrest := StepSeq.ProcSeq.Status>TS_GOINGOFF;
(* La posizione di riposo del premilastra deve assicurare una certa
   distanza dal vetro per non interferire sulle movimentazioni con le cinghie *)
Hrest := SEL(vbClamps_HomeRest AND StepSeq.AtRest AND NOT StrictHrest, vqClamps_Hover+Hglass, Ps.HomePos);

CLAMPMOT_SEQ('fbClampMotDtch',vnClampDtch_Cmd,Ps,Ps2);

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbClampAlgn

{ DE:"Servizio generico premilastra lato riscontro" }

	VAR_IN_OUT
	Pneum : fbClampPneum; { DE:"Attuazione premilastra pneumatico" }
	Mot : fbClampMotAlgn; { DE:"Premilastra motorizzato lato riscontri" }
	END_VAR

	VAR_INPUT
	Emulated : BOOL; { DE:"Emula l'azione" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Hglass : DINT; { DE:"Altezza vetro [um]" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del premilastra" }
	AtRest : BOOL; { DE:"Premilastra alto e a riposo" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	vnClampAlgn_Type : INT; { DE:"Tipo premilastra riscontro (0:none 1:pneum 2:mot)" }
	vbHomingDone : BOOL; { DE:"Homing successfully executed" }
	vqClamps_PushMax : DINT; { DE:"Spinta massima ammessa dei premilastra [mN]" }
	vqClampAlgn_Weight : DINT; { DE:"Peso premilastra lato riscontri [mN]" }
	vqClampAlgn_CylFr : DINT; { DE:"Forza resistente statica cilindri premilastra lato riscontri [mN]" }
	vqY_TopEdge : DINT; { DE:"Quota misurata bordo vetro alto [um]" }
	vqClamps_Y_TopCyl : DINT; { DE:"Ordinata limite uso secondo gruppo di cilindri [um]" }
	vnClampAlgn_Cmd : INT; { DE:"Comando premilastra lato riscontri (v.'CLCMD_PRESS',...)" }
	vqClampAlgn_P : DINT; { DE:"Spinta desiderata premilastra lato riscontri [mN]" }
	vbClampAlgn_AlmostUp : BOOL; { DE:"Segnale per anticipo attesa premilastra alto" }
	O_CLAMP_ALGN_SELP : BOOL; { DE:"Seleziona pressione premilastra lato riscontri (0:linea, 1:propvalv)" }
	O_CLAMP_ALGN : BOOL; { DE:"Aziona premilastra lato riscontri (0:up, 1:down)" }
	O_CLAMP_ALGN_TCYL : BOOL; { DE:"Aziona cilindri addizionali zona alta dei premilastra riscontri" }
	END_VAR

	{ CODE:ST }(*    fbClampAlgn (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Premilastra lato riscontro

      DETAILS
      ----------------------------------------------
      Può essere pneumatico o motorizzato.
      Se motorizzato il carrello superiore (e i suoi
      utensili) sono solidali ad esso!
*)
    (* -- Premilastra pneumatico -- *)
    IF vnClampAlgn_Type=1 THEN
        IF vnClampAlgn_Cmd=CMD_PARK THEN vnClampAlgn_Cmd:=CMD_STOP; END_IF; (* Hook park command *)
        Pneum( ID := ID_CLAMP_ALGN,
               Cmd := vnClampAlgn_Cmd,
               ClampPush := vqClampAlgn_P, (* Vedi: vqClamps_PushMax *)
               TopCyl := (vqY_TopEdge >= vqClamps_Y_TopCyl),
               Weight := vqClampAlgn_Weight,
               Fr := vqClampAlgn_CylFr );
        O_CLAMP_ALGN_SELP := Pneum.SelPv;
        O_CLAMP_ALGN := Pneum.DownOutput AND Allow AND NOT Emulated;
        O_CLAMP_ALGN_TCYL := Pneum.TopCyl;
        vbClampAlgn_AlmostUp := Pneum.AlmostUp;

        Status := Pneum.Status;
        AtRest := Pneum.AtRest;

    (* -- Premilastra motorizzato -- *)
    ELSIF vnClampAlgn_Type=2 THEN
        IF vbHomingDone THEN
            Mot( ClampPush := vqClampAlgn_P, (* Vedi 'vqPr_MaxForce' *)
                 Weight := vq[ivqAx_Inertia+AX_PR-1],
                 Hglass := Hglass );
            vbClampAlgn_AlmostUp := Mot.AtRest;
            Status := Mot.Status;
            AtRest := Mot.AtRest;
        ELSE (* Macchina non ancora azzerata *)
            vbClampAlgn_AlmostUp := FALSE;
            Status := CL_FALLING;
            AtRest := FALSE; (* Non so dove siano! *)
        END_IF;
    END_IF;


(* -- Monitors -- *)
vn[ivnStatus+ID_CLAMP_ALGN] := Status;
vb[ivbAtRest+ID_CLAMP_ALGN] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbClampDtch

{ DE:"Servizio generico premilastra lato stacco" }

	VAR_IN_OUT
	Pneum : fbClampPneum; { DE:"Attuazione premilastra pneumatico" }
	Mot : fbClampMotDtch; { DE:"Premilastra motorizzato lato stacco" }
	END_VAR

	VAR_INPUT
	Emulated : BOOL; { DE:"Emula l'azione" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Hglass : DINT; { DE:"Altezza vetro [um]" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del premilastra" }
	AtRest : BOOL; { DE:"Premilastra abbastanza alto per cinghie e piedini riscontro" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	vnClampDtch_Type : INT; { DE:"Tipo premilastra stacco (0:none 1:pneum 2:mot)" }
	vbHomingDone : BOOL; { DE:"Homing successfully executed" }
	vqClamps_PushMax : DINT; { DE:"Spinta massima ammessa dei premilastra [mN]" }
	vqClampDtch_Weight : DINT; { DE:"Peso premilastra lato stacco [mN]" }
	vqClampDtch_CylFr : DINT; { DE:"Forza resistente statica cilindri premilastra lato stacco [mN]" }
	vqY_TopEdge : DINT; { DE:"Quota misurata bordo vetro alto [um]" }
	vqClamps_Y_TopCyl : DINT; { DE:"Ordinata limite uso secondo gruppo di cilindri [um]" }
	vnClampDtch_Cmd : INT; { DE:"Comando premilastra lato stacco (v.'CLCMD_PRESS',...)" }
	vqClampDtch_P : DINT; { DE:"Spinta desiderata premilastra lato stacco [mN]" }
	vbClampDtch_AlmostUp : BOOL; { DE:"Segnale per anticipo attesa premilastra alto" }
	O_CLAMP_DTCH_SELP : BOOL; { DE:"Seleziona pressione premilastra lato stacco (0:linea, 1:propvalv)" }
	O_CLAMP_DTCH : BOOL; { DE:"Aziona premilastra lato stacco (0:up, 1:down)" }
	O_CLAMP_DTCH_TCYL : BOOL; { DE:"Aziona cilindri addizionali zona alta dei premilastra stacco" }
	END_VAR

	{ CODE:ST }(*    fbClampDtch (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Premilastra lato stacco

      DETAILS
      ----------------------------------------------
      Può essere pneumatico o motorizzato
*)
    (* -- Premilastra pneumatico -- *)
    IF vnClampDtch_Type=1 THEN
        IF vnClampDtch_Cmd=CMD_PARK THEN vnClampDtch_Cmd:=CMD_STOP; END_IF; (* Hook park command *)
        Pneum( ID := ID_CLAMP_DTCH,
               Cmd := vnClampDtch_Cmd,
               ClampPush := vqClampDtch_P, (* Vedi: vqClamps_PushMax *)
               TopCyl := (vqY_TopEdge >= vqClamps_Y_TopCyl),
               Weight := vqClampDtch_Weight,
               Fr := vqClampDtch_CylFr );
        O_CLAMP_DTCH_SELP := Pneum.SelPv;
        O_CLAMP_DTCH := Pneum.DownOutput AND Allow AND NOT Emulated;
        O_CLAMP_DTCH_TCYL := Pneum.TopCyl;
        vbClampDtch_AlmostUp := Pneum.AlmostUp;

        Status := Pneum.Status;
        AtRest := Pneum.AtRest;

    (* -- Premilastra motorizzato -- *)
    ELSIF vnClampDtch_Type=2 THEN
        IF vbHomingDone THEN
            Mot( ClampPush := vqClampDtch_P, (* Vedi 'vqPs_MaxForce' *)
                 Weight := vq[ivqAx_Inertia+AX_PS-1],
                 Hglass := Hglass );
            vbClampDtch_AlmostUp := Mot.AtRest;
            Status := Mot.Status;
            AtRest := Mot.AtRest;
        ELSE (* Macchina non ancora azzerata *)
            vbClampDtch_AlmostUp := FALSE;
            Status := CL_FALLING;
            AtRest := FALSE; (* Non so dove siano! *)
        END_IF;
    END_IF;



(* -- Monitors -- *)
vn[ivnStatus+ID_CLAMP_DTCH] := Status;
vb[ivbAtRest+ID_CLAMP_DTCH] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbTscore

{ DE:"Testina di incisione" }

	VAR_INPUT
	ID : INT; { DE:"Identificativo componente" }
	Emulated : BOOL; { DE:"Non accostare sul vetro" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Wait : BOOL := FALSE; { DE:"Condizione da attendere prima di attivazione" }
	Cmd : BOOL; { DE:"Comando attivazione" }
	ScorePush : DINT; { DE:"Spinta durante incisione [mN]" }
	ApproachPush : DINT; { DE:"Spinta accostamento [mN]" }
	CurrSpd : DINT; { DE:"Velocità carrello [um/min]" }
	CurrDelta : DINT; { DE:"Distanza dall'arrivo del carrello [um]" }
	Weight : DINT := 0; { DE:"Peso attuatore [mN]" }
	Fr : DINT := 0; { DE:"Forza resistente statica attuatore [mN]" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato dell'utensile" }
	AtRest : BOOL; { DE:"Utensile a riposo" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	Output : BOOL; { DE:"Aziona uscita utensile" }
	LubOutput : BOOL; { DE:"Aziona uscita lubrificazione incisione" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vqTscore_CylArea : DINT; { DE:"Area cilindro attuatore pneumatico testine di incisione [um mm]" }
	vqTscore_Latency : DINT; { DE:"Latenza attuatore pneumatico testine di incisione [us/N]" }
	vqTscore_PushMax : DINT; { DE:"Spinta massima attuatore testine di incisione [mN]" }
	vqTscore_UpPush : DINT; { DE:"Forza di salita/ritenuta testine di incisione [mN]" }
	vnTscore_SettlePush : INT; { DE:"Modulazione spinta iniziale testine di incisione [%]" }
	vqTscore_Tapprch : DINT; { DE:"Tempo accostamento al vetro testine di incisione [ms]" }
	vqTscore_Tsettle : DINT; { DE:"Tempo minimo assestamento pressione testine di incisione [ms]" }
	vqTscore_Tleave : DINT; { DE:"Tempo attesa allontanamento testine di incisione [ms]" }
	vbBtnLubPulse : BOOL; { DE:"Comando impulso lubrificazione testine di incisione" }
	vqTscore_LubPulse : DINT; { DE:"Impulso lubrificazione testine di incisione [ms]" }
	vqTscore_LubOffDist : DINT; { DE:"Anticipo spegnimento lubrificazione incisione [um]" }
	vqTscore_LubMinSpd : DINT; { DE:"Velocità minima lubrificazione incisione [um/min]" }
	END_VAR

	VAR
	TApprchDelay : Ton; { DE:"Timer accostamento utensile al vetro" }
	TSettleDelay : Ton; { DE:"Timer per stabilizzazione pressione di lavoro" }
	TLeaveDelay : Ton; { DE:"Timer per attesa allontanamento utensile" }
	SettleTime : UDINT; { DE:"Tempo stabilizzazione pressione di lavoro" }
	SettlePush : DINT; { DE:"Initial pushing force [mN]" }
	Push : DINT; { DE:"Current pushing force [mN]" }
	END_VAR

	{ CODE:ST }(*    fbTscore (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa l'attuazione di una testina di
      incisione.

      DETAILS
      ----------------------------------------------
      Sia alla camera di discesa che a quella di
      salita del cilindro arriva la pressione della
      proporzionale, quindi va gestita la pressione
      di salita/ritenuta.

      USAGE
      ----------------------------------------------
      Tinf : fbTscore; { DE:"Testina incisione inferiore" }
      Tinf(ID:=ID_TINF, ApproachPush:=vqTinf_Papprch, ScorePush:=vqF_score_inf, Weight:=vqTinf_Weight);
      O_TINF := Tinf.Output;
*)


(* Uscita lubrificazione taglio *)
LubOutput := Output AND Status=TS_GOINGON; (* Un colpetto alla lubrificazione mentre scende *)


(* -- Up/down sequence -- *)
TApprchDelay( in:=(Status=TS_GOINGON), pt:=TO_UDINT(vqTscore_Tapprch) );
TSettleDelay( in:=(Status=TS_WAITON), pt:=SettleTime);
TLeaveDelay( in:=(Status=TS_GOINGOFF), pt:=TO_UDINT(vqTscore_Tleave) );
CASE Status OF

    TS_ON : (* Tool pressing on glass *)
        (* Modulazione della pressione (0:plain 1:no-Po 2:speed 3:pos) *)
        Push := ScorePush;

        IF NOT Cmd OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbTscore %d: !! ON: Aborted', Lvl:=3, Val1:=TO_DINT(ID) ); END_IF; *)
            Status := TS_GOINGOFF;
        ELSE
            (* Lubrificazione durante taglio *)
            LubOutput := Output (* Sta incidendo *)
                         AND (ABS(CurrSpd)>=vqTscore_LubMinSpd) (* oltre soglia velocità *)
                         (* AND NOT Decelerating (* Non in decelerazione *)
                         AND (ABS(CurrDelta) > vqTscore_LubOffDist); (* anticipo off *)
            (* Modulazione della lubrificazione
            PwmLub : fbPwmControl; { DE:"Pulsed modulation of lub valve" }
            PwmLub.t := PwmLub.T; (* synch start
            PwmLub( in:=Mach.Axes.SpeedXY, dt:=vdPlcScanTime, T:=2 );
            *)
        END_IF;


    TS_WAITON : (* Stabilizing pressure *)
        IF NOT Cmd OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbTscore %d: !! WAITON: Aborted', Lvl:=3, Val1:=TO_DINT(ID) ); END_IF; *)
            Status := TS_GOINGOFF;
        ELSIF TSettleDelay.q THEN
            (* Settle time expired *)
            Push := ScorePush;
            dlog( Txt:='fbTscore %d: Down, P=%ld N', Lvl:=5, Val1:=TO_DINT(ID), Val2:=Push/1E3 );
            Status := TS_ON;
            (* Could do here the depth measure *)
        END_IF;


    TS_GOINGON : (* Tool approaching glass *)
        IF NOT Cmd OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbTscore %d: !! GOINGON: Aborted', Lvl:=3, Val1:=TO_DINT(ID) ); END_IF; *)
            Status := TS_GOINGOFF;
        ELSIF TApprchDelay.q THEN (* AND is_down *)
            (* Approaching time expired *)
            (* Calculate initial pressure force *)
            SettlePush := (TO_DINT(vnTscore_SettlePush) * ScorePush) / 100;
            (* Calculate settle time basing on pressure jump *)
            SettleTime := TO_UDINT( vqTscore_Tsettle + ((ABS(SettlePush-Push)/10) * (vqTscore_Latency/100))/1000 ) ; (* [mN] → [ms] *)
            (* es. (20000 mN * 10 ms/N) / 1000 = 200 ms *)
            (* dlog( Txt:='fbTscore %d: Psettle=%ld N Tsettle=%ld ms', Lvl:=7, Val1:=TO_DINT(ID), Val2:=SettlePush/1E3, Val3:=TO_DINT(SettleTime)); *)
            Push := SettlePush;
            Status := TS_WAITON; (* proceed *)
        END_IF;


    TS_GOINGOFF : (* Tool leaving glass *)
        (* Se sale con la proporzionale *)
        Push := -vqTscore_UpPush; (* Spinta di salita *)
        IF TLeaveDelay.q THEN (* AND is_up *)
            (* Leave time expired *)
            Status := TS_OFF;
        END_IF;


    TS_OFF : (* Tool at rest *)
        (* mantengo la pressione della prossima discesa
        Push := SEL( vqTscore_Tapprch>0, ScorePush, ApproachPush ); *)
        IF Cmd AND NOT Wait THEN
            Push := SEL( vqTscore_Tapprch>0, ScorePush, ApproachPush ); (* Spinta di discesa *)
            Status := TS_GOINGON;
        ELSE
            Push := -vqTscore_UpPush; (* Spinta di ritenuta *)
        END_IF;

END_CASE; (* --- Up/down sequence *)

(* -- Calcolo della pressione da dare alla proporzionale --
  Conversione da forza a pressione in base all'area cilindro
  P[bar] = (10 * F[N]) / A[mm²]
  Uso interi a virgola fissa 3 decimali
  Per evitare overflow scarto qualche decimale  (2^31-1)=2147483647
      P = (10000 * Push) / vqTscore_CylArea      Push max = 214N
      P = (1000 * Push) / (vqTscore_CylArea/10)  Push max = 2147N
      P = (100 * Push) / (vqTscore_CylArea/100)  Push max = 21474N
      P = (10 * Push) / (vqTscore_CylArea/1000)  Push max = 214748N *)
(* Verifica limite spinta *)
IF Push > vqTscore_PushMax THEN
    dlog( Txt:='fbTscore %d: ! Limit F=%ld => %ld N', Lvl:=1, Val1:=TO_DINT(ID), Val2:=Push/1E3, Val3:=vqTscore_PushMax/1E3 );
    Push := vqTscore_PushMax;
END_IF;
(* Qui il peso è positivo se concorde, ossia per utensili superiori; l'attrito è sempre opposto *)
Pressure := (100 * (Push-Weight + Fr) ) / (vqTscore_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)

(* Uscita attuazione cilindro *)
Output := Status>=TS_GOINGON AND Cmd AND Allow AND NOT Emulated;

(* Supporto pressione di salita data dalla proporzionale *)
IF NOT Output THEN
    Pressure := P_TOOLUP;
ELSIF Pressure<0 THEN
    (* Se la pressione è negativa devo salire *)
    Pressure := -Pressure; (* Dovrei riapplicare peso e attriti cambiando segno *)
    Output := FALSE;
END_IF;


(* -- Monitors -- *)
AtRest := Status=TS_OFF AND NOT Output;
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbRbrk

{ DE:"Rotella di apertura" }

	VAR_INPUT
	ID : INT; { DE:"Identificativo componente" }
	Emulated : BOOL; { DE:"Non accostare sul vetro" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Wait : BOOL := FALSE; { DE:"Condizione da attendere prima di attivazione" }
	Cmd : BOOL; { DE:"Comando attivazione" }
	SelC : BOOL; { DE:"Seleziona contro-rotella" }
	SynchPush : BOOL; { DE:"Meccanismo per spingere nello stesso istante della contro-rotella" }
	OppDoubled : BOOL; { DE:"La rotella antagonista ha selezionato la doppia camera" }
	BrkPush : DINT; { DE:"Spinta durante apertura [N]" }
	ApproachPush : DINT; { DE:"Spinta accostamento [mN]" }
	Weight : DINT; { DE:"Peso attuatore [N]" }
	Fr : DINT; { DE:"Forza resistente statica attuatore [mN]" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato utensile" }
	AtRest : BOOL; { DE:"Utensile a riposo" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	Output : BOOL; { DE:"Aziona uscita utensile" }
	Output_SelC : BOOL; { DE:"Pilotaggio uscita selezione contro-rotella" }
	DoublePush : BOOL; { DE:"Raddoppia spinta mediante seconda camera cilindro" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vqRbrk_DblPressLim : DINT; { DE:"Soglia pressione uso doppia camera [bar]" }
	vqRbrk_CylArea : DINT; { DE:"Area cilindro attuatore pneumatico rotelle di apertura [um mm]" }
	vqRbrk_Latency : DINT; { DE:"Latenza attuatore pneumatico rotelle di apertura [us/N]" }
	vqRbrk_SelTime : DINT; { DE:"Tempo scambio contro-rotella [ms]" }
	vqRbrk_PushMax : DINT; { DE:"Spinta massima rotelle di apertura [mN]" }
	vqRbrk_UpPush : DINT; { DE:"Forza di salita/ritenuta rotelle di apertura [mN]" }
	vqRbrk_Tapprch : DINT; { DE:"Tempo accostamento al vetro rotelle di apertura [ms]" }
	vqRbrk_Tsettle : DINT; { DE:"Tempo minimo assestamento pressione rotelle di apertura [ms]" }
	vqRbrk_Tleave : DINT; { DE:"Tempo attesa allontanamento rotelle di apertura [ms]" }
	END_VAR

	VAR
	TApprchDelay : Ton; { DE:"Timer accostamento utensile al vetro" }
	TSettleDelay : Ton; { DE:"Timer per stabilizzazione pressione di lavoro" }
	TLeaveDelay : Ton; { DE:"Timer per attesa allontanamento utensile" }
	SettleTime : UDINT; { DE:"Tempo stabilizzazione pressione di lavoro" }
	Push : DINT; { DE:"Current pushing force [mN]" }
	TChangingTool : Tmono; { DE:"Timer commutazione utensile" }
	END_VAR

	{ CODE:ST }(*    fbRbrk (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa le logiche riguardanti le rotelle
      di apertura.
      La rotella sul carrello superiore viene usata
      per aprire lo strato sotto da sola nel ciclo
      normale o in congiunzione con la controrotella
      sul carrello inferiore nel ciclo di apertura
      rifilo.
      La rotella sul carrello inferiore viene usata
      per aprire lo strato sopra al posto della barra
      di troncaggio nel ciclo di apertura rifilo, in
      congiunzione con la controrotella sul carrello
      superiore.

      DETAILS
      ----------------------------------------------
      I cilindri sono dotati di doppia camera, una
      uscita 'O_*_DBL' convoglia la pressione nella
      seconda camera raddoppiando la forza a parità
      di pressione; non va usata quando si sale!
      Sia alla camera di discesa che a quella di
      salita del cilindro arriva la pressione della
      proporzionale, quindi va gestita la pressione
      di salita/ritenuta.
      Su alcune macchine la proporzionale potrebbe
      essere condivisa con la mola, quindi criticità
      sulla pressione di ritenuta quando scende la
      mola!

      USAGE
      ----------------------------------------------
      Rinf : fbRbrk; { DE:"Rotella di apertura inferiore" }
      Rinf(ID:=ID_RINF);
*)

TApprchDelay( in:=Status=TS_GOINGON AND NOT TChangingTool.q, pt:=TO_UDINT(vqRbrk_Tapprch) );
TSettleDelay( in:=Status=TS_WAITON, pt:=SettleTime);
TLeaveDelay( in:=Status=TS_GOINGOFF, pt:=TO_UDINT(vqRbrk_Tleave) );

CASE Status OF

    TS_ON : (* Tool pressing on glass *)
        Push := BrkPush;
        IF NOT Cmd OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbRbrk %d: !! ON: Aborted', Lvl:=3, Val1:=TO_DINT(ID) ); END_IF; *)
            Status := TS_GOINGOFF;
        (* Rileva commutazione rotella/controrotella mentre basso *)
        ELSIF TChangingTool.q THEN
            Push := 0; (* Scarico la pressione *)
            Status := TS_GOINGON; (* Attendo scambio *)
        END_IF;


    TS_WAITON : (* Stabilizing pressure *)
        IF NOT Cmd OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbRbrk %d: !! WAITON: Aborted', Lvl:=5, Val1:=TO_DINT(ID) ); END_IF; *)
            Status := TS_GOINGOFF;
        ELSIF TSettleDelay.q THEN (* Settle time expired *)
            Push := BrkPush;
            dlog( Txt:='fbRbrk %d: Down, P=%ld N', Lvl:=5, Val1:=TO_DINT(ID), Val2:=Push/1E3 );
            Status := TS_ON;
            (* Could do here the depth measure *)
        END_IF;


    TS_GOINGON : (* Tool approaching glass *)
        IF NOT Cmd OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbRbrk %d: !! GOINGON: Aborted', Lvl:=5, Val1:=TO_DINT(ID) ); END_IF; *)
            Status := TS_GOINGOFF;
        ELSIF TApprchDelay.q AND SynchPush THEN (* AND is_down *)
            (* Approaching time expired *)
            (* Calculate settle time basing on pressure jump *)
            SettleTime := TO_UDINT( vqRbrk_Tsettle + ((ABS(BrkPush-Push)/10) * (vqRbrk_Latency/100))/1000 ) ; (* [mN] → [ms] *)
            (* es. (20000 mN * 10 ms/N) / 1000 = 200 ms *)
            Push := BrkPush;
            (* dlog( Txt:='fbRbrk %d: Psettle=%ld N Tsettle=%ld ms', Lvl:=7, Val1:=TO_DINT(ID), Val2:=Push/1E3, Val3:=TO_DINT(SettleTime)); *)
            Status := TS_WAITON; (* proceed *)
        END_IF;


    TS_GOINGOFF : (* Tool leaving glass *)
        (* Se sale con la propozionale *)
        Push := -vqRbrk_UpPush; (* Spinta di salita *)
        (* Nota: per salire non si usa la pressione della proporzionale *)
        IF TLeaveDelay.q THEN (* AND is_up *)
            (* Leave time expired *)
            Status := TS_OFF;
        END_IF;


    TS_OFF : (* Tool at rest *)
        (* Mantengo la pressione della prossima discesa
        Push := ApproachPush; *)
        IF Cmd AND SynchPush AND NOT TChangingTool.q AND NOT Wait THEN
            Push := ApproachPush; (* Spinta di discesa *)
            Status := TS_GOINGON;
        ELSE
            Push := -vqRbrk_UpPush; (* Spinta di ritenuta *)
        END_IF;

END_CASE; (* --- Up/down sequences *)





(* -- Calcolo della pressione da dare alla proporzionale --
  Conversione da forza a pressione in base all'area cilindro
  P[bar] = (10 * F[N]) / A[mm²]
  Uso interi a virgola fissa 3 decimali
  Per evitare overflow scarto qualche decimale  (2^31-1)=2147483647
      P = (10000 * Push) / vqRbrk_CylArea      Push max = 214 N
      P = (1000 * Push) / (vqRbrk_CylArea/10)  Push max = 2147 N
      P = (100 * Push) / (vqRbrk_CylArea/100)  Push max = 21474 N
      P = (10 * Push) / (vqRbrk_CylArea/1000)  Push max = 214748 N *)
(* Verifica limite spinta  *)
IF Push > vqRbrk_PushMax THEN
    dlog( Txt:='fbRbrk %d: ! Limit F=%ld to %ld N', Lvl:=3, Val1:=TO_DINT(ID), Val2:=Push/1E3, Val3:=vqRbrk_PushMax/1E3);
    Push := vqRbrk_PushMax;
END_IF;
(* Qui il peso è positivo se concorde, ossia per utensili superiori; l'attrito è sempre opposto *)
Pressure := (100 * (Push-Weight + Fr) ) / (vqRbrk_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)

(* Uscita attuazione cilindro *)
Output := Status>=TS_GOINGON AND Cmd AND Allow AND NOT Emulated AND NOT TChangingTool.q;

(* Supporto pressione di salita data dalla proporzionale *)
IF NOT Output THEN
    Pressure := P_TOOLUP;
ELSIF Pressure<0 THEN
    (* Se la pressione è negativa devo salire *)
    Pressure := -Pressure; (* Dovrei riapplicare peso e attriti cambiando segno *)
    Output := FALSE;
END_IF;


(* -- Gestione raddoppio forza con doppia camera --
   Quando devo erogare una forza oltre una certa soglia.
   Decido la soglia in base alla pressione associata:
    F[N] = P[bar] * A[mm²] / 10
   Ad es., se non voglio andare oltre i 5.7bar:
     DoublePushLim := 57 * vqRbrk_CylArea/100; (* [mN] *)
DoublePush := Output AND (Pressure>vqRbrk_DblPressLim OR OppDoubled);
IF DoublePush THEN
   Pressure := Pressure / 2;
END_IF;


(* -- Servizio selezione rotella/controrotella -- *)
(* Quando SelC commuta, segnala commutazione in corso *)
TChangingTool( in:=SelC<>Output_SelC, pt:=TO_UDINT(vqRbrk_SelTime) );
Output_SelC := SelC; (* Applica sempre il comando *)
               (* AND NOT TLeaveDelay.q; (* ...A meno del reset alla disattivazione *)

(* -- Monitors -- *)
AtRest := Status=TS_OFF AND NOT Output;
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbHammerBrk

{ DE:"Utensile di apertura a percissione per sagome" }

	VAR_INPUT
	ID : INT; { DE:"Identificativo componente" }
	Emulated : BOOL; { DE:"Non accostare sul vetro" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Wait : BOOL := FALSE; { DE:"Condizione da attendere prima di attivazione" }
	Cmd : BOOL; { DE:"Comando attivazione" }
	ApproachPush : DINT; { DE:"Spinta accostamento [mN]" }
	WorkPush : DINT; { DE:"Spinta di lavoro [mN]" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato utensile" }
	AtRest : BOOL; { DE:"Utensile a riposo" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vqRbrk2_Tapprch : DINT; { DE:"Tempo accostamento al vetro utensili apertura sagomato [ms]" }
	vqRbrk2_Tleave : DINT; { DE:"Tempo attesa allontanamento utensili apertura sagomato [ms]" }
	vqRbrk2_Tsettle : DINT; { DE:"Tempo attivazione utensili apertura sagomato [ms]" }
	vqRbrk2_CylArea : DINT; { DE:"Area cilindro attuatore pneumatico utensili apertura a percussione [um mm]" }
	END_VAR

	VAR
	TSettleDelay : Ton; { DE:"Timer accensione percussione" }
	TApprchDelay : Ton; { DE:"Timer accostamento utensile al vetro" }
	TLeaveDelay : Ton; { DE:"Timer per attesa allontanamento utensile" }
	Push : DINT; { DE:"Current pushing force [mN]" }
	END_VAR

	{ CODE:ST }(*    fbHammerBrk (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Questo è un utensile non orientato utilizzato
      per aprire le sagome, normalmente montato
      sui traini passivi.

      DETAILS
      ----------------------------------------------
      All'accensione si attiva un moto alternato di
      un percussore.
*)

TSettleDelay( in:=Status=TS_WAITON, pt:=TO_UDINT(vqRbrk2_Tsettle) );
TApprchDelay( in:=Status=TS_GOINGON, pt:=TO_UDINT(vqRbrk2_Tapprch) );
TLeaveDelay( in:=Status=TS_GOINGOFF, pt:=TO_UDINT(vqRbrk2_Tleave) );
CASE Status OF

    TS_ON : (* Tool pressing on glass *)
        IF NOT Cmd OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbHammerBrk %d: !! ON: Aborted', Lvl:=3, Val1:=TO_DINT(ID) ); END_IF; *)
            Status := TS_GOINGOFF;
        END_IF;


    TS_WAITON : (* Activating precussion *)
        IF NOT Cmd OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbHammerBrk %d: !! WAITON: Aborted', Lvl:=5, Val1:=TO_DINT(ID) ); END_IF; *)
            Status := TS_GOINGOFF;
        ELSIF TSettleDelay.q THEN (* Settle time expired *)
            Push := WorkPush;
            (* dlog( Txt:='fbHammerBrk %d: Down, P=%ld N', Lvl:=5, Val1:=TO_DINT(ID), Val2:=Push/1E3 ); *)
            Status := TS_ON;
        END_IF;


    TS_GOINGON : (* Tool approaching glass *)
        IF NOT Cmd OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbHammerBrk %d: !! GOINGON: Aborted', Lvl:=5, Val1:=TO_DINT(ID) ); END_IF; *)
            Status := TS_GOINGOFF;
        ELSIF TApprchDelay.q THEN (* AND is_down *) (* Approaching time expired *)
            Push := WorkPush;
            (* dlog( Txt:='fbHammerBrk %d: P=%ld N', Lvl:=7, Val1:=TO_DINT(ID), Val2:=Push/1E3 ); *)
            Status := TS_WAITON; (* proceed *)
        END_IF;


    TS_GOINGOFF : (* Tool leaving glass *)
        (* Nota: per salire non si usa la pressione della proporzionale *)
        IF TLeaveDelay.q THEN (* AND is_up *) (* Leave time expired *)
            Status := TS_OFF;
        END_IF;


    TS_OFF : (* Tool at rest *)
        IF Cmd AND NOT Wait THEN
            Push := ApproachPush; (* Spinta di discesa *)
            Status := TS_GOINGON;
        END_IF;

END_CASE; (* --- Up/down sequences *)


(* -- Calcolo della pressione da dare alla proporzionale -- *)
Pressure := (100 * Push ) / (vqRbrk2_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)


(* -- Monitors -- *)
AtRest := Status=TS_OFF;
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbPvbBladeSup

{ DE:"Attuazione lametta superiore taglio plastico" }

	VAR_INPUT
	ID : INT; { DE:"Identificativo componente" }
	Emulated : BOOL; { DE:"Non accostare sul vetro" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Wait : BOOL := FALSE; { DE:"Condizione da attendere prima di attivazione" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato della lametta" }
	AtRest : BOOL; { DE:"Lametta a riposo" }
	Steady : BOOL; { DE:"Nessun movimento in corso (misura altezza)" }
	Stable : BOOL; { DE:"Comando eseguito/Pressione stabilizzata" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	Pr : fbM32Axis; { DE:"Motore primario premilastra motorizzato lato riscontro" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vqBlade_PushMax : DINT; { DE:"Spinta massima attuatore lametta PVB [mN]" }
	vqBlade_Papprch : DINT; { DE:"Spinta accostamento lametta PVB [mN]" }
	vqBlade_Tapprch : DINT; { DE:"Tempo accostamento al vetro lametta PVB [ms]" }
	vqBlade_UpPush : DINT; { DE:"Forza di salita/ritenuta lametta PVB [mN]" }
	vqBlade_Tleave : DINT; { DE:"Tempo attesa allontanamento lametta PVB [ms]" }
	vqBlade_Pcut : DINT; { DE:"Spinta taglio per ogni decimo di plastico [mN/0.1mm]" }
	vqBlade_Tpush : DINT; { DE:"Tempo spinta sfondamento plastico [ms]" }
	vqBlade_AddPush : DINT; { DE:"Compensazione forza antagonista [mN]" }
	vqBladeSup_CylFr : DINT; { DE:"Forza resistente statica attuazione lametta superiore [mN]" }
	vqBladeSup_CylArea : DINT; { DE:"Area cilindro attuatore pneumatico lametta superiore [um mm]" }
	vnBladeSup_ReadHup : INT; { DE:"Lettura sensore altezza lametta sup in posizione alta [mV]" }
	vnBladeSup_ReadHdwn : INT; { DE:"Lettura sensore altezza lametta sup in posizione bassa [mV]" }
	vqBladeSup_Hup : DINT; { DE:"Altezza lametta sup in posizione alta (risp premilastra) [um]" }
	vqBladeSup_Hdwn : DINT; { DE:"Altezza lametta sup in posizione bassa (risp premilastra) [um]" }
	vqBladeSup_Htol : DINT; { DE:"Tolleranza sulla misura altezza lametta sup [um]" }
	vqBladeSup_Href : DINT; { DE:"Altezza piano riferimento lametta [um]" }
	vnBladeSup_Cmd : INT; { DE:"Comando a lametta PVB superiore" }
	vqBladeSup_SelX : DINT; { DE:"Selezione posizione X lametta PVB superiore [um]" }
	vqPvbThckn : DINT; { DE:"Spessore dichiarato plastico 'h-plast' [um]" }
	vqBladeSup_H : DINT; { DE:"Misura altezza lametta superiore [um]" }
	IFC_BLADESUP_OUT : BOOL; { DE:"Sensore cilindro lametta superiore completamente allungato" }
	O_BLADESUP : BOOL; { DE:"Aziona lametta superiore" }
	O_BLADESUP_SHFTBCK : BOOL; { DE:"Spostamento orizzontale lametta PVB superiore verso stacco (per ciclo rifilo)" }
	O_BLADESUP_UNLOCKZ : BOOL; { DE:"Sblocca fermo su stelo cilindro (regolazione finecorsa basso)" }
	END_VAR

	VAR
	Buf_Cmd : INT; { DE:"Ricorda il comando" }
	TOffDelay : Ton; { DE:"Timer attesa ritorno" }
	TApprDelay : Ton; { DE:"Timer attesa approccio" }
	TPushDelay : Ton; { DE:"Timer test sfondamento" }
	Push : DINT; { DE:"Requested pushing force [mN]" }
	aiHeight : fbAnalogInput; { DE:"Ingresso sensore lettura altezza" }
	END_VAR

	{ CODE:ST }(*    fbPvbBladeSup (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa le logiche riguardanti la lametta
      per il taglio plastico posta sul carrello
      superiore.
      Questa viene usata durante il riscaldamento e
      tensionatura del plastico per tagliarlo
      completando il ciclo di separazione.

      DETAILS (GENERAL)
      ----------------------------------------------
      Nelle vecchie macchine anche alla camera di
      salita del cilindro arriva la pressione della
      proporzionale, quindi va gestita la pressione
      di salita/ritenuta.
      Questo blocco astrae la gestione della posizione
      X della lametta, che può essere ottenuta
      mediante lo spostamento orizzontale oppure
      più drasticamente con una lametta aggiuntiva.
      Lo spostamento X verso lo stacco/riscontri
      serve per abbassare il limite sulla larghezza
      minima della rimanenza/prodotto separabile.

      DETAILS (SUP)
      ----------------------------------------------
      Su macchine in cui l'altezza Z del carrello
      superiore non è fissa la lametta può collidere
      con la lampada: per gestire questa problematica
      si monta un sensore analogico e un fermo sullo
      stelo del cilindro per bloccarne la corsa.
*)


(* -- Misura altezza lametta superiore (vqBladeSup_H) --
      la lametta superiore può appoggiarsi alla lampada.
      Se nelle macchine con carrello superiore ad altezza
      fissa basta montare opportunamente il cilindro, in
      quelle con premilastra motorizzato è necessario
      prendere opportuni accorgimenti (blocco estensione
      cilindro). In questi casi è necessario misurare
      l'altezza effettiva della lametta per creare la
      condizione di plastico sfondato. *)
IF AI_BLADESUP_H>0 THEN
    aiHeight(Index:=AI_BLADESUP_H, ReadMin:=vnBladeSup_ReadHdwn,
                                   ReadMax:=vnBladeSup_ReadHup,
                                   ValueMin:=vqBladeSup_Hdwn,
                                   ValueMax:=vqBladeSup_Hup, a:=0.04); (* a:=vdPlcScanTime/(Tcut+vdPlcScanTime) *)
    (* vnBladeSup_ReadH := TO_INT(aiHeight.Read); *)

    Steady := aiHeight.Steady;

    (* Se il premilastra al quale è solidale la lametta si muove
       (vnClampAlgn_Type=2 ossia NOT Pr.Emulated)
       Le altezze sono relative ad esso: quella assoluta si ottiene
       sommando la posizione del premilastra *)
    vqBladeSup_H := aiHeight.Value + Pr.CurrPos;

    (* Emulazione dell'ingresso lametta fuori (plastico sfondato): *)
    (* IFC_BLADESUP_OUT := vnBladeSup_ReadH <= vnBladeSup_ReadHdwn; (* Nah, meglio tenere conto di Pr.CurrPos *)
    IFC_BLADESUP_OUT := O_BLADESUP AND vqBladeSup_H < (vqBladeSup_Href+vqBladeSup_Htol);
ELSE
    vqBladeSup_H := SEL(Status<>TS_OFF, vqBladeSup_Hup, vqBladeSup_Href);
    Steady := NOT (TApprDelay.q OR TOffDelay.q);
END_IF;


(* -- Gestione del fermo su stelo cilindro --
   Usato per la regolazione finecorsa basso durante test lametta prima della
   separazione, per assicurare di non andare contro la lampada.
   Normalmente lo lascio bloccato, sblocco solo durante il tuning lametta
O_BLADESUP_UNLOCKZ := O_BLADESUP AND vnBladeSup_Cmd=BLCMD_PROBE; *)



(* -- State machine -- *)
TApprDelay( in:=Status=BS_APPROACH, pt:=TO_UDINT(vqBlade_Tapprch) );
TPushDelay( in:=Status>=BS_PUSHING, pt:=TO_UDINT(vqBlade_Tpush) );
TOffDelay( in:=Status=TS_GOINGOFF, pt:=TO_UDINT(vqBlade_Tleave) );
CASE Status OF

    BS_PUSHING, (* Premendo su vetro/plastico *)
    BS_PUSHED, (* Appoggiata a vetro *)
    BS_THROUGH : (* Attraversato il plastico *)
        IF vnBladeSup_Cmd=CMD_STOP THEN
            O_BLADESUP_UNLOCKZ := FALSE; (* Assicuro che il fermo sullo stelo sia bloccato *)
            Status := TS_GOINGOFF;
        (* Vedi se sono passato attraverso il plastico (cilindro giù) *)
        ELSIF Status<>BS_THROUGH AND O_BLADESUP AND IFC_BLADESUP_OUT THEN
            O_BLADESUP_UNLOCKZ := FALSE; (* Assicuro che il fermo sullo stelo sia bloccato *)
            dlog( Txt:='fbPvbBladeSup: Through (h=%ld um)', Lvl:=3, Val1:=vqBladeSup_H );
            Status := BS_THROUGH; (* La lametta ha superato il plastico o è rotta *)
            IF vnBladeSup_Cmd=BLCMD_CUTPVB THEN
                Push := vqPvbThckn * (vqBlade_Pcut/100); (* [um mN/0.1mm] Pressione di taglio *)
            END_IF;
        (* Vedi se è terminato il tempo per vedere se ho sfondato *)
        ELSIF Status=BS_PUSHING AND TPushDelay.q THEN
            O_BLADESUP_UNLOCKZ := FALSE; (* Assicuro che il fermo sullo stelo sia bloccato *)
            Status := BS_PUSHED;
        (* Vedi se è cambiato il comando *)
        ELSIF vnBladeSup_Cmd<>Buf_Cmd THEN
            dlog( Txt:='fbPvbBladeSup: ! Cmd %d => %d', Lvl:=3, Val1:=TO_DINT(Buf_Cmd), Val2:=TO_DINT(vnBladeSup_Cmd) );
            Buf_Cmd := vnBladeSup_Cmd;
            (* Imposto la pressione opportuna *)
            IF vnBladeSup_Cmd=BLCMD_CUTPVB THEN
                Push := vqPvbThckn * (vqBlade_Pcut/100); (* [um mN/0.1mm] Pressione di sfondamento/taglio *)
            ELSE (* BLCMD_PROBE *)
                Push := 0;
            END_IF;
            Status := BS_APPROACH;
        END_IF;


    BS_APPROACH : (* Attendi tempo minimo per discesa lametta *)
        IF vnBladeSup_Cmd=CMD_STOP THEN
            Status := TS_GOINGOFF;
        ELSIF Steady AND TApprDelay.q THEN
            (* Calculate settle time basing on pressure jump *)
            (* SettleTime := TO_UDINT( 100 + ((ABS(DeltaPush)/10) * (vqBlade_Latency/100))/1000 ) ; (* [mN] → [ms] *)
            (* Imposto la pressione opportuna *)
            IF vnBladeSup_Cmd=BLCMD_CUTPVB THEN
                Push := vqPvbThckn * (vqBlade_Pcut/100); (* [um mN/0.1mm] Pressione di sfondamento *)
            ELSE (* BLCMD_PROBE *)
                Push := 0;
            END_IF;
            Status := BS_PUSHING;
        END_IF;


    TS_GOINGOFF : (* Attendo tempo minimo salita *)
        IF TOffDelay.q AND NOT IFC_BLADESUP_OUT THEN
            dlog( Txt:='fbPvbBladeSup: Off (h=%ld)', Lvl:=3, Val1:=vqBladeSup_H/1E3 );
            Status := TS_OFF; (* Lametta salita *)
        END_IF;


    TS_OFF : (* Lametta alta *)
        (* È possibile selezionare la posizione X solo a utensile a riposo *)
        IF vqBladeSup_SelX>0 THEN
            (* Lametta verso riscontri (rifilo di testa) *)
            (* Non è costruttivamente possibile spostare la lametta superiore
               verso i riscontri (per rifili di testa), quindi o di usa una
               seconda lametta (che non ci sta) o si usa una lametta montata
               sul carrello inferiore. *)
            O_BLADESUP_SHFTBCK := FALSE;
            (* O_BLADESUP_SHFTFWD := TRUE; *)
        ELSIF vqBladeSup_SelX<0 THEN
            (* Lametta verso stacco (rifilo rimanenza) *)
            O_BLADESUP_SHFTBCK := TRUE;
            (* O_BLADESUP_SHFTFWD := FALSE; *)
        ELSE
            (* Lametta centrata (taglio normale) *)
            O_BLADESUP_SHFTBCK := FALSE;
            (* O_BLADESUP_SHFTFWD := FALSE; *)
        END_IF;
        IF vnBladeSup_Cmd>CMD_STOP AND NOT Wait THEN
            dlog( Txt:='fbPvbBladeSup: Cmd %d', Lvl:=3, Val1:=TO_DINT(vnBladeSup_Cmd) ); (* BLCMD_CUTPVB,BLCMD_PROBE *)
            Buf_Cmd := vnBladeSup_Cmd;
            Push := vqBlade_Papprch; (* Spinta di accostamento *)
            Status := BS_APPROACH;
        END_IF;

END_CASE; (* -- state machine *)


(* -- Attuazioni -- *)
(* Cilindro discesa/salita *)
O_BLADESUP := Status>=BS_APPROACH AND NOT Emulated;
(* Supporto pressione di salita/ritenuta data dalla proporzionale *)
IF NOT O_BLADESUP THEN
    Push := vqBlade_UpPush; (* Spinta di salita/ritenuta *)
END_IF;


(* -- Calcolo della pressione da dare alla proporzionale --
  Conversione da forza a pressione in base all'area cilindro
  P[bar] = (10 * F[N]) / A[mm²]
  Uso interi a virgola fissa 3 decimali
  Per evitare overflow scarto qualche decimale  (2^31-1)=2147483647
      P = (1000 * Push) / (vq*_CylArea/10)  Push max = 2147N
      P = (100 * Push) / (vq*_CylArea/100)  Push max = 21474N *)
(* Verifica limite spinta  *)
IF Push > vqBlade_PushMax THEN
    dlog( Txt:='fbPvbBladeSup: ! Limit F=%ld => %ld N', Lvl:=1, Val1:=Push/1E3, Val2:=vqBlade_PushMax/1E3);
    Push := vqBlade_PushMax;
END_IF;
(* Qualora il fermo su stelo cilindro fosse sbloccato, la molla che
   lo spinge contro la parte mobile si oppone alla discesa:
   in tal coso applico una compensazione di questa forza antagonista *)
Pressure := (100 * (Push + vqBladeSup_CylFr + SEL(O_BLADESUP_UNLOCKZ AND O_BLADESUP, DINT#0, vqBlade_AddPush))) / (vqBladeSup_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)
(* Se la pressione è negativa devo ritornare! *)
IF Pressure<0 THEN
    Pressure := -Pressure; (* Dovrei riapplicare peso e attriti cambiando segno *)
    O_BLADESUP := FALSE;
END_IF;


(* -- Monitors -- *)
Stable := Status=TS_OFF OR Status>=BS_PUSHED;
AtRest := Status=TS_OFF;
vn[ivnStatus+ID_BLADE_SUP] := Status;
vb[ivbAtRest+ID_BLADE_SUP] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbPvbBladeInf

{ DE:"Attuazione lametta inferiore taglio plastico" }

	VAR_INPUT
	ID : INT; { DE:"Identificativo componente" }
	Emulated : BOOL; { DE:"Non accostare sul vetro" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Wait : BOOL := FALSE; { DE:"Condizione da attendere prima di attivazione" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato della lametta" }
	AtRest : BOOL; { DE:"Lametta a riposo" }
	Stable : BOOL; { DE:"Comando eseguito/Pressione stabilizzata" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vqBlade_PushMax : DINT; { DE:"Spinta massima attuatore lametta PVB [mN]" }
	vqBlade_Papprch : DINT; { DE:"Spinta accostamento lametta PVB [mN]" }
	vqBlade_Tapprch : DINT; { DE:"Tempo accostamento al vetro lametta PVB [ms]" }
	vqBlade_UpPush : DINT; { DE:"Forza di salita/ritenuta lametta PVB [mN]" }
	vqBlade_Tleave : DINT; { DE:"Tempo attesa allontanamento lametta PVB [ms]" }
	vqBlade_Pcut : DINT; { DE:"Spinta taglio per ogni decimo di plastico [mN/0.1mm]" }
	vqBlade_Tpush : DINT; { DE:"Tempo spinta sfondamento plastico [ms]" }
	vqBladeInf_CylFr : DINT; { DE:"Forza resistente statica attuazione lametta inferiore [mN]" }
	vqBladeInf_CylArea : DINT; { DE:"Area cilindro attuatore pneumatico lametta inferiore [um mm]" }
	vnBladeInf_Cmd : INT; { DE:"Comando a lametta PVB inferiore" }
	vqBladeInf_SelX : DINT; { DE:"Selezione posizione X lametta PVB inferiore [um]" }
	vqPvbThckn : DINT; { DE:"Spessore dichiarato plastico 'h-plast' [um]" }
	IFC_BLADEINF_OUT : BOOL; { DE:"Sensore cilindro lametta inferiore completamente allungato" }
	O_BLADEINF : BOOL; { DE:"Aziona lametta inferiore" }
	END_VAR

	VAR
	Buf_Cmd : INT; { DE:"Ricorda il comando" }
	TOffDelay : Ton; { DE:"Timer attesa ritorno" }
	TApprDelay : Ton; { DE:"Timer attesa approccio" }
	TPushDelay : Ton; { DE:"Timer test sfondamento" }
	Push : DINT; { DE:"Requested pushing force [mN]" }
	END_VAR

	{ CODE:ST }(*    fbPvbBladeInf (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa le logiche riguardanti la lametta
      per il taglio plastico posta sul carrello
      inferiore.
      Questa viene usata durante il riscaldamento e
      tensionatura del plastico per tagliarlo
      completando il ciclo di separazione.

      CONTEXT
      ----------------------------------------------
      Questa lametta, posta quasi a filo del premilastra
      lato riscontri, è stata introdotta per separare
      il rifilo di testa (prodotto stretto).
*)

(* -- State machine -- *)
TApprDelay( in:=Status=BS_APPROACH, pt:=TO_UDINT(vqBlade_Tapprch) );
TPushDelay( in:=Status>=BS_PUSHING, pt:=TO_UDINT(vqBlade_Tpush) );
TOffDelay( in:=Status=TS_GOINGOFF, pt:=TO_UDINT(vqBlade_Tleave) );
CASE Status OF

    BS_PUSHING, (* Premendo su vetro/plastico *)
    BS_PUSHED, (* Appoggiata a vetro *)
    BS_THROUGH : (* Attraversato il plastico *)
        IF vnBladeInf_Cmd=CMD_STOP THEN
            Status := TS_GOINGOFF;
        (* Vedi se sono passato attraverso il plastico (cilindro giù) *)
        ELSIF Status<>BS_THROUGH AND O_BLADEINF AND IFC_BLADEINF_OUT THEN
            Push := vqPvbThckn * (vqBlade_Pcut/100); (* [um mN/0.1mm] Pressione di taglio *)
            dlog( Txt:='fbPvbBladeInf: Through', Lvl:=3 );
            Status := BS_THROUGH; (* La lametta ha superato il plastico o è rotta *)
        (* Vedi se è terminato il tempo per vedere se ho sfondato *)
        ELSIF Status=BS_PUSHING AND TPushDelay.q THEN
            Status := BS_PUSHED;
        (* Vedi se è cambiato il comando *)
        ELSIF vnBladeInf_Cmd<>Buf_Cmd THEN
            Buf_Cmd := vnBladeInf_Cmd;
            (* Imposto la pressione opportuna *)
            IF vnBladeInf_Cmd=BLCMD_CUTPVB THEN
                Push := vqPvbThckn * (vqBlade_Pcut/100); (* [um mN/0.1mm] Pressione di sfondamento/taglio *)
            ELSE (* BLCMD_PROBE *)
                Push := vqBlade_Papprch/5; (* Un minimo di compensazione peso? *)
            END_IF;
            Status := BS_APPROACH;
        END_IF;


    BS_APPROACH : (* Attendi tempo minimo per discesa lametta *)
        IF vnBladeInf_Cmd=CMD_STOP THEN
            Status := TS_GOINGOFF;
        ELSIF TApprDelay.q THEN
            (* Calculate settle time basing on pressure jump *)
            (* SettleTime := TO_UDINT( 100 + ((ABS(BrkPush-Push)/10) * (vqBlade_Latency/100))/1000 ) ; (* [mN] → [ms] *)
            (* Imposto la pressione opportuna *)
            IF vnBladeInf_Cmd=BLCMD_CUTPVB THEN
                Push := vqPvbThckn * (vqBlade_Pcut/100); (* [um mN/0.1mm] Pressione di sfondamento plastico *)
            ELSE (* BLCMD_PROBE *)
                Push := vqBlade_Papprch/5; (* Un minimo di compensazione peso? *)
            END_IF;
            Status := BS_PUSHING;
        END_IF;


    TS_GOINGOFF : (* Attendo tempo minimo salita *)
        IF TOffDelay.q AND NOT IFC_BLADEINF_OUT THEN
            dlog( Txt:='fbPvbBladeInf: Off', Lvl:=3 );
            Status := TS_OFF; (* Lametta salita *)
        END_IF;


    TS_OFF : (* Lametta alta *)
        (* È possibile selezionare la posizione X solo a utensile a riposo *)
        (* vqBladeInf_SelX: Per ora la lametta è fissa in X *)
        IF vnBladeInf_Cmd>CMD_STOP AND NOT Wait THEN
            dlog( Txt:='fbPvbBladeInf: Cmd %d', Lvl:=3, Val1:=TO_DINT(vnBladeInf_Cmd) ); (* BLCMD_CUTPVB,BLCMD_PROBE *)
            Buf_Cmd := vnBladeInf_Cmd;
            Push := vqBlade_Papprch; (* Spinta di accostamento *)
            Status := BS_APPROACH;
        END_IF;

END_CASE; (* -- state machine *)


(* -- Attuazioni -- *)
(* Cilindro discesa/salita *)
O_BLADEINF := Status>=BS_APPROACH AND NOT Emulated;
(* Supporto pressione di salita/ritenuta data dalla proporzionale *)
IF NOT O_BLADEINF THEN
    Push := vqBlade_UpPush; (* Spinta di salita/ritenuta *)
END_IF;


(* -- Calcolo della pressione da dare alla proporzionale --
  Conversione da forza a pressione in base all'area cilindro
  P[bar] = (10 * F[N]) / A[mm²]
  Uso interi a virgola fissa 3 decimali
  Per evitare overflow scarto qualche decimale  (2^31-1)=2147483647
      P = (1000 * Push) / (vq*_CylArea/10)  Push max = 2147N
      P = (100 * Push) / (vq*_CylArea/100)  Push max = 21474N *)
(* Verifica limite spinta  *)
IF Push > vqBlade_PushMax THEN
    dlog( Txt:='fbPvbBladeInf: ! Limit F=%ld => %ld N', Lvl:=1, Val1:=Push/1E3, Val2:=vqBlade_PushMax/1E3);
    Push := vqBlade_PushMax;
END_IF;
Pressure := (100 * (Push + vqBladeInf_CylFr)) / (vqBladeInf_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)
(* Se la pressione è negativa devo ritornare! *)
IF Pressure<0 THEN
    Pressure := -Pressure; (* Dovrei riapplicare peso e attriti cambiando segno *)
    O_BLADEINF := FALSE;
END_IF;


(* -- Monitors -- *)
Stable := Status=TS_OFF OR Status>=BS_PUSHED;
AtRest := Status=TS_OFF;
vn[ivnStatus+ID_BLADE_INF] := Status;
vb[ivbAtRest+ID_BLADE_INF] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbGrLe

{ DE:"Mola asportazione basso emissivo principale" }

	VAR_INPUT
	Emulated : BOOL; { DE:"Non accostare sul vetro" }
	Cmd_Spin : BOOL; { DE:"Comando attivazione rotazione mandrino" }
	Cmd_Down : BOOL; { DE:"Comando discesa su vetro" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Wait : BOOL := FALSE; { DE:"Condizione da attendere prima di attivazione" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato della mola" }
	AtRest : BOOL; { DE:"Mola a riposo" }
	Up : BOOL; { DE:"Mola alta" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	CurrRotSpeed : INT; { DE:"Velocità di rotazione corrente [rpm]" }
	ID : INT := ID_GRLE; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	Scu : fbSafety; { DE:"Safety unit" }
	Sle_ax : fbM32Axis; { DE:"Mandrino rotazione gestito con servo" }
	vqGrLe_P : DINT; { DE:"Spinta sul vetro mola asportazione basso emissivo [mN]" }
	vnGrLe_Rpm : INT; { DE:"Velocità rotazione mola (con segno) [rpm]" }
	vqGrLe_Tapprch : DINT; { DE:"Tempo accostamento al vetro mola Low-E [s]" }
	vqGrLe_Tleave : DINT; { DE:"Tempo attesa allontanamento mola Low-E [s]" }
	vqGrLe_Papprch : DINT; { DE:"Spinta accostamento mola Low-E [mN]" }
	vnGrLe_Type : INT; { DE:"Tipo mola asportazione basso emissivo" }
	vqGrLe_CylArea : DINT; { DE:"Area cilindro attuatore mola basso emissivo [um mm]" }
	vqGrLe_SpdMax : DINT; { DE:"Velocità massima mola basso emissivo [um/min]" }
	vqGrLe_PushMax : DINT; { DE:"Spinta massima mola basso emissivo [mN]" }
	vqGrLe_Weight : DINT; { DE:"Peso attuazione mola basso emissivo [mN]" }
	vqGrLe_CylFr : DINT; { DE:"Forza resistente statica attuazione mola basso emissivo [mN]" }
	vnGrLe_RpmTol : INT; { DE:"Tolleranza sulla velocità rotazione mola [rpm]" }
	IFC_GRLE_HIGH : BOOL; { DE:"Sensore mola low-E in posizione alta" }
	O_GRLE : BOOL; { DE:"Aziona discesa mola low-E" }
	O_GRLE_ROT : BOOL; { DE:"Attiva mandrino rotazione mola low-E" }
	O_GRLE_ASP : BOOL; { DE:"Attiva aspirazione polvere mola low-E" }
	O_GRLE_BRAKEREL : BOOL; { DE:"Sblocca freno mola low-E" }
	vnGrLe_ReadH : INT; { DE:"Lettura sensore altezza mola [mV]" }
	vnGrLe_ReadHup : INT; { DE:"[mV] Lettura sensore altezza con mola in posizione alta" }
	vnGrLe_ReadHdwn : INT; { DE:"[mV] Lettura sensore altezza con mola in posizione bassa" }
	vqGrLe_Hdwn : DINT; { DE:"Altezza mola in posizione bassa [um]" }
	vqGrLe_Hup : DINT; { DE:"Altezza mola in posizione alta [um]" }
	vqGrLe_Htol : DINT; { DE:"Tolleranza sulla misura altezza mola [um]" }
	Pr : fbM32Axis; { DE:"Motore primario premilastra motorizzato lato riscontro" }
	vqGrLe_H : DINT; { DE:"Altezza mola rispetto il piano di riferimento [um]" }
	vqGrLe_MaxWear : DINT; { DE:"Massimo consumo ammesso mola low-E [um]" }
	vqGlass_ActualThckn : DINT; { DE:"Spessore complessivo misurato [um]" }
	I_SCU_POW_Y : BOOL; { DE:"Potenza gruppo assi taglio" }
	END_VAR

	VAR
	TApprchDelay : Ton; { DE:"Timer accostamento utensile al vetro" }
	TLeaveDelay : Ton; { DE:"Timer per attesa allontanamento utensile" }
	Push : DINT; { DE:"Current pushing force [mN]" }
	Sle_inv : fbECatInverter; { DE:"Mandrino mola LowE" }
	aiHeight : fbAnalogInput; { DE:"Ingresso sensore lettura altezza" }
	END_VAR

	{ CODE:ST }(*    fbGrLe (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa le logiche riguardanti la mola
      asportazione basso emissivo principale,
      montata sul carrello o traino superiore,
      costituita tipicamente da un disco con
      asse di rotazione orizzontale.
      Questa viene usata prima di incidere, sullo
      strato soprastante.
      Notare che la rimozione del basso emissivo
      va eseguita non solo sui tagli ma anche sui
      bordi della lastra, quindi la sua attivazione
      cambia la sequenza della lavorazione automatica.

      DETAILS
      ----------------------------------------------
      -- Meccanica --
      Per la discesa abbiamo due soluzioni:
      .Discesa incernierata (tradizionale)
       La camera di discesa del cilindro su proporzionale
       e salita su pressione fissata
      .Discesa libera (tipo monolitiche)
       La camera di discesa del cilindro su proporzionale
       e salita su pressione compensazione peso regolata
       manualmente
      -- Mandrino --
      Sono supportati tre comandi: uscita digitale,
      mandrino con motore asincrono (inverter) oppure
      con motore sincrono (servo), ques'ultimo a volte
      usato per mere ragioni di compattezza.
*)

(* -- Up/down sequence -- *)
TApprchDelay( in:=(Status=TS_WAITON), pt:=TO_UDINT(vqGrLe_Tapprch) );
TLeaveDelay( in:=(Status=TS_GOINGOFF), pt:=TO_UDINT(vqGrLe_Tleave) );
CASE Status OF

    TS_ON : (* Tool down *)
        Push := vqGrLe_P;
        IF NOT Cmd_Down OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbGrLe: !! ON: Aborted', Lvl:=3 ); END_IF; *)
            Status := TS_GOINGOFF; (* Wait return *)
        END_IF;


    TS_WAITON : (* Tool approaching glass *)
        IF NOT Cmd_Down OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbGrLe: !! WAITON: Aborted', Lvl:=3 ); END_IF; *)
            Status := TS_GOINGOFF; (* Wait return *)
        ELSIF TApprchDelay.q AND NOT IFC_GRLE_HIGH (* AND IsDown *) THEN
            (* Approach done *)
            Push := vqGrLe_P; (* Set the working pressure *)
            dlog( Txt:='fbGrLe: Down, P=%ld N', Lvl:=5, Val1:=Push/1E3 );
            Status := TS_ON;
        END_IF;


    TS_READY : (* Spindle rotating, ready to approach *)
        IF NOT Cmd_Spin OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbGrLe: !! READY: Aborted', Lvl:=3 ); END_IF; *)
            Status := TS_GOINGOFF; (* Wait return *)
        ELSIF ABS(vnGrLe_Rpm-CurrRotSpeed)>vnGrLe_RpmTol THEN
            (* Speed lost! *)
            Status := TS_GOINGON;
        ELSE
            Push := SEL( vqGrLe_Tapprch>0, vqGrLe_P, vqGrLe_Papprch ); (* Be ready to approach *)
            IF Cmd_Down AND NOT Wait THEN
                Status := TS_WAITON;
            END_IF;
        END_IF;


    TS_GOINGON : (* Waiting spindle rotation *)
        IF NOT Cmd_Spin OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbGrLe: !! GOINGON: Aborted', Lvl:=3 ); END_IF; *)
            Status := TS_GOINGOFF; (* Wait return *)
        ELSIF ABS(vnGrLe_Rpm-CurrRotSpeed)<=vnGrLe_RpmTol THEN
            (* Spindle speed reached *)
            Status := TS_READY;
        END_IF;


    TS_GOINGOFF : (* Tool leaving glass *)
        (* Se salisse con la proporzionale: Push := vqGrLe_Pup; (* Spinta di salita *)
        IF TLeaveDelay.q AND IFC_GRLE_HIGH THEN
            Status := TS_OFF;
        END_IF;


    (*TS_WAITOFF : (* Waiting spindle stop
        IF ABS(CurrRotSpeed)<vnGrLe_RpmTol THEN
            Status := TS_OFF;
        END_IF; *)


    TS_OFF : (* Tool at rest *)
        IF Cmd_Spin THEN (* Rotation requested *)
            Status := TS_GOINGON; (* Wait for rotation *)
        ELSIF Cmd_Down AND NOT Wait THEN (* Approach requested *)
            Push := SEL( vqGrLe_Tapprch>0, vqGrLe_P, vqGrLe_Papprch ); (* Be ready to approach *)
            Status := TS_WAITON; (* Wait for approach *)
        ELSIF NOT IFC_GRLE_HIGH THEN (* Mola non a riposo! *)
            Status := TS_GOINGOFF; (* Wait return *)
        ELSE
            (* Push := vqGrLe_UpPush; (* Spinta di ritenuta *)
        END_IF;

END_CASE; (* --- Up/down sequence *)


(* Qui il peso è positivo se concorde, ossia per utensili superiori; l'attrito è sempre opposto *)
Pressure := (100 * (MAX(0,MIN(Push,vqGrLe_PushMax) - vqGrLe_Weight) + vqGrLe_CylFr) ) / (vqGrLe_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)
(* La mola sale con una pressione di ritenuta manuale *)


(* Uscita attuazione cilindro *)
O_GRLE := Status>=TS_WAITON AND Cmd_Down AND Allow AND NOT Emulated;


(* -- Gestione mandrino (spindle) -- *)
O_GRLE_ROT := Status>=TS_GOINGON AND Cmd_Spin AND Allow;

IF INV_GRLE>0 THEN
    (* Mandrino mosso da inverter su EtherCAT *)
    Sle_inv( Idx:=INV_GRLE );
    IF Sle_inv.Fault THEN
        (* Inverter in allarme *)
        SET_MSG(MSG_GRLE_HWFAULT,'MSG_GRLE_HWFAULT: inv2',DINT#0);
        (* Dò reset se abilitato *)
        IF Sle_inv.Enable THEN
            dlog( Txt:='fbGrLe: !! Sle spindle fault occurrence', Lvl:=1 );
            Sle_inv.Enable := FALSE;
        END_IF;
        (* Forzo velocità nulla *)
        Sle_inv.TgtSpd := 0;
    ELSE
        (* Inverter mandrino ok *)
        IF IS_MSG(MSG_GRLE_HWFAULT) THEN
            RST_MSG(MSG_GRLE_HWFAULT);
        END_IF;
        Sle_inv.Enable := O_GRLE_ROT;
        (* Applico velocità di rotazione mola *)
        Sle_inv.TgtSpd := SEL( O_GRLE_ROT, 0, vnGrLe_Rpm );
    END_IF;
    CurrRotSpeed := Sle_inv.CurrSpd;
ELSIF NOT Sle_ax.Emulated THEN
    (* Mandrino mosso da servoazionamento *)
    IF NOT I_SCU_POW_Y THEN
        Sle_ax.Cmd := AXC_STOP_FREE; (* Disable/Quickstop *)
    ELSIF O_GRLE_ROT THEN
        IF Sle_ax.Cmd<>AXC_START_SPD THEN
            Sle_ax.TgtSpd := DINT#360000 * TO_DINT(vnGrLe_Rpm); (* rpm => mdeg/min *)
            Sle_ax.TgtPos := DINT#360000; (* Modulo [mdeg] *)
            Sle_ax.AccPerc := 0; (* 0:max [%] *)
            Sle_ax.DecPerc := 0; (* 0:max [%] *)
            Sle_ax.OutFrc := -1; (* max *)
            (* Sle_ax.MaxPosErr := WTR_DISABLE; *)
            Sle_ax.Cmd := AXC_START_SPD;
        (* ELSE (* Could regulate the rotation speed:
            Sle.TgtSpd := vnGrLe_Rpm; *)
        END_IF;
    ELSIF Sle_ax.Status>AXS_READY THEN
        Sle_ax.Cmd := AXC_STOP_ENAB; (* Normal stop *)
    ELSE
        Sle_ax.Cmd := AXC_STOP_FREE; (* Disable *)
    END_IF;
    Sle_ax( Idx:=AX_SLE );
    CurrRotSpeed := TO_INT(Sle_ax.CurrSpd / DINT#360000);  (* mdeg/min => rpm *)
    (* vnGrLe_RotStatus := Sle_ax.Status; *)
END_IF;


(* -- Gestione aspirazione polveri -- *)
O_GRLE_ASP := O_GRLE_ROT AND O_GRLE;


(* -- Supporto a soluzione con compensazione peso e freno --
    La compensazione peso è manuale e ridondante, si usa 'vqGrLe_Weight' negativo per vincerla *)

(* -- Gestione rilascio freno elettromeccanico sul cilindro -- *)
O_GRLE_BRAKEREL := Status<>TS_OFF; (* AND Scu.PneumActReady *)


(* -- Gestione misura altezza -- *)
IF AI_GRLE_H>0 THEN
    aiHeight(Index:=AI_GRLE_H, ReadMin:=vnGrLe_ReadHdwn,
                               ReadMax:=vnGrLe_ReadHup,
                               ValueMin:=vqGrLe_Hdwn,
                               ValueMax:=vqGrLe_Hup, a:=0.04); (* a:=vdPlcScanTime/(Tcut+vdPlcScanTime) *)
    vnGrLe_ReadH := TO_INT(aiHeight.Read);

    (* Se non fosse cablato l'ingresso mola alta:
    IFC_GRLE_HIGH := aiHeight.Value > (vqGrLe_Hup-vqGrLe_Htol); *)
    (* IsDown := Status=TS_ON AND aiHeight.Steady; *)

    (* Se il premilastra al quale è solidale la mola si muove
       (vnClampAlgn_Type=2 ossia NOT Pr.Emulated)
       Le altezze sono relative ad esso: quella assoluta si ottiene
       sommando la posizione del premilastra *)
    vqGrLe_H := aiHeight.Value + Pr.CurrPos;

    (* Notifica consumo mola: Se va giù troppo può segnare il vetro *)
    IF vqGrLe_MaxWear>0 AND Status=TS_ON AND O_GRLE AND aiHeight.Steady AND
       vqGrLe_H < (vqGlass_ActualThckn - vqGrLe_MaxWear) THEN
        SET_MSG(MSG_GRLE_WORNOUT,'MSG_GRLE_WORNOUT',0);
    END_IF;
ELSE
    vqGrLe_H := SEL(Status<>TS_OFF, vqGrLe_Hup, vqGrLe_Hdwn);
END_IF;


(* -- Monitors -- *)
Up := vnGrLe_Type=0 OR (Status<TS_WAITON AND NOT O_GRLE AND IFC_GRLE_HIGH);
AtRest := Up; (* AND Status=TS_OFF *)
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbGrLe2

{ DE:"Mola asportazione basso emissivo principale" }

	VAR_INPUT
	Cmd_Spin : BOOL; { DE:"Comando attivazione rotazione mandrino" }
	Cmd_Down : BOOL; { DE:"Comando discesa su vetro" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Wait : BOOL := FALSE; { DE:"Condizione da attendere prima di attivazione" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato della mola" }
	AtRest : BOOL; { DE:"Mola a riposo" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	ID : INT := ID_GRLE2; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vqGrLe_PushMax : DINT; { DE:"Spinta massima mola basso emissivo [mN]" }
	vqGrLe2_P : DINT; { DE:"Spinta di lavoro mola Low-E aggiuntiva [mN]" }
	vnGrLe2_Type : INT; { DE:"Tipo mola asportazione basso emissivo aggiuntiva 'ID_GRLE2' (0:none 1:light 2:perif)" }
	vqGrLe2_CylArea : DINT; { DE:"Area cilindro attuatore mola basso emissivo aggiuntiva [mm²]" }
	vqGrLe2_CylFr : DINT; { DE:"Forza resistente statica attuazione mola basso emissivo aggiuntiva [mN]" }
	vqGrLe2_Tspindle : DINT; { DE:"Tempo attesa mandrino Low-E aggiuntiva [s]" }
	vqGrLe2_Tapprch : DINT; { DE:"Tempo accostamento al vetro mola Low-E aggiuntiva [s]" }
	vqGrLe2_Tleave : DINT; { DE:"Tempo attesa allontanamento mola Low-E aggiuntiva [s]" }
	vqGrLe2_Papprch : DINT; { DE:"Spinta accostamento mola Low-E aggiuntiva [mN]" }
	IFC_GRLE2_HIGH : BOOL; { DE:"Sensore mola aggiuntiva per sagomato in posizione alta" }
	O_GRLE2 : BOOL; { DE:"Aziona discesa mola aggiuntiva per sagomato" }
	O_GRLE2_ROT : BOOL; { DE:"Attiva mandrino rotazione mola aggiuntiva per sagomato" }
	O_GRLE2_ASP : BOOL; { DE:"Attiva aspirazione polvere mola aggiuntiva per sagomato" }
	END_VAR

	VAR
	TApprchDelay : Ton; { DE:"Timer accostamento utensile al vetro" }
	TSpindleDelay : Ton; { DE:"Timer attesa mandrino" }
	TLeaveDelay : Ton; { DE:"Timer per attesa allontanamento utensile" }
	Push : DINT; { DE:"Current pushing force [mN]" }
	END_VAR

	{ CODE:ST }(*    fbGrLe2 (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa le logiche riguardanti la mola
      asportazione basso emissivo aggiuntiva per
      sagomato, costituita da un semplice disco
      non orientato con asse di rotazione verticale
*)

(* -- Up/down sequence -- *)
TSpindleDelay( in:=O_GRLE2_ROT, pt:=TO_UDINT(vqGrLe2_Tspindle) );
TApprchDelay( in:=(Status=TS_WAITON), pt:=TO_UDINT(vqGrLe2_Tapprch) );
TLeaveDelay( in:=(Status=TS_GOINGOFF), pt:=TO_UDINT(vqGrLe2_Tleave) );
CASE Status OF

    TS_ON : (* Tool down *)
        Push := vqGrLe2_P;
        IF NOT Cmd_Down OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbGrLe2: !! ON: Aborted', Lvl:=3 ); END_IF; *)
            Status := TS_GOINGOFF; (* Wait return *)
        END_IF;


    TS_WAITON : (* Tool approaching glass *)
        IF NOT Cmd_Down OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbGrLe2: !! WAITON: Aborted', Lvl:=3 ); END_IF; *)
            Status := TS_GOINGOFF; (* Wait return *)
        ELSIF TApprchDelay.q AND NOT IFC_GRLE2_HIGH (* AND IsDown *) THEN
            Push := vqGrLe2_P; (* Set the working pressure *)
            dlog( Txt:='fbGrLe2: Down, P=%ld N', Lvl:=5, Val1:=Push/1E3 );
            Status := TS_ON;
        END_IF;


    TS_READY : (* Spindle rotating, ready to approach *)
        IF NOT Cmd_Spin OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbGrLe2: !! READY: Aborted', Lvl:=3 ); END_IF; *)
            Status := TS_GOINGOFF; (* Wait return time *)
        ELSE
            Push := SEL( vqGrLe2_Tapprch>0, vqGrLe2_P, vqGrLe2_Papprch ); (* Be ready to approach *)
            IF Cmd_Down AND NOT Wait THEN
                Status := TS_WAITON;
            END_IF;
        END_IF;


    TS_GOINGON : (* Waiting spindle rotation *)
        IF NOT Cmd_Spin OR NOT Allow THEN
            (* IF NOT Allow THEN dlog( Txt:='fbGrLe2: !! GOINGON: Aborted', Lvl:=3 ); END_IF; *)
            Status := TS_GOINGOFF; (* Wait return *)
        ELSIF TSpindleDelay.q THEN
            Status := TS_READY;
        END_IF;


    TS_GOINGOFF : (* Tool leaving glass *)
        IF TLeaveDelay.q AND IFC_GRLE2_HIGH THEN
            Status := TS_OFF;
        END_IF;


    TS_OFF : (* Tool at rest *)
        IF Cmd_Spin THEN (* Rotation requested *)
            Status := TS_GOINGON; (* Wait for rotation *)
        ELSIF Cmd_Down AND NOT Wait THEN (* Approach requested *)
            Push := SEL( vqGrLe2_Tapprch>0, vqGrLe2_P, vqGrLe2_Papprch ); (* Be ready to approach *)
            Status := TS_WAITON; (* Wait for approach *)
        ELSIF NOT IFC_GRLE2_HIGH THEN (* Mola non alta! *)
            Status := TS_GOINGOFF; (* Wait return *)
        END_IF;

END_CASE; (* --- Up/down sequence *)


(* Qui il peso è positivo se concorde, ossia per utensili superiori; l'attrito è sempre opposto *)
Pressure := (100 * MAX(0,MIN(Push,vqGrLe_PushMax) + vqGrLe2_CylFr) ) / (vqGrLe2_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)
(* La mola sale con una pressione di ritenuta manuale *)


(* -- Uscita attuazione cilindro discesa -- *)
O_GRLE2 := Status>=TS_WAITON; (* AND NOT Emulated *)

(* -- Gestione mandrino (spindle) -- *)
O_GRLE2_ROT := Cmd_Spin; (* Status>=TS_GOINGON *)

(* -- Gestione aspirazione polveri -- *)
O_GRLE2_ASP := O_GRLE2_ROT AND O_GRLE2;


(* -- Monitors -- *)
AtRest := vnGrLe2_Type=0 OR (Status<TS_WAITON AND NOT O_GRLE2 AND IFC_GRLE2_HIGH);
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbMarker

{ DE:"Gestione pastello marcatore" }

	VAR_INPUT
	ID : INT; { DE:"Identificativo componente" }
	Emulated : BOOL; { DE:"Non accostare sul vetro" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Wait : BOOL := FALSE; { DE:"Condizione da attendere prima di attivazione" }
	Cmd : BOOL; { DE:"Comando attivazione" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato dell'utensile" }
	AtRest : BOOL; { DE:"Utensile a riposo" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vqMarker_CylArea : DINT; { DE:"Area cilindro attuatore pneumatico pastello marcatore [um mm]" }
	vqMarker_PushMax : DINT; { DE:"Spinta massima attuatore pastello marcatore [mN]" }
	vqMarker_Tapprch : DINT; { DE:"Tempo accostamento al vetro pastello marcatore [ms]" }
	vqMarker_Tleave : DINT; { DE:"Tempo attesa allontanamento pastello marcatore [ms]" }
	vqMarker_Push : DINT; { DE:"Spinta pastello marcatore [mN]" }
	O_MARKER : BOOL; { DE:"Aziona discesa marcatore" }
	END_VAR

	VAR
	TDownDelay : Ton; { DE:"Timer to wait the actuation out" }
	TUpDelay : Ton; { DE:"Timer to wait the actuation in" }
	Push : DINT; { DE:"Current pushing force [mN]" }
	END_VAR

	{ CODE:ST }(*    fbMarker (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Attuazione pastello marcatore 'ID_MARKER'

      USAGE
      ----------------------------------------------
      VAR
      Marker : fbMarker;
      END_VAR
      Marker( ID:=ID_MARKER );
*)

(* - In/Out sequences - *)
TDownDelay( in:=Status=TS_GOINGON, pt:=TO_UDINT(vqMarker_Tapprch) );
TUpDelay( in:=Status=TS_GOINGOFF, pt:=TO_UDINT(vqMarker_Tleave) );
CASE Status OF

    TS_ON : (* Down *)
        IF Cmd THEN
            Push := vqMarker_Push;
        ELSE
            Status := TS_GOINGOFF; (* Return inside *)
        END_IF;

    TS_GOINGON : (* Going down *)
        IF Cmd THEN
            Push := vqMarker_Push;
            IF TDownDelay.q THEN
                Status := TS_ON;
            END_IF;
        ELSE
            Status := TS_GOINGOFF;
        END_IF;

    TS_GOINGOFF : (* Going up *)
        Push := 0;
        IF TUpDelay.q THEN
            Status := TS_OFF;
        END_IF;

    TS_OFF : (* Up and still *)
        IF Cmd AND NOT Wait THEN
            Push := vqMarker_Push;
            Status := TS_GOINGON;
        ELSE
            Push := 0;
        END_IF;

END_CASE;

(* -- Calcolo della pressione da dare alla proporzionale -- *)
Pressure := (100 * MIN(Push,vqMarker_PushMax)) / (vqMarker_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)

(* Uscita attuazione cilindro *)
O_MARKER := Status>=TS_GOINGON AND Cmd AND Allow AND NOT Emulated;

(* Supporto pressione di salita data dalla proporzionale *)
IF NOT O_MARKER THEN
    Pressure := P_TOOLUP;
ELSIF Pressure<0 THEN
    (* Se la pressione è negativa devo salire *)
    Pressure := -Pressure; (* Dovrei riapplicare peso e attriti cambiando segno *)
    O_MARKER := FALSE;
END_IF;

(* -- Monitors -- *)
AtRest := Status=TS_OFF AND NOT O_MARKER;
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbGrabber

{ DE:"Pinza girapezzi oleodinamica sul carrello inferiore" }

	VAR_INPUT
	Emulated : BOOL; { DE:"Non ruotare effettivamente" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	AllowUp : BOOL; { DE:"Consensi alla salita/apertura" }
	END_VAR

	VAR_OUTPUT
	Status : INT := GSTS_UNKNOWN; { DE:"Stato complessivo della pinza" }
	UpStatus : INT := TS_OFF; { DE:"Stato salita/discesa pinza" }
	ClampStatus : INT := GSTS_UNKNOWN; { DE:"Stato apertura/chiusura ganasce" }
	AtRest : BOOL; { DE:"Pinza a riposo (bassa e chiusa)" }
	ID : INT := ID_GRABBER; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vbHeartBeat : BOOL; { DE:"Battito di vita 1s" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqGrab_MaxGlassThckn : DINT; { DE:"Spessore complessivo massimo agguantabile da pinza [um]" }
	IFC_ZG_ZERO : BOOL; { DE:"Sensore azzeramento orientazione pinza (0:engaged)" }
	IFC_GRAB_HIGH : BOOL; { DE:"Sensore pinza in posizione alta" }
	IFC_GRAB_LOW : BOOL; { DE:"Sensore pinza in posizione bassa" }
	IFC_GRAB_OPENED : BOOL; { DE:"Sensore pinza aperta" }
	IFC_GRAB_CLOSED : BOOL; { DE:"Sensore pinza chiusa" }
	IPR_GRAB : BOOL; { DE:"Protezione attuatore pinza (0:OK)" }
	O_GRAB_ON : BOOL; { DE:"Accensione attuatore pinza girapezzi (pompa)" }
	O_GRAB_ON2 : BOOL; { DE:"Attivazione attuatore pinza girapezzi (olio in torretta)" }
	O_GRAB_UP_SET : BOOL; { DE:"Aziona bistabile per salita pinza girapezzi" }
	O_GRAB_UP_RST : BOOL; { DE:"Aziona bistabile per discesa pinza girapezzi" }
	O_GRAB_DWN : BOOL; { DE:"Aziona monostabile per discesa pinza girapezzi" }
	O_GRAB_CLOSE_COMP : BOOL; { DE:"Spostamento verso l'alto per afferrare il vetro" }
	O_GRAB_CLOSE : BOOL; { DE:"Aziona bistabile per chiusura pinza girapezzi" }
	O_GRAB_OPEN : BOOL; { DE:"Aziona bistabile per apertura pinza girapezzi" }
	O_SCU_GRABBER_ISON : BOOL; { DE:"Se attivo la centralina ne ritarda l'inibizione per permettere manovra di stop" }
	vnGrabber_Cmd : INT; { DE:"Command" }
	vbGrabber_KeepOpen : BOOL; { DE:"Mantieni la pressione sulla ganascia in apertura" }
	vqGrabber_OffDelay : DINT; { DE:"Ritardo spegnimento attuazione [ms]" }
	vqGrabber_OnDelay : DINT; { DE:"Ritardo apertura olio in torretta [ms]" }
	vqGrabber_CmdDelay : DINT; { DE:"Ritardo attivazione completa [ms]" }
	vqGrabber_Tgrab : DINT; { DE:"Tempo di agguantamento/chiusura ganasce [ms]" }
	vqGrabber_Timeout : DINT; { DE:"Tempo massimo dei movimenti del girapezzi [ms]" }
	END_VAR

	VAR
	OilActuation : fbOilActuation; { DE:"Centralina oleodinamica" }
	TGrab : Ton; { DE:"Attesa chiusura/agguantamento" }
	TUpDownTimeout : Ton; { DE:"Notifica problemi salita/discesa" }
	TOpenCloseTimeout : Ton; { DE:"Notifica problemi apertura/chiusura" }
	END_VAR

	{ CODE:ST }(*    fbGrabber (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa le logiche riguardanti la pinza
      girapezzi oleodinamica montata sul carrello
      inferiore.

      DETAILS
      ----------------------------------------------
      L'attuazione dell'apertura/chiusura è data
      oleodinamica, una prima uscita attiva la pompa,
      una seconda uscita devia l'olio nella torretta
      (mandandolo in pressione), e poi due uscite
      comandano l'apertura delle camere del cilindro
      causando l'apertura e la chiusura delle ganasce.
      Quando la pinza è agguantata bisogna spingere
      per mantenere la pressione, sarebbe bene anche
      quando è alta; occhio la pompa si surriscalda!
      La salita/discesa è data da una attuazione
      pneumatica, idealmente bistabile.
      Le vecchie macchine hanno attuazione
      monostabile che fa scendere la pinza (in
      caso di emergenza sale).
      Una ulteriore uscita fa alzare lievemente
      il blocco ganasce per centrare la chiusura
      delle stesse sul vetro durante l'agguantamento.
      Le operazioni di chiusura e apertura pinza
      sono delicate e coinvolgono il carrello per
      andare a quote sicure.
      Una fotocellula verso lo zero consente di
      evitare alcune possibili collisioni andando
      verso quote negative.
      Gli stati di interesse sono:
         .Bassa e chiusa (può passare sotto il vetro)
         .Alta e aperta (può passare attraverso il vetro se ben orientata)
         .Agguantata (alta e chiusa, per ruotare il vetro)

      SENSORS
      ----------------------------------------------
      Prima assunzione: se è attivo il sensore sulle
      ganasce chiuse, non ci può essere vetro, quindi
      è sicuro comandare una discesa.
      Quando la pinza è chiusa (che sia alta o bassa
      non importa) il sensore 'IFC_GRAB_OPENED'
      potrebbe leggere in certe posizioni, quindi
      meglio ignorarlo.
*)

(* -- Attivazione attuazione apertura/chiusura -- *)
OilActuation( Request:=vnGrabber_Cmd<>GCMD_NONE OR (ClampStatus>GSTS_CLOSED AND (ClampStatus<>GSTS_OPENED OR vbGrabber_KeepOpen)),
              Allow:=Allow,
              OffDelay:=TO_UDINT(vqGrabber_OffDelay),
              OnDelay:=TO_UDINT(vqGrabber_OnDelay),
              CmdDelay:=TO_UDINT(vqGrabber_CmdDelay) );
O_GRAB_ON := OilActuation.PumpOutput;
O_GRAB_ON2 := OilActuation.OilOutput;


(* -- Gestione salita e discesa -- *)
(* Notifica problemi salita/discesa *)
TUpDownTimeout( in:=UpStatus=TS_GOINGON OR UpStatus=TS_GOINGOFF, pt:=TO_UDINT(vqGrabber_Timeout) );
CASE UpStatus OF

    TS_ON : (* Pinza alta *)
        (* Rispondo alla richiesta di discesa *)
        IF Status=GSTS_CLOSING THEN
            dlog( Txt:='fbGrabber: Going down', Lvl:=5 );
            UpStatus := TS_GOINGOFF;
        END_IF;


    TS_GOINGON : (* Pinza in salita *)
        IF IFC_GRAB_HIGH AND NOT IFC_GRAB_LOW THEN
            dlog( Txt:='fbGrabber: Up', Lvl:=5 );
            UpStatus := TS_ON;
        END_IF;


    TS_GOINGOFF : (* Pinza in discesa *)
        IF IFC_GRAB_LOW AND NOT IFC_GRAB_HIGH THEN
            dlog( Txt:='fbGrabber: Down', Lvl:=5 );
            UpStatus := TS_OFF;
        END_IF;


    TS_OFF : (* Pinza bassa *)
        (* Rispondo alla richiesta di salita *)
        IF Status=GSTS_OPENING THEN
            dlog( Txt:='fbGrabber: Going up', Lvl:=5 );
            UpStatus := TS_GOINGON;
        END_IF;
        (* Controllo stato *)
        IF IFC_GRAB_HIGH OR NOT IFC_GRAB_LOW THEN
            dlog( Txt:='fbGrabber: ! Not down', Lvl:=2 );
            UpStatus := SEL(IFC_GRAB_HIGH AND NOT IFC_GRAB_LOW, TS_GOINGOFF, TS_ON);
        END_IF;

END_CASE; (* -- up/down state machine *)

(* -Attuazione uscite salita/discesa- *)
O_GRAB_UP_SET := UpStatus=TS_GOINGON;
O_GRAB_UP_RST := UpStatus=TS_GOINGOFF;
O_GRAB_DWN := UpStatus<=TS_GOINGOFF; (* Alternativa monostabile *)



(* -- Gestione apertura e chiusura ganasce -- *)
(* Notifica problemi apertura/chiusura *)
TOpenCloseTimeout( in:=ClampStatus=GSTS_CLOSING OR UpStatus=GSTS_OPENING, pt:=TO_UDINT(vqGrabber_Timeout) );
(* Tempo agguantamento *)
TGrab( in:=(ClampStatus=GSTS_CLOSING OR ClampStatus=GSTS_GRABBING) AND O_GRAB_CLOSE );
CASE ClampStatus OF

    GSTS_CLOSED : (* Ganasce completamente chiuse *)
        (* Rispondo alla richiesta comando di apertura *)
        IF Status=GSTS_OPENING THEN (* Open command *)
            dlog( Txt:='fbGrabber: Opening clamps', Lvl:=6 );
            ClampStatus := GSTS_OPENING;
        END_IF;


    GSTS_GRABBED : (* Ganasce serrate in pressione *)
        (* Rispondo alla richiesta comando di apertura *)
        IF Status=GSTS_OPENING THEN (* Open command *)
            dlog( Txt:='fbGrabber: Opening clamps (grabbed)', Lvl:=6 );
            ClampStatus := GSTS_OPENING;
        END_IF;


    GSTS_CLOSING, GSTS_GRABBING : (* Ganasce in chiusura *)
        (* Rispondi a richiesta di abort *)
        IF Status=GSTS_UNKNOWN THEN
            ClampStatus := GSTS_UNKNOWN;
        (* Rispondi a richieste di apertura *)
        ELSIF Status=GSTS_OPENING THEN (* Open command *)
            ClampStatus := GSTS_OPENING;
        (* Se sto agguantando non ho finecorsa (il vetro ha vari spessori)
           attendere un tempo per essere sicuri che si stia premendo *)
        ELSIF Status=GSTS_GRABBING THEN (* Agguantamento in corso *)
            IF TGrab.q THEN
                dlog( Txt:='fbGrabber: Clamps grabbed', Lvl:=6 );
                ClampStatus := GSTS_GRABBED;
            (* Creo una condizione di "quasi agguantato" per anticipare l'accensione dei ventilatori
               Nota: Il tempo rimanente è: TGrab.pt - TGrab.et [ms] *)
            ELSIF (TGrab.pt-TGrab.et)<500 AND ClampStatus<>GSTS_GRABBING THEN
                (* Notifico che ho quasi agguantato *)
                ClampStatus := GSTS_GRABBING;
                (* Nota: È questo stato è usato per anticipo accensione aria,
                         il tempo potrebbe essere correlato a vqVent_ShutTime *)
            END_IF;
        (* Se qui sto chiudendo: potremmo essere nella condizione di avere
           materiale in mezzo che non permette la chiusura: forse sarebbe
           bene abortire dopo un certo timeout *)
        (* ELSIF TOpenCloseTimeout.q THEN *)
        (* Controlla chiusura completata *)
        (* Nota: se 'IFC_GRAB_CLOSED=TRUE' è meglio ignorare 'IFC_GRAB_OPENED' *)
        ELSIF IFC_GRAB_CLOSED THEN
            dlog( Txt:='fbGrabber: Clamps fully closed', Lvl:=6 );
            ClampStatus := GSTS_CLOSED;
        END_IF;


    GSTS_OPENING : (* Ganasce in apertura *)
        (* Rispondi a richiesta di abort *)
        IF Status=GSTS_UNKNOWN THEN
            ClampStatus := GSTS_UNKNOWN;
        (* Rispondi richieste di chiusura *)
        ELSIF Status=GSTS_CLOSING THEN (* Close command *)
            ClampStatus := GSTS_CLOSING;
        (* Controlla se apertura completata *)
        (* Nota: se 'IFC_GRAB_CLOSED=TRUE' è meglio ignorare 'IFC_GRAB_OPENED' *)
        ELSIF IFC_GRAB_OPENED AND NOT IFC_GRAB_CLOSED THEN
            dlog( Txt:='fbGrabber: Clamps fully opened', Lvl:=6 );
            ClampStatus := GSTS_OPENED;
        END_IF;


    GSTS_OPENED : (* Ganasce aperte *)
        (* Rispondo alla richiesta di chiusura o agguantamento *)
        IF Status=GSTS_CLOSING OR Status=GSTS_GRABBING THEN (* Close command *)
            dlog( Txt:='fbGrabber: Closing clamps', Lvl:=6 );
            ClampStatus := GSTS_CLOSING;
        (* Intercetto se invece è chiuso *)
        (* Nota: se 'IFC_GRAB_CLOSED=TRUE' è meglio ignorare 'IFC_GRAB_OPENED' *)
        ELSIF IFC_GRAB_CLOSED THEN
            dlog( Txt:='fbGrabber: !! Got IFC_GRAB_CLOSED', Lvl:=2 );
            ClampStatus := GSTS_CLOSED;
        END_IF;


    ELSE (* GSTS_UNKNOWN *)
        (* Vedo stato effettivo *)
        IF IFC_GRAB_CLOSED THEN ClampStatus := GSTS_CLOSED;
        ELSIF IFC_GRAB_OPENED THEN ClampStatus := GSTS_OPENED;
        (* Rispondo alle richieste di apertura e chiusura *)
        ELSIF Status=GSTS_CLOSING THEN ClampStatus := GSTS_CLOSING;
        ELSIF Status=GSTS_OPENING THEN ClampStatus := GSTS_OPENING;
        END_IF;

END_CASE; (* -- clamps state machine *)

(* -Attuazione uscite apertura/chiusura ganasce- *)
O_GRAB_CLOSE := OilActuation.Ready AND (ClampStatus>=GSTS_GRABBING OR ClampStatus=GSTS_CLOSING);
O_GRAB_OPEN := OilActuation.Ready AND (ClampStatus=GSTS_OPENING OR (ClampStatus=GSTS_OPENED AND vbGrabber_KeepOpen));



(* -- Main state machine -- *)
(* Per avere lo stato ritentivo, poichè non è possibile che 'Status' sia 'RETAIN'
Status := vnGrabber_Status; *)
CASE Status OF

    GSTS_GRABBED : (* Up and closed on glass *)
        (* Quando sono agguantato rispondo al comando di apertura *)
        IF vnGrabber_Cmd=GCMD_OPEN THEN
            Status := GSTS_OPENING;
        (* Controllo stato effettivo *)
        ELSIF UpStatus=TS_OFF AND ClampStatus=GSTS_CLOSED THEN (* Pinza bassa e chiusa *)
            dlog( Txt:='fbGrabber: ! Was grabbed, now Im closed', Lvl:=1 );
            Status := GSTS_CLOSED;
        END_IF;


    GSTS_GRABBING : (* Clamping glass *)
        IF ClampStatus=GSTS_CLOSED THEN
            vnGrabber_Cmd := GCMD_NONE; (* Reset comando *)
            dlog( Txt:='fbGrabber: !! No glass to grab', Lvl:=1 );
            SET_MSG(MSG_GRABBER_NOGLASS,'MSG_GRABBER_NOGLASS',0);
            vnGrabber_Cmd := GCMD_OPEN;
            Status := GSTS_OPENING;
        ELSIF ClampStatus=GSTS_GRABBED THEN
            vnGrabber_Cmd := GCMD_NONE; (* Reset comando *)
            Status := GSTS_GRABBED;
        (* Abort del comando *)
        ELSIF vnGrabber_Cmd<>GCMD_GRAB THEN
            (* dlog( Txt:='fbGrabber: ! Grabbing aborted', Lvl:=4 ); *)
            Status := GSTS_UNKNOWN;
        END_IF;


    GSTS_OPENED : (* Up and opened *)
        (* Quando sono alto e aperto posso agguantare *)
        IF vnGrabber_Cmd=GCMD_GRAB THEN
            (* Ha senso solo se c'è del vetro *)
            (* Ottimizzazione: per vetri più spessi voglio aspettare meno
               Diciamo che:
                -Allo spessore massimo voglio attendere 'vqGrabber_Tgrab/2'
                -Allo spessore minimo (6 mm) voglio attendere 'vqGrabber_Tgrab'
                                           ^
                           vqGrabber_Tgrab |-----.
                                           |     ·`.
                                           |     ·  `.
                         vqGrabber_Tgrab/2 | · · · · ·`-----
                                          -+-----+-----+---->
                                           |     6     vqGrab_MaxGlassThckn   *)
            TGrab.pt := TO_UDINT( fnLinterp( x := TO_LREAL(vqGlass_Thckn),
                                             x1 := 6.38E3,
                                             y1 := TO_LREAL(vqGrabber_Tgrab),
                                             x2 := TO_LREAL(vqGrab_MaxGlassThckn),
                                             y2 := TO_LREAL(vqGrabber_Tgrab/2) ) );
            Status := GSTS_GRABBING;
        (* E rispondo al comando di chiusura *)
        ELSIF vnGrabber_Cmd=GCMD_CLOSE THEN
            Status := GSTS_CLOSING; (* Occhio, se c'è il vetro lo triti! *)
        ELSIF vnGrabber_Cmd=GCMD_OPEN THEN
            Status := GSTS_OPENING; (* Strano, ma lo faccio comunque *)
        (* Controllo stato *)
        ELSIF ClampStatus=GSTS_CLOSED AND AllowUp THEN
            dlog( Txt:='fbGrabber: ! Closed while up, reopening', Lvl:=1 );
            vnGrabber_Cmd := GCMD_OPEN;
            Status := GSTS_OPENING;
        END_IF;


    GSTS_OPENING : (* Rising and opening *)
        IF UpStatus=TS_ON AND ClampStatus=GSTS_OPENED THEN
            vnGrabber_Cmd := GCMD_NONE; (* Reset comando *)
            Status := GSTS_OPENED;
        (* Abort del comando *)
        ELSIF vnGrabber_Cmd=GCMD_NONE THEN
            (* dlog( Txt:='fbGrabber: ! Opening aborted', Lvl:=4 ); *)
            Status := GSTS_UNKNOWN;
        END_IF;


    GSTS_CLOSING : (* Descending and closing *)
        IF UpStatus=TS_OFF AND ClampStatus=GSTS_CLOSED THEN
            vnGrabber_Cmd := GCMD_NONE; (* Reset comando *)
            Status := GSTS_CLOSED;
            (* Resetto un po' di messaggi *)
            RST_MSG(MSG_GRABBER_OUT);
            RST_MSG(MSG_GRABBER_NOGLASS);
        (* Abort del comando *)
        ELSIF vnGrabber_Cmd=GCMD_NONE THEN
            (* dlog( Txt:='fbGrabber: ! Closing aborted', Lvl:=4 ); *)
            Status := GSTS_UNKNOWN;
        END_IF;


    GSTS_CLOSED : (* Down and closed *)
        (* Rispondo al comando di apertura *)
        IF vnGrabber_Cmd=GCMD_OPEN AND AllowUp THEN
            Status := GSTS_OPENING;
        ELSIF vnGrabber_Cmd=GCMD_CLOSE THEN
            Status := GSTS_CLOSING; (* Strano, ma lo faccio comunque *)
        (* Controllo stato effettivo *)
        ELSIF UpStatus<>TS_OFF OR ClampStatus<>GSTS_CLOSED THEN
            Status := GSTS_UNKNOWN;
        END_IF;


    ELSE (* GSTS_UNKNOWN *)
        (* Stato sconosciuto, cerca di capire dove sono *)
        (* Controllo stato effettivo *)
        IF UpStatus=TS_ON THEN (* Pinza alta *)
            IF ClampStatus=GSTS_OPENED THEN (* Pinza alta e completamente aperta *)
                Status := GSTS_OPENED;
            ELSIF ClampStatus=GSTS_CLOSED THEN (* Pinza alta e completamente chiusa *)
                (* Se le ganasce sono chiuse, non ci può essere vetro, quindi è sicuro comandare una discesa *)
                IF Allow THEN
                    dlog( Txt:='fbGrabber: ! Up and closed, going down', Lvl:=1 );
                    vnGrabber_Cmd := GCMD_CLOSE;
                END_IF;
            ELSE (* Pinza alta e ganasce non si sa dove *)
                (* Mah, in questi casi meglio aprire, tanto sono già alto, potrebbe essere agguantata *)
                IF Allow THEN
                    dlog( Txt:='fbGrabber: ! Up and not closed, opening', Lvl:=1 );
                    vnGrabber_Cmd := GCMD_OPEN;
                END_IF;
            END_IF;
        ELSIF UpStatus=TS_OFF THEN
            IF ClampStatus=GSTS_CLOSED THEN (* Pinza bassa e completamente chiusa *)
                Status := GSTS_CLOSED;
            ELSE (* Pinza bassa e ganasce non si sa dove *)
                (* Se è bassa e aperta non dovrebbero esserci problemi nel chiuderla *)
                IF Allow THEN
                    dlog( Txt:='fbGrabber: ! Down and not closed, closing', Lvl:=1 );
                    vnGrabber_Cmd := GCMD_CLOSE;
                END_IF;
            END_IF;
        END_IF;
        (* Rispondo ai comandi di apertura e chiusura *)
        IF vnGrabber_Cmd=GCMD_OPEN AND AllowUp THEN Status:=GSTS_OPENING;
        ELSIF vnGrabber_Cmd=GCMD_CLOSE THEN Status:=GSTS_CLOSING; END_IF;

END_CASE; (* -- main state machine *)
(* vnGrabber_Status := Status; (* Ricorda lo stato *)


(* -- Compensazione agguantamento --
      Quando agguanto attivo questa uscita per alzare leggermente la ganascia inferiore *)
O_GRAB_CLOSE_COMP := Status>=GSTS_GRABBING;


(* -- Segnalazione a centralina di pinza in uso --
      se attivo la centralina ritarda l'inibizione dell'attuazione per permettere manovra di stop *)
O_SCU_GRABBER_ISON := O_GRAB_CLOSE_COMP; (* ...o è meglio NOT AtRest?  *)


(* -- Notifiche a bassa priorità -- *)
IF vbHeartBeat THEN

    (* Timeout salita/discesa *)
    SET_MSG_IF(TUpDownTimeout.q,MSG_GRABBER_UPDWNTOUT,'MSG_GRABBER_UPDWNTOUT',0);

    (* Timeout apertura/chiusura *)
    SET_MSG_IF(TOpenCloseTimeout.q,MSG_GRABBER_CLAMPTOUT,'MSG_GRABBER_CLAMPTOUT',0);

    (* Se l'attuatore apertura/chiusura è in protezione *)
    SET_MSG_IF(IPR_GRAB,MSG_GRABBER_HWFAULT,'IPR_GRAB',0);

END_IF;


(* -- Monitors -- *)
AtRest := Status=GSTS_CLOSED; (* AND (vbAx_NoStillChkAtRest OR Zg.Still) *)
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbBreakoutBar

{ DE:"Attuazione della barra di troncaggio principale" }

	VAR_INPUT
	Emulated : BOOL; { DE:"Non salire con la barra" }
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	END_VAR

	VAR_OUTPUT
	ID : INT := ID_BRKBAR; { DE:"Identificativo componente" }
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Barra a riposo" }
	IsDown : BOOL; { DE:"Barra bassa" }
	END_VAR

	VAR_EXTERNAL
	LowerCutZone_Algn : INT; { DE:"Spazio sotto il piano nell'area di taglio lato risc" }
	LowerCutZone_Dtch : INT; { DE:"Spazio sotto il piano nell'area di taglio lato stacco" }
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vnBrkBar_Cmd : INT; { DE:"Aziona barra di troncaggio del ponte di taglio (0:riposo 1:esci 2:esci+sali)" }
	vbBrkBar_SelHigh : BOOL; { DE:"Seleziona altezza salita barra" }
	vbBrkBar_Done : BOOL; { DE:"Sequenza barra di troncaggio effettuata" }
	vqBrkBar_RiseTime : DINT; { DE:"Tempo di salita barra [ms]" }
	vqBrkBar_T : DINT; { DE:"Tempo di barra alta per apertura vetro [ms]" }
	IFC_BAR_DOWN : BOOL; { DE:"Sensore barra di troncaggio in posizione bassa" }
	O_BAR_UP : BOOL; { DE:"Aziona salita barra di troncaggio" }
	O_BAR_SEL_HIGH : BOOL; { DE:"Seleziona posizione alta della barra di troncaggio (1:più alta)" }
	IFC_BAR_SHIFT_IN : BOOL; { DE:"Sensore barra di troncaggio rientrata orizzontalmente" }
	IFC_BAR_SHIFT_OUT : BOOL; { DE:"Sensore barra di troncaggio uscita orizzontalmente" }
	O_BAR_SHIFT_SET : BOOL; { DE:"Aziona bistabile per uscita orizzontale della barra di troncaggio" }
	O_BAR_SHIFT_RST : BOOL; { DE:"Aziona bistabile per rientro orizzontale della barra di troncaggio" }
	vqBrkBar_MidShift_Dist : DINT; { DE:"Spostamento orizzontale intermedio barra (doppio cilindro) [um]" }
	vbBrkBar_MidShift : BOOL; { DE:"Seleziona posizione orizzontale intermedia (doppio cilindro)" }
	IFC_BAR_SHIFT1_IN : BOOL; { DE:"Cilindro piccolo aggiuntivo uscita barra contratto (doppio cilindro)" }
	IFC_BAR_SHIFT1_OUT : BOOL; { DE:"Cilindro piccolo aggiuntivo uscita barra esteso (doppio cilindro)" }
	O_BAR_SHIFT1_SET : BOOL; { DE:"Estendi cilindro piccolo aggiuntivo uscita barra (doppio cilindro)" }
	O_BAR_SHIFT1_RST : BOOL; { DE:"Contrai cilindro piccolo aggiuntivo uscita barra (doppio cilindro)" }
	END_VAR

	VAR
	TRiseDelay : Ton; { DE:"Timer minima attesa salita" }
	TBreakTime : Ton; { DE:"Timer BreakTime" }
	InOut_Status : INT; { DE:"Stato generico uscita orizzontale" }
	InOut : fbOnOffSeq; { DE:"Sequenze movimento orizzontale cilindro principale" }
	InOut1 : fbOnOffSeq; { DE:"Sequenze movimento orizzontale cilindro piccolo aggiuntivo" }
	END_VAR

	{ CODE:ST }(*    fbBreakoutBar (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Main breakout bar of laminated cutting system.
      Servizio di attuazione della barra di troncaggio
      della zona taglio.
      Risorse che può occupare:
        .'LowerCutZone_Dtch' (zona taglio bassa lato stacco - collisione carr inf)
        .'LowerCutZone_Algn' (zona taglio bassa lato risc - collisione lampada)

      SIGNALS
      ----------------------------------------------
                   ______      up
        Cmd  __――――      ―――__ out
        Done ____________――――― (ok)
        Done _________________ (error)

      DETAILS
      ----------------------------------------------
      La barra di troncaggio è solidale al modulo
      di stacco, essa va usata solo con stacco in
      una posizione ben determinata (in genere parcheggio).

      La sequenza è la seguente:
       .La barra esce orizzontalmente per andare nella zona
        di salita
       .Quando è totalmente uscita la barra sale
       .Una volta alta la barra deve attendere un certo tempo
        in base ai parametri materiale
       .La barra scende
       .Quando è totalmente scesa, rientra orizzontalmente

      I movimenti sono due:
       .Rientra/Esci: Una valvola bistabile aziona uno
                      o più cilindri che spostano la barra
                      orizzontalmente
       .Sali/Scendi:  Una valvola monostabile aziona il
                      cilindro della salita; questo deve
                      avvenire solo con barra uscita

      In certe macchine l'attuazione del movimento orizzontale
      consta di due cilindri in cascata, comandati da due bistabili:
        ┌───────┬───────┐
        │ SHIFT │ SHIFT1│
        ├───────┼───────┼──────────────────────┐
        │ RESET │ RESET │ Completamente dentro │
        ├───────┼───────┼──────────────────────┤
        │ SET   │ RESET │ Posizione intermedia │
        ├───────┼───────┼──────────────────────┤
        │ RESET │ SET   │ Non usata            │
        ├───────┼───────┼──────────────────────┤
        │ SET   │ SET   │ Completamente fuori  │
        └───────┴───────┴──────────────────────┘
*)


(* ---- Gestione uscita orizzontale ---- *)

(* -- Cilindro principale -- *)
InOut( is_on:=IFC_BAR_SHIFT_OUT, is_off:=IFC_BAR_SHIFT_IN );
(* Per non stressare le bistabili:
PulseTrain : fbPulseTrain; { DE:"Pulses train" }
PulseTrain( in:=I_NOTSET, T:=2000, pt:=1000 );
O_SET := PulseTrain.q; *)
O_BAR_SHIFT_SET  := InOut.Status=TS_GOINGON;
O_BAR_SHIFT_RST  := InOut.Status=TS_GOINGOFF;

(* -- Cilindro singolo/doppio -- *)
IF vqBrkBar_MidShift_Dist>0 THEN
    (* Barra con cilindretto aggiuntivo *)
    (* Quando è selezionata la posizione intermedia vbBrkBar_MidShift
       il cilindretto aggiuntivo deve rimanere contratto, altrimenti
       deve seguire il cilindro principale *)
    InOut1( in:=InOut.in AND NOT vbBrkBar_MidShift, is_on:=IFC_BAR_SHIFT1_OUT, is_off:=IFC_BAR_SHIFT1_IN );
    O_BAR_SHIFT1_SET := InOut1.Status=TS_GOINGON;
    O_BAR_SHIFT1_RST := InOut1.Status=TS_GOINGOFF;

    (* Stato movimento orizzontale *)
    IF vbBrkBar_MidShift THEN
        (* Il cilindretto aggiuntivo deve essere contratto! *)
        IF InOut1.Status=TS_OFF THEN
            (* Ok *)
            InOut_Status := InOut.Status;
        ELSE
            (* Meglio attendere che il cilindretto aggiuntivo sia contratto *)
            InOut_Status := TS_GOINGOFF;
        END_IF;
    ELSE
        (* I due cilindri si muovono insieme, compongo gli stati *)
        IF InOut.Status=TS_ON AND InOut1.Status=TS_ON THEN
            InOut_Status := TS_ON;
        ELSIF InOut.Status=TS_OFF AND InOut1.Status=TS_OFF THEN
            InOut_Status := TS_OFF;
        ELSIF InOut.Status=TS_GOINGON OR InOut1.Status=TS_GOINGON THEN
            InOut_Status := TS_GOINGON;
        ELSE
            InOut_Status := TS_GOINGOFF;
        END_IF;
    END_IF;
ELSE
    (* Barra con cilindro singolo *)
    O_BAR_SHIFT1_SET := FALSE;
    O_BAR_SHIFT1_RST := FALSE;

    (* Stato movimento orizzontale *)
    InOut_Status := InOut.Status;
END_IF;


(* ---- Sequenze principali ---- *)
TRiseDelay( in:=vnBrkBar_Cmd>1 AND Status=TS_WAITON AND (Emulated OR NOT IFC_BAR_DOWN), pt:=TO_UDINT(vqBrkBar_RiseTime) );
TBreakTime( in:=Status=TS_ON );
CASE Status OF

    TS_ON : (* Alta *)
        IF vnBrkBar_Cmd<2 THEN (* Tolto il comando, vai giù *)
            Status := TS_GOINGOFF; (* Attendi discesa *)
        ELSIF TBreakTime.q THEN (* Break done *)
            dlog( Txt:='fbBreakoutBar: Done (T=%ld s)', Lvl:=3, Val1:=vqBrkBar_T/1E3 );
            vbBrkBar_Done := TRUE;
            vnBrkBar_Cmd := 1; (* Scendi ma rimani fuori *)
            Status := TS_GOINGOFF; (* Attendi discesa *)
        END_IF;


    TS_WAITON : (* Fuori, attendi comando salita barra *)
        IF vnBrkBar_Cmd<1 THEN (* Tolto il comando *)
            Status := TS_GOINGOFF; (* Assicura discesa *)
        ELSIF TRiseDelay.q THEN
            dlog( Txt:='fbBreakoutBar: Up (H=%d)', Lvl:=3, Val1:=TO_DINT(O_BAR_SEL_HIGH) );
            Status := TS_ON; (* Alta *)
        END_IF;


    TS_GOINGON : (* Attendi l'uscita orizzontale della barra *)
        IF vnBrkBar_Cmd<1 THEN (* Tolto il comando *)
            InOut.in := FALSE; (* Rientra *)
            Status := TS_WAITOFF; (* Attendi rientro *)
        ELSIF InOut_Status=TS_ON THEN (* Barra uscita *)
            Status := TS_WAITON; (* Attendi comando salita *)
        END_IF;


    TS_GOINGOFF : (* Attendendo discesa barra *)
        IF IFC_BAR_DOWN THEN (* Barra scesa *)
            IF vnBrkBar_Cmd>0 AND Allow THEN
                Status := TS_WAITON; (* Attendi comando salita *)
            ELSE
                InOut.in := FALSE; (* Rientra *)
                Status := TS_WAITOFF; (* Attendi rientro *)
            END_IF;
        END_IF;


    TS_WAITOFF : (* Attendi il rientro orizzontale barra *)
        IF InOut_Status=TS_OFF THEN (* Barra rientrata *)
            vbBrkBar_MidShift := FALSE; (* Eat *)
            Status := TS_OFF;
            (* Libero risorse acquisite *)
            IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=0; END_IF;
            IF LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=0; END_IF;
        END_IF;


    TS_OFF : (* Barra a riposo *)
        IF vnBrkBar_Cmd>0 AND Allow THEN
            (* Cerco di acquisire le risorse "zona taglio bassa lato risc e stacco" *)
            IF LowerCutZone_Algn<>ID AND LowerCutZone_Algn=0 THEN LowerCutZone_Algn:=ID; END_IF;
            IF LowerCutZone_Dtch<>ID AND LowerCutZone_Dtch=0 THEN LowerCutZone_Dtch:=ID; END_IF;
            (* Controlla di aver acquisito le risorse... *)
            IF LowerCutZone_Algn=ID AND LowerCutZone_Dtch=ID THEN
                vbBrkBar_Done := FALSE; (* Inizializza risultato *)
                TBreakTime.pt := TO_UDINT(vqBrkBar_T);
                dlog( Txt:='fbBreakoutBar: Out (mid=%d)', Lvl:=3, Val1:=TO_DINT(vbBrkBar_MidShift) );
                InOut.in := TRUE; (* Esci *)
                Status := TS_GOINGON; (* Attendi uscita *)
            ELSE (* ...Altrimenti aspetta che si liberino *)
                IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=0; END_IF;
                IF LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=0; END_IF;
            END_IF;
        ELSIF NOT IFC_BAR_DOWN THEN
            dlog( Txt:='fbBreakoutBar: ! Lost IFC_BAR_DOWN', Lvl:=3 );
            Status := TS_ON;
        ELSIF InOut_Status<>TS_OFF THEN
            dlog( Txt:='fbBreakoutBar: ! Not in (%d)', Lvl:=3, Val1:=TO_DINT(InOut_Status) );
            InOut.in := FALSE; (* Rientra *)
            Status := TS_WAITOFF;
        ELSE
            O_BAR_SEL_HIGH := vbBrkBar_SelHigh; (* Seleziona posizione alta/bassa *)
        END_IF;
END_CASE;


(* -- Gestione salita/discesa -- *)
O_BAR_UP := Status>=TS_WAITON AND vnBrkBar_Cmd>1 AND NOT Emulated;


(* -- Monitors -- *)
AtRest := Status=TS_OFF AND InOut_Status=TS_OFF;
IsDown := Status<TS_ON AND IFC_BAR_DOWN AND NOT O_BAR_UP; (* Segnale barra bassa *)
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;
END_FUNCTION_BLOCK




FUNCTION_BLOCK fbHeatLamp

{ DE:"Lampada riscaldatore PVB" }

	VAR_INPUT
	Emulated : BOOL; { DE:"Non accendere la lampada" }
	Allow : BOOL; { DE:"Consenso per stare fuori" }
	AllowGoUp : BOOL; { DE:"Consensi per uscire" }
	AllowGoDwn : BOOL; { DE:"Consensi per rientrare" }
	AllowTurnOn : BOOL; { DE:"Consensi da attendere per l'accensione" }
	SelBoth : BOOL; { DE:"Accendi anche secondo modulo (banda alta)" }
	InOutDelay : UDINT := 500; { DE:"Minima attesa per movimento uscita-rientro [ms]" }
	END_VAR

	VAR_OUTPUT
	ID : INT := ID_HEATLAMP; { DE:"Identificativo componente" }
	Status : INT; { DE:"Stato della lampada" }
	AtRest : BOOL; { DE:"Lampada a riposo" }
	END_VAR

	VAR_EXTERNAL
	LowerCutZone_Algn : INT; { DE:"Spazio sotto il piano nell'area di taglio lato risc" }
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	IFC_LAMP1_UP : BOOL; { DE:"Sensore posizione alta riscaldatore 1" }
	IFC_LAMP1_DOWN : BOOL; { DE:"Sensore posizione bassa riscaldatore 1" }
	IFC_LAMP2_UP : BOOL; { DE:"Sensore posizione alta riscaldatore 2" }
	IFC_LAMP2_DOWN : BOOL; { DE:"Sensore posizione bassa riscaldatore 2" }
	O_LAMP1_ON : BOOL; { DE:"Accendi riscaldatore 1" }
	O_LAMP2_ON : BOOL; { DE:"Accendi riscaldatore 2" }
	vqLamp_MaxTimeOut : DINT; { DE:"Massimo tempo di accensione con lampada fuori [ms]" }
	vqLamp_MaxTimeIn : DINT; { DE:"Massimo tempo di accensione con lampada dentro [ms]" }
	vbLampOut_Cmd : BOOL; { DE:"Aziona uscita lampada riscaldamento PVB (0:dentro 1:fuori)" }
	vbLampOn_Cmd : BOOL; { DE:"Accendi lampada riscaldamento PVB" }
	vnLamp_Seq : INT; { DE:"Sequenza lampada (0:init 1:tempo1 2:tempo2)" }
	vqLamp_T1 : DINT; { DE:"Tempo 1 sequenza riscaldamento con lampada [ms]" }
	vqLamp_T2 : DINT; { DE:"Tempo 2 sequenza riscaldamento con lampada [ms]" }
	vqLamp_TimeToEnd : DINT; { DE:"Tempo rimanente fase riscaldamento corrente [s]" }
	vbLamp_SelBoth : BOOL; { DE:"Accendi anche lampada banda alta" }
	vbHeatLamp_ManCmd : BOOL; { DE:"Comando manuale lampada" }
	vqT_heat_add : DINT; { DE:"Tempo riscaldamento addizionale per ciclo rifilo  [ms]" }
	vbFeat_FixedCarriages : BOOL; { DE:"Macchina con carrelli vincolati" }
	vbLamp_BlocksCarrInf : BOOL; { DE:"La lampada sta bloccando il movimento del carrello inferiore" }
	END_VAR

	VAR
	TInOutDelay : Ton; { DE:"Minima attesa per salita/discesa [ms]" }
	THeatTime : Ton; { DE:"Timer riscaldamento" }
	TMaxOn : Ton; { DE:"Massimo tempo di accensione" }
	ManCmd : fbEdges; { DE:"Comando manuale" }
	END_VAR

	{ CODE:ST }(*    fbHeatLamp (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Servizio di attuazione della lampada/e per
      riscaldamento plastico.
      Risorse che può occupare:
        .'LowerCutZone_Algn' (zona taglio bassa lato riscontri)

      DETAILS
      ----------------------------------------------
      La lampada è divisa in due moduli, la salita
      e rientro è un'unica attuazione con due
      cilindri (sono montati due sensori per ogni
      cilindro).
      L'accensione e spegnimento è indipendente
      per entrambi i moduli e può essere anticipata
      rispetto il movimento di uscita.

      NOTES
      ----------------------------------------------
      Essendo questo un servizio finale rispondo
      direttamente ai comandi 'vbLampOut_Cmd' e
      'vbLampOn_Cmd' in modo da poterli resettare
      e dare un feedback immediato.
*)

(* -- State machine -- *)
TInOutDelay( in:=Status=TS_GOINGON OR Status=TS_GOINGOFF, pt:=InOutDelay );
THeatTime( in:=(Status=TS_ON) );

CASE Status OF

    TS_ON : (* Lampada alta e accesa *)
        IF NOT Allow OR NOT vbLampOut_Cmd THEN
            (* É caduto il consenso per stare su oppure ho tolto il comando *)
            vbLampOn_Cmd := FALSE; (* Spengo la lampada *)
            Status := TS_WAITON; (* Vedi se rientrare *)
        ELSIF NOT vbLampOn_Cmd THEN
            (* Lampada spenta *)
            Status := TS_WAITON;
        ELSE
            (* Controllo il tempo di riscaldamento *)
            IF THeatTime.q THEN
                dlog( Txt:='fbHeatLamp: Heat phase %d done (%ld s)', Lvl:=5, Val1:=TO_DINT(vnLamp_Seq), Val2:=TO_DINT(THeatTime.pt/1E3));
                (* Riscaldamento avvenuto, passo al successivo *)
                vnLamp_Seq := vnLamp_Seq + 1;
                (* Tempo accodato successivo, ne ho solo 1 *)
                IF vnLamp_Seq=2 THEN
                    THeatTime.pt := TO_UDINT(vqLamp_T2);
                    Status := TS_WAITON; (* Serve per resettare il timer *)
                ELSE
                    dlog( Txt:='fbHeatLamp: Seq done (%d)', Lvl:=5, Val1:=TO_DINT(vnLamp_Seq));
                    (* Spengo e faccio scendere? *)
                    vbLampOn_Cmd := FALSE; (* Spengo *)
                    vbLampOut_Cmd := FALSE; (* Torna dentro *)
                    (* Status := TS_WAITON; (* Vedi se rientrare, oppure per fare prima: *)
                    Status := SEL(AllowGoDwn, TS_WAITON, TS_GOINGOFF);
                END_IF;
            END_IF;
        END_IF;


    TS_WAITON : (* Lampada alta *)
        IF AllowGoDwn AND (NOT Allow OR NOT vbLampOut_Cmd) THEN
            vbLampOut_Cmd := FALSE; (* Assicuro reset comando *)
            Status := TS_GOINGOFF; (* Attendi rientro *)
        ELSIF vbLampOn_Cmd THEN
            (* Lampada accesa! *)
            IF vnLamp_Seq=0 THEN
                (* Inizio della sequenza, primo tempo accodato *)
                vnLamp_Seq := 1;
                THeatTime.pt := TO_UDINT(vqLamp_T1);
            END_IF;
            dlog( Txt:='fbHeatLamp: Start heat phase %d (%ld s)', Lvl:=5, Val1:=TO_DINT(vnLamp_Seq), Val2:=TO_DINT(THeatTime.pt/1E3));
            Status := TS_ON;
        ELSIF IFC_LAMP1_DOWN AND IFC_LAMP2_DOWN AND NOT IFC_LAMP1_UP AND NOT IFC_LAMP2_UP AND NOT vbLampOut_Cmd THEN
            (* Rilevata lampada già effettivamente bassa (riavvio) *)
            Status := TS_GOINGOFF;
        END_IF;


    TS_GOINGON : (* Attendo salita lampada *)
        IF (NOT Allow OR NOT vbLampOut_Cmd) AND AllowGoDwn THEN
            (* É caduto il consenso o tolto il comando, torna dentro e notifica *)
            dlog( Txt:='fbHeatLamp: !! Rise aborted', Lvl:=2 );
            vbLampOut_Cmd := FALSE; (* Resetto il comando *)
            Status := TS_GOINGOFF; (* Attendi rientro *)
        ELSIF TInOutDelay.q AND IFC_LAMP1_UP AND IFC_LAMP2_UP THEN
            Status := TS_WAITON; (* Lampada salita *)
        END_IF;


    TS_GOINGOFF : (* Attendo discesa lampada *)
        vbLampOn_Cmd := FALSE; (* Quando rientro spengo automaticamente il filamento *)
        IF TInOutDelay.q AND IFC_LAMP1_DOWN AND IFC_LAMP2_DOWN THEN
            IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=0; END_IF; (* Libero risorsa acquisita *)
            Status := TS_OFF; (* Lampada rientrata *)
        END_IF;


    TS_WAITOFF : (* Situazione strana con lampada non dentro *)
        IF IFC_LAMP1_DOWN AND IFC_LAMP2_DOWN THEN
            IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=0; END_IF; (* Libero risorsa acquisita *)
            Status := TS_OFF; (* Lampada rientrata *)
        ELSIF IFC_LAMP1_UP OR IFC_LAMP2_UP THEN
            Status := TS_WAITON;
        END_IF;


    TS_OFF : (* Lampada a riposo *)
        IF vbLampOut_Cmd THEN
            vnLamp_Seq := 0; (* Inizializzo contatore fasi *)
            IF AllowGoUp THEN
                (* Cerco di acquisire la risorsa "zona taglio bassa lato risc" *)
                IF LowerCutZone_Algn<>ID AND LowerCutZone_Algn=0 THEN LowerCutZone_Algn:=ID; END_IF;
                (* Controlla di aver acquisito la risorsa *)
                IF LowerCutZone_Algn=ID THEN
                    dlog( Txt:='fbHeatLamp: Rising', Lvl:=3 );
                    TMaxOn.pt := TO_UDINT(vqLamp_MaxTimeOut); (* Quando esco il timeout è maggiore *)
                    Status := TS_GOINGON; (* Attendi l'uscita della lampada *)
                (* ELSE (* Altrimenti aspetta che si liberi *)
                END_IF;
            END_IF;
        ELSE
            TMaxOn.pt := TO_UDINT(vqLamp_MaxTimeIn); (* Quando sono dentro il timeout è minore *)
            IF IFC_LAMP1_UP OR IFC_LAMP2_UP THEN
                (* dlog( Txt:='fbHeatLamp: ! IFC_LAMP#_UP at rest', Lvl:=1 ); *)
                Status := TS_WAITON;
            ELSIF NOT IFC_LAMP1_DOWN OR NOT IFC_LAMP2_DOWN THEN
                (* dlog( Txt:='fbHeatLamp: ! Lost IFC_LAMP#_DOWN at rest', Lvl:=1 ); *)
                Status := TS_WAITOFF;
            END_IF;
        END_IF;
END_CASE; (* -- State machine *)


(* Diagnostica sensori * )
IF Status>=TS_WAITON THEN
    IF IFC_LAMP1_DOWN OR IFC_LAMP2_DOWN THEN
        dlog( Txt:='fbHeatLamp: ! IFC_LAMP#_DOWN while up', Lvl:=1 );
    ELSIF NOT IFC_LAMP1_UP OR NOT IFC_LAMP2_UP THEN
        dlog( Txt:='fbHeatLamp: ! Lost IFC_LAMP#_UP while up', Lvl:=1 );
    END_IF;
END_IF; *)


(* -Comando manuale lampada- *)
ManCmd( in:=vbHeatLamp_ManCmd );
IF ManCmd.rise AND AllowGoUp THEN
    (* Inizializzo... *)
    vqLamp_T1 := 0;
    vqLamp_T2 := SEL(vqT_heat_add>0, 10000, vqT_heat_add);
    vbLamp_SelBoth := TRUE;
    (* ...E dò il comando *)
    vbLampOn_Cmd := TRUE;
    vbLampOut_Cmd := TRUE;
ELSIF ManCmd.fall THEN
    vbLampOn_Cmd := FALSE;
    vbLampOut_Cmd := FALSE;
ELSIF vbHeatLamp_ManCmd AND NOT vbLampOn_Cmd THEN
    vbHeatLamp_ManCmd := FALSE;
END_IF;


(* Segnale lampada a riposo *)
AtRest := Status=TS_OFF;

(* -- Monitors -- *)
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

vqLamp_TimeToEnd := TO_DINT(THeatTime.pt - THeatTime.et); (* Tempo rimanente *)

(* Se il carrello inferiore è indipendente la lampada deve essere totalmente a riposo,
   altrimenti con carrelli vincolati essi possono muoversi se lampada non sale o scende *)
vbLamp_BlocksCarrInf := (Status=TS_GOINGON OR Status=TS_GOINGOFF) OR NOT (vbFeat_FixedCarriages OR AtRest);

(* Gestione accensione *)
(* La lampada deve uscire entro un certo tempo, soprattutto se accesa *)
TMaxOn( in:=O_LAMP1_ON OR O_LAMP2_ON );
IF TMaxOn.q THEN
    dlog( Txt:='fbHeatLamp: !! Heating timeout %ld s', Lvl:=1, Val1:=TO_DINT(TMaxOn.pt/1E3) );
    vbLampOn_Cmd := FALSE; (* Resetto comando accensione *)
END_IF;
O_LAMP1_ON := AllowTurnOn AND vbLampOn_Cmd AND NOT Emulated;
O_LAMP2_ON := SelBoth AND O_LAMP1_ON;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbCarrSup

{ DE:"Carrello superiore" }

	VAR_IN_OUT
	ToolsOff : BOOL; { DE:"Deactivate all tools" }
	Ext : fbExtraCarrSup; { DE:"Appendice passiva/traino del carrello superiore" }
	END_VAR

	VAR_INPUT
	Allow : BOOL; { DE:"Consenso alle operazioni del carrello" }
	Abort : BOOL; { DE:"Segnale di stop/annullamento sequenza" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Carrello parcheggiato fuori da area taglio" }
	AtHome : BOOL; { DE:"Carrello parcheggiato in posizione di home" }
	CutAreaFreed : BOOL; { DE:"Area taglio liberata" }
	ToolsAtRest : BOOL; { DE:"Tutti gli utensili sono a riposo" }
	YroomM : DINT; { DE:"Ingombro Y corrente indietro corpo carrello [um]" }
	YroomP : DINT; { DE:"Ingombro Y corrente avanti corpo carrello [um]" }
	ID : INT := ID_CARR_SUP; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vbAx_NoStillChkAtRest : BOOL; { DE:"Non controllare asse fermo nella condizione di parcheggio" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vnMach_Type : INT; { DE:"Tipo macchina" }
	vbFeat_FixedCarriages : BOOL; { DE:"Macchina con carrelli vincolati" }
	vbCarriages_Prepos : BOOL; { DE:"Preposiziona i carrelli all'inizio del lavoro" }
	vnCarrSup_Cmd : INT; { DE:"Comando carrello superiore (vedi 'CMD_*')" }
	vbCarrSup_ParkOnEnd : BOOL; { DE:"Parcheggia il carrello alla fine dell'operazione" }
	vnCarrSup_Seq : INT; { DE:"Risultato sequenza carrello superiore" }
	vqCarrSup_Tgt : DINT; { DE:"Posizione obiettivo carrello superiore [um]" }
	vqCarrSup_Spd : DINT; { DE:"Velocità carrello superiore [um/min]" }
	vqCarrSup_Frc : DINT; { DE:"Limite forza carrello superiore [mN]" }
	UpperCutZone : INT; { DE:"Spazio sopra il piano all'interno del ponte di taglio" }
	LowerCutZone_Algn : INT; { DE:"Spazio sotto il piano nell'area di taglio lato risc" }
	LowerCutZone_Dtch : INT; { DE:"Spazio sotto il piano nell'area di taglio lato stacco" }
	vqCarr_CutAreaYbtm : DINT; { DE:"Ordinata inizio area non sicura carrelli [um]" }
	vqCarr_CutAreaYtop : DINT; { DE:"Ordinata fine area non sicura carrelli [um]" }
	vbLamp_BlocksCarrInf : BOOL; { DE:"La lampada sta bloccando il movimento del carrello inferiore" }
	vbCarr_PartAcc : BOOL; { DE:"Parzializza accelerazione carrelli in base a velocità" }
	vbCarr_ToolsOffOnErr : BOOL; { DE:"Alza subito utensili in caso di errori del movimento" }
	vbCarr_ParkFreesCutArea : BOOL; { DE:"Il comando parcheggio garantisce di liberare l'area taglio" }
	vnCarr_FreeMovPerc : INT; { DE:"Parzializzazione vel/acc movimenti liberi carrelli [%]" }
	vnCarr_ChgTgtDec : INT; { DE:"Decelerazione per ricerca bordo finale vetro [%]" }
	vqCarr_SafeSpd : DINT; { DE:"Velocità con pericolo collisioni [um/min]" }
	vnECarr_Acc : INT; { DE:"Parzializzazione accelerazione carrelli con traini agganciati [%]" }
	vqYmin : DINT; { DE:"Ordinata minima del bordo vetro [um]" }
	vqYmax : DINT; { DE:"Ordinata massima del bordo vetro [um]" }
	vqCarrSup_CurrDYroomM : DINT; { DE:"Ingombro Y effettivo (indietro) carrello superiore [um]" }
	vqCarrSup_CurrDYroomP : DINT; { DE:"Ingombro Y effettivo (avanti) carrello superiore [um]" }
	vqYsup_TopParkPos : DINT; { DE:"Posizione di parcheggio alto carrello superiore [um]" }
	vqYsup_BtmParkPos : DINT; { DE:"Posizione di parcheggio basso carrello superiore [um]" }
	vbFeat_CarrHomeOnTop : BOOL; { DE:"Macchina con parcheggio carrelli opposto ad operatore" }
	vqECarrSup_Length : DINT; { DE:"Dimensione traino superiore [um]" }
	vnECarrSup_Lock : INT; { DE:"Comando aggancio/sgancio traino carrello superiore" }
	vqYsup_LockPos : DINT; { DE:"Posizione di aggancio/sgancio traino carrello superiore [um]" }
	vqECarr_LockApproach : DINT; { DE:"Margine avvicinamento posizione di aggancio/sgancio traini [um]" }
	vqECarr_LockApproachSpd : DINT; { DE:"Velocità avvicinamento posizione di aggancio/sgancio traini [um/min]" }
	vbGrLe_NotLocked : BOOL; { DE:"Mola su traino e non agganciata a carrello superiore" }
	vbGrLe_CanBeUnlocked : BOOL; { DE:"Mola su traino e agganciata a carrello superiore" }
	Ysup : fbM32Axis; { DE:"Asse carrello superiore AX_YSUP" }
	IFC_YSUP_ZERO : BOOL; { DE:"Sensore azzeramento carrello superiore (0:engaged)" }
	IFC_YSUP_POSLIM : BOOL; { DE:"Finecorsa (min e max) carrello inferiore (1:engaged)" }
	IFC_YSUP_HOME : BOOL; { DE:"Sensore carrello superiore in posizione di riposo (area taglio libera)" }
	vqSubSheet_ProcHeight : DINT; { DE:"Dimensione trasversale lastra in arrivo (dopo la rotazione) [um]" }
	vnEdgeDet_Mode : INT; { DE:"Modo rilevazione bordi (0=single-sweep, 1=double-sweep, 2=accurate)" }
	vqEdgeDet_Margin : DINT; { DE:"Margine per rilevazione bordo vetro [um]" }
	vqEdgeDet_MaxErr : DINT; { DE:"Massima discrepanza ammessa delle catture di un bordo [um]" }
	vqEdgeDet_SweepSpd : DINT; { DE:"Velocità spazzate misurazione vetro [um/min]" }
	vqEdgeDet_OnTheFlySpd : DINT; { DE:"Velocità ricerca al volo [um/min]" }
	vbEdgeDet_AutoFlyUseDim : BOOL; { DE:"In automatico usa la dimensione lastra per il target della ricerca al volo" }
	vqEdgeDet_AcqSpd : DINT; { DE:"Velocità acquisizione fine [um/min]" }
	vbFeat_HasProbeSup2 : BOOL; { DE:"Sonda secondaria per ricerca al volo durante lavorazione" }
	vqCut_MinLength : DINT; { DE:"Altezza minima tagliabile [um]" }
	vqY_BtmEdge : DINT; { DE:"Quota misurata bordo vetro basso [um]" }
	vqY_TopEdge : DINT; { DE:"Quota misurata bordo vetro alto [um]" }
	vqCut_Length : DINT; { DE:"Lunghezza taglio effettiva [um]" }
	Tsup : fbTscore; { DE:"Testina di incisione superiore" }
	vbTsup_Cmd : BOOL; { DE:"Activate upper scoring head 'ID_TSUP'" }
	vnHoldPads_Cmd : INT; { DE:"Comando discesa tamponi fermavetro" }
	vqTsup_P : DINT; { DE:"Spinta incisione superiore [mN]" }
	vqTscore_BtmMargin : DINT; { DE:"Margine da bordo vetro basso incisione [um]" }
	vqTscore_TopMargin : DINT; { DE:"Margine da bordo vetro alto incisione [um]" }
	vqF_score_sup : DINT; { DE:"Forza pressione incisione superiore 'F-score-sup' [mN]" }
	vqV_score : DINT; { DE:"Velocità di incisione 'V-score' [um/min]" }
	vqTscore_ScoreYforce : DINT; { DE:"Forza massima che il carrello può erogare durante incisione [mN]" }
	vqMod_F_score_sup : DINT; { DE:"Modifier 'f-score-sup' [mN]" }
	vqMod_Tscore_BtmMargin : DINT; { DE:"Modifier [um]" }
	vqMod_Tscore_TopMargin : DINT; { DE:"Modifier [um]" }
	Rsup : fbRbrk; { DE:"Rotella di apertura superiore" }
	vbRsup_Cmd : BOOL; { DE:"Activate upper breakout wheel" }
	vqRsup_P : DINT; { DE:"Spinta rotella di apertura superiore [mN]" }
	vbRsup_OpenWithCWheel : BOOL; { DE:"Apri usando la controrotella" }
	vbRsup_SelC : BOOL; { DE:"Select counter-wheel" }
	vbRinf_SelC : BOOL; { DE:"Select counter-wheel" }
	vqRsup_DY : DINT; { DE:"Offset rotella apertura superiore [um]" }
	vqRbrk_BtmMargin : DINT; { DE:"Margine da bordo vetro basso rotelle di apertura [um]" }
	vqRbrk_TopMargin : DINT; { DE:"Margine da bordo vetro alto rotelle di apertura [um]" }
	vqF_brkwhl_sup : DINT; { DE:"Forza pressione rotella di apertura singola 'f-brkwhl-sup' [mN]" }
	vqV_brkwhl_sup : DINT; { DE:"Velocità rotella di apertura singola 'v-brkwhl-sup' [um/min]" }
	vqMod_Rbrk_BtmMargin : DINT; { DE:"Modifier [um]" }
	vqMod_Rbrk_TopMargin : DINT; { DE:"Modifier [um]" }
	vqRbrk_StartInside : DINT; { DE:"Inizio apertura interno rispetto il margine [um]" }
	vqRbrk_OpenYforce : DINT; { DE:"Forza massima che il carrello può erogare durante apertura con rotelle [mN]" }
	GrLe : fbGrLe; { DE:"Mola asportazione basso emissivo" }
	vnGrLe_Cmd : INT; { DE:"Activate low-E grinder (0:stop 1:spin 2:down 3:spin+down)" }
	vqGrLe_P : DINT; { DE:"Spinta sul vetro mola asportazione basso emissivo [mN]" }
	vqGrLe_DY : DINT; { DE:"Offset mola basso emissivo [um]" }
	vqGrLe_BtmMargin : DINT; { DE:"Margine da bordo vetro basso molatura Low-E [um]" }
	vqGrLe_TopMargin : DINT; { DE:"Margine da bordo vetro alto molatura Low-E [um]" }
	vqF_lowe : DINT; { DE:"Forza pressione mola basso emissivo 'f-lowe' [mN]" }
	vqV_lowe : DINT; { DE:"Velocità mola basso emissivo 'v-lowe' [um/min]" }
	vqMod_GrLe_BtmMargin : DINT; { DE:"Modifier [um]" }
	vqMod_GrLe_TopMargin : DINT; { DE:"Modifier [um]" }
	BladeSup : fbPvbBladeSup; { DE:"Lametta superiore taglio plastico" }
	vnBladeSup_Cmd : INT; { DE:"Comando a lametta PVB superiore" }
	vbLampOut_Cmd : BOOL; { DE:"Aziona uscita lampada riscaldamento PVB" }
	vqBladeSup_DY : DINT; { DE:"Offset lametta PVB su carrello superiore [um]" }
	vbBlade_Through : BOOL; { DE:"Segnale sfondamento plastico" }
	vbBladeSup_Jammed : BOOL; { DE:"Segnale lametta superiore incagliata" }
	vqBlade_BtmMargin : DINT; { DE:"Margine da bordo vetro basso lametta [um]" }
	vqBlade_TopMargin : DINT; { DE:"Margine da bordo vetro alto lametta [um]" }
	vqPvbThckn : DINT; { DE:"Spessore dichiarato plastico [um]" }
	vbBlade_WaitFinalPull : BOOL; { DE:"Dopo sfondamento attendi movimento finale stacco" }
	vqBlade_MaxPosErr : DINT; { DE:"Massimo errore inseguimento ammesso durante taglio plastico [um]" }
	vqBlade_StuckPosErr : DINT; { DE:"Errore inseguimento per rilevazione lametta inceppata [um]" }
	vqBlade_UnjamForce : DINT; { DE:"Forza per disincastrare la lametta [mN]" }
	vqBlade_UnjamMove : DINT; { DE:"Ampiezza movimento per disincastrare la lametta [um]" }
	vqBlade_Speed : DINT; { DE:"Velocità durante taglio PVB [um/min]" }
	vnBlade_Accel : INT; { DE:"Parzializzazione accelerazione durante taglio PVB [%]" }
	vqBlade_CutYforce : DINT; { DE:"Forza del carrello durante taglio PVB per ogni decimo di plastico [mN/0.1mm]" }
	vnBlade_PrbTries : INT; { DE:"Numero di tentativi per passare al secondo tasteggio" }
	vqBlade_PrbMargin : DINT; { DE:"Margine dal bordo del primo tasteggio [um]" }
	vqBlade_PrbDelta : DINT; { DE:"Spostamento verso l'interno dei tentativi successivi [um]" }
	vqBlade_Tdelay : DINT; { DE:"Tempo attesa tasteggio successivo [ms]" }
	vqBlade_SliceDelta : DINT; { DE:"Movimento orizzontale durante tasteggio [um]" }
	vqBlade_SliceSpeed : DINT; { DE:"Velocità affettatura durante tasteggio [um/min]" }
	vbBlade_SliceKeepOn : BOOL; { DE:"Non alzare lametta durante tasteggio" }
	vbBlade_NoWaitUp : BOOL; { DE:"Vai direttamente in parcheggio dopo taglio PVB" }
	O_AIRBLOW_SUP : BOOL; { DE:"Ugello soffio polvere su carrello superiore" }
	vbDustBlow_Cmd : BOOL; { DE:"Soffio polvere durante ricerca lastra" }
	END_VAR

	VAR
	MoveTo : EN_AXIS_MV_CMD := MV_DONE; { DE:"Servizio movimentazione asse carrello" }
	Probe1 : fbProbe; { DE:"Primary probe latches service" }
	Probe2 : fbProbe; { DE:"Secondary probe latches service (vbFeat_HasProbeSup2)" }
	try_count : INT; { DE:"Contatore spazzate ricerca/tentativi lametta" }
	fly_fall_latch : DINT; { DE:"Cattura posizione bordo finale vetro [um]" }
	btm_latch : DINT; { DE:"Cattura posizione bordo basso vetro [um]" }
	top_latch : DINT; { DE:"Cattura posizione bordo alto vetro [um]" }
	btm_meas : DINT; { DE:"Misura posizione bordo basso vetro [um]" }
	top_meas : DINT; { DE:"Misura posizione bordo alto vetro [um]" }
	Y : DINT; { DE:"Quota y [um]" }
	Ybegin : DINT; { DE:"Quota di partenza dell'utensile [um]" }
	Yend : DINT; { DE:"Quota di arrivo dell'utensile [um]" }
	TBladeDelay : Ton; { DE:"Timer attesa tasteggio lametta PVB" }
	END_VAR

	{ CODE:ST }(*    fbCarrSup (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Logiche relative al carrello superiore come
      entità singola.
      I comandi singoli sono introdotti oltre a
      quelli del modulo di funzionamento coordinato
      dei carrelli 'fbCarriages' per permettere la
      sovrapposizione di movimenti singoli
      (es. porta un carrello in parcheggio e nel
      frattempo muovi l'altro).
      Risorse che può occupare:
        .'UpperCutZone' (zona taglio alta)
      Nel caso di carrelli vincolati ovviamente anche:
        .'LowerCutZone_Dtch' (zona taglio bassa lato stacco - collisione stacco)
        .'LowerCutZone_Algn' (zona taglio bassa lato risc - collisione lampada)

      NOTES
      ----------------------------------------------
      Essendo questo un servizio finale rispondo
      direttamente al comando 'vnCarrSup_Cmd' in modo
      da poterlo resettare e dare un feedback immediato.
*)


(* -- Manage stop signal -- *)
IF Abort THEN
    vnCarrSup_Cmd := CMD_STOP; (* Remove command *)
(* ELSIF Suspend THEN (* Could suspend? servirebbe fermare l'asse e partire dallo step precedente *)
END_IF;
(* Notify abort *)
IF (Status>STS_STOPPING AND Status<>CARSTS_GRLE_END AND MoveTo<>MV_WAITSTOP) AND vnCarrSup_Cmd=CMD_STOP THEN
    dlog( Txt:='fbCarrSup: !! Abort Sts=%d', Lvl:=3, Val1:=TO_DINT(Status) );
END_IF;



(* -- State machine -- *)
TBladeDelay( in:=Status=CARSTS_PVB_UP AND BladeSup.Stable, pt:=TO_UDINT(vqBlade_Tdelay) );
CASE Status OF
    (* ------------------------------------------------------------------- *)
    STS_MOVING : (* Movimento singolo libero *)
        IF MoveTo=MV_DONE THEN
            (* Ok, arrivato a destinazione, vediamo cosa dobbiamo fare *)
            CASE vnCarrSup_Cmd OF

                CARCMD_SCORE_FWD, CARCMD_SCORE_BCK :
                    IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                        (* Ricerca "al volo": Preparo le sonde
                           La sonda principale Probe1 rileva con un fronte di salita
                           il bordo iniziale, e con un fronte di discesa il bordo finale.
                           Una eventuale sonda secondaria Probe2, montata più avanti,
                           aiuta a rilevare con un fronte di discesa il bordo finale
                           con maggiore anticipo *)
                        Probe1( ProbeIdx:=IRQ_PROBESUP, AxIdx:=AX_YSUP, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                        Probe2( ProbeIdx:=IRQ_PROBESUP2, AxIdx:=AX_YSUP, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                        fly_fall_latch := NO_POS_UM; (* Bordo finale ignoto *)
                        try_count := 0; (* Inizializzo tentativi *)
                        Status := CARSTS_SRCH_FLY_INI;
                    ELSE
                        (* Arrivato alla quota di inizio incisione *)
                        (* Attivo testina *)
                        (* vbLubScore_Cmd := TRUE; *)
                        vqTsup_P := vqF_score_sup + vqMod_F_score_sup;
                        vqMod_F_score_sup := 0; (* Reset modificatore temporaneo *)
                        vbTsup_Cmd := TRUE;
                        Status := CARSTS_SCORE_INIT;
                    END_IF;

                CARCMD_OPEN_FWD, CARCMD_OPEN_BCK :
                    (* Arrivato alla quota di inizio apertura con rotella *)
                    (* Attivo rotella *)
                    vqRsup_P := vqF_brkwhl_sup;
                    vbRsup_SelC := vbRsup_OpenWithCWheel;
                    vbRinf_SelC := FALSE; (* Assicuro no controrotella altrimenti c'è il 'Synch' *)
                    vbRsup_Cmd:= TRUE;
                    (* Vediamo dove parto ad aprire *)
                    IF vqCarrSup_Tgt<>Ybegin THEN
                        (* Inizio ad aprire dentro, vado verso il bordo iniziale *)
                        dlog( Txt:='fbCarrSup: Inner opening at %ld', Lvl:=4, Val1:=vqCarrSup_Tgt/1E3 );
                        vqCarrSup_Tgt := Ybegin;
                    ELSE
                        (* Sono partito dal bordo iniziale, vado direttamente alla fine *)
                        vqCarrSup_Tgt := Yend;
                    END_IF;
                    Status := CARSTS_OPEN_INIT;

                CARCMD_SRCHGLASS_FWD, CARCMD_SRCHGLASS_BCK :
                    (* Arrivato alla quota iniziale di ricerca *)
                    (* Inizializzo e preparo la prima spazzata *)
                    try_count := 0; (* Inizializzo tentativi *)
                    btm_latch := 0; (* [um] *)
                    top_latch := 0; (* [um] *)
                    btm_meas := NO_POS_UM; (* Usati per rilevazione fine *)
                    top_meas := NO_POS_UM;
                    vqY_BtmEdge := NO_POS_UM; (* Inizializzo risultato ricerca *)
                    vqY_TopEdge := NO_POS_UM;
                    vqCut_Length := 0;
                    (* Attivo la sonda *)
                    Probe1( ProbeIdx:=IRQ_PROBESUP, AxIdx:=AX_YSUP, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                    Status := CARSTS_SRCH_SWEEP_INI;

                CARCMD_BLADE_FWD, CARCMD_BLADE_BCK :
                    (* Arrivato alla quota iniziale di tasteggio *)
                    (* Ysup.MaxPosErr := WTR_DISABLE; *)
                    dlog( Txt:='fbCarrSup: Blade tries at %ld mm', Lvl:=3, Val1:=Ysup.CurrPos/1E3 );
                    try_count := 0; (* Inizializzo tentativi *)
                    Status := CARSTS_PVB_DWN;

                CARCMD_GRLE_FWD, CARCMD_GRLE_BCK :
                    (* Se l'utensile è su traino e non è agganciato, errore! *)
                    IF vbGrLe_NotLocked THEN
                        dlog( Txt:='fbCarrSup: !! Trail not locked for low-E', Lvl:=1 );
                        Status := STS_ERROR;
                    ELSIF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                        (* Ricerca "al volo": Preparo le sonde *)
                        Probe1( ProbeIdx:=IRQ_PROBESUP, AxIdx:=AX_YSUP, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                        Probe2( ProbeIdx:=IRQ_PROBESUP2, AxIdx:=AX_YSUP, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                        fly_fall_latch := NO_POS_UM; (* Bordo finale ignoto *)
                        try_count := 0; (* Inizializzo tentativi *)
                        Status := CARSTS_SRCH_FLY_INI;
                    ELSE
                        (* Arrivato alla quota di inizio rimozione basso emissivo *)
                        (* Attivo mola *)
                        vqGrLe_P := vqF_lowe;
                        vnGrLe_Cmd := 3; (* spin+down *)
                        Status := CARSTS_GRLE_INIT;
                    END_IF;

                CMD_PARK, CARCMD_BTMPARK, CARCMD_TOPPARK :
                    (* Comandato un parcheggio: C'è un ulteriore movimentino da fare? *)
                    IF vqCarrSup_Tgt=Yend THEN
                        (* Arrivato alla posizione finale, fatto *)
                        vnCarrSup_Cmd := CMD_STOP;
                        vnCarrSup_Seq := SEQ_DONE;
                        Status := STS_IDLE;
                    ELSE
                        (* Vado alla posizione finale con un... *)
                        vqCarrSup_Tgt := Yend;
                        (* ...Movimentino personalizzato *)
                        Ysup.TgtSpd := vqECarr_LockApproachSpd; (* [um/min] *)
                        Ysup.AccPerc := 10; (* [%] *)
                        Ysup.DecPerc := 10; (* [%] *)
                        Ysup.OutFrc := 0; (* just move [mN] *)
                        Ysup.MaxPosErr := WTR_HITDET;
                        MoveTo := MV_TOOLMOVE;
                    END_IF;

                CARCMD_FULLPARK :
                    (* Comandato un parcheggio completo, vedi se ho completato *)
                    IF vqECarrSup_Length<>0 AND Ext.Locked>0 THEN
                        (* Traino ancora agganciato a carrello *)
                        IF vqCarrSup_Tgt=vqYsup_LockPos THEN
                            (* Arrivato alla quota di aggancio/sgancio *)
                            vnECarrSup_Lock := -1; (* Comanda sgancio *)
                            Status := CARSTS_TRAIL_LOCK;
                        ELSE
                            (* Arrivato alla quota di prossimità aggancio/sgancio,
                               vado a quella finale con un... *)
                            vqCarrSup_Tgt := vqYsup_LockPos;
                            (* ...Movimentino personalizzato *)
                            Ysup.TgtSpd := vqECarr_LockApproachSpd; (* [um/min] *)
                            Ysup.AccPerc := 10; (* [%] *)
                            Ysup.DecPerc := 10; (* [%] *)
                            Ysup.OutFrc := 0; (* just move [mN] *)
                            Ysup.MaxPosErr := WTR_HITDET;
                            MoveTo := MV_TOOLMOVE;
                        END_IF;
                    ELSE
                        (* Terminato? Alla fine devo arrivare in 'home' *)
                        IF Ysup.TgtPos=Ysup.HomePos THEN
                            vnCarrSup_Cmd := CMD_STOP;
                            vnCarrSup_Seq := SEQ_DONE;
                        END_IF;
                        Status := STS_IDLE;
                    END_IF;

                CARCMD_TRAIL_LOCK, CARCMD_TRAIL_UNLOCK :
                    IF vqCarrSup_Tgt=vqYsup_LockPos THEN
                        (* Arrivato alla quota di aggancio/sgancio *)
                        vnECarrSup_Lock := SEL(vnCarrSup_Cmd=CARCMD_TRAIL_LOCK,TO_INT(-1),INT#1);
                        Status := CARSTS_TRAIL_LOCK;
                    ELSE
                        (* Arrivato alla quota di prossimità aggancio/sgancio,
                           vado a quella finale con un... *)
                        vqCarrSup_Tgt := vqYsup_LockPos;
                        (* ...Movimentino personalizzato *)
                        Ysup.TgtSpd := vqECarr_LockApproachSpd; (* [um/min] *)
                        Ysup.AccPerc := 10; (* [%] *)
                        Ysup.DecPerc := 10; (* [%] *)
                        Ysup.OutFrc := 0; (* just move [mN] *)
                        Ysup.MaxPosErr := WTR_HITDET;
                        MoveTo := MV_TOOLMOVE;
                    END_IF;

                ELSE (* Terminiamo qui *)
                    vnCarrSup_Cmd := CMD_STOP;
                    vnCarrSup_Seq := SEQ_DONE;
                    Status := STS_IDLE;
            END_CASE;
        ELSIF MoveTo=MV_ERROR THEN
            (* dlog( Txt:='fbCarrSup: !! Free move error', Lvl:=6 ); *)
            Status := STS_ERROR;
        (* ELSE (* Wait move *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_PRBINIT : (* Preparo nuovo tentativo tasteggio *)
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF MoveTo<MV_WAITSTOP THEN
            vqCarrSup_Tgt := Ybegin; (* [um] *)
            IF vbBlade_SliceKeepOn THEN
                Ysup.TgtSpd := vqBlade_SliceSpeed;
                Ysup.AccPerc := vnBlade_Accel; (* [%] *)
                Ysup.DecPerc := 100; (* [%] *)
                Ysup.OutFrc := vqBlade_UnjamForce/2; (* [mN] *)
                Ysup.MaxPosErr := WTR_DEFAULT;
                MoveTo := MV_TOOLMOVE;
            ELSE
                MoveTo := MV_FREEMOVE;
            END_IF;
            Status := STS_MOVING; (* Proceed *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_DWN : (* Tasteggio - lametta giù *)
        IF vnCarrSup_Cmd=CMD_STOP OR IS_MSG(MSG_LAMP_ATRISK) THEN (* Abort sequence *)
            vnBladeSup_Cmd := CMD_STOP;
            Status := STS_ERROR;
        ELSE
            (* Spingi con lametta *)
            vnBladeSup_Cmd := BLCMD_CUTPVB;
            BladeSup();

            (* Attendo spinta lametta *)
            IF BladeSup.Status=BS_THROUGH THEN
                (* Ha sfondato il plastico! Nota: se try_count=0 era il primo tentativo *)
                vbBlade_Through := TRUE;
                dlog( Txt:='fbCarrSup: Blade passed through (try %d)', Lvl:=3, Val1:=TO_DINT(try_count) );
                (* Assicuro lampada giù e spenta *)
                vbLampOut_Cmd := FALSE;
                (* Ferma movimento di affettatura *)
                Ysup.Cmd := AXC_STOP_ENAB;
                (* Procedo a tagliare il plastico indietro verso bordo iniziale, tipicamente è un movimentino *)
                Status := CARSTS_PVB_CUT1INIT;
            ELSIF BladeSup.Status=BS_PUSHED THEN
                (* Si è appoggiata al vetro, ritentiamo *)
                vnBladeSup_Cmd := SEL(vbBlade_SliceKeepOn, CMD_STOP, BLCMD_PROBE);
                BladeSup();

                try_count := try_count + 1;
                IF try_count >= vnBlade_PrbTries THEN
                    dlog( Txt:='fbCarrSup: ! Tried %d times at pos %ld', Lvl:=3, Val1:=TO_DINT(try_count), Val2:=Ybegin/1E3 );
                    (* Ci spostiamo un po' in là e ritentiamo? *)
                    IF vnCarrSup_Cmd=CARCMD_BLADE_FWD AND Ybegin<(vqY_TopEdge-vqCut_Length/2) THEN
                        Ybegin := Ybegin + vqBlade_PrbDelta; (* tasteggio *)
                        Yend := Ybegin + vqBlade_SliceDelta; (* affettatura *)
                        (* Mi porto in posizione di inizio tasteggio con un movimento libero *)
                        Ysup.Cmd := AXC_STOP_ENAB; (* Ferma movimento di affettatura *)
                        Status := CARSTS_PVB_PRBINIT; (* Proceed *)
                    ELSIF vnCarrSup_Cmd=CARCMD_BLADE_BCK AND Ybegin>(vqY_TopEdge-vqCut_Length/2) THEN
                        Ybegin := Ybegin - vqBlade_PrbDelta; (* tasteggio *)
                        Yend := Ybegin - vqBlade_SliceDelta; (* affettatura *)
                        (* Mi porto in posizione di inizio tasteggio con un movimento libero *)
                        Ysup.Cmd := AXC_STOP_ENAB; (* Ferma movimento di affettatura *)
                        Status := CARSTS_PVB_PRBINIT; (* Proceed *)
                    ELSE
                        dlog( Txt:='fbCarrSup: !! Give up', Lvl:=3 );
                        Status := STS_ERROR;
                    END_IF;
                ELSE
                    (* Continua a provare, torna su *)
                    Status := CARSTS_PVB_UP;
                END_IF;
            END_IF;

            (* Movimento di affettatura: potrei sincronizzarmi con la discesa
               lametta ma è interessante lasciare uno sfasamento variabile *)
            IF MoveTo<MV_WAITSTOP THEN
                IF vqCarrSup_Tgt<>Yend THEN vqCarrSup_Tgt := Yend;
                ELSE vqCarrSup_Tgt := Ybegin; END_IF;
                Ysup.TgtSpd := vqBlade_SliceSpeed; (* [um/min] *)
                Ysup.AccPerc := vnBlade_Accel; (* [%] *)
                Ysup.DecPerc := 100; (* max [%] *)
                Ysup.OutFrc := (vqBlade_CutYforce/10) * (vqPvbThckn/10); (* [mN] *)
                Ysup.MaxPosErr := WTR_DISABLE;
                dlog( Txt:='fbCarrSup: Blade slicing to %ld mm (count %d)', Lvl:=5, Val1:=vqCarrSup_Tgt/1E3, Val2:=TO_DINT(try_count) );
                MoveTo := MV_TOOLMOVE;
            END_IF;

        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_UP : (* Tasteggio - lametta su *)
        vnBladeSup_Cmd := SEL(vbBlade_SliceKeepOn, CMD_STOP, BLCMD_PROBE);
        BladeSup();
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Attendo condizione per il tentativo successivo *)
        ELSIF TBladeDelay.q THEN
            Status := CARSTS_PVB_DWN;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_CUT1INIT : (* Preparo taglio plastico verso bordo iniziale *)
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF MoveTo<MV_WAITSTOP AND (vn[ivnStatus+ID_DTCH]=STS_IDLE OR NOT vbBlade_WaitFinalPull) THEN (* AND vn[ivnStatus+ID_HEATLAMP]=TS_OFF Potrei attendere lampada bassa  *)
            vbBlade_WaitFinalPull := FALSE; (* eat *)
            IF vnCarrSup_Cmd=CARCMD_BLADE_FWD THEN
                (* Verso avanti *)
                Ybegin := vqY_BtmEdge + vqBlade_BtmMargin - vqBladeSup_DY; (* [um] *)
                Yend := vqY_TopEdge - vqBlade_TopMargin - vqBladeSup_DY; (* [um] *)
            ELSE
                (* Verso indietro *)
                Ybegin := vqY_TopEdge - vqBlade_TopMargin - vqBladeSup_DY; (* [um] *)
                Yend := vqY_BtmEdge + vqBlade_BtmMargin - vqBladeSup_DY; (* [um] *)
            END_IF;
            vbBladeSup_Jammed := FALSE; (* Inizializzo segnale lametta incagliata *)
            vqCarrSup_Tgt := Ybegin; (* [um] *)
            Ysup.TgtSpd := vqBlade_Speed; (* [um/min] *)
            Ysup.AccPerc := vnBlade_Accel; (* [%] *)
            Ysup.DecPerc := 100; (* max [%] *)
            Ysup.OutFrc := (vqBlade_CutYforce/10) * (vqPvbThckn/10); (* [mN] *)
            (* Nota: la spinta verso il basso è 'BladeSup.Push' *)
            Ysup.MaxPosErr := vqBlade_MaxPosErr; (* [um] *)
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_PVB_CUT1;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_CUT1 : (* Taglio plastico verso bordo iniziale *)
        IF MoveTo<MV_WAITSTOP THEN
            IF vbBladeSup_Jammed THEN
                (* Ero incagliato, abortisco, lascio che il programma gestisca la cosa *)
                Status := STS_ERROR;
            ELSIF MoveTo=MV_DONE THEN
                (* Ok, ora devo tagliare verso bordo finale *)
                Status := CARSTS_PVB_CUT2INIT;
            ELSE
                dlog( Txt:='fbCarrSup: !! Blade cut to Ybtm error', Lvl:=2 );
                Status := STS_ERROR;
            END_IF;
        (* ELSE (* Wait move *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_CUT2INIT : (* Preparo taglio plastico verso bordo finale *)
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Attendo che stacco abbia completato l'ultimo tiro *)
        ELSIF vn[ivnStatus+ID_DTCH]=STS_IDLE OR NOT vbBlade_WaitFinalPull THEN
            vbBlade_WaitFinalPull := FALSE; (* eat *)
            (* Ok, ora vado verso bordo finale *)
            IF vbBlade_NoWaitUp AND
               ( (Yend>Ybegin AND Ysup.HomePos>Yend) OR
                 (Yend<Ybegin AND Ysup.HomePos<Yend) ) THEN
                (* Finisci direttamente in parcheggio *)
                vqCarrSup_Tgt := Ysup.HomePos; (* [um] *)
            ELSE
                (* Finisci normalmente al bordo finale *)
                vqCarrSup_Tgt := Yend; (* [um] *)
            END_IF;
            Ysup.TgtSpd := vqBlade_Speed; (* [um/min] *)
            Ysup.AccPerc := vnBlade_Accel; (* [%] *)
            Ysup.DecPerc := 100; (* max [%] *)
            Ysup.OutFrc := (vqBlade_CutYforce/10) * (vqPvbThckn/10); (* [mN] *)
            Ysup.MaxPosErr := vqBlade_MaxPosErr; (* [um] *)
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_PVB_CUT2;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_CUT2 : (* Taglio plastico verso bordo finale *)
        IF MoveTo<MV_WAITSTOP THEN
            (* Movimento terminato *)
            vnBladeSup_Cmd := CMD_STOP; (* Lametta via *)
            Status := CARSTS_PVB_END;
        ELSE (* Wait move *)
            (* Tengo monitorato l'errore di posizione *)
            IF ABS(Ysup.CurrPosErr) > vqBlade_StuckPosErr THEN
                vbBladeSup_Jammed := TRUE; (* Segnalo incagliamento lametta *)
                dlog( Txt:='fbCarrSup: !! Blade jammed (poserr=%ld mm)', Lvl:=2, Val1:=Ysup.CurrPosErr/1E3 );
                (* Ysup.Cmd := AXC_STOP_ENAB; (* Fermo il posizionamento, MoveTo andrà in MV_ERROR *)
                Ysup.Cmd := AXC_RESET; (* Resetto l'errore di inseguimento, MoveTo andrà in MV_ERROR *)
                (* Nota: l'asse tornerà 'AXS_READY' dopo non meno di tre cicli PLC *)
                Status := CARSTS_PVB_UNJAM;
            END_IF;
            (* Se 'vbBlade_NoWaitUp' e ho superato 'Yend' alzo lametta *)
            IF vnBladeSup_Cmd<>CMD_STOP AND vbBlade_NoWaitUp AND
               ( (Ysup.MovingFwd AND Ysup.CurrPos>=Yend) OR (Ysup.MovingBck AND Ysup.CurrPos<=Yend) ) THEN
                vnBladeSup_Cmd := CMD_STOP; (* Lametta via *)
                vnCarrSup_Seq := SEQ_DONE; (* Taglio lametta terminato *)

                (* Se manca ancora tanto, ripristino parametri movimento *)
                IF ABS(Ysup.TgtPos-Ysup.CurrPos)>500E3 THEN
                    Ysup.TgtSpd := TO_DINT(vnCarr_FreeMovPerc); (* [%] *)
                    Ysup.OutFrc := 0; (* [mN] *)
                    Ysup.MaxPosErr := WTR_DEFAULT;
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_UNJAM : (* Sblocca lametta *)
        IF MoveTo<MV_WAITSTOP AND Ysup.Status=AXS_READY AND Ysup.Cmd=AXC_STOP_ENAB AND Ysup.Still THEN
            IF vqBlade_UnjamMove<>0 THEN
                (* Pronto a muovere *)
                vnBladeSup_Cmd := BLCMD_PROBE; (* Tengo lametta bassa? *)
                (* Comando movimento verso bordo iniziale per disincastrare *)
                vqCarrSup_Tgt := MAX(Ybegin, Ysup.CurrPos - ABS(vqBlade_UnjamMove));  (* [um] *)
                Ysup.TgtSpd := vqBlade_Speed; (* [um/min] *)
                Ysup.AccPerc := vnBlade_Accel; (* [%] *)
                Ysup.DecPerc := 100; (* max [%] *)
                Ysup.OutFrc := vqBlade_UnjamForce; (* Forza per disincastrare [mN] *)
                (* Nota: la spinta verso il basso è 'BladeSup.Push' *)
                Ysup.MaxPosErr := vqBlade_UnjamMove/3; (* [um] *)
                MoveTo := MV_TOOLMOVE;
                Status := CARSTS_PVB_CUT1;
                dlog( Txt:='fbCarrSup: ! Blade unjam to %ld mm (err=%ld)', Lvl:=2, Val1:=vqCarrSup_Tgt/1E3, Val2:=Ysup.CurrPosErr/1E3 );
            ELSE
                dlog( Txt:='fbCarrSup: !! Blade jammed!', Lvl:=2 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_END : (* Finalizzazione taglio plastico *)
        (* Se qui assumo che movimento terminato *)
        vnBladeSup_Cmd := CMD_STOP; (* Assicuro lametta via *)
        (* Attendo lametta a riposo *)
        IF BladeSup.AtRest OR vbBlade_NoWaitUp THEN
            IF MoveTo=MV_DONE THEN
                dlog( Txt:='fbCarrSup: PVB cut Done', Lvl:=3 );
                vnCarrSup_Seq := SEQ_DONE;
                vnCarrSup_Cmd := CMD_STOP;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbCarrSup: !! PVB cut Error', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_FLY_INI : (* Preparazione ricerca "al volo" bordo inizio vetro *)
        (* Attendi sonde e asse pronto *)
        Probe1( Activate:=TRUE ); (* Sonda principale *)
        Probe2( Activate:=TRUE ); (* Eventuale sonda aggiuntiva per il bordo finale, 'vbFeat_HasProbeSup2' *)
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Probe1.Status>=PS_WAITMOVE AND Ysup.Status=AXS_READY THEN
            (* Pronto per ricercare, comando movimento master *)
            vqCarrSup_Tgt := Yend; (* [um] *)
            Ysup.TgtSpd := vqEdgeDet_OnTheFlySpd; (* [um/min] *)
            Ysup.AccPerc := 100; (* max [%] *)
            Ysup.DecPerc := 100; (* max [%] *)
            Ysup.OutFrc := 0; (* just move [mN] (per la ricerca non mi serve coppia) *)
            Ysup.MaxPosErr := WTR_HITDET;
            MoveTo := MV_TOOLMOVE;
            (* Direzione ricerca *)
            Probe1.Back := vqCarrSup_Tgt < Ysup.CurrPos;
            Probe2.Back := Probe1.Back;
            (* Proceed *)
            try_count := try_count + 1;
            Status := CARSTS_SRCH_FLY;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_FLY : (* Movimento ricerca "al volo" in corso *)
        Probe1(); (* Sonda principale *)
        Probe2(); (* Eventuale sonda aggiuntiva per il bordo finale, 'vbFeat_HasProbeSup2' *)

        (* Rilevo fin da subito anche il bordo finale con la sonda secondaria *)
        IF Probe2.NewFallLatch THEN (* => Probe2.LastFallLatch *)
            dlog( Txt:='fbCarrSup: Probe2 fall at %ld mm', Lvl:=4, Val1:=Probe2.LastFallLatch/1E3 );
            fly_fall_latch := Probe2.LastFallLatch;
            Probe2( Activate:=FALSE ); (* La sonda non serve più, prendo per buono il primo ed ignoro i successivi (più sicuro?) *)
        ELSIF Probe1.NewRiseLatch THEN (* => Probe1.LastRiseLatch *)
            dlog( Txt:='fbCarrSup: Probe1 rise at %ld mm', Lvl:=4, Val1:=Probe1.LastRiseLatch/1E3 );
            (* IF Probe1.SliversCount>0 THEN
                dlog( Txt:='fbCarrSup: SRCH_FLY: ! Found %d chips', Lvl:=2, Val1:=TO_DINT(Probe1.SliversCount));
                SET_MSG(REQ_CLEAN_CUTFLOOR,'REQ_CLEAN_CUTFLOOR',TO_DINT(Probe1.SliversCount));
            END_IF; *)
            (* Catturato il bordo iniziale del vetro! Vediamo se non è da scartare *)
            IF Probe1.LastRiseLatch >= (vqYmin-vqEdgeDet_Margin) THEN
                (* Memorizzo il bordo iniziale misurato *)
                IF Probe1.Back THEN vqY_TopEdge := Probe1.LastRiseLatch;
                ELSE                vqY_BtmEdge := Probe1.LastRiseLatch; END_IF;

                (* - Calcolo la quota iniziale della lavorazione - *)
                (* Incisione avanti *)
                IF vnCarrSup_Cmd=CARCMD_SCORE_FWD THEN
                    Ybegin := vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                (* Incisione indietro *)
                ELSIF vnCarrSup_Cmd=CARCMD_SCORE_BCK THEN
                    Ybegin := vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                (* Rimozione basso emissivo avanti *)
                ELSIF vnCarrSup_Cmd=CARCMD_GRLE_FWD THEN
                    Ybegin := vqY_BtmEdge + (vqGrLe_BtmMargin+vqMod_GrLe_BtmMargin) - vqGrLe_DY; (* [um] *)
                    vqMod_GrLe_BtmMargin := 0; (* Reset modificatore temporaneo *)
                (* Rimozione basso emissivo indietro *)
                ELSIF vnCarrSup_Cmd=CARCMD_GRLE_BCK THEN
                    Ybegin := vqY_TopEdge - (vqGrLe_TopMargin+vqMod_GrLe_TopMargin) - vqGrLe_DY; (* [um] *)
                    vqMod_GrLe_TopMargin := 0; (* Reset modificatore temporaneo *)
                ELSE (* Should never be here! *)
                    Status := STS_ERROR;
                    RETURN;
                END_IF;
                (* Cambio target ricerca al volo *)
                Ysup( TgtPos:=Ybegin, Flags:=0 ); (* Voglio tornare indietro se non fattibile *)
                Status := CARSTS_SRCH_FLY_END;
            ELSE
                dlog( Txt:='fbCarrSup: SRCH_FLY: ! Discarding %ld mm', Lvl:=3, Val1:=Probe1.LastRiseLatch/1E3 );
            END_IF;
        ELSIF MoveTo<MV_WAITSTOP THEN
            (* Ehm, arrivato a destinazione senza catture! *)
            (* IF try_count>3 THEN *)
            dlog( Txt:='fbCarrSup: !! Arrived to %ld without latches (Probe1.Status=%d)', Lvl:=1, Val1:=Ysup.CurrPos/1E3, Val2:=TO_DINT(Probe1.Status) );
            SET_MSG(MSG_SEARCHERROR,'MSG_SEARCHERROR',0);
            Status := STS_ERROR;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_FLY_END : (* Attendo arrivo in posizione *)
        IF MoveTo<MV_WAITSTOP THEN
            (* Movimento terminato *)
            IF MoveTo=MV_DONE THEN
                (* Carrello in quota di inizio lavorazione *)

                (* Ho già catturato il bordo finale? *)
                IF fly_fall_latch<>NO_POS_UM THEN
                    (* Memorizzo il bordo misurato *)
                    IF Probe2.Back THEN vqY_BtmEdge := fly_fall_latch;
                    ELSE                vqY_TopEdge := fly_fall_latch; END_IF;

                    (* Ora ho entrambi i bordi del vetro! *)
                    vqCut_Length := vqY_TopEdge - vqY_BtmEdge;
                    dlog( Txt:='fbCarrSup: Fly-Measured %ld-%ld=%ld mm', Lvl:=2, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqCut_Length/1E3 );

                    (* Le sonde non servono più *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );

                    (* Controllo misura *)
                    IF vqCut_Length<=0 THEN
                        dlog( Txt:='!!Bad measure', Lvl:=1);
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;

                    (* - Calcolo la quota finale della lavorazione - *)
                    (* Incisione avanti *)
                    IF vnCarrSup_Cmd=CARCMD_SCORE_FWD THEN
                        Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                    (* Incisione indietro *)
                    ELSIF vnCarrSup_Cmd=CARCMD_SCORE_BCK THEN
                        Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                    (* Rimozione basso emissivo avanti *)
                    ELSIF vnCarrSup_Cmd=CARCMD_GRLE_FWD THEN
                        Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqGrLe_TopMargin+vqMod_GrLe_TopMargin)) - vqGrLe_DY; (* [um] *)
                        vqMod_GrLe_TopMargin := 0; (* Reset modificatore temporaneo *)
                    (* Rimozione basso emissivo indietro *)
                    ELSIF vnCarrSup_Cmd=CARCMD_GRLE_BCK THEN
                        Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqGrLe_BtmMargin+vqMod_GrLe_BtmMargin)) - vqGrLe_DY; (* [um] *)
                        vqMod_GrLe_BtmMargin := 0; (* Reset modificatore temporaneo *)
                    ELSE (* Should never be here! *)
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;
                ELSE
                    (* Non ho ancora rilevato il bordo finale *)

                    (* - Decido la quota finale della lavorazione - *)
                    (* Incisione avanti *)
                    IF vnCarrSup_Cmd=CARCMD_SCORE_FWD THEN
                        IF vbEdgeDet_AutoFlyUseDim AND vbAutoMode THEN
                            Yend := MAX(vqY_BtmEdge, (vqY_BtmEdge+vqSubSheet_ProcHeight) - (vqTscore_TopMargin+vqMod_Tscore_TopMargin));
                        ELSE
                            Yend := vqYmax;
                        END_IF;
                    (* Incisione indietro *)
                    ELSIF vnCarrSup_Cmd=CARCMD_SCORE_BCK THEN
                        IF vbEdgeDet_AutoFlyUseDim AND vbAutoMode THEN
                            Yend := MIN(vqY_TopEdge, (vqY_TopEdge-vqSubSheet_ProcHeight) + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin));
                        ELSE
                            Yend := vqYmin;
                        END_IF;
                    (* Rimozione basso emissivo avanti *)
                    ELSIF vnCarrSup_Cmd=CARCMD_GRLE_FWD THEN
                        IF vbEdgeDet_AutoFlyUseDim AND vbAutoMode THEN
                            Yend := MAX(vqY_BtmEdge, (vqY_BtmEdge+vqSubSheet_ProcHeight) - (vqGrLe_TopMargin+vqMod_GrLe_TopMargin)) - vqGrLe_DY;
                        ELSE
                            Yend := vqYmax - vqGrLe_DY;
                        END_IF;
                    (* Rimozione basso emissivo indietro *)
                    ELSIF vnCarrSup_Cmd=CARCMD_GRLE_BCK THEN
                        IF vbEdgeDet_AutoFlyUseDim AND vbAutoMode THEN
                            Yend := MIN(vqY_TopEdge, (vqY_TopEdge-vqSubSheet_ProcHeight) + (vqGrLe_BtmMargin+vqMod_GrLe_BtmMargin)) - vqGrLe_DY;
                        ELSE
                            Yend := vqYmin - vqGrLe_DY;
                        END_IF;
                    ELSE (* Should never be here! *)
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;

                    (* Se non ci sono sonde sul vetro il bordo finale non potrà essere rilevato:
                       meglio dare errore, ci penserà il chiamante a gestire la cosa *)
                    IF (NOT Probe1.Input AND NOT vbFeat_HasProbeSup2) OR (NOT Probe2.Input AND vbFeat_HasProbeSup2) THEN
                        dlog( Txt:='fbCarrSup: !! Probe2 not on glass at %ld mm', Lvl:=2, Val1:=Ysup.CurrPos/1E3 );
                        SET_MSG(MSG_SEARCHERROR,'MSG_SEARCHERROR',0);
                        Ysup.Cmd := AXC_STOP_ENAB; (* Stop the movement *)
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;
                END_IF;
                dlog( Txt:='fbCarrSup: Fly range %ld|%ld mm', Lvl:=3, Val1:=Ybegin/1E3, Val2:=Yend/1E3 );

                (* - Attivo utensili - *)
                IF vnCarrSup_Cmd=CARCMD_SCORE_FWD OR vnCarrSup_Cmd=CARCMD_SCORE_BCK THEN
                    (* Attivo testina *)
                    (* vbLubScore_Cmd := TRUE; *)
                    vqTsup_P := vqF_score_sup + vqMod_F_score_sup;
                    vqMod_F_score_sup := 0; (* Reset modificatore temporaneo *)
                    vbTsup_Cmd := TRUE;
                    Status := CARSTS_SCORE_INIT;
                ELSIF vnCarrSup_Cmd=CARCMD_GRLE_FWD OR vnCarrSup_Cmd=CARCMD_GRLE_BCK THEN
                    (* Attivo mola *)
                    vqGrLe_P := vqF_lowe;
                    vnGrLe_Cmd := 3; (* spin+down *)
                    Status := CARSTS_GRLE_INIT;
                END_IF;
            ELSE
                dlog( Txt:='fbCarrSup: !! ChgTgt to Ybegin=%ld failed', Lvl:=1, Val1:=Ybegin/1E3 );
                Status := STS_ERROR;
            END_IF;
        ELSE
            (* Movimento in corso *)
            (* Se devo ancora catturare il bordo finale... *)
            IF fly_fall_latch=NO_POS_UM THEN
                (* ...Controllo se per caso lo leggo durante il riposizionamento! *)
                (* Sonda primaria *)
                Probe1();
                IF Probe1.NewFallLatch AND (Ysup.CurrSpd<0)=Probe1.Back THEN
                    dlog( Txt:='fbCarrSup: Probe1 fall at %ld mm', Lvl:=4, Val1:=Probe1.LastFallLatch/1E3 );
                    fly_fall_latch := Probe1.LastFallLatch;
                    (* Le sonde non servono più, prendo per buono il primo ed ignoro i successivi (più sicuro) *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;
                (* Sonda secondaria *)
                Probe2();
                IF Probe2.NewFallLatch AND (Ysup.CurrSpd<0)=Probe2.Back THEN
                    dlog( Txt:='fbCarrSup: Probe2 fall at %ld mm', Lvl:=4, Val1:=Probe2.LastFallLatch/1E3 );
                    fly_fall_latch := Probe2.LastFallLatch;
                    (* Le sonde non servono più, prendo per buono il primo ed ignoro i successivi (più sicuro) *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SCORE_INIT : (* Attesa discesa testina *)
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Attendo requisiti *)
        ELSIF (vn[ivnStatus+ID_HOLDPADS]=TS_ON OR vnHoldPads_Cmd=0) AND (* Tamponi pronti se richiesti *)
              (vb[ivbAtRest+ID_CLAMP_ALGN] OR vn[ivnStatus+ID_CLAMP_ALGN]>=CL_DOWN) AND (* Premilastra stabili *)
              (vb[ivbAtRest+ID_CLAMP_DTCH] OR vn[ivnStatus+ID_CLAMP_DTCH]>=CL_DOWN) AND
              Tsup.Status=TS_ON THEN (* Testina taglio pronta *)
            (* Pronto per incidere, comando movimento *)
            vqCarrSup_Tgt := Yend; (* [um] *)
            Ysup.TgtSpd := vqV_score; (* [um/min] *)
            Ysup.AccPerc := 100; (* max [%] *)
            Ysup.DecPerc := 100; (* max [%] *)
            Ysup.OutFrc := vqTscore_ScoreYforce; (* [mN] *)
            Ysup.MaxPosErr := WTR_DEFAULT;
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_SCORE;
            (* Se ancora non conosco il bordo finale... *)
            (* IF (Ybegin<Yend AND vqY_TopEdge=NO_POS_UM) OR (Ybegin>Yend AND vqY_BtmEdge=NO_POS_UM) THEN *)
            IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                (* ...Assicuro sonde pronte e resettate *)
                Probe1( Activate:=TRUE, Reset:=TRUE );
                Probe2( Activate:=TRUE, Reset:=TRUE );
                (* Assicuro decelerazione necessaria alla riuscita del cambio target
                delta := fnRampSpace(V:=Ysup.TgtSpd, ta:=vq[ivqAx_DecTime+AX_YSUP-1], p:=50);
                IF delta >= ABS(vq[ivqProbe_DY+IRQ_PROBESUP2]) THEN
                    Ysup.DecPerc := vnCarr_ChgTgtDec;
                    dlog( Txt:='fbCarrSup: ! DecPerc=%d%% to stop in %ld > %ld mm', Lvl:=1, Val1:=TO_DINT(Ysup.DecPerc), Val2:=delta/1E3, Val3:=vq[ivqProbe_DY+IRQ_PROBESUP2]/1E3 );
                END_IF; *)
                Ysup.DecPerc := vnCarr_ChgTgtDec;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SCORE : (* Movimento incisione *)
        IF MoveTo<MV_WAITSTOP THEN (* Movimento terminato *)
            vbTsup_Cmd := FALSE;
            (* vbLubScore_Cmd := FALSE; *)
            Status := CARSTS_SCORE_END;
        (* Se qualcosa va storto nel movimento, tira via subito l'utensile *)
        ELSIF vbCarr_ToolsOffOnErr AND Ysup.Status=AXS_STOPPING AND NOT Ysup.Arrived AND vbTsup_Cmd THEN
            dlog( Txt:='fbCarrSup: !! Tsup off on stop', Lvl:=2 );
            vbTsup_Cmd := FALSE;
        (* Supporto ricerca al volo: se ancora non so dov'è il bordo
           finale, cambio target al fronte di discesa di una delle sonde *)
        ELSIF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
            Probe1(); (* Sonda principale *)
            Probe2(); (* Eventuale sonda aggiuntiva per il bordo finale, 'vbFeat_HasProbeSup2' *)
            (* Se ricerca al volo almeno una sonda dovrebbe essere attiva! *)
            IF Probe1.Status<PS_WAITMOVE AND Probe2.Status<PS_WAITMOVE THEN
                dlog( Txt:='fbCarrSup: !! No probes', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;

            (* Stay ready for the change target to glass end edge *)
            IF Probe2.NewFallLatch THEN (* => Probe2.LastFallLatch *)
                fly_fall_latch := Probe2.LastFallLatch;
            ELSIF Probe1.NewFallLatch THEN (* => Probe1.LastFallLatch *)
                fly_fall_latch := Probe1.LastFallLatch;
            ELSE
                fly_fall_latch := NO_POS_UM; (* Sfruttato per segnalare un nuovo fronte di discesa *)
            END_IF;
            IF fly_fall_latch<>NO_POS_UM THEN
                (* Rilevato un nuovo fronte di discesa da non ignorare *)
                (* dlog( Txt:='fbCarrSup: Fall at %ld', Lvl:=4, Val1:=fly_fall_latch/1E3 ); *)
                (* Store the measured edge and calculate the true Yend *)
                IF Ybegin<Yend THEN (* Incisione avanti *)
                    vqY_TopEdge := fly_fall_latch;
                    Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                ELSE (* Incisione indietro *)
                    vqY_BtmEdge := fly_fall_latch;
                    Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                END_IF;
                vqCut_Length := vqY_TopEdge - vqY_BtmEdge;
                dlog( Txt:='fbCarrSup: Fly-Measured %ld-%ld=%ld mm (score to %ld)', Lvl:=2, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqCut_Length/1E3, Val4:=Yend/1E3 );

                (* Le sonde non servono più *)
                Probe1( Activate:=FALSE );
                Probe2( Activate:=FALSE );

                (* Controllo misura *)
                IF vqCut_Length<=0 THEN
                    dlog( Txt:='!!Bad measure', Lvl:=1);
                    Status := STS_ERROR;
                    RETURN;
                END_IF;

                (* Cambio target su bordo finale: In automatico è meno importante perché ho un'altezza teorica *)
                IF Ysup.PosPhase<>AFS_POS_DEC OR NOT vbAutoMode THEN
                    Ysup( TgtPos:=Yend, Flags:=AXCB_STRICT );
                ELSE
                    dlog( Txt:='fbCarrSup: !! Ysup already decel to %ld (%ld)', Lvl:=2, Val1:=Ysup.TgtPos/1E3, Val1:=Yend/1E3 );
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SCORE_END : (* Finalizzazione incisione *)
        vbTsup_Cmd := FALSE;
        IF Tsup.Status=TS_OFF THEN
            IF MoveTo=MV_DONE THEN
                dlog( Txt:='fbCarrSup: Score Done', Lvl:=3 );

                (* Se il bordo finale non è ancora stato rilevato
                   probabilmente si è trattato di una preincisione molto interna,
                   forse è meglio dare un valore a 'vqCut_Length'? *)
                IF vbAutoMode AND vqCut_Length<=0 THEN
                    vqCut_Length := vqSubSheet_ProcHeight;
                    (* Assicuro di resettare lo stato delle sonde *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;

                vnCarrSup_Seq := SEQ_DONE;
                vnCarrSup_Cmd := CMD_STOP;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbCarrSup: !! Score Error', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_OPEN_INIT : (* Attesa inizio apertura con rotelle: discesa utensile *)
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Rsup.Status=TS_ON THEN
            (* Pronto per passata rotelle, comando movimento *)
            Ysup.TgtSpd := vqV_brkwhl_sup; (* [um/min] *)
            Ysup.AccPerc := 100; (* max [%] *)
            Ysup.DecPerc := 100; (* max [%] *)
            Ysup.OutFrc := vqRbrk_OpenYforce; (* [mN] *)
            Ysup.MaxPosErr := WTR_DEFAULT;
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_OPEN;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_OPEN : (* Movimento apertura con rotelle *)
        IF MoveTo<MV_WAITSTOP THEN (* Movimento terminato *)
            (* Vediamo se devo completare l'apertura *)
            IF vqCarrSup_Tgt=Yend THEN
                (* Ho aperto fino al bordo finale, fatto *)
                vbRsup_Cmd := FALSE;
                Status := CARSTS_OPEN_END;
            ELSE
                (* Devo ancora arrivare al bordo finale, proseguo *)
                vqCarrSup_Tgt := Yend;
                dlog( Txt:='fbCarrSup: Prosecuting opening pass', Lvl:=5 );
                Status := CARSTS_OPEN_INIT;
            END_IF;
        (* Se qualcosa va storto nel movimento, tira via subito l'utensile * )
        ELSIF vbCarr_ToolsOffOnErr AND Ysup.Status=AXS_STOPPING AND NOT Ysup.Arrived AND vbRsup_Cmd THEN
            dlog( Txt:='fbCarrSup: !! Rsup off on stop', Lvl:=2 );
            vbRsup_Cmd := FALSE;
        (* ELSE (* Wait move *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_OPEN_END : (* Finalizzazione apertura con rotelle *)
        vbRsup_Cmd := FALSE;
        vbRsup_SelC := FALSE;
        IF Rsup.Status=TS_OFF THEN
            IF MoveTo=MV_DONE THEN
                dlog( Txt:='fbCarrSup: Open Done', Lvl:=3 );
                vnCarrSup_Seq := SEQ_DONE;
                vnCarrSup_Cmd := CMD_STOP;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbCarrSup: !! Open Error', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRLE_INIT : (* Attesa inizio rimozione basso emissivo: Discesa utensile *)
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF GrLe.Status=TS_ON THEN
            (* Pronto per passata mola, comando movimento *)
            vqCarrSup_Tgt := Yend; (* [um] *)
            Ysup.TgtSpd := vqV_lowe; (* [um/min] *)
            Ysup.AccPerc := 100; (* max [%] *)
            Ysup.DecPerc := 100; (* max [%] *)
            Ysup.OutFrc := -1; (* max *)
            Ysup.MaxPosErr := WTR_HITDET;
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_GRLE;
            (* Se ancora non conosco il bordo finale... *)
            (* IF (Ybegin<Yend AND vqY_TopEdge=NO_POS_UM) OR (Ybegin>Yend AND vqY_BtmEdge=NO_POS_UM) THEN *)
            IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                (* ...Assicuro sonde pronte e resettate *)
                Probe1( Activate:=TRUE, Reset:=TRUE );
                Probe2( Activate:=TRUE, Reset:=TRUE );
                (* Assicuro decelerazione necessaria alla riuscita del cambio target
                delta := fnRampSpace(V:=Ysup.TgtSpd, ta:=vq[ivqAx_DecTime+AX_YSUP-1], p:=50);
                IF delta >= ABS(vq[ivqProbe_DY+IRQ_PROBESUP2]) THEN
                    Ysup.DecPerc := vnCarr_ChgTgtDec;
                    dlog( Txt:='fbCarrSup: ! DecPerc=%d%% to stop in %ld > %ld mm', Lvl:=1, Val1:=TO_DINT(Ysup.DecPerc), Val2:=delta/1E3, Val3:=vq[ivqProbe_DY+IRQ_PROBESUP2]/1E3 );
                END_IF; *)
                Ysup.DecPerc := vnCarr_ChgTgtDec;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRLE : (* Movimento rimozione basso emissivo *)
        IF MoveTo<MV_WAITSTOP THEN (* Movimento terminato *)
            vnGrLe_Cmd := 0;
            Status := CARSTS_GRLE_END;
        (* Se qualcosa va storto nel movimento, tira via subito l'utensile *)
        ELSIF vbCarr_ToolsOffOnErr AND Ysup.Status=AXS_STOPPING AND NOT Ysup.Arrived AND vnGrLe_Cmd<>0 THEN
            dlog( Txt:='fbCarrSup: !! GrLe off on stop', Lvl:=2 );
            vnGrLe_Cmd := 0;
        (* Supporto ricerca al volo: se ancora non so dov'è il bordo
           finale, cambio target al fronte di discesa delle sonde *)
        ELSIF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
            Probe1();
            Probe2(); (* Sonda secondaria 'vbFeat_HasProbeSup2' *)
            (* Se ricerca al volo almeno una sonda dovrebbe essere attiva! *)
            IF Probe1.Status<PS_WAITMOVE AND Probe2.Status<PS_WAITMOVE THEN
                dlog( Txt:='fbCarrSup: !! No probes', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;

            (* Stay ready for the change target to glass end edge *)
            IF Probe2.NewFallLatch THEN (* => Probe2.LastFallLatch *)
                fly_fall_latch := Probe2.LastFallLatch;
            ELSIF Probe1.NewFallLatch THEN (* => Probe1.LastFallLatch *)
                fly_fall_latch := Probe1.LastFallLatch;
            ELSE
                fly_fall_latch := NO_POS_UM; (* Sfruttato per segnalare un nuovo fronte di discesa *)
            END_IF;
            IF fly_fall_latch<>NO_POS_UM THEN
                (* Rilevato un nuovo fronte di discesa da non ignorare *)
                (* dlog( Txt:='fbCarrSup: Fall at %ld', Lvl:=4, Val1:=fly_fall_latch/1E3 ); *)
                (* Store the measured edge and calculate the true Yend *)
                IF Ybegin<Yend THEN (* Rimozione basso emissivo avanti *)
                    vqY_TopEdge := fly_fall_latch;
                    Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqGrLe_TopMargin+vqMod_GrLe_TopMargin)) - vqGrLe_DY; (* [um] *)
                    vqMod_GrLe_TopMargin := 0; (* Reset modificatore temporaneo *)
                ELSE (* Rimozione basso emissivo indietro *)
                    vqY_BtmEdge := fly_fall_latch;
                    Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqGrLe_BtmMargin+vqMod_GrLe_BtmMargin)) - vqGrLe_DY; (* [um] *)
                    vqMod_GrLe_BtmMargin := 0; (* Reset modificatore temporaneo *)
                END_IF;
                vqCut_Length := vqY_TopEdge - vqY_BtmEdge;
                dlog( Txt:='fbCarrSup: Fly-Measured %ld-%ld=%ld mm (lowE to %ld)', Lvl:=2, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqCut_Length/1E3, Val4:=Yend/1E3 );

                (* Le sonde non servono più *)
                Probe1( Activate:=FALSE );
                Probe2( Activate:=FALSE );

                (* Controllo misura *)
                IF vqCut_Length<=0 THEN
                    dlog( Txt:='!!Bad measure', Lvl:=1);
                    Status := STS_ERROR;
                    RETURN;
                END_IF;

                (* Cambio target su bordo finale: In automatico è meno importante perché ho un'altezza teorica *)
                IF Ysup.PosPhase<>AFS_POS_DEC OR NOT vbAutoMode THEN
                    Ysup( TgtPos:=Yend, Flags:=AXCB_STRICT );
                ELSE
                    dlog( Txt:='fbCarrSup: !! Ysup already decel to %ld (%ld)', Lvl:=2, Val1:=Ysup.TgtPos/1E3, Val1:=Yend/1E3 );
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRLE_END : (* Finalizzazione rimozione basso emissivo *)
        vnGrLe_Cmd := 0;
        IF GrLe.Status=TS_OFF THEN
            IF MoveTo=MV_DONE THEN
                dlog( Txt:='fbCarrSup: LowE Done', Lvl:=3 );

                (* Se il bordo finale non è ancora stato rilevato
                   forse è meglio dare un valore a 'vqCut_Length'? *)
                IF vbAutoMode AND vqCut_Length<=0 THEN
                    vqCut_Length := vqSubSheet_ProcHeight;
                    (* Assicuro di resettare lo stato delle sonde *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;

                vnCarrSup_Seq := SEQ_DONE;
                vnCarrSup_Cmd := CMD_STOP;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbCarrSup: !! LowE Error', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_SWEEP_INI : (* Attesa condizioni per spazzata *)
        (* Attendi sonda pronta e asse pronto *)
        Probe1( Activate:=TRUE );
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Probe1.Status>=PS_WAITMOVE AND Ysup.Status=AXS_READY THEN
            (* Dove andare: se (try_count MOD 2)<>0 è una spazzata multipla in senso opposto *)
            IF (vnCarrSup_Cmd=CARCMD_SRCHGLASS_FWD AND (try_count MOD 2)=0) OR
               (vnCarrSup_Cmd=CARCMD_SRCHGLASS_BCK AND (try_count MOD 2)<>0) THEN
                (* Spazzata avanti *)
                vqCarrSup_Tgt := vqYmax + vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
            ELSE
                (* Spazzata indietro *)
                vqCarrSup_Tgt := 0 - vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
            END_IF;
            Probe1.Back := vqCarrSup_Tgt < Ysup.CurrPos; (* Direzione spazzata *)
            Ysup.TgtSpd := vqEdgeDet_SweepSpd; (* [um/min] *)
            Ysup.OutFrc := 0; (* just move [mN] (per la ricerca non mi serve coppia) *)
            Ysup.MaxPosErr := WTR_HITDET;
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_SRCH_SWEEP;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_SWEEP : (* Spazzata ricerca bordi vetro *)
        Probe1();
        IF Probe1.Status=PS_DONE THEN
            (* Spazzata eseguita *)
            Ysup.Cmd := AXC_STOP_ENAB; (* Fermo il posizionamento, MoveTo andrà in MV_ERROR *)
            try_count := try_count + 1;
            (* Metto via catture *)
            IF Probe1.Back THEN
                (* Questa spazzata era indietro *)
                top_latch := Probe1.EdgeIn;
                btm_latch := Probe1.EdgeOut;
            ELSE
                (* Questa spazzata era avanti *)
                btm_latch := Probe1.EdgeIn;
                top_latch := Probe1.EdgeOut;
            END_IF;
            Probe1( Activate:=FALSE ); (* Disattivo la sonda *)
            (* Un doveroso controllo *)
            IF top_latch<=btm_latch THEN
                dlog( Txt:='fbCarrSup: !! Sweep %d: btm=%ld top=%ld mm', Lvl:=1, Val1:=TO_DINT(try_count), Val2:=btm_latch/1E3, Val3:=top_latch/1E3);
                vnCarrSup_Seq := SEQ_ERROR;
            END_IF;
            (* Se ho già delle misure, controlla discrepanze *)
            IF try_count>1 THEN
                dlog( Txt:='fbCarrSup: Sweep %d: btm=%ld prec=%ld mm (err=%ld um)', Lvl:=3, Val1:=TO_DINT(try_count), Val2:=btm_latch/1E3, Val3:=vqY_BtmEdge/1E3, Val4:=(btm_latch-vqY_BtmEdge));
                IF ABS(btm_latch-vqY_BtmEdge)>vqEdgeDet_MaxErr THEN
                    dlog( Txt:='fbCarrSup: !! Sweep %d: Invalid btm (err=%ld mm)', Lvl:=1, Val1:=TO_DINT(try_count), Val2:=(btm_latch-vqY_BtmEdge)/1E3);
                    vnCarrSup_Seq := SEQ_ERROR;
                END_IF;
                dlog( Txt:='fbCarrSup: Sweep %d: top=%ld mm prec=%ld mm (err=%ld um)', Lvl:=3, Val1:=TO_DINT(try_count), Val2:=top_latch/1E3, Val3:=vqY_TopEdge/1E3, Val4:=(top_latch-vqY_TopEdge));
                IF ABS(top_latch-vqY_TopEdge)>vqEdgeDet_MaxErr THEN
                    dlog( Txt:='fbCarrSup: !! Sweep %d: Invalid top (err=%ld mm)', Lvl:=1, Val1:=TO_DINT(try_count), Val2:=(top_latch-vqY_TopEdge)/1E3);
                    vnCarrSup_Seq := SEQ_ERROR;
                END_IF;
                (* Aggiungo alla media: avg<n+1> = (N avg<n> + a) / (N+1) *)
                vqY_BtmEdge := (TO_DINT(try_count-1)*vqY_BtmEdge + btm_latch) / TO_DINT(try_count);
                vqY_TopEdge := (TO_DINT(try_count-1)*vqY_TopEdge + top_latch) / TO_DINT(try_count);
            ELSE
                (* Prima spazzata *)
                vqY_BtmEdge := btm_latch;
                vqY_TopEdge := top_latch;
            END_IF;
            Status := CARSTS_SRCH_END;
        ELSIF MoveTo=MV_DONE THEN
            (* Ehm, arrivato a destinazione! *)
            dlog( Txt:='fbCarrSup: !! Sweep %d to %ld without latches (Probe1.Status=%d)', Lvl:=1, Val1:=TO_DINT(try_count), Val2:=Ysup.TgtPos/1E3, Val3:=TO_DINT(Probe1.Status));
            (* SET_MSG(MSG_GLASSNOTFOUND,'MSG_GLASSNOTFOUND',0); *)
            vnCarrSup_Seq := SEQ_ERROR;
            Status := CARSTS_SRCH_END;
        ELSIF MoveTo=MV_ERROR THEN
            dlog( Txt:='fbCarrSup: !! Sweep %d to %ld failed', Lvl:=2, Val1:=TO_DINT(try_count), Val2:=Ysup.TgtPos/1E3);
            vnCarrSup_Seq := SEQ_ERROR;
            Status := CARSTS_SRCH_END;
        (* ELSE (* Wait latches/move *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_INOUT_INI : (* Preparazione rilevazione accurata del bordo *)
        IF MoveTo=MV_DONE THEN
            (* Attendi sonda pronta e asse pronto *)
            Probe1( Activate:=TRUE, SweepMode:=FALSE ); (* Niente compensazioni e filtro schegge *)
            IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
                Status := STS_ERROR;
            ELSIF Probe1.Status>=PS_WAITMOVE AND Ysup.Status=AXS_READY THEN
                vqCarrSup_Tgt := Yend;
                Probe1.Back := vqCarrSup_Tgt < Ysup.CurrPos; (* Direzione *)
                Probe1.Reset := TRUE; (* Per sicurezza? *)
                Ysup.TgtSpd := vqEdgeDet_AcqSpd; (* [um/min] *)
                Ysup.OutFrc := 0; (* just move [mN] (per la ricerca non mi serve coppia) *)
                Ysup.MaxPosErr := WTR_HITDET;
                MoveTo := MV_TOOLMOVE;
                Status := CARSTS_SRCH_INOUT;
            END_IF;
        ELSIF MoveTo=MV_ERROR THEN
            Status := STS_ERROR;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_INOUT : (* Rilevazione accurata del bordo *)
        Probe1();
        (* Eseguo movimentini dentro e fuori *)
        IF MoveTo=MV_DONE THEN
            (* Devo fare il secondo movimentino? *)
            IF vqCarrSup_Tgt=Yend THEN
                vqCarrSup_Tgt := Ybegin;
                Probe1.Back := vqCarrSup_Tgt < Ysup.CurrPos; (* Direzione *)
                MoveTo := MV_TOOLMOVE;
            ELSE
                (* Movimento dentro fuori completato *)
                (* Controllo se ho acquisito i due fronti *)
                IF Probe1.Status=PS_DONE THEN
                    (* Ok, metto via catture *)
                    (* Un doveroso controllo *)
                    IF ABS(Probe1.EdgeIn-Probe1.EdgeOut)>vqEdgeDet_MaxErr THEN
                        dlog( Txt:='fbCarrSup: !! Acq: Too diff in=%ld out=%ld um ', Lvl:=1, Val1:=Probe1.EdgeIn, Val2:=Probe1.EdgeOut );
                        vnCarrSup_Seq := SEQ_ERROR;
                    END_IF;
                    IF Ybegin < Yend THEN
                        (* Ho acquisito il bordo sotto *)
                        btm_meas := (Probe1.EdgeIn + Probe1.EdgeOut)/2; (* [um] *)
                        vqY_BtmEdge := btm_meas;
                    ELSE
                        (* Ho acquisito il bordo sopra *)
                        top_meas := (Probe1.EdgeIn + Probe1.EdgeOut)/2; (* [um] *)
                        vqY_TopEdge := top_meas + vq[ivqProbe_FixOpp+Probe1.ProbeIdx];
                    END_IF;
                    Probe1( Activate:=FALSE ); (* Disattivo la sonda *)
                    Status := CARSTS_SRCH_END;
                ELSE
                    dlog( Txt:='fbCarrSup: !! Acq failed (%d)', Lvl:=2, Val1:=TO_DINT(Probe1.Status) );
                    vnCarrSup_Seq := SEQ_ERROR;
                    Status := CARSTS_SRCH_END;
                END_IF;
            END_IF;
        ELSIF MoveTo=MV_ERROR THEN
            dlog( Txt:='fbCarrSup: !! Acq from %d to %ld failed', Lvl:=2, Val1:=Ybegin/1E3, Val2:=Yend/1E3 );
            vnCarrSup_Seq := SEQ_ERROR;
            Status := CARSTS_SRCH_END;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_END : (* Fine cattura, attesa off sonda e asse fermo *)
        Probe1( Activate:=FALSE );
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Probe1.Status=STS_IDLE AND Ysup.Status=AXS_READY THEN
            IF Probe1.SliversCount>0 THEN
                dlog( Txt:='fbCarrSup: SRCH_END: ! Found %d chips', Lvl:=2, Val1:=TO_DINT(Probe1.SliversCount));
                SET_MSG(REQ_CLEAN_CUTFLOOR,'REQ_CLEAN_CUTFLOOR',TO_DINT(Probe1.SliversCount));
            END_IF;
            (* - Vedi se ho terminato - *)
            (* Intercetto eventuale errore *)
            IF vnCarrSup_Seq=SEQ_ERROR THEN
                Status := STS_ERROR;
            (* Devo rilevare i bordi in modo accurato? *)
            ELSIF vnEdgeDet_Mode=2 AND (btm_meas=NO_POS_UM OR top_meas=NO_POS_UM) THEN
                (* Vediamo quale bordo rilevare in modo accurato
                   Le quote rilevate dalla spazzata sono in: vqY_BtmEdge, vqY_TopEdge *)
                IF ABS(Ysup.CurrPos-vqY_BtmEdge) < ABS(Ysup.CurrPos-vqY_TopEdge) THEN
                    (* Sono più vicino al bordo basso *)
                    IF btm_meas=NO_POS_UM THEN
                        (* Procedo a rilevare in modo accurato il bordo basso *)
                        Ybegin := vqY_BtmEdge - vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
                        Yend := Ybegin + 2*vqEdgeDet_Margin;
                    ELSE
                        (* Procedo a rilevare in modo accurato il bordo alto *)
                        Ybegin := vqY_TopEdge + vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
                        Yend := Ybegin - 2*vqEdgeDet_Margin;
                    END_IF;
                ELSE
                    (* Sono più vicino al bordo alto *)
                    IF top_meas=NO_POS_UM THEN
                        (* Procedo a rilevare in modo accurato il bordo alto *)
                        Ybegin := vqY_TopEdge + vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
                        Yend := Ybegin - 2*vqEdgeDet_Margin;
                    ELSE
                        (* Procedo a rilevare in modo accurato il bordo basso *)
                        Ybegin := vqY_BtmEdge - vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
                        Yend := Ybegin + 2*vqEdgeDet_Margin;
                    END_IF;
                END_IF;
                vqCarrSup_Tgt := Ybegin;
                MoveTo := MV_FREEMOVE;
                Status := CARSTS_SRCH_INOUT_INI;
            (* Devo fare una doppia passata? *)
            ELSIF vnEdgeDet_Mode=1 AND try_count=1 THEN
                (* Faccio una seconda spazzata, riattivo la sonda *)
                Probe1( Activate:=TRUE );
                Status := CARSTS_SRCH_SWEEP_INI;
            ELSE
                (* Terminato con successo *)
                vqCut_Length := vqY_TopEdge - vqY_BtmEdge; (* [um] *)
                dlog( Txt:='fbCarrSup: Ymeas %ld|%ld=%ld', Lvl:=3, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqCut_Length/1E3 );
                vnCarrSup_Cmd := CMD_STOP;
                vnCarrSup_Seq := SEQ_DONE;
                Status := STS_IDLE;
                IF vbCarrSup_ParkOnEnd THEN
                    vbCarrSup_ParkOnEnd := FALSE; (* Eat *)
                    vnCarrSup_Cmd := CMD_PARK;
                END_IF;
            END_IF; (* -- Vedi se ho terminato *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_TRAIL_LOCK : (* Agganciando/sganciando traino passivo *)
        IF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnECarrSup_Lock=0 THEN
            (* L'aggancio/sgancio è stato correttamente completato? *)
            IF (Ext.Locked>0 AND vnCarrSup_Cmd=CARCMD_TRAIL_LOCK) OR
               (Ext.Locked<0 AND vnCarrSup_Cmd<>CARCMD_TRAIL_LOCK) THEN
                (* dlog( Txt:='fbCarrSup: Trail lock: %d', Lvl:=5, Val1:=TO_DINT(Ext.Locked) ); *)
                (* Poichè altri comandi possono richiedere aggancio/sgancio,
                   resetto il comando solo se è un comando esplicito, così
                   l'altro rimane in coda e viene rieseguito *)
                IF vnCarrSup_Cmd=CARCMD_TRAIL_LOCK OR vnCarrSup_Cmd=CARCMD_TRAIL_UNLOCK THEN
                    vnCarrSup_Cmd := CMD_STOP;
                END_IF;
                vnCarrSup_Seq := SEQ_DONE;
                Status := STS_IDLE;
                IF vbCarrSup_ParkOnEnd THEN
                    vbCarrSup_ParkOnEnd := FALSE; (* Eat *)
                    vnCarrSup_Cmd := CMD_PARK;
                END_IF;
            ELSE
                dlog( Txt:='fbCarrSup: !! TRAIL_LOCK: Error (%d)', Lvl:=1, Val1:=TO_DINT(Ext.Locked) );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_STOPPING : (* Waiting stop *)
        IF MoveTo<MV_WAITSTOP AND Ysup.Status<=AXS_READY THEN
            Probe1( Activate:=FALSE );
            Probe2( Activate:=FALSE );
            vnCarrSup_Cmd := CMD_STOP; (* Eat command *)
            Status := STS_IDLE;

            IF CutAreaFreed THEN (* AtRest *)
                (* Free possible acquired resources (CarrSup) *)
                IF UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
                IF vbFeat_FixedCarriages AND LowerCutZone_Algn=ID_CARR_INF THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_HEATLAMP]=TS_OFF,ID_HEATLAMP,0); END_IF;
                IF vbFeat_FixedCarriages AND LowerCutZone_Dtch=ID_CARR_INF THEN LowerCutZone_Dtch:=0; END_IF;
            END_IF;
        ELSIF MoveTo>MV_WAITSTOP THEN
            MoveTo := MV_WAITSTOP;
        ELSIF Ysup.Cmd>AXC_STOP_ENAB THEN
            Ysup.Cmd := AXC_STOP_ENAB;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_IDLE : (* Carrello superiore non attivo *)
        (* Rispondi ai comandi *)
        IF vnCarrSup_Cmd<>CMD_STOP THEN
            vnCarrSup_Seq := SEQ_START; (* Resetto risultato *)
            (* Comando attivo, controllo conflitti con comandi combinati?
               No, un comando combinato può usare i comandi singoli
            IF vnCarriages_Cmd<>CMD_STOP THEN
                dlog( Txt:='fbCarrSup: !! vnCarrSup_Cmd=%d with vnCarriages_Cmd=%d', Lvl:=1, Val1:=TO_DINT(vnCarrSup_Cmd), Val2:=TO_DINT(vnCarriages_Cmd));
                Status := STS_ERROR; (* Questo assicura ad es. che l'altro carrello non sia in inseguimento *)
            IF vnCarrSup_Cmd=CMD_PARK OR
               vnCarrSup_Cmd=CARCMD_BTMPARK OR
               vnCarrSup_Cmd=CARCMD_TOPPARK OR
               vnCarrSup_Cmd=CARCMD_FULLPARK THEN
                (* Parcheggia carrello a... *)
                (* dlog( Txt:='fbCarrSup: Going to park', Lvl:=5 ); *)
                CASE vnCarrSup_Cmd OF
                    CARCMD_BTMPARK :
                        (* Parcheggio basso (coincide con 'home' se 'vbFeat_CarrHomeOnTop=FALSE') *)
                        vqCarrSup_Tgt := vqYsup_BtmParkPos;
                    CARCMD_TOPPARK :
                        (* Parcheggio alto (coincide con 'home' se 'vbFeat_CarrHomeOnTop=TRUE') *)
                        vqCarrSup_Tgt := vqYsup_TopParkPos;
                    CARCMD_FULLPARK :
                        (* Assicuro sgancio eventuale traino *)
                        IF vqECarrSup_Length>0 AND Ext.Locked>0 THEN
                            vqCarrSup_Tgt := vqYsup_LockPos - vqECarr_LockApproach;
                            IF Ysup.CurrPos>vqCarrSup_Tgt THEN vqCarrSup_Tgt := vqYsup_LockPos; END_IF;
                        (* ELSIF vqECarrSup_Length<0 AND Ext.Locked>0 THEN (* Traini in basso non supportati per ora! *)
                        ELSE
                            vqCarrSup_Tgt := Ysup.HomePos;
                        END_IF;
                    ELSE (* CMD_PARK *)
                        (* Verso quota di 'home' (coinciderà con uno dei precedenti) *)
                        vqCarrSup_Tgt := Ysup.HomePos;
                        (* Devo garantire di liberare l'area taglio? *)
                        IF vbCarr_ParkFreesCutArea THEN
                            IF vbFeat_CarrHomeOnTop THEN
                                IF (vqYsup_TopParkPos + vqCarrSup_CurrDYroomM) <= vqCarr_CutAreaYtop THEN
                                    (* Il parcheggio alto non libererebbe l'area taglio *)
                                    (* dlog( Txt:='fbCarrSup: ! Opposite park (%ld<=%ld)', Lvl:=4, Val1:=(vqYsup_TopParkPos+vqCarrSup_CurrDYroomM)/1E3, Val2:=vqCarr_CutAreaYtop/1E3 ); *)
                                    vqCarrSup_Tgt := vqYsup_BtmParkPos;
                                END_IF;
                            ELSE
                                IF (vqYsup_BtmParkPos + vqCarrSup_CurrDYroomP) >= vqCarr_CutAreaYbtm THEN
                                    (* Il parcheggio basso non libererebbe l'area taglio *)
                                    (* dlog( Txt:='fbCarrSup: ! Opposite park (%ld>=%ld)', Lvl:=4, Val1:=(vqYsup_BtmParkPos+vqCarrSup_CurrDYroomP)/1E3, Val2:=vqCarr_CutAreaYbtm/1E3 ); *)
                                    vqCarrSup_Tgt := vqYsup_TopParkPos;
                                END_IF;
                            END_IF;
                        END_IF;
                END_CASE;
                (* Verifica se siamo già in parcheggio? *)
                IF ABS(Ysup.CurrPos-vqCarrSup_Tgt)<500 AND AtRest (* Ysup.InPosDelta *)
                   AND (vnCarrSup_Cmd<>CARCMD_FULLPARK OR vqECarrSup_Length=0 OR Ext.Locked<=0) THEN
                    (* Sono già in parcheggio! Non fare nulla e dai Ok *)
                    dlog( Txt:='fbCarrSup: Already in park at %ld mm', Lvl:=4, Val1:=Ysup.CurrPos/1E3 );
                    vnCarrSup_Seq := SEQ_DONE;
                    vnCarrSup_Cmd := CMD_STOP;
                ELSE
                    (* Movimento libero verso 'vqCarrSup_Tgt' *)
                    Yend := vqCarrSup_Tgt; (* Ricorda destinazione finale *)
                    (* Assicuro un movimentino di avvicinamento se... *)
                    IF vqECarrSup_Length>0 AND vnCarrSup_Cmd=CARCMD_TOPPARK THEN
                        vqCarrSup_Tgt := vqCarrSup_Tgt - vqECarr_LockApproach;
                    END_IF;
                    MoveTo := MV_FREEMOVE;
                    Status := STS_MOVING; (* Proceed *)
                END_IF;
            ELSIF vnCarrSup_Cmd=CARCMD_FREEAREA THEN
                (* È richiesta la liberazione dell'area taglio *)
                IF NOT CutAreaFreed THEN
                    (* Sto occupando l'area taglio *)
                    (* dlog( Txt:='fbCarrSup: Freeing (%ld|%ld) (%ld|%ld)', Lvl:=4, Val1:=YroomM/1E3, Val2:=YroomP/1E3, Val3:=vqCarr_CutAreaYbtm/1E3, Val4:=vqCarr_CutAreaYtop/1E3 ); *)
                    (* Vediamo prima l'ingombro in park basso (prediligo questo), poi alto *)
                    IF (vqYsup_BtmParkPos+vqCarrSup_CurrDYroomP)<vqCarr_CutAreaYbtm THEN
                        (* Carrello+Traino in park basso libera l'area taglio, vai giù *)
                        vnCarrSup_Cmd := CARCMD_BTMPARK;
                    ELSIF (vqYsup_TopParkPos+vqCarrSup_CurrDYroomM)>vqCarr_CutAreaYtop THEN
                        (* Carrello+Traino in park alto libera l'area taglio, vai su *)
                        vnCarrSup_Cmd := CARCMD_TOPPARK;
                    ELSE
                        (* Mah, se c'è un traino, sgancialo *)
                        vnCarrSup_Cmd := CARCMD_FULLPARK;
                    END_IF;
                ELSE
                    (* Area taglio già liberata *)
                    (* dlog( Txt:='fbCarrSup: Already freed (%ld|%ld) (%ld|%ld)', Lvl:=4, Val1:=YroomM/1E3, Val2:=YroomP/1E3, Val3:=vqCarr_CutAreaYbtm/1E3, Val4:=vqCarr_CutAreaYtop/1E3 ); *)
                    vnCarrSup_Seq := SEQ_DONE;
                    vnCarrSup_Cmd := CMD_STOP;
                END_IF;
            ELSIF vnCarrSup_Cmd=CARCMD_TRAIL_LOCK OR vnCarrSup_Cmd=CARCMD_TRAIL_UNLOCK THEN
                IF vqECarrSup_Length>0 THEN
                    dlog( Txt:='fbCarrSup: Trail (%d)', Lvl:=5, Val1:=TO_DINT(vnCarrSup_Cmd) );
                    vqCarrSup_Tgt := vqYsup_LockPos - vqECarr_LockApproach;
                    IF Ysup.CurrPos>vqCarrSup_Tgt THEN vqCarrSup_Tgt := vqYsup_LockPos; END_IF;
                    MoveTo := MV_FREEMOVE;
                    Status := STS_MOVING; (* Proceed *)
                (* Traini in basso non supportati per ora! * )
                ELSIF vqECarrSup_Length<0 THEN
                    vqCarrSup_Tgt := vqYsup_LockPos + vqECarr_LockApproach; *)
                ELSE
                    (* Non c'è nessun traino, ignora comando *)
                    vnCarrSup_Cmd := CMD_STOP;
                    vnCarrSup_Seq := SEQ_DONE;
                END_IF;
            ELSIF vnCarrSup_Cmd=CMD_MOVETO THEN
                (* Movimento libero generico verso 'vqCarrSup_Tgt' *)
                (* Nota: Non controllo lo stato del carrello inferiore,
                         eventualmente interverranno i vincoli generali *)
                MoveTo := MV_FREEMOVE;
                Status := STS_MOVING; (* Proceed *)
            ELSIF vnCarrSup_Cmd=CMD_FULLMOVETO THEN
                (* Movimento generico verso 'vqCarrSup_Tgt' *)
                Ysup.TgtSpd := vqCarrSup_Spd; (* [um/min] *)
                (* Più vado piano più parzializzo le accelerazioni? *)
                IF vbCarr_PartAcc THEN
                    Ysup.AccPerc := TO_INT( 10.0 + 100.0 * TO_LREAL(Ysup.TgtSpd) / TO_LREAL(Ysup.SpdMax) ); (* DANGER_DIVISION_BY_ZERO *)
                    Ysup.AccPerc := LIMIT(Ysup.AccPerc, 2, 100);
                    Ysup.DecPerc := Ysup.AccPerc;
                ELSE
                    Ysup.AccPerc := 100; (* max [%] *)
                    Ysup.DecPerc := 100; (* max [%] *)
                END_IF;
                Ysup.OutFrc := vqCarrSup_Frc; (* [mN] *)
                Ysup.MaxPosErr := WTR_DEFAULT;
                MoveTo := MV_TOOLMOVE;
                Status := STS_MOVING; (* Proceed *)
            ELSIF vnCarrSup_Cmd=CARCMD_SRCHGLASS OR
                  vnCarrSup_Cmd=CARCMD_SRCHGLASS_FWD OR
                  vnCarrSup_Cmd=CARCMD_SRCHGLASS_BCK THEN
                (* Sequenza di ricerca vetro *)
                (* Resetto eventuali messaggi *)
                RST_MSG_IF_ON(MSG_SEARCHERROR);
                (* Scegli opportunamente il verso della spazzata se non ancora specificato *)
                IF vnCarrSup_Cmd=CARCMD_SRCHGLASS THEN
                    vnCarrSup_Cmd := SEL(vbFeat_CarrHomeOnTop, CARCMD_SRCHGLASS_FWD, CARCMD_SRCHGLASS_BCK );
                END_IF;
                (* Devo prima andare in una certa posizione? *)
                (* Il range di ricerca: *)
                Ybegin := 0 - vqEdgeDet_Margin - vq[ivqProbe_DY+IRQ_PROBESUP]; (* [um] Sonda sotto lo zero di un certo margine *)
                Yend := vqYmax + vqEdgeDet_Margin - vq[ivqProbe_DY+IRQ_PROBESUP]; (* [um] Sonda sopra banda alta di un certo margine *)
                IF ABS(Ysup.CurrPos-SEL(vnCarrSup_Cmd=CARCMD_SRCHGLASS_BCK,Yend,Ybegin))<vqCut_MinLength
                   OR NOT fnInRange_DINT(Ysup.CurrPos,Ybegin,Yend)
                   OR NOT (vbCarriages_Prepos AND vbAutoMode) THEN
                    (* Assicura di partire dalla posizione iniziale di ricerca *)
                    vqCarrSup_Tgt := SEL(vnCarrSup_Cmd=CARCMD_SRCHGLASS_BCK, Ybegin, Yend );
                    MoveTo := MV_FREEMOVE; (* Vado alla posizione iniziale di ricerca *)
                ELSE
                    MoveTo := MV_DONE; (* Va bene partire da dove sono *)
                END_IF;
                Status := STS_MOVING; (* Proceed *)
            ELSIF vnCarrSup_Cmd=CARCMD_SCORE_FWD OR
                  vnCarrSup_Cmd=CARCMD_SCORE_BCK OR
                  vnCarrSup_Cmd=CARCMD_GRLE_FWD OR
                  vnCarrSup_Cmd=CARCMD_GRLE_BCK THEN
                (* Sequenza di incisione/asportazione low-E con carrello singolo
                   .Usa vqY_BtmEdge, vqY_TopEdge
                   .I controlli dei parametri utensile li ho già fatti in 'fbToolsParams' *)

                (* Qualora i bordi del vetro non fossero ancora noti, cerco di rilevarli "al volo" *)
                IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                    dlog( Txt:='fbCarrSup: ! Search on the fly', Lvl:=4 );
                    (* Ok, quello che voglio fare ora è:
                        1) Portarmi alla quota di inizio ricerca
                        2) Programmare la sonda/e
                        3) Eseguire il movimento di ricerca
                    *)
                    (* Determino quote di ricerca per Probe1 *)
                    Y := Ysup.CurrPos + vq[ivqProbe_DY+IRQ_PROBESUP]; (* Posizione sonda *)
                    IF vnCarrSup_Cmd=CARCMD_SCORE_FWD OR vnCarrSup_Cmd=CARCMD_GRLE_FWD THEN
                        (* Lavorazione avanti *)
                        Ybegin := vqYmin - vqEdgeDet_Margin; (* Quota inizio ricerca *)
                        (* Yend := SEL( vbAutoMode, vqYmax, vqYmax-vqSubSheet_ProcHeight ) + vqEdgeDet_Margin; (* Ymax ricerca iniziale *)
                        Yend := vqYmin + (vqYmax-vqYmin)/2; (* Ymax ricerca bordo iniziale *)
                        (* È necessario portarsi alla quota di inizio ricerca o possiamo partire da dove siamo? *)
                        IF Y<=Ybegin THEN Ybegin := Y; END_IF; (* Parto da dove sono *)
                    ELSE
                        (* Lavorazione indietro *)
                        Ybegin := vqYmax + vqEdgeDet_Margin; (* Quota inizio ricerca *)
                        Yend := vqYmin - vqEdgeDet_Margin; (* Ymin ricerca bordo iniziale *)
                        (* È necessario portarsi alla quota di inizio ricerca o possiamo partire da dove siamo? *)
                        IF Y>=Ybegin THEN Ybegin := Y; END_IF; (* Parto da dove sono *)
                    END_IF;
                    Ybegin := Ybegin - vq[ivqProbe_DY+IRQ_PROBESUP];
                    Yend := Yend - vq[ivqProbe_DY+IRQ_PROBESUP];
                ELSE
                    (* Bordi vetro già noti *)
                    IF vnCarrSup_Cmd=CARCMD_SCORE_FWD THEN
                        (* Incisione avanti *)
                        Ybegin := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                        Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                        vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                    ELSIF vnCarrSup_Cmd=CARCMD_SCORE_BCK THEN
                        (* Incisione indietro *)
                        Ybegin := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                        Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                        vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                    ELSIF vnCarrSup_Cmd=CARCMD_GRLE_FWD THEN
                        (* Rimozione basso emissivo avanti *)
                        Ybegin := MIN(vqY_TopEdge, vqY_BtmEdge + (vqGrLe_BtmMargin+vqMod_GrLe_BtmMargin)) - vqGrLe_DY; (* [um] *)
                        Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqGrLe_TopMargin+vqMod_GrLe_TopMargin)) - vqGrLe_DY; (* [um] *)
                        vqMod_GrLe_BtmMargin := 0; (* Reset modificatore temporaneo *)
                        vqMod_GrLe_TopMargin := 0; (* Reset modificatore temporaneo *)
                    ELSIF vnCarrSup_Cmd=CARCMD_GRLE_BCK THEN
                        (* Rimozione basso emissivo indietro *)
                        Ybegin := MAX(vqY_BtmEdge, vqY_TopEdge - (vqGrLe_TopMargin+vqMod_GrLe_TopMargin)) - vqGrLe_DY; (* [um] *)
                        Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqGrLe_BtmMargin+vqMod_GrLe_BtmMargin)) - vqGrLe_DY; (* [um] *)
                        vqMod_GrLe_BtmMargin := 0; (* Reset modificatore temporaneo *)
                        vqMod_GrLe_TopMargin := 0; (* Reset modificatore temporaneo *)
                    END_IF;
                END_IF;
                (* Mi porto in posizione di inizio ricerca/lavorazione con un movimento libero *)
                dlog( Txt:='fbCarrSup: Range %ld|%ld mm', Lvl:=3, Val1:=Ybegin/1E3, Val2:=Yend/1E3);
                vqCarrSup_Tgt := Ybegin; (* [um] *)
                MoveTo := MV_FREEMOVE;
                Status := STS_MOVING; (* Proceed *)

            ELSIF vnCarrSup_Cmd=CARCMD_OPEN_FWD OR
                  vnCarrSup_Cmd=CARCMD_OPEN_BCK THEN
                (* Sequenza di apertura con carrello singolo
                   .I controlli dei parametri utensile li ho già fatti in 'fbToolsParams' *)
                IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                    dlog( Txt:='fbCarrSup: !! Cannot open before searching', Lvl:=1 );
                    Status := STS_ERROR;
                    RETURN;
                ELSIF vnCarrSup_Cmd=CARCMD_OPEN_FWD THEN
                    (* Apertura con rotella superiore avanti *)
                    Ybegin := MIN(vqY_TopEdge, vqY_BtmEdge + (vqRbrk_BtmMargin+vqMod_Rbrk_BtmMargin)) - vqRsup_DY; (* [um] *)
                    Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqRbrk_TopMargin+vqMod_Rbrk_TopMargin)) - vqRsup_DY; (* [um] *)
                    vqMod_Rbrk_BtmMargin := 0; (* Reset modificatore temporaneo *)
                    vqMod_Rbrk_TopMargin := 0; (* Reset modificatore temporaneo *)
                    vqCarrSup_Tgt := LIMIT(Ybegin + vqRbrk_StartInside, vqY_BtmEdge-vqRsup_DY, vqY_TopEdge-vqRsup_DY); (* [um] *)
                    vbRsup_SelC := vbRsup_OpenWithCWheel; (* Anticipo selezione utensile *)
                ELSIF vnCarrSup_Cmd=CARCMD_OPEN_BCK THEN
                    (* Apertura con rotella superiore indietro *)
                    Ybegin := MAX(vqY_BtmEdge, vqY_TopEdge - (vqRbrk_TopMargin+vqMod_Rbrk_TopMargin)) - vqRsup_DY; (* [um] *)
                    Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqRbrk_BtmMargin+vqMod_Rbrk_BtmMargin)) - vqRsup_DY; (* [um] *)
                    vqMod_Rbrk_BtmMargin := 0; (* Reset modificatore temporaneo *)
                    vqMod_Rbrk_TopMargin := 0; (* Reset modificatore temporaneo *)
                    vqCarrSup_Tgt := LIMIT(Ybegin - vqRbrk_StartInside, vqY_BtmEdge-vqRsup_DY, vqY_TopEdge-vqRsup_DY); (* [um] *)
                    vbRsup_SelC := vbRsup_OpenWithCWheel; (* Anticipo selezione utensile *)
                END_IF;
                dlog( Txt:='fbCarrSup: Open range %ld|%ld mm', Lvl:=3, Val1:=Ybegin/1E3, Val2:=Yend/1E3);
                (* Mi porto in posizione di inizio lavorazione con un movimento libero *)
                MoveTo := MV_FREEMOVE;
                Status := STS_MOVING; (* Proceed *)

            ELSIF vnCarrSup_Cmd=CARCMD_BLADE_FWD OR
                  vnCarrSup_Cmd=CARCMD_BLADE_BCK THEN
                (* Tasteggio lametta *)
                vbBlade_Through := FALSE; (* Inizializzo segnale sfondamento plastico *)
                vbBladeSup_Jammed := FALSE; (* Inizializzo segnale lametta incagliata *)
                (* Nota: è responsabilità del chiamante:
                         -Effettuare il test lametta rotta in una posizione idonea
                         -Far partire la trazione con lo stacco *)
                IF vnCarrSup_Cmd=CARCMD_BLADE_FWD THEN
                    (* Tasteggio e taglio plastico avanti *)
                    dlog( Txt:='fbCarrSup: Blade seq from bottom to top', Lvl:=3 );
                    Ybegin := vqY_BtmEdge - vqBladeSup_DY + vqBlade_PrbMargin; (* tasteggio *)
                    Yend := Ybegin + vqBlade_SliceDelta; (* affettatura *)
                ELSE
                    (* Tasteggio e taglio plastico indietro *)
                    dlog( Txt:='fbCarrSup: Blade seq from top to bottom', Lvl:=3 );
                    Ybegin := vqY_TopEdge - vqBladeSup_DY - vqBlade_PrbMargin; (* tasteggio *)
                    Yend := Ybegin - vqBlade_SliceDelta; (* affettatura *)
                END_IF;
                (* Mi porto in posizione di inizio tasteggio con un movimento libero *)
                vqCarrSup_Tgt := Ybegin; (* [um] *)
                MoveTo := MV_FREEMOVE;
                Status := STS_MOVING; (* Proceed *)
            ELSE
                dlog( Txt:='fbCarrSup: !! Unknown cmd=%d', Lvl:=1, Val1:=TO_DINT(vnCarrSup_Cmd));
                Status := STS_ERROR;
            END_IF; (* -- See command *)
        END_IF; (* -- Comando attivo *)


    ELSE (* Errore sequenza (STS_ERROR) *)
        vbCarrSup_ParkOnEnd := FALSE; (* Eat temporary flags *)
        vnCarrSup_Seq := SEQ_ERROR; (* Risultato di errore *)
        MoveTo := MV_WAITSTOP;
        Ysup.Cmd := AXC_STOP_ENAB;
        Status := STS_STOPPING;

END_CASE; (* -- state machine *)



(* - Servizio di movimentazione -
     Visto che le sequenza sono tante, meglio separare il boilerplate
     della movimentazione, mi serve il movimento libero a utensili
     disattivati e il movimento di lavoro con utensile *)
IF Status<>STS_IDLE THEN
    CASE MoveTo OF

        MV_WAITMOVE : (* Attendi movimento verso quota obiettivo *)
            IF Ysup.Arrived THEN
                (* Ok, arrivato a destinazione *)
                dlog( Txt:='fbCarrSup: Arrived at %ld mm', Lvl:=6, Val1:=Ysup.TgtPos/1E3 );
                MoveTo := MV_DONE;
                (* Ho liberato la zona taglio? (Gestisco risorse acquisite) *)
                IF CutAreaFreed THEN (* AtRest *)
                    IF vnMach_Type>1 THEN dlog( Txt:='fbCarrSup: Freed cut area', Lvl:=5 ); END_IF;
                    (* Sono fuori da area taglio, libero eventuali risorse acquisite *)
                    (* Free possible acquired resources (CarrSup) *)
                    IF UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
                    IF vbFeat_FixedCarriages AND LowerCutZone_Algn=ID_CARR_INF THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_HEATLAMP]=TS_OFF,ID_HEATLAMP,0); END_IF;
                    IF vbFeat_FixedCarriages AND LowerCutZone_Dtch=ID_CARR_INF THEN LowerCutZone_Dtch:=0; END_IF;
                END_IF;
                (* Se sono andato in quota 'home' controllo sensore *)
                IF Ysup.TgtPos=Ysup.HomePos AND ToolsAtRest AND NOT IFC_YSUP_HOME THEN
                    dlog( Txt:='!! IFC_YSUP_HOME', Lvl:=1 );
                    MoveTo := MV_ERROR;
                END_IF;
            (* Per anticipare ulteriormente il rilascio delle risorse (evito il ritardo di asse fermo in quota) * )
            ELSIF (YroomP<vqCarr_CutAreaYbtm AND Ysup.Spd<=0) OR (YroomM>vqCarr_CutAreaYtop AND Ysup.Spd>=0) THEN
                (* Free possible acquired resources (CarrSup) *)
            ELSIF Ysup.Status<=AXS_READY THEN
                (* Se comando esternamente uno stop o non si attiva il bit in quota entra qui *)
                dlog( Txt:='fbCarrSup: ! Ysup move to %ld not arrived (%ld mm)', Lvl:=2, Val1:=Ysup.TgtPos/1E3, Val2:=Ysup.CurrPos/1E3 );
                MoveTo := MV_ERROR;
            ELSIF vnCarrSup_Cmd=CMD_STOP THEN (* Abort sequence *)
                dlog( Txt:='fbCarrSup: ! MoveTo aborted', Lvl:=2 );
                Ysup.Cmd := AXC_STOP_ENAB;
                MoveTo := MV_WAITSTOP;
            END_IF;


        MV_WAITSTOP : (* Attendi stop asse *)
            IF Ysup.Status<=AXS_READY THEN
                MoveTo := MV_ERROR; (* Comunque non sono arrivato *)
            END_IF;


        MV_FREEMOVE,  (* Prepara movimento libero *)
        MV_TOOLMOVE : (* Prepara movimento con utensile attivo *)
            (* TODO 4: non sarebbe male una notifica di questa attesa
               SET_MSG(MSG_CARRSUPWAITTOOLSUP,'MSG_CARRSUPWAITTOOLSUP',0);
            *)
            (* Se è un movimento libero, disattiva utensili *)
            IF MoveTo=MV_FREEMOVE THEN
                ToolsOff := TRUE;
            END_IF;
            (* Detect null movement *)
            IF ABS(Ysup.CurrPos-vqCarrSup_Tgt)<=Ysup.InPosDelta THEN
                dlog( Txt:='fbCarrSup: Already at %ld mm (inpos=%ld um)', Lvl:=4, Val1:=Ysup.CurrPos/1E3, Val2:=Ysup.InPosDelta );
                MoveTo := MV_DONE;
            (* Detect command abort *)
            ELSIF vnCarrSup_Cmd=CMD_STOP THEN (* Abort *)
                dlog( Txt:='fbCarrSup: !! Move aborted', Lvl:=1 );
                MoveTo := MV_ERROR;
            ELSIF MoveTo<>MV_FREEMOVE OR ToolsAtRest THEN (* AND Ysup.Status=AXS_READY *)
                (* Cerco di acquisire le risorse necessarie *)
                IF UpperCutZone<>ID AND UpperCutZone=0 THEN UpperCutZone:=ID; END_IF;
                (* Se carrelli vincolati, dovrei acquisire per conto di CarrInf anche: *)
                IF vbFeat_FixedCarriages THEN
                    (* ...Posso muovermi anche con lampada fuori (e ferma!) *)
                    IF LowerCutZone_Algn<>ID_CARR_INF AND (LowerCutZone_Algn=0 OR (LowerCutZone_Algn=ID_HEATLAMP AND NOT vbLamp_BlocksCarrInf)) THEN LowerCutZone_Algn:=ID_CARR_INF; END_IF;
                    IF LowerCutZone_Dtch<>ID_CARR_INF AND LowerCutZone_Dtch=0 THEN LowerCutZone_Dtch:=ID_CARR_INF; END_IF;
                END_IF;
                (* Controlla di aver acquisito le risorse *)
                IF UpperCutZone=ID
                   AND (NOT vbFeat_FixedCarriages OR (LowerCutZone_Algn=ID_CARR_INF AND LowerCutZone_Dtch=ID_CARR_INF))
                   AND Ysup.Status<>AXS_STOPPING THEN (* Evito errori se l'asse si sta fermando *)
                    (* Adesso puoi comandare il movimento *)
                    dlog( Txt:='fbCarrSup: Move from %ld to %ld mm', Lvl:=5, Val1:=Ysup.CurrPos/1E3, Val2:=vqCarrSup_Tgt/1E3);
                    IF Ysup.Status=AXS_READY THEN
                        (* Gli argomenti del posizionamento: *)
                        (* Ysup.TgtPos := <Già definito>; (* [um] *)
                        IF MoveTo=MV_FREEMOVE THEN
                            (* La velocità la decido in base a pericolo collisioni? *)
                            Ysup.TgtSpd := SEL(FALSE, TO_DINT(vnCarr_FreeMovPerc), vqCarr_SafeSpd);
                            Ysup.AccPerc := vnCarr_FreeMovPerc; (* [%] *)
                            Ysup.DecPerc := vnCarr_FreeMovPerc; (* [%] *)
                            Ysup.OutFrc := 0; (* just move [mN] *)
                            Ysup.MaxPosErr := WTR_HITDET;
                        (* ELSE (* Altrimenti devono essere già definiti! *)
                        END_IF;

                        (* Se c'è il traino agganciato parzializzo le accelerazioni *)
                        IF Ext.Locked>0 THEN
                            Ysup.AccPerc := fnPartializeAcc(Ysup.AccPerc, vnECarr_Acc);
                            Ysup.DecPerc := fnPartializeAcc(Ysup.DecPerc, vnECarr_Acc);
                        END_IF;

                        (* Forzo silenziosamente la quota obiettivo entro i limiti sw *)
                        IF vqCarrSup_Tgt>Ysup.PosLim THEN
                            dlog( Txt:='! Forcing tgt %ld>%ld', Lvl:=2, Val1:=vqCarrSup_Tgt/1E3, Val2:=Ysup.PosLim/1E3);
                            vqCarrSup_Tgt := Ysup.PosLim;
                        ELSIF vqCarrSup_Tgt<Ysup.NegLim THEN
                            dlog( Txt:='! Forcing tgt %ld<%ld', Lvl:=2, Val1:=vqCarrSup_Tgt/1E3, Val2:=Ysup.NegLim/1E3);
                            vqCarrSup_Tgt := Ysup.NegLim;
                        END_IF;
                        Ysup.TgtPos := vqCarrSup_Tgt; (* [um] *)
                        Ysup.Cmd := AXC_START_POS;
                        MoveTo := MV_WAITMOVE;
                    ELSE
                        dlog( Txt:='!! Ysup not ready (%d) to move', Lvl:=1, Val1:=TO_DINT(Ysup.Status));
                        MoveTo := MV_ERROR;
                    END_IF;
                ELSE (* Altrimenti aspetta che si liberino *)
                    (* Probabilmente non sono riuscito ad acquisire una o più risorse,
                       oppure l'asse non è ancora pronto: tenterò il prossimo giro *)
                    (* Free possible acquired resources (CarrSup) *)
                    IF UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
                    IF vbFeat_FixedCarriages AND LowerCutZone_Algn=ID_CARR_INF THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_HEATLAMP]=TS_OFF,ID_HEATLAMP,0); END_IF;
                    IF vbFeat_FixedCarriages AND LowerCutZone_Dtch=ID_CARR_INF THEN LowerCutZone_Dtch:=0; END_IF;
                END_IF;
            (*ELSE (* Notifica attesa utensili a riposo?
                SET_MSG(MSG_CARRSUPWAITTOOLSUP,'',0); *)
            END_IF;

    END_CASE; (* -- servizio movimentazione *)
END_IF; (* -- Sequenza in corso *)



(* -- Deactivate all tools services -- *)
IF ToolsOff THEN
    vbTsup_Cmd := FALSE;
    vbRsup_Cmd := FALSE;
    vnBladeSup_Cmd := CMD_STOP;
    Probe1( Activate:=FALSE );
    Probe2( Activate:=FALSE );
    IF vnGrLe_Cmd>1 THEN vnGrLe_Cmd := 0; END_IF; (* Se la mola sta solo girando la lascio girare. Nota: Potrebbe essere su traino *)
    ToolsOff := FALSE; (* Eat *)
END_IF;


(* -- Gestione soffio polvere -- *)
O_AIRBLOW_SUP := vbDustBlow_Cmd;


(* -- Eventuale traino carrello (ActiveHP) -- *)
IF vqECarrSup_Length<>0 THEN
    Ext();
END_IF;


(* -- Monitors -- *)

(* Ingombri carrello *)
(* Per l'ingombro attuale: Ysup.CurrPos, altrimenti per quello futuro: Ysup.StopPos *)
YroomM := Ysup.SafeStopPos + vqCarrSup_CurrDYroomM;
YroomP := Ysup.SafeStopPos + vqCarrSup_CurrDYroomP;

ToolsAtRest := Tsup.AtRest AND Rsup.AtRest AND BladeSup.AtRest AND GrLe.Up; (* Tsup2.AtRest AND Rsup2.AtRest *)

(* Collisione stacco-carrello
   Nota: Nelle StratoS (vnMach_Type<=1) lo stacco non può collidere coi carrelli *)
CutAreaFreed := YroomM>vqCarr_CutAreaYtop OR YroomP<vqCarr_CutAreaYbtm;

(* La posizione di home corrisponde a quella a cui va l'asse dopo l'azzeramento (QuoHome);
   Se l'asse è in home si è sempre a riposo (a meno che non ci sia il traino attaccato?) *)
AtHome := IFC_YSUP_HOME AND ABS(Ysup.CurrPos-Ysup.HomePos)<1E3;
          (* AND (vqECarrSup_Length=0 OR Ext.Locked<=0) (* ...E non ha il traino attaccato *)

(* Il segnale 'AtRest' significa che la zona taglio è libera
   Su alcune macchine questo avviene sia con parcheggio alto che basso.
   In ogni caso questo è sempre vero se si è nella posizione di 'Home',
   che coincide col parcheggio alto se 'vbFeat_CarrHomeOnTop' *)
AtRest := (vbAx_NoStillChkAtRest OR Ysup.Still) (* Asse fermo? *)
          AND NOT (Ysup.MovingFwd OR Ysup.MovingBck) (* vbFeat_CarrHomeOnTop *)
          AND ( AtHome (* In 'home' si è sempre "a riposo" *)
                OR CutAreaFreed ); (* Se Parcheggio diverso da 'home' *)

vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbCarrInf

{ DE:"Carrello inferiore" }

	VAR_IN_OUT
	ToolsOff : BOOL; { DE:"Deactivate all tools" }
	Ext : fbExtraCarrInf; { DE:"Appendice passiva/traino del carrello inferiore" }
	END_VAR

	VAR_INPUT
	Allow : BOOL; { DE:"Consenso alle operazioni del carrello" }
	Abort : BOOL; { DE:"Segnale di stop/annullamento sequenza" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Carrello parcheggiato fuori da area taglio" }
	AtHome : BOOL; { DE:"Carrello parcheggiato in posizione di home" }
	CutAreaFreed : BOOL; { DE:"Area taglio liberata" }
	ToolsAtRest : BOOL; { DE:"Tutti gli utensili sono a riposo" }
	YroomM : DINT; { DE:"Ingombro Y indietro corrente corpo carrello [um]" }
	YroomP : DINT; { DE:"Ingombro Y avanti corrente corpo carrello [um]" }
	GrabberYroomM : DINT; { DE:"Ingombro Y indietro corrente pinza [um]" }
	GrabberYroomP : DINT; { DE:"Ingombro Y avanti corrente pinza [um]" }
	ID : INT := ID_CARR_INF; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	vd : ARRAY[ 0..255 ] OF LREAL; { DE:"VD[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vbAx_NoStillChkAtRest : BOOL; { DE:"Non controllare asse fermo nella condizione di parcheggio" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vnMach_Type : INT; { DE:"Tipo macchina" }
	vbFeat_FixedCarriages : BOOL; { DE:"Macchina con carrelli vincolati" }
	vbCarriages_Prepos : BOOL; { DE:"Preposiziona i carrelli all'inizio del lavoro" }
	vnCarrInf_Cmd : INT; { DE:"Comando carrello inferiore (vedi 'CMD_*')" }
	vbCarrInf_ParkOnEnd : BOOL; { DE:"Parcheggia il carrello alla fine dell'operazione" }
	vnCarrInf_Seq : INT; { DE:"Risultato sequenza carrello inferiore" }
	vqCarrInf_Tgt : DINT; { DE:"Posizione obiettivo carrello inferiore [um]" }
	vqCarrInf_Spd : DINT; { DE:"Velocità carrello inferiore [um/min]" }
	vqCarrInf_Frc : DINT; { DE:"Limite forza carrello inferiore [mN]" }
	UpperCutZone : INT; { DE:"Spazio sopra il piano all'interno del ponte di taglio" }
	LowerCutZone_Algn : INT; { DE:"Spazio sotto il piano nell'area di taglio lato risc" }
	LowerCutZone_Dtch : INT; { DE:"Spazio sotto il piano nell'area di taglio lato stacco" }
	vqCarr_CutAreaYbtm : DINT; { DE:"Ordinata inizio area non sicura carrelli [um]" }
	vqCarr_CutAreaYtop : DINT; { DE:"Ordinata fine area non sicura carrelli [um]" }
	vbLamp_BlocksCarrInf : BOOL; { DE:"La lampada sta bloccando il movimento del carrello inferiore" }
	vbCarr_PartAcc : BOOL; { DE:"Parzializza accelerazione carrelli in base a velocità" }
	vbCarr_ToolsOffOnErr : BOOL; { DE:"Alza subito utensili in caso di errori del movimento" }
	vbCarr_ParkFreesCutArea : BOOL; { DE:"Il comando parcheggio garantisce di liberare l'area taglio" }
	vnCarr_FreeMovPerc : INT; { DE:"Parzializzazione vel/acc movimenti liberi carrelli [%]" }
	vnCarr_ChgTgtDec : INT; { DE:"Decelerazione per ricerca bordo finale vetro [%]" }
	vqCarr_SafeSpd : DINT; { DE:"Velocità con pericolo collisioni [um/min]" }
	vnECarr_Acc : INT; { DE:"Parzializzazione accelerazione carrelli con traini agganciati [%]" }
	vqYmin : DINT; { DE:"Ordinata minima del bordo vetro [um]" }
	vqYmax : DINT; { DE:"Ordinata massima del bordo vetro [um]" }
	vqCarrInf_CurrDYroomM : DINT; { DE:"Ingombro Y effettivo (indietro) carrello inferiore [um]" }
	vqCarrInf_CurrDYroomP : DINT; { DE:"Ingombro Y effettivo (avanti) carrello inferiore [um]" }
	vqYinf_TopParkPos : DINT; { DE:"Posizione di parcheggio alto carrello inferiore [um]" }
	vqYinf_BtmParkPos : DINT; { DE:"Posizione di parcheggio basso carrello inferiore [um]" }
	vbFeat_CarrHomeOnTop : BOOL; { DE:"Macchina con parcheggio carrelli opposto ad operatore" }
	vqY_Middle : DINT; { DE:"Posizione a metà corsa dei carrelli [um]" }
	vqECarrInf_Length : DINT; { DE:"Dimensione traino inferiore [um]" }
	vnECarrInf_Lock : INT; { DE:"Comando aggancio/sgancio traino carrello inferiore" }
	vqYinf_LockPos : DINT; { DE:"Posizione di aggancio/sgancio traino carrello inferiore [um]" }
	vqECarr_LockApproach : DINT; { DE:"Margine avvicinamento posizione di aggancio/sgancio traini [um]" }
	vqECarr_LockApproachSpd : DINT; { DE:"Velocità avvicinamento posizione di aggancio/sgancio traini [um/min]" }
	vbGrabber_NotLocked : BOOL; { DE:"Pinza su traino e non agganciata a carrello inferiore" }
	vbGrabber_CanBeUnlocked : BOOL; { DE:"Pinza su traino e agganciata a carrello inferiore" }
	Yinf : fbM32Axis; { DE:"Asse carrello inferiore AX_YINF" }
	IFC_YINF_ZERO : BOOL; { DE:"Sensore azzeramento carrello inferiore (0:engaged)" }
	IFC_YINF_POSLIM : BOOL; { DE:"Finecorsa (min e max) carrello inferiore (1:engaged)" }
	IFC_YINF_HOME : BOOL; { DE:"Sensore carrello inferiore in posizione di riposo (area taglio libera)" }
	vqSubSheet_ProcHeight : DINT; { DE:"Dimensione trasversale lastra in arrivo (dopo la rotazione) [um]" }
	vnEdgeDet_Mode : INT; { DE:"Modo rilevazione bordi (0=single-sweep, 1=double-sweep, 2=accurate)" }
	vqEdgeDet_Margin : DINT; { DE:"Margine per rilevazione bordo vetro [um]" }
	vqEdgeDet_MaxErr : DINT; { DE:"Massima discrepanza ammessa delle catture di un bordo [um]" }
	vqEdgeDet_SweepSpd : DINT; { DE:"Velocità spazzate misurazione vetro [um/min]" }
	vqEdgeDet_OnTheFlySpd : DINT; { DE:"Velocità ricerca al volo [um/min]" }
	vbEdgeDet_AutoFlyUseDim : BOOL; { DE:"In automatico usa la dimensione lastra per il target della ricerca al volo" }
	vqEdgeDet_AcqSpd : DINT; { DE:"Velocità acquisizione fine [um/min]" }
	vbFeat_HasProbeInf2 : BOOL; { DE:"Sonda secondaria per ricerca al volo durante lavorazione" }
	vqY_BtmEdge : DINT; { DE:"Quota misurata bordo vetro basso [um]" }
	vqY_TopEdge : DINT; { DE:"Quota misurata bordo vetro alto [um]" }
	vqCut_Length : DINT; { DE:"Lunghezza taglio effettiva [um]" }
	Tinf : fbTscore; { DE:"Testina di incisione inferiore" }
	vbTinf_Cmd : BOOL; { DE:"Activate lower scoring head 'ID_TINF'" }
	vnHoldPads_Cmd : INT; { DE:"Comando discesa tamponi fermavetro" }
	vqTinf_P : DINT; { DE:"Spinta incisione inferiore [mN]" }
	vqTscore_BtmMargin : DINT; { DE:"Margine da bordo vetro basso incisione [um]" }
	vqTscore_TopMargin : DINT; { DE:"Margine da bordo vetro alto incisione [um]" }
	vqF_score_inf : DINT; { DE:"Forza pressione incisione inferiore 'F-score-inf' [mN]" }
	vqV_score : DINT; { DE:"Velocità di incisione 'V-score' [um/min]" }
	vqTscore_ScoreYforce : DINT; { DE:"Forza massima che il carrello può erogare durante incisione [mN]" }
	vqMod_F_score_inf : DINT; { DE:"Modifier 'f-score-inf' [mN]" }
	vqMod_Tscore_BtmMargin : DINT; { DE:"Modifier [um]" }
	vqMod_Tscore_TopMargin : DINT; { DE:"Modifier [um]" }
	Rinf : fbRbrk; { DE:"Rotella di apertura inferiore" }
	vbRinf_Cmd : BOOL; { DE:"Activate lower breakout wheel" }
	vqRinf_P : DINT; { DE:"Spinta rotella di apertura inferiore [mN]" }
	vbRsup_SelC : BOOL; { DE:"Select counter-wheel" }
	vbRinf_SelC : BOOL; { DE:"Select counter-wheel" }
	vqRinf_DY : DINT; { DE:"Offset rotella apertura inferiore [um]" }
	vqRbrk_BtmMargin : DINT; { DE:"Margine da bordo vetro basso rotelle di apertura [um]" }
	vqRbrk_TopMargin : DINT; { DE:"Margine da bordo vetro alto rotelle di apertura [um]" }
	vqF_brkwhl_sup : DINT; { DE:"Forza pressione rotella di apertura singola 'f-brkwhl-sup' [mN]" }
	vqV_brkwhl_sup : DINT; { DE:"Velocità rotella di apertura singola 'v-brkwhl-sup' [um/min]" }
	vqMod_Rbrk_BtmMargin : DINT; { DE:"Modifier [um]" }
	vqMod_Rbrk_TopMargin : DINT; { DE:"Modifier [um]" }
	vqRbrk_StartInside : DINT; { DE:"Inizio apertura interno rispetto il margine [um]" }
	vqRbrk_OpenYforce : DINT; { DE:"Forza massima che il carrello può erogare durante apertura con rotelle [mN]" }
	Zg : fbM32Axis; { DE:"Asse orientazione pinza AX_ZG" }
	vqZgSetTorqueLim : DINT; { DE:"Servizio impostazione coppia orientazione (NO_POS_UM:none pos:mNmm/deg neg:max)" }
	Grabber : fbGrabber; { DE:"Pinza girapezzi su carrello inferiore" }
	vnGrabber_Type : INT; { DE:"Tipo girapezzi 'ID_GRABBER' (0:none 1:ventosa 2:pinza)" }
	vqGrabber_DY : DINT; { DE:"Offset asse pinza girapezzi [um]" }
	vqGrabber_Radius : DINT; { DE:"Raggio pinza girapezzi [um]" }
	vnGrabber_Cmd : INT; { DE:"Grabber command" }
	O_GRAB_PRESSREDUCER : BOOL; { DE:"Aziona riduttore di pressione ganasce pinza" }
	vbSubSheet_Prescored : BOOL; { DE:"La sottolastra in arrivo contiene preincisioni" }
	vbZprescored_Done : BOOL; { DE:"Il passo precedente è stato una preincisione eseguita con successo" }
	BladeInf : fbPvbBladeInf; { DE:"Lametta inferiore taglio plastico" }
	vnBladeInf_Cmd : INT; { DE:"Comando a lametta PVB inferiore" }
	vbLampOut_Cmd : BOOL; { DE:"Aziona uscita lampada riscaldamento PVB" }
	vqBladeInf_DY : DINT; { DE:"Offset lametta PVB su carrello inferiore [um]" }
	vbBlade_Through : BOOL; { DE:"Segnale sfondamento plastico" }
	vbBladeInf_Jammed : BOOL; { DE:"Segnale lametta inferiore incagliata" }
	vqBlade_BtmMargin : DINT; { DE:"Margine da bordo vetro basso lametta [um]" }
	vqBlade_TopMargin : DINT; { DE:"Margine da bordo vetro alto lametta [um]" }
	vqPvbThckn : DINT; { DE:"Spessore dichiarato plastico [um]" }
	vbBlade_WaitFinalPull : BOOL; { DE:"Dopo sfondamento attendi movimento finale stacco" }
	vqBlade_MaxPosErr : DINT; { DE:"Massimo errore inseguimento ammesso durante taglio plastico [um]" }
	vqBlade_StuckPosErr : DINT; { DE:"Errore inseguimento per rilevazione lametta inceppata [um]" }
	vqBlade_UnjamForce : DINT; { DE:"Forza per disincastrare la lametta [mN]" }
	vqBlade_UnjamMove : DINT; { DE:"Ampiezza movimento per disincastrare la lametta [um]" }
	vqBlade_Speed : DINT; { DE:"Velocità durante taglio PVB [um/min]" }
	vnBlade_Accel : INT; { DE:"Parzializzazione accelerazione durante taglio PVB [%]" }
	vqBlade_CutYforce : DINT; { DE:"Forza del carrello durante taglio PVB per ogni decimo di plastico [mN/0.1mm]" }
	vnBlade_PrbTries : INT; { DE:"Numero di tentativi per passare al secondo tasteggio" }
	vqBlade_PrbMargin : DINT; { DE:"Margine dal bordo del primo tasteggio [um]" }
	vqBlade_PrbDelta : DINT; { DE:"Spostamento verso l'interno dei tentativi successivi [um]" }
	vqBlade_Tdelay : DINT; { DE:"Tempo attesa tasteggio successivo [ms]" }
	vqBlade_SliceDelta : DINT; { DE:"Movimento orizzontale durante tasteggio [um]" }
	vqBlade_SliceSpeed : DINT; { DE:"Velocità affettatura durante tasteggio [um/min]" }
	vbBlade_SliceKeepOn : BOOL; { DE:"Non alzare lametta durante tasteggio" }
	vbBlade_NoWaitUp : BOOL; { DE:"Vai direttamente in parcheggio dopo taglio PVB" }
	vbEdgeTrim_Cmd : BOOL; { DE:"Activate edge trimming tool (up+out)" }
	O_AIRBLOW_INF : BOOL; { DE:"Ugello soffio aria pulizia su carrello inferiore" }
	END_VAR

	VAR
	MoveTo : EN_AXIS_MV_CMD := MV_DONE; { DE:"Servizio movimentazione asse carrello" }
	Probe1 : fbProbe; { DE:"Primary probe latches service" }
	Probe2 : fbProbe; { DE:"Secondary probe latches service (vbFeat_HasProbeInf2)" }
	try_count : INT; { DE:"Contatore spazzate ricerca/tentativi lametta" }
	fly_fall_latch : DINT; { DE:"Cattura posizione bordo finale vetro [um]" }
	btm_latch : DINT; { DE:"Cattura posizione bordo basso vetro [um]" }
	top_latch : DINT; { DE:"Cattura posizione bordo alto vetro [um]" }
	btm_meas : DINT; { DE:"Misura posizione bordo basso vetro [um]" }
	top_meas : DINT; { DE:"Misura posizione bordo alto vetro [um]" }
	Y : DINT; { DE:"Quota y [um]" }
	Ybegin : DINT; { DE:"Quota di partenza dell'utensile [um]" }
	Yend : DINT; { DE:"Quota di arrivo dell'utensile [um]" }
	TBladeDelay : Ton; { DE:"Timer attesa tasteggio lametta PVB" }
	ZgSetForce : RiseEdge; { DE:"Servizio set forza orientazione pinza" }
	END_VAR

	{ CODE:ST }(*    fbCarrInf (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Logiche relative al carrello inferiore come
      entità singola.
      I comandi singoli sono introdotti oltre a
      quelli del modulo di funzionamento coordinato
      dei carrelli 'fbCarriages' per permettere la
      sovrapposizione di movimenti singoli
      (es. porta un carrello in parcheggio e nel
      frattempo muovi l'altro).
      Risorse che può occupare:
        .'LowerCutZone_Dtch' (zona taglio bassa lato stacco - collisione stacco)
        .'LowerCutZone_Algn' (zona taglio bassa lato risc - collisione lampada)
      Nel caso di carrelli vincolati ovviamente anche:
        .'UpperCutZone' (zona taglio alta)

      NOTES
      ----------------------------------------------
      Essendo questo un servizio finale rispondo
      direttamente al comando 'vnCarrInf_Cmd' in modo
      da poterlo resettare e dare un feedback immediato.
*)


(* -- Manage stop signal -- *)
IF Abort THEN
    vnCarrInf_Cmd := CMD_STOP; (* Remove command *)
(* ELSIF Suspend THEN (* Could suspend? servirebbe fermare l'asse e partire dallo step precedente *)
END_IF;
(* Notify abort *)
IF (Status>STS_STOPPING AND MoveTo<>MV_WAITSTOP) AND vnCarrInf_Cmd=CMD_STOP THEN
    dlog( Txt:='fbCarrInf: !! Abort Sts=%d', Lvl:=3, Val1:=TO_DINT(Status) );
END_IF;



(* -- State machine -- *)
TBladeDelay( in:=Status=CARSTS_PVB_UP AND BladeInf.Stable, pt:=TO_UDINT(vqBlade_Tdelay) );
CASE Status OF
    (* ------------------------------------------------------------------- *)
    STS_MOVING : (* Movimento singolo libero *)
        IF MoveTo=MV_DONE AND Zg.Status<=AXS_READY THEN
            (* Ok, arrivato a destinazione, vediamo cosa dobbiamo fare *)
            CASE vnCarrInf_Cmd OF

                CARCMD_SCORE_FWD, CARCMD_SCORE_BCK :
                    IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                        (* Ricerca "al volo": Preparo le sonde
                           La sonda principale Probe1 rileva con un fronte di salita
                           il bordo iniziale, e con un fronte di discesa il bordo finale.
                           Una eventuale sonda secondaria Probe2, montata più avanti,
                           aiuta a rilevare con un fronte di discesa il bordo finale
                           con maggiore anticipo *)
                        Probe1( ProbeIdx:=IRQ_PROBEINF, AxIdx:=AX_YINF, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                        Probe2( ProbeIdx:=IRQ_PROBEINF2, AxIdx:=AX_YINF, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                        fly_fall_latch := NO_POS_UM; (* Bordo finale ignoto *)
                        try_count := 0; (* Inizializzo tentativi *)
                        Status := CARSTS_SRCH_FLY_INI;
                    ELSE
                        (* Arrivato alla quota di inizio incisione *)
                        (* Attivo testina *)
                        (* vbLubScore_Cmd := TRUE; *)
                        vqTinf_P := vqF_score_inf + vqMod_F_score_inf;
                        vqMod_F_score_inf := 0; (* Reset modificatore temporaneo *)
                        vbTinf_Cmd := TRUE;
                        Status := CARSTS_SCORE_INIT;
                    END_IF;

                CARCMD_OPEN_FWD, CARCMD_OPEN_BCK :
                    (* Arrivato alla quota di inizio apertura con rotella *)
                    (* Attivo rotella *)
                    vqRinf_P := vqF_brkwhl_sup; (* [mN] Eh, di solito la singola è quella sopra! *)
                    vbRinf_SelC := FALSE; (* wheel *)
                    vbRsup_SelC := FALSE; (* Assicuro no controrotella altrimenti c'è il 'Synch' *)
                    vbRinf_Cmd := TRUE;
                    (* Vediamo dove parto ad aprire *)
                    IF vqCarrInf_Tgt<>Ybegin THEN
                        (* Inizio ad aprire dentro, vado verso il bordo iniziale *)
                        dlog( Txt:='fbCarrInf: Inner opening at %ld', Lvl:=4, Val1:=vqCarrInf_Tgt/1E3 );
                        vqCarrInf_Tgt := Ybegin;
                    ELSE
                        (* Sono partito dal bordo iniziale, vado direttamente alla fine *)
                        vqCarrInf_Tgt := Yend;
                    END_IF;
                    Status := CARSTS_OPEN_INIT;

                CARCMD_SRCHGLASS_FWD, CARCMD_SRCHGLASS_BCK :
                    (* Arrivato alla quota iniziale di ricerca *)
                    (* Inizializzo e preparo la prima spazzata *)
                    try_count := 0; (* Inizializzo tentativi *)
                    btm_latch := 0; (* [um] *)
                    top_latch := 0; (* [um] *)
                    btm_meas := NO_POS_UM; (* Usati per rilevazione fine *)
                    top_meas := NO_POS_UM;
                    vqY_BtmEdge := NO_POS_UM; (* Inizializzo risultato ricerca *)
                    vqY_TopEdge := NO_POS_UM;
                    vqCut_Length := 0;
                    (* Attivo la sonda *)
                    Probe1( ProbeIdx:=IRQ_PROBEINF, AxIdx:=AX_YINF, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                    Status := CARSTS_SRCH_SWEEP_INI;

                CARCMD_BLADE_FWD, CARCMD_BLADE_BCK :
                    (* Arrivato alla quota iniziale di tasteggio *)
                    (* Yinf.MaxPosErr := WTR_DISABLE; *)
                    dlog( Txt:='fbCarrInf: Blade tries at %ld mm', Lvl:=3, Val1:=Yinf.CurrPos/1E3 );
                    try_count := 0; (* Inizializzo tentativi *)
                    Status := CARSTS_PVB_DWN;

                CMD_PARK, CARCMD_BTMPARK, CARCMD_TOPPARK :
                    (* Comandato un parcheggio: C'è un ulteriore movimentino da fare? *)
                    IF vqCarrInf_Tgt=Yend THEN
                        (* Arrivato alla posizione finale, fatto *)
                        vnCarrInf_Cmd := CMD_STOP;
                        vnCarrInf_Seq := SEQ_DONE;
                        Status := STS_IDLE;
                    ELSE
                        (* Vado alla posizione finale con un... *)
                        vqCarrInf_Tgt := Yend;
                        (* ...Movimentino personalizzato *)
                        Yinf.TgtSpd := vqECarr_LockApproachSpd; (* [um/min] *)
                        Yinf.AccPerc := 10; (* [%] *)
                        Yinf.DecPerc := 10; (* [%] *)
                        Yinf.OutFrc := 0; (* just move [mN] *)
                        Yinf.MaxPosErr := WTR_HITDET;
                        MoveTo := MV_TOOLMOVE;
                    END_IF;

                CARCMD_FULLPARK :
                    (* Comandato un parcheggio completo, vedi se ho completato *)
                    IF vqECarrInf_Length<>0 AND Ext.Locked>0 THEN
                        (* Traino ancora agganciato a carrello *)
                        IF vqCarrInf_Tgt=vqYinf_LockPos THEN
                            (* Arrivato alla quota di aggancio/sgancio *)
                            vnECarrInf_Lock := -1; (* Comanda sgancio *)
                            Status := CARSTS_TRAIL_LOCK;
                        ELSE
                            (* Arrivato alla quota di prossimità aggancio/sgancio,
                               vado a quella finale con un... *)
                            vqCarrInf_Tgt := vqYinf_LockPos;
                            (* ...Movimentino personalizzato *)
                            Yinf.TgtSpd := vqECarr_LockApproachSpd; (* [um/min] *)
                            Yinf.AccPerc := 10; (* [%] *)
                            Yinf.DecPerc := 10; (* [%] *)
                            Yinf.OutFrc := 0; (* just move [mN] *)
                            Yinf.MaxPosErr := WTR_HITDET;
                            MoveTo := MV_TOOLMOVE;
                        END_IF;
                    ELSE
                        (* Terminato? Alla fine devo arrivare in 'home' *)
                        IF Yinf.TgtPos=Yinf.HomePos THEN
                            vnCarrInf_Cmd := CMD_STOP;
                            vnCarrInf_Seq := SEQ_DONE;
                        END_IF;
                        Status := STS_IDLE;
                    END_IF;

                CARCMD_TRAIL_LOCK, CARCMD_TRAIL_UNLOCK :
                    IF vqCarrInf_Tgt=vqYinf_LockPos THEN
                        (* Arrivato alla quota di aggancio/sgancio *)
                        vnECarrInf_Lock := SEL(vnCarrInf_Cmd=CARCMD_TRAIL_LOCK,TO_INT(-1),INT#1);
                        Status := CARSTS_TRAIL_LOCK;
                    ELSE
                        (* Arrivato alla quota di prossimità aggancio/sgancio,
                           vado a quella finale con un... *)
                        vqCarrInf_Tgt := vqYinf_LockPos;
                        (* ...Movimentino personalizzato *)
                        Yinf.TgtSpd := vqECarr_LockApproachSpd; (* [um/min] *)
                        Yinf.AccPerc := 10; (* [%] *)
                        Yinf.DecPerc := 10; (* [%] *)
                        Yinf.OutFrc := 0; (* just move [mN] *)
                        Yinf.MaxPosErr := WTR_HITDET;
                        MoveTo := MV_TOOLMOVE;
                    END_IF;

                CMD_DRIVEN :
                    (* Mi sono portato alla posizione iniziale *)
                    Status := STS_IDLE;

                ELSE (* Terminiamo qui *)
                    vnCarrInf_Cmd := CMD_STOP;
                    vnCarrInf_Seq := SEQ_DONE;
                    Status := STS_IDLE;
            END_CASE;
        ELSIF MoveTo=MV_ERROR THEN
            (* dlog( Txt:='fbCarrInf: !! Free move error', Lvl:=6 ); *)
            Status := STS_ERROR;
        (* ELSE (* Wait move *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_PRBINIT : (* Preparo nuovo tentativo tasteggio *)
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF MoveTo<MV_WAITSTOP THEN
            vqCarrInf_Tgt := Ybegin; (* [um] *)
            IF vbBlade_SliceKeepOn THEN
                Yinf.TgtSpd := vqBlade_SliceSpeed;
                Yinf.AccPerc := vnBlade_Accel; (* [%] *)
                Yinf.DecPerc := 100; (* [%] *)
                Yinf.OutFrc := vqBlade_UnjamForce/2; (* [mN] *)
                Yinf.MaxPosErr := WTR_DEFAULT;
                MoveTo := MV_TOOLMOVE;
            ELSE
                MoveTo := MV_FREEMOVE;
            END_IF;
            Status := STS_MOVING; (* Proceed *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_DWN : (* Tasteggio - lametta giù *)
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            vnBladeInf_Cmd := CMD_STOP;
            Status := STS_ERROR;
        ELSE
            (* Spingi con lametta *)
            vnBladeInf_Cmd := BLCMD_CUTPVB;
            BladeInf();

            (* Attendo spinta lametta *)
            IF BladeInf.Status=BS_THROUGH THEN
                (* Ha sfondato il plastico! Nota: se try_count=0 era il primo tentativo *)
                vbBlade_Through := TRUE;
                dlog( Txt:='fbCarrInf: Blade passed through (try %d)', Lvl:=3, Val1:=TO_DINT(try_count) );
                (* Assicuro lampada giù e spenta *)
                vbLampOut_Cmd := FALSE;
                (* Ferma movimento di affettatura *)
                Yinf.Cmd := AXC_STOP_ENAB;
                (* Procedo a tagliare il plastico indietro verso bordo iniziale, tipicamente è un movimentino *)
                Status := CARSTS_PVB_CUT1INIT;
            ELSIF BladeInf.Status=BS_PUSHED THEN
                (* Si è appoggiata al vetro, ritentiamo *)
                vnBladeInf_Cmd := SEL(vbBlade_SliceKeepOn, CMD_STOP, BLCMD_PROBE);
                BladeInf();

                try_count := try_count + 1;
                IF try_count >= vnBlade_PrbTries THEN
                    dlog( Txt:='fbCarrInf: ! Tried %d times at pos %ld', Lvl:=3, Val1:=TO_DINT(try_count), Val2:=Ybegin/1E3 );
                    (* Ci spostiamo un po' in là e ritentiamo? *)
                    IF vnCarrInf_Cmd=CARCMD_BLADE_FWD AND Ybegin<(vqY_TopEdge-vqCut_Length/2) THEN
                        Ybegin := Ybegin + vqBlade_PrbDelta; (* tasteggio *)
                        Yend := Ybegin + vqBlade_SliceDelta; (* affettatura *)
                        (* Mi porto in posizione di inizio tasteggio con un movimento libero *)
                        Yinf.Cmd := AXC_STOP_ENAB; (* Ferma movimento di affettatura *)
                        Status := CARSTS_PVB_PRBINIT; (* Proceed *)
                    ELSIF vnCarrInf_Cmd=CARCMD_BLADE_BCK AND Ybegin>(vqY_TopEdge-vqCut_Length/2) THEN
                        Ybegin := Ybegin - vqBlade_PrbDelta; (* tasteggio *)
                        Yend := Ybegin - vqBlade_SliceDelta; (* affettatura *)
                        (* Mi porto in posizione di inizio tasteggio con un movimento libero *)
                        Yinf.Cmd := AXC_STOP_ENAB; (* Ferma movimento di affettatura *)
                        Status := CARSTS_PVB_PRBINIT; (* Proceed *)
                    ELSE
                        dlog( Txt:='fbCarrInf: !! Give up', Lvl:=3 );
                        Status := STS_ERROR;
                    END_IF;
                ELSE
                    (* Continua a provare, torna su *)
                    Status := CARSTS_PVB_UP;
                END_IF;
            END_IF;

            (* Movimento di affettatura: potrei sincronizzarmi con la discesa
               lametta ma è interessante lasciare uno sfasamento variabile *)
            IF MoveTo<MV_WAITSTOP THEN
                IF vqCarrInf_Tgt<>Yend THEN vqCarrInf_Tgt := Yend;
                ELSE vqCarrInf_Tgt := Ybegin; END_IF;
                Yinf.TgtSpd := vqBlade_SliceSpeed; (* [um/min] *)
                Yinf.AccPerc := vnBlade_Accel; (* [%] *)
                Yinf.DecPerc := 100; (* max [%] *)
                Yinf.OutFrc := (vqBlade_CutYforce/10) * (vqPvbThckn/10); (* [mN] *)
                Yinf.MaxPosErr := WTR_DISABLE;
                dlog( Txt:='fbCarrInf: Blade slicing to %ld mm (count %d)', Lvl:=5, Val1:=vqCarrInf_Tgt/1E3, Val2:=TO_DINT(try_count) );
                MoveTo := MV_TOOLMOVE;
            END_IF;

        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_UP : (* Tasteggio - lametta su *)
        vnBladeInf_Cmd := SEL(vbBlade_SliceKeepOn, CMD_STOP, BLCMD_PROBE);
        BladeInf();
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Attendo condizione per il tentativo successivo *)
        ELSIF TBladeDelay.q THEN
            Status := CARSTS_PVB_DWN;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_CUT1INIT : (* Preparo taglio plastico verso bordo iniziale *)
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF MoveTo<MV_WAITSTOP AND (vn[ivnStatus+ID_DTCH]=STS_IDLE OR NOT vbBlade_WaitFinalPull) THEN (* AND vn[ivnStatus+ID_HEATLAMP]=TS_OFF Potrei attendere lampada bassa  *)
            vbBlade_WaitFinalPull := FALSE; (* eat *)
            IF vnCarrInf_Cmd=CARCMD_BLADE_FWD THEN
                (* Verso avanti *)
                Ybegin := vqY_BtmEdge + vqBlade_BtmMargin - vqBladeInf_DY; (* [um] *)
                Yend := vqY_TopEdge - vqBlade_TopMargin - vqBladeInf_DY; (* [um] *)
            ELSE
                (* Verso indietro *)
                Ybegin := vqY_TopEdge - vqBlade_TopMargin - vqBladeInf_DY; (* [um] *)
                Yend := vqY_BtmEdge + vqBlade_BtmMargin - vqBladeInf_DY; (* [um] *)
            END_IF;
            vbBladeInf_Jammed := FALSE; (* Inizializzo segnale lametta incagliata *)
            vqCarrInf_Tgt := Ybegin; (* [um] *)
            Yinf.TgtSpd := vqBlade_Speed; (* [um/min] *)
            Yinf.AccPerc := vnBlade_Accel; (* [%] *)
            Yinf.DecPerc := 100; (* max [%] *)
            Yinf.OutFrc := (vqBlade_CutYforce/10) * (vqPvbThckn/10); (* [mN] *)
            (* Nota: la spinta verso il basso è 'BladeInf.Push' *)
            Yinf.MaxPosErr := vqBlade_MaxPosErr; (* [um] *)
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_PVB_CUT1;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_CUT1 : (* Taglio plastico verso bordo iniziale *)
        IF MoveTo<MV_WAITSTOP THEN
            IF vbBladeInf_Jammed THEN
                (* Ero incagliato, abortisco, lascio che il programma gestisca la cosa *)
                Status := STS_ERROR;
            ELSIF MoveTo=MV_DONE THEN
                (* Ok, ora devo tagliare verso bordo finale *)
                Status := CARSTS_PVB_CUT2INIT;
            ELSE
                dlog( Txt:='fbCarrInf: !! Blade cut to begin edge not completed!', Lvl:=2 );
                Status := STS_ERROR;
            END_IF;
        (* ELSE (* Wait move *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_CUT2INIT : (* Preparo taglio plastico verso bordo finale *)
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Attendo che stacco abbia completato l'ultimo tiro *)
        ELSIF vn[ivnStatus+ID_DTCH]=STS_IDLE OR NOT vbBlade_WaitFinalPull THEN
            vbBlade_WaitFinalPull := FALSE; (* eat *)
            (* Ok, ora vado verso bordo finale *)
            IF vbBlade_NoWaitUp AND
               ( (Yend>Ybegin AND Yinf.HomePos>Yend) OR
                 (Yend<Ybegin AND Yinf.HomePos<Yend) ) THEN
                (* Finisci direttamente in parcheggio *)
                vqCarrInf_Tgt := Yinf.HomePos; (* [um] *)
            ELSE
                (* Finisci normalmente al bordo finale *)
                vqCarrInf_Tgt := Yend; (* [um] *)
            END_IF;
            Yinf.TgtSpd := vqBlade_Speed; (* [um/min] *)
            Yinf.AccPerc := vnBlade_Accel; (* [%] *)
            Yinf.DecPerc := 100; (* max [%] *)
            Yinf.OutFrc := (vqBlade_CutYforce/10) * (vqPvbThckn/10); (* [mN] *)
            Yinf.MaxPosErr := vqBlade_MaxPosErr; (* [um] *)
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_PVB_CUT2;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_CUT2 : (* Taglio plastico verso bordo finale *)
        IF MoveTo<MV_WAITSTOP THEN
            (* Movimento terminato *)
            vnBladeInf_Cmd := CMD_STOP; (* Lametta via *)
            Status := CARSTS_PVB_END;
        ELSE (* Wait move *)
            (* Tengo monitorato l'errore di posizione *)
            IF ABS(Yinf.CurrPosErr) > vqBlade_StuckPosErr THEN
                vbBladeInf_Jammed := TRUE; (* Segnalo incagliamento lametta *)
                dlog( Txt:='fbCarrInf: !! Blade jammed (poserr=%ld mm)', Lvl:=2, Val1:=Yinf.CurrPosErr/1E3 );
                (* Yinf.Cmd := AXC_STOP_ENAB; (* Fermo il posizionamento, MoveTo andrà in MV_ERROR *)
                Yinf.Cmd := AXC_RESET; (* Resetto l'errore di inseguimento, MoveTo andrà in MV_ERROR *)
                (* Nota: l'asse tornerà 'AXS_READY' dopo non meno di tre cicli PLC *)
                Status := CARSTS_PVB_UNJAM;
            END_IF;
            (* Se 'vbBlade_NoWaitUp' e ho superato 'Yend' alzo lametta *)
            IF vnBladeInf_Cmd<>CMD_STOP AND vbBlade_NoWaitUp AND
               ( (Yinf.MovingFwd AND Yinf.CurrPos>=Yend) OR (Yinf.MovingBck AND Yinf.CurrPos<=Yend) ) THEN
                vnBladeInf_Cmd := CMD_STOP; (* Lametta via *)
                vnCarrInf_Seq := SEQ_DONE; (* Taglio lametta terminato *)

                (* Se manca ancora tanto, ripristino parametri movimento *)
                IF ABS(Yinf.TgtPos-Yinf.CurrPos)>500E3 THEN
                    Yinf.TgtSpd := TO_DINT(vnCarr_FreeMovPerc); (* [%] *)
                    Yinf.OutFrc := 0; (* [mN] *)
                    Yinf.MaxPosErr := WTR_DEFAULT;
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_UNJAM : (* Sblocca lametta *)
        IF MoveTo<MV_WAITSTOP AND Yinf.Status=AXS_READY AND Yinf.Cmd=AXC_STOP_ENAB AND Yinf.Still THEN
            IF vqBlade_UnjamMove<>0 THEN
                (* Pronto a muovere *)
                vnBladeInf_Cmd := BLCMD_PROBE; (* Tengo lametta bassa? *)
                (* Comando movimento verso bordo iniziale per disincastrare *)
                vqCarrInf_Tgt := MAX(Ybegin, Yinf.CurrPos - ABS(vqBlade_UnjamMove));  (* [um] *)
                Yinf.TgtSpd := vqBlade_Speed; (* [um/min] *)
                Yinf.AccPerc := vnBlade_Accel; (* [%] *)
                Yinf.DecPerc := 100; (* max [%] *)
                Yinf.OutFrc := vqBlade_UnjamForce; (* Forza per disincastrare [mN] *)
                (* Nota: la spinta verso il basso è 'BladeInf.Push' *)
                Yinf.MaxPosErr := vqBlade_UnjamMove/3; (* [um] *)
                MoveTo := MV_TOOLMOVE;
                Status := CARSTS_PVB_CUT1;
                dlog( Txt:='fbCarrInf: ! Blade unjam to %ld mm (err=%ld)', Lvl:=2, Val1:=vqCarrInf_Tgt/1E3, Val2:=Yinf.CurrPosErr/1E3 );
            ELSE
                dlog( Txt:='fbCarrInf: !! Blade jammed!', Lvl:=2 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PVB_END : (* Finalizzazione taglio plastico *)
        (* Se qui assumo che movimento terminato *)
        vnBladeInf_Cmd := CMD_STOP; (* Assicuro lametta via *)
        (* Attendo lametta a riposo *)
        IF BladeInf.AtRest OR vbBlade_NoWaitUp THEN
            IF MoveTo=MV_DONE THEN
                dlog( Txt:='fbCarrInf: PVB cut Done', Lvl:=3 );
                vnCarrInf_Seq := SEQ_DONE;
                vnCarrInf_Cmd := CMD_STOP;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbCarrInf: !! PVB cut Error', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_FLY_INI : (* Preparazione ricerca "al volo" bordo inizio vetro *)
        (* Attendi sonde e asse pronto *)
        Probe1( Activate:=TRUE ); (* Sonda principale *)
        Probe2( Activate:=TRUE ); (* Eventuale sonda aggiuntiva per il bordo finale, 'vbFeat_HasProbeInf2' *)
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Probe1.Status>=PS_WAITMOVE AND Yinf.Status=AXS_READY THEN
            (* Pronto per ricercare, comando movimento master *)
            vqCarrInf_Tgt := Yend; (* [um] *)
            Yinf.TgtSpd := vqEdgeDet_OnTheFlySpd; (* [um/min] *)
            Yinf.AccPerc := 100; (* max [%] *)
            Yinf.DecPerc := 100; (* max [%] *)
            Yinf.OutFrc := 0; (* just move [mN] (per la ricerca non mi serve coppia) *)
            Yinf.MaxPosErr := WTR_HITDET;
            MoveTo := MV_TOOLMOVE;
            (* Direzione ricerca *)
            Probe1.Back := vqCarrInf_Tgt < Yinf.CurrPos;
            Probe2.Back := Probe1.Back;
            (* Proceed *)
            try_count := try_count + 1;
            Status := CARSTS_SRCH_FLY;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_FLY : (* Movimento ricerca "al volo" in corso *)
        Probe1(); (* Sonda principale *)
        Probe2(); (* Eventuale sonda aggiuntiva per il bordo finale, 'vbFeat_HasProbeInf2' *)

        (* Rilevo fin da subito anche il bordo finale con la sonda secondaria *)
        IF Probe2.NewFallLatch THEN (* => Probe2.LastFallLatch *)
            dlog( Txt:='fbCarrInf: Probe2 fall at %ld mm', Lvl:=4, Val1:=Probe2.LastFallLatch/1E3 );
            fly_fall_latch := Probe2.LastFallLatch;
            Probe2( Activate:=FALSE ); (* La sonda non serve più, prendo per buono il primo ed ignoro i successivi (più sicuro?) *)
        ELSIF Probe1.NewRiseLatch THEN (* => Probe1.LastRiseLatch *)
            dlog( Txt:='fbCarrInf: Probe1 rise at %ld mm', Lvl:=4, Val1:=Probe1.LastRiseLatch/1E3 );
            (* IF Probe1.SliversCount>0 THEN
                dlog( Txt:='fbCarrInf: SRCH_FLY: ! Found %d chips', Lvl:=2, Val1:=TO_DINT(Probe1.SliversCount));
                SET_MSG(REQ_CLEAN_CUTFLOOR,'REQ_CLEAN_CUTFLOOR',TO_DINT(Probe1.SliversCount));
            END_IF; *)
            (* Catturato il bordo iniziale del vetro! Vediamo se non è da scartare *)
            IF Probe1.LastRiseLatch >= (vqYmin-vqEdgeDet_Margin) THEN
                (* Memorizzo il bordo iniziale misurato *)
                IF Probe1.Back THEN vqY_TopEdge := Probe1.LastRiseLatch;
                ELSE                vqY_BtmEdge := Probe1.LastRiseLatch; END_IF;

                (* - Calcolo la quota iniziale della lavorazione - *)
                (* Incisione avanti *)
                IF vnCarrInf_Cmd=CARCMD_SCORE_FWD THEN
                    Ybegin := vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                (* Incisione indietro *)
                ELSIF vnCarrInf_Cmd=CARCMD_SCORE_BCK THEN
                    Ybegin := vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                ELSE (* Should never be here! *)
                    Status := STS_ERROR;
                    RETURN;
                END_IF;
                (* Cambio target ricerca al volo *)
                Yinf( TgtPos:=Ybegin, Flags:=0 ); (* Voglio tornare indietro se non fattibile *)
                Status := CARSTS_SRCH_FLY_END;
            ELSE
                dlog( Txt:='fbCarrInf: SRCH_FLY: ! Discarding %ld mm', Lvl:=3, Val1:=Probe1.LastRiseLatch/1E3 );
            END_IF;
        ELSIF MoveTo<MV_WAITSTOP THEN
            (* Ehm, arrivato a destinazione senza catture! *)
            (* IF try_count>3 THEN *)
            dlog( Txt:='fbCarrInf: !! Arrived to %ld without latches (Probe1.Status=%d)', Lvl:=1, Val1:=Yinf.CurrPos/1E3, Val2:=TO_DINT(Probe1.Status) );
            SET_MSG(MSG_SEARCHERROR,'MSG_SEARCHERROR',0);
            Status := STS_ERROR;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_FLY_END : (* Attendo arrivo in posizione *)
        IF MoveTo<MV_WAITSTOP THEN
            (* Movimento terminato *)
            IF MoveTo=MV_DONE THEN
                (* Carrello in quota di inizio lavorazione *)

                (* Ho già catturato il bordo finale? *)
                IF fly_fall_latch<>NO_POS_UM THEN
                    (* Memorizzo il bordo misurato *)
                    IF Probe2.Back THEN vqY_BtmEdge := fly_fall_latch;
                    ELSE                vqY_TopEdge := fly_fall_latch; END_IF;

                    (* Ora ho entrambi i bordi del vetro! *)
                    vqCut_Length := vqY_TopEdge - vqY_BtmEdge;
                    dlog( Txt:='fbCarrInf: Fly-Measured %ld-%ld=%ld mm', Lvl:=2, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqCut_Length/1E3 );

                    (* Le sonde non servono più *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );

                    (* Controllo misura *)
                    IF vqCut_Length<=0 THEN
                        dlog( Txt:='!!Bad measure', Lvl:=1);
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;

                    (* - Calcolo la quota finale della lavorazione - *)
                    (* Incisione avanti *)
                    IF vnCarrInf_Cmd=CARCMD_SCORE_FWD THEN
                        Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                    (* Incisione indietro *)
                    ELSIF vnCarrInf_Cmd=CARCMD_SCORE_BCK THEN
                        Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                    ELSE (* Should never be here! *)
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;
                ELSE
                    (* Non ho ancora rilevato il bordo finale *)

                    (* - Decido la quota finale della lavorazione - *)
                    (* Incisione avanti *)
                    IF vnCarrInf_Cmd=CARCMD_SCORE_FWD THEN
                        IF vbEdgeDet_AutoFlyUseDim AND vbAutoMode THEN
                            Yend := MAX(vqY_BtmEdge, (vqY_BtmEdge+vqSubSheet_ProcHeight) - (vqTscore_TopMargin+vqMod_Tscore_TopMargin));
                        ELSE
                            Yend := vqYmax;
                        END_IF;
                    (* Incisione indietro *)
                    ELSIF vnCarrInf_Cmd=CARCMD_SCORE_BCK THEN
                        IF vbEdgeDet_AutoFlyUseDim AND vbAutoMode THEN
                            Yend := MIN(vqY_TopEdge, (vqY_TopEdge-vqSubSheet_ProcHeight) + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin));
                        ELSE
                            Yend := vqYmin;
                        END_IF;
                    ELSE (* Should never be here! *)
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;

                    (* Se non ci sono sonde sul vetro il bordo finale non potrà essere rilevato:
                       meglio dare errore, ci penserà il chiamante a gestire la cosa *)
                    IF (NOT Probe1.Input AND NOT vbFeat_HasProbeInf2) OR (NOT Probe2.Input AND vbFeat_HasProbeInf2) THEN
                        dlog( Txt:='fbCarrInf: !! Probe2 not on glass at %ld mm', Lvl:=2, Val1:=Yinf.CurrPos/1E3 );
                        SET_MSG(MSG_SEARCHERROR,'MSG_SEARCHERROR',0);
                        Yinf.Cmd := AXC_STOP_ENAB; (* Stop the movement *)
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;
                END_IF;
                dlog( Txt:='fbCarrInf: Fly range %ld|%ld mm', Lvl:=3, Val1:=Ybegin/1E3, Val2:=Yend/1E3 );

                (* - Attivo utensili - *)
                (* IF vnCarrInf_Cmd=CARCMD_SCORE_FWD OR vnCarrInf_Cmd=CARCMD_SCORE_BCK THEN *)
                (* Assumo incisione: Attivo testina *)
                (* vbLubScore_Cmd := TRUE; *)
                vqTinf_P := vqF_score_inf + vqMod_F_score_inf;
                vqMod_F_score_inf := 0; (* Reset modificatore temporaneo *)
                vbTinf_Cmd := TRUE;
                Status := CARSTS_SCORE_INIT;
            ELSE
                dlog( Txt:='fbCarrInf: !! ChgTgt to Ybegin=%ld failed', Lvl:=1, Val1:=Ybegin/1E3 );
                Status := STS_ERROR;
            END_IF;
        ELSE
            (* Movimento in corso *)
            (* Se devo ancora catturare il bordo finale... *)
            IF fly_fall_latch=NO_POS_UM THEN
                (* ...Controllo se per caso lo leggo durante il riposizionamento! *)
                (* Sonda primaria *)
                Probe1();
                IF Probe1.NewFallLatch AND (Yinf.CurrSpd<0)=Probe1.Back THEN
                    dlog( Txt:='fbCarrInf: Probe1 fall at %ld mm', Lvl:=4, Val1:=Probe1.LastFallLatch/1E3 );
                    fly_fall_latch := Probe1.LastFallLatch;
                    (* Le sonde non servono più, prendo per buono il primo ed ignoro i successivi (più sicuro) *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;
                (* Sonda secondaria *)
                Probe2();
                IF Probe2.NewFallLatch AND (Yinf.CurrSpd<0)=Probe2.Back THEN
                    dlog( Txt:='fbCarrInf: Probe2 fall at %ld mm', Lvl:=4, Val1:=Probe2.LastFallLatch/1E3 );
                    fly_fall_latch := Probe2.LastFallLatch;
                    (* Le sonde non servono più, prendo per buono il primo ed ignoro i successivi (più sicuro) *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SCORE_INIT : (* Attesa discesa testina *)
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Attendo requisiti *)
        ELSIF (vn[ivnStatus+ID_HOLDPADS]=TS_ON OR vnHoldPads_Cmd=0) AND (* Tamponi pronti se richiesti *)
              (vb[ivbAtRest+ID_CLAMP_ALGN] OR vn[ivnStatus+ID_CLAMP_ALGN]>=CL_DOWN) AND (* Premilastra stabili *)
              (vb[ivbAtRest+ID_CLAMP_DTCH] OR vn[ivnStatus+ID_CLAMP_DTCH]>=CL_DOWN) AND
              Tinf.Status=TS_ON THEN (* Testina taglio pronta *)
            (* Pronto per incidere, comando movimento *)
            vqCarrInf_Tgt := Yend; (* [um] *)
            Yinf.TgtSpd := vqV_score; (* [um/min] *)
            Yinf.AccPerc := 100; (* max [%] *)
            Yinf.DecPerc := 100; (* max [%] *)
            Yinf.OutFrc := vqTscore_ScoreYforce; (* [mN] *)
            Yinf.MaxPosErr := WTR_DEFAULT;
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_SCORE;
            (* Se ancora non conosco il bordo finale... *)
            (* IF (Ybegin<Yend AND vqY_TopEdge=NO_POS_UM) OR (Ybegin>Yend AND vqY_BtmEdge=NO_POS_UM) THEN *)
            IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                (* ...Assicuro sonde pronte e resettate *)
                Probe1( Activate:=TRUE, Reset:=TRUE );
                Probe2( Activate:=TRUE, Reset:=TRUE );
                (* Assicuro decelerazione necessaria alla riuscita del cambio target
                delta := fnRampSpace(V:=Yinf.TgtSpd, ta:=vq[ivqAx_DecTime+AX_YINF-1], p:=50);
                IF delta >= ABS(vq[ivqProbe_DY+IRQ_PROBEINF2]) THEN
                    Yinf.DecPerc := vnCarr_ChgTgtDec;
                    dlog( Txt:='fbCarrInf: ! DecPerc=%d%% to stop in %ld > %ld mm', Lvl:=1, Val1:=TO_DINT(Yinf.DecPerc), Val2:=delta/1E3, Val3:=vq[ivqProbe_DY+IRQ_PROBEINF2]/1E3 );
                END_IF; *)
                Yinf.DecPerc := vnCarr_ChgTgtDec;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SCORE : (* Movimento incisione *)
        IF MoveTo<MV_WAITSTOP THEN (* Movimento terminato *)
            vbTinf_Cmd := FALSE;
            (* vbLubScore_Cmd := FALSE; *)
            Status := CARSTS_SCORE_END;
        (* Se qualcosa va storto nel movimento, tira via subito l'utensile *)
        ELSIF vbCarr_ToolsOffOnErr AND Yinf.Status=AXS_STOPPING AND NOT Yinf.Arrived AND vbTinf_Cmd THEN
            dlog( Txt:='fbCarrInf: !! Tinf off on stop', Lvl:=2 );
            vbTinf_Cmd := FALSE;
        (* Supporto ricerca al volo: se ancora non so dov'è il bordo
           finale, cambio target al fronte di discesa di una delle sonde *)
        ELSIF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
            Probe1(); (* Sonda principale *)
            Probe2(); (* Eventuale sonda aggiuntiva per il bordo finale, 'vbFeat_HasProbeInf2' *)
            (* Se ricerca al volo almeno una sonda dovrebbe essere attiva! *)
            IF Probe1.Status<PS_WAITMOVE AND Probe2.Status<PS_WAITMOVE THEN
                dlog( Txt:='fbCarrInf: !! No probes', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;

            (* Stay ready for the change target to glass end edge *)
            IF Probe2.NewFallLatch THEN (* => Probe2.LastFallLatch *)
                fly_fall_latch := Probe2.LastFallLatch;
            ELSIF Probe1.NewFallLatch THEN (* => Probe1.LastFallLatch *)
                fly_fall_latch := Probe1.LastFallLatch;
            ELSE
                fly_fall_latch := NO_POS_UM; (* Sfruttato per segnalare un nuovo fronte di discesa *)
            END_IF;
            IF fly_fall_latch<>NO_POS_UM THEN
                (* Rilevato un nuovo fronte di discesa da non ignorare *)
                (* dlog( Txt:='fbCarrInf: Fall at %ld', Lvl:=4, Val1:=fly_fall_latch/1E3 ); *)
                (* Store the measured edge and calculate the true Yend *)
                IF Ybegin<Yend THEN (* Incisione avanti *)
                    vqY_TopEdge := fly_fall_latch;
                    Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                ELSE (* Incisione indietro *)
                    vqY_BtmEdge := fly_fall_latch;
                    Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                END_IF;
                vqCut_Length := vqY_TopEdge - vqY_BtmEdge;
                dlog( Txt:='fbCarrInf: Fly-Measured %ld-%ld=%ld mm (score to %ld)', Lvl:=2, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqCut_Length/1E3, Val4:=Yend/1E3 );

                (* Le sonde non servono più *)
                Probe1( Activate:=FALSE );
                Probe2( Activate:=FALSE );

                (* Controllo misura *)
                IF vqCut_Length<=0 THEN
                    dlog( Txt:='!!Bad measure', Lvl:=1);
                    Status := STS_ERROR;
                    RETURN;
                END_IF;

                (* Cambio target su bordo finale: In automatico è meno importante perché ho un'altezza teorica *)
                IF Yinf.PosPhase<>AFS_POS_DEC OR NOT vbAutoMode THEN
                    Yinf( TgtPos:=Yend, Flags:=AXCB_STRICT );
                ELSE
                    dlog( Txt:='fbCarrInf: !! Yinf already decel to %ld (%ld)', Lvl:=2, Val1:=Yinf.TgtPos/1E3, Val1:=Yend/1E3 );
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SCORE_END : (* Finalizzazione incisione *)
        vbTinf_Cmd := FALSE;
        IF Tinf.Status=TS_OFF THEN
            IF MoveTo=MV_DONE THEN
                dlog( Txt:='fbCarrInf: Score Done', Lvl:=3 );

                (* Se il bordo finale non è ancora stato rilevato
                   probabilmente si è trattato di una preincisione molto interna,
                   forse è meglio dare un valore a 'vqCut_Length'? *)
                IF vbAutoMode AND vqCut_Length<=0 THEN
                    vqCut_Length := vqSubSheet_ProcHeight;
                    (* Assicuro di resettare lo stato delle sonde *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;

                vnCarrInf_Seq := SEQ_DONE;
                vnCarrInf_Cmd := CMD_STOP;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbCarrInf: !! Score Error', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_OPEN_INIT : (* Attesa inizio apertura con rotelle: discesa utensile *)
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Rinf.Status=TS_ON THEN
            (* Pronto per passata rotelle, comando movimento *)
            Yinf.TgtSpd := vqV_brkwhl_sup; (* [um/min] Eh, di solito la singola è quella sopra! *)
            Yinf.AccPerc := 100; (* max [%] *)
            Yinf.DecPerc := 100; (* max [%] *)
            Yinf.OutFrc := vqRbrk_OpenYforce; (* [mN] *)
            Yinf.MaxPosErr := WTR_DEFAULT;
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_OPEN;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_OPEN : (* Movimento apertura con rotelle *)
        IF MoveTo<MV_WAITSTOP THEN
            (* Movimento terminato *)
            (* Vediamo se devo completare l'apertura *)
            IF vqCarrInf_Tgt=Yend THEN
                (* Ho aperto fino al bordo finale, fatto *)
                vbRinf_Cmd := FALSE;
                Status := CARSTS_OPEN_END;
            ELSE
                (* Devo ancora arrivare al bordo finale, proseguo *)
                vqCarrInf_Tgt := Yend;
                dlog( Txt:='fbCarrInf: Prosecuting opening pass', Lvl:=5 );
                Status := CARSTS_OPEN_INIT;
            END_IF;
        (* Se qualcosa va storto nel movimento, tira via subito l'utensile * )
        ELSIF vbCarr_ToolsOffOnErr AND Yinf.Status=AXS_STOPPING AND NOT Yinf.Arrived AND vbRinf_Cmd THEN
            dlog( Txt:='fbCarrInf: !! Rinf off on stop', Lvl:=2 );
            vbRinf_Cmd := FALSE;
        (* ELSE (* Wait move *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_OPEN_END : (* Finalizzazione apertura con rotelle *)
        vbRinf_Cmd := FALSE;
        IF Rinf.Status=TS_OFF THEN
            IF MoveTo=MV_DONE THEN
                dlog( Txt:='fbCarrInf: Open Done', Lvl:=3 );
                vnCarrInf_Seq := SEQ_DONE;
                vnCarrInf_Cmd := CMD_STOP;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbCarrInf: !! Open Error', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    (* CARSTS_GRLE_INIT : (* Attesa inizio rimozione basso emissivo: discesa utensile *)


    (* ------------------------------------------------------------------- *)
    (* CARSTS_GRLE : (* Movimento rimozione basso emissivo *)


    (* ------------------------------------------------------------------- *)
    (* CARSTS_GRLE_END : (* Finalizzazione rimozione basso emissivo *)


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_SWEEP_INI : (* Attesa condizioni per spazzata *)
        (* Attendi sonda pronta e asse pronto *)
        Probe1( Activate:=TRUE );
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Probe1.Status>=PS_WAITMOVE AND Yinf.Status=AXS_READY THEN
            (* Dove andare: se (try_count MOD 2)<>0 è una spazzata multipla in senso opposto *)
            IF (vnCarrInf_Cmd=CARCMD_SRCHGLASS_FWD AND (try_count MOD 2)=0) OR
               (vnCarrInf_Cmd=CARCMD_SRCHGLASS_BCK AND (try_count MOD 2)<>0) THEN
                (* Spazzata avanti *)
                vqCarrInf_Tgt := vqYmax + vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
            ELSE
                (* Spazzata indietro *)
                vqCarrInf_Tgt := 0 - vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
            END_IF;
            Probe1.Back := vqCarrInf_Tgt < Yinf.CurrPos; (* Direzione spazzata *)
            Yinf.TgtSpd := vqEdgeDet_SweepSpd; (* [um/min] *)
            Yinf.OutFrc := 0; (* just move [mN] (per la ricerca non mi serve coppia) *)
            Yinf.MaxPosErr := WTR_HITDET;
            MoveTo := MV_TOOLMOVE;
            Status := CARSTS_SRCH_SWEEP;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_SWEEP : (* Spazzata ricerca bordi vetro *)
        Probe1();
        IF Probe1.Status=PS_DONE THEN
            (* Spazzata eseguita *)
            Yinf.Cmd := AXC_STOP_ENAB; (* Fermo il posizionamento, MoveTo andrà in MV_ERROR *)
            try_count := try_count + 1;
            (* Metto via catture *)
            IF Probe1.Back THEN
                (* Questa spazzata era indietro *)
                top_latch := Probe1.EdgeIn;
                btm_latch := Probe1.EdgeOut;
            ELSE
                (* Questa spazzata era avanti *)
                btm_latch := Probe1.EdgeIn;
                top_latch := Probe1.EdgeOut;
            END_IF;
            Probe1( Activate:=FALSE ); (* Disattivo la sonda *)
            (* Un doveroso controllo *)
            IF top_latch<=btm_latch THEN
                dlog( Txt:='fbCarrInf: !! Sweep %d: btm=%ld top=%ld mm', Lvl:=1, Val1:=TO_DINT(try_count), Val2:=btm_latch/1E3, Val3:=top_latch/1E3);
                vnCarrInf_Seq := SEQ_ERROR;
            END_IF;
            (* Se ho già delle misure, controlla discrepanze *)
            IF try_count>1 THEN
                dlog( Txt:='fbCarrInf: Sweep %d: btm=%ld prec=%ld mm (err=%ld um)', Lvl:=3, Val1:=TO_DINT(try_count), Val2:=btm_latch/1E3, Val3:=vqY_BtmEdge/1E3, Val4:=(btm_latch-vqY_BtmEdge));
                IF ABS(btm_latch-vqY_BtmEdge)>vqEdgeDet_MaxErr THEN
                    dlog( Txt:='fbCarrInf: !! Sweep %d: Invalid btm (err=%ld mm)', Lvl:=1, Val1:=TO_DINT(try_count), Val2:=(btm_latch-vqY_BtmEdge)/1E3);
                    vnCarrInf_Seq := SEQ_ERROR;
                END_IF;
                dlog( Txt:='fbCarrInf: Sweep %d: top=%ld mm prec=%ld mm (err=%ld um)', Lvl:=3, Val1:=TO_DINT(try_count), Val2:=top_latch/1E3, Val3:=vqY_TopEdge/1E3, Val4:=(top_latch-vqY_TopEdge));
                IF ABS(top_latch-vqY_TopEdge)>vqEdgeDet_MaxErr THEN
                    dlog( Txt:='fbCarrInf: !! Sweep %d: Invalid top (err=%ld mm)', Lvl:=1, Val1:=TO_DINT(try_count), Val2:=(top_latch-vqY_TopEdge)/1E3);
                    vnCarrInf_Seq := SEQ_ERROR;
                END_IF;
                (* Aggiungo alla media: avg<n+1> = (N avg<n> + a) / (N+1) *)
                vqY_BtmEdge := (TO_DINT(try_count-1)*vqY_BtmEdge + btm_latch) / TO_DINT(try_count);
                vqY_TopEdge := (TO_DINT(try_count-1)*vqY_TopEdge + top_latch) / TO_DINT(try_count);
            ELSE
                (* Prima spazzata *)
                vqY_BtmEdge := btm_latch;
                vqY_TopEdge := top_latch;
            END_IF;
            Status := CARSTS_SRCH_END;
        ELSIF MoveTo=MV_DONE THEN
            (* Ehm, arrivato a destinazione! *)
            dlog( Txt:='fbCarrInf: !! Sweep %d to %ld without latches (Probe1.Status=%d)', Lvl:=1, Val1:=TO_DINT(try_count), Val2:=Yinf.TgtPos/1E3, Val3:=TO_DINT(Probe1.Status));
            (* SET_MSG(MSG_GLASSNOTFOUND,'MSG_GLASSNOTFOUND',0); *)
            vnCarrInf_Seq := SEQ_ERROR;
            Status := CARSTS_SRCH_END;
        ELSIF MoveTo=MV_ERROR THEN
            dlog( Txt:='fbCarrInf: !! Sweep %d to %ld failed', Lvl:=2, Val1:=TO_DINT(try_count), Val2:=Yinf.TgtPos/1E3);
            vnCarrInf_Seq := SEQ_ERROR;
            Status := CARSTS_SRCH_END;
        (* ELSE (* Wait latches/move *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_INOUT_INI : (* Preparazione rilevazione accurata del bordo *)
        IF MoveTo=MV_DONE THEN
            (* Attendi sonda pronta e asse pronto *)
            Probe1( Activate:=TRUE, SweepMode:=FALSE ); (* Niente compensazioni e filtro schegge *)
            IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
                Status := STS_ERROR;
            ELSIF Probe1.Status>=PS_WAITMOVE AND Yinf.Status=AXS_READY THEN
                vqCarrInf_Tgt := Yend;
                Probe1.Back := vqCarrInf_Tgt < Yinf.CurrPos; (* Direzione *)
                Probe1.Reset := TRUE; (* Per sicurezza? *)
                Yinf.TgtSpd := vqEdgeDet_AcqSpd; (* [um/min] *)
                Yinf.OutFrc := 0; (* just move [mN] (per la ricerca non mi serve coppia) *)
                Yinf.MaxPosErr := WTR_HITDET;
                MoveTo := MV_TOOLMOVE;
                Status := CARSTS_SRCH_INOUT;
            END_IF;
        ELSIF MoveTo=MV_ERROR THEN
            Status := STS_ERROR;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_INOUT : (* Rilevazione accurata del bordo *)
        Probe1();
        (* Eseguo movimentini dentro e fuori *)
        IF MoveTo=MV_DONE THEN
            (* Devo fare il secondo movimentino? *)
            IF vqCarrInf_Tgt=Yend THEN
                vqCarrInf_Tgt := Ybegin;
                Probe1.Back := vqCarrInf_Tgt < Yinf.CurrPos; (* Direzione *)
                MoveTo := MV_TOOLMOVE;
            ELSE
                (* Movimento dentro fuori completato *)
                (* Controllo se ho acquisito i due fronti *)
                IF Probe1.Status=PS_DONE THEN
                    (* Ok, metto via catture *)
                    (* Un doveroso controllo *)
                    IF ABS(Probe1.EdgeIn-Probe1.EdgeOut)>vqEdgeDet_MaxErr THEN
                        dlog( Txt:='fbCarrInf: !! Acq: Too diff in=%ld out=%ld um ', Lvl:=1, Val1:=Probe1.EdgeIn, Val2:=Probe1.EdgeOut );
                        vnCarrInf_Seq := SEQ_ERROR;
                    END_IF;
                    IF Ybegin < Yend THEN
                        (* Ho acquisito il bordo sotto *)
                        btm_meas := (Probe1.EdgeIn + Probe1.EdgeOut)/2; (* [um] *)
                        vqY_BtmEdge := btm_meas;
                    ELSE
                        (* Ho acquisito il bordo sopra *)
                        top_meas := (Probe1.EdgeIn + Probe1.EdgeOut)/2; (* [um] *)
                        vqY_TopEdge := top_meas + vq[ivqProbe_FixOpp+Probe1.ProbeIdx];
                    END_IF;
                    Probe1( Activate:=FALSE ); (* Disattivo la sonda *)
                    Status := CARSTS_SRCH_END;
                ELSE
                    dlog( Txt:='fbCarrInf: !! Acq failed (%d)', Lvl:=2, Val1:=TO_DINT(Probe1.Status) );
                    vnCarrInf_Seq := SEQ_ERROR;
                    Status := CARSTS_SRCH_END;
                END_IF;
            END_IF;
        ELSIF MoveTo=MV_ERROR THEN
            dlog( Txt:='fbCarrInf: !! Acq from %d to %ld failed', Lvl:=2, Val1:=Ybegin/1E3, Val2:=Yend/1E3 );
            vnCarrInf_Seq := SEQ_ERROR;
            Status := CARSTS_SRCH_END;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_END : (* Fine cattura, attesa off sonda e asse fermo *)
        Probe1( Activate:=FALSE );
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Probe1.Status=STS_IDLE AND Yinf.Status=AXS_READY THEN
            IF Probe1.SliversCount>0 THEN
                dlog( Txt:='fbCarrInf: SRCH_END: ! Found %d chips', Lvl:=2, Val1:=TO_DINT(Probe1.SliversCount));
                (* SET_MSG(REQ_CLEAN_CUTFLOOR,'REQ_CLEAN_CUTFLOOR',TO_DINT(Probe1.SliversCount)); *)
            END_IF;
            (* - Vedi se ho terminato - *)
            (* Intercetto eventuale errore *)
            IF vnCarrInf_Seq=SEQ_ERROR THEN
                Status := STS_ERROR;
            (* Devo rilevare i bordi in modo accurato? *)
            ELSIF vnEdgeDet_Mode=2 AND (btm_meas=NO_POS_UM OR top_meas=NO_POS_UM) THEN
                (* Vediamo quale bordo rilevare in modo accurato
                   Le quote rilevate dalla spazzata sono in: vqY_BtmEdge, vqY_TopEdge *)
                IF ABS(Yinf.CurrPos-vqY_BtmEdge) < ABS(Yinf.CurrPos-vqY_TopEdge) THEN
                    (* Sono più vicino al bordo basso *)
                    IF btm_meas=NO_POS_UM THEN
                        (* Procedo a rilevare in modo accurato il bordo basso *)
                        Ybegin := vqY_BtmEdge - vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
                        Yend := Ybegin + 2*vqEdgeDet_Margin;
                    ELSE
                        (* Procedo a rilevare in modo accurato il bordo alto *)
                        Ybegin := vqY_TopEdge + vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
                        Yend := Ybegin - 2*vqEdgeDet_Margin;
                    END_IF;
                ELSE
                    (* Sono più vicino al bordo alto *)
                    IF top_meas=NO_POS_UM THEN
                        (* Procedo a rilevare in modo accurato il bordo alto *)
                        Ybegin := vqY_TopEdge + vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
                        Yend := Ybegin - 2*vqEdgeDet_Margin;
                    ELSE
                        (* Procedo a rilevare in modo accurato il bordo basso *)
                        Ybegin := vqY_BtmEdge - vqEdgeDet_Margin - vq[ivqProbe_DY+Probe1.ProbeIdx]; (* [um] *)
                        Yend := Ybegin + 2*vqEdgeDet_Margin;
                    END_IF;
                END_IF;
                vqCarrInf_Tgt := Ybegin;
                MoveTo := MV_FREEMOVE;
                Status := CARSTS_SRCH_INOUT_INI;
            (* Devo fare una doppia passata? *)
            ELSIF vnEdgeDet_Mode=1 AND try_count=1 THEN
                (* Faccio una seconda spazzata, riattivo la sonda *)
                Probe1( Activate:=TRUE );
                Status := CARSTS_SRCH_SWEEP_INI;
            ELSE
                (* Terminato con successo *)
                vqCut_Length := vqY_TopEdge - vqY_BtmEdge; (* [um] *)
                dlog( Txt:='fbCarrInf: Ymeas %ld|%ld=%ld', Lvl:=3, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqCut_Length/1E3 );
                vnCarrInf_Cmd := CMD_STOP;
                vnCarrInf_Seq := SEQ_DONE;
                Status := STS_IDLE;
                IF vbCarrInf_ParkOnEnd THEN
                    vbCarrInf_ParkOnEnd := FALSE; (* Eat *)
                    vnCarrInf_Cmd := CMD_PARK;
                END_IF;
            END_IF; (* -- Vedi se ho terminato *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_TRAIL_LOCK : (* Agganciando/sganciando traino passivo *)
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnECarrInf_Lock=0 THEN
            (* L'aggancio/sgancio è stato correttamente completato? *)
            IF (Ext.Locked>0 AND vnCarrInf_Cmd=CARCMD_TRAIL_LOCK) OR
               (Ext.Locked<0 AND vnCarrInf_Cmd<>CARCMD_TRAIL_LOCK) THEN
                (* dlog( Txt:='fbCarrInf: Trail lock: %d', Lvl:=5, Val1:=TO_DINT(Ext.Locked) ); *)
                (* Poichè altri comandi possono richiedere aggancio/sgancio,
                   resetto il comando solo se è un comando esplicito, così
                   l'altro rimane in coda e viene rieseguito *)
                IF vnCarrInf_Cmd=CARCMD_TRAIL_LOCK OR vnCarrInf_Cmd=CARCMD_TRAIL_UNLOCK THEN
                    vnCarrInf_Cmd := CMD_STOP;
                END_IF;
                vnCarrInf_Seq := SEQ_DONE;
                Status := STS_IDLE;
                IF vbCarrInf_ParkOnEnd THEN
                    vbCarrInf_ParkOnEnd := FALSE; (* Eat *)
                    vnCarrInf_Cmd := CMD_PARK;
                END_IF;
            ELSE
                dlog( Txt:='fbCarrInf: !! TRAIL_LOCK: Error (%d)', Lvl:=1, Val1:=TO_DINT(Ext.Locked) );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_INITDRIVEN : (* Impostando inseguimento camma *)
        IF vnCarrInf_Cmd<>CMD_DRIVEN OR Yinf.Cmd<>AXC_START_FOL THEN
            Status := STS_ERROR;
        ELSIF Yinf.Status=AXS_MOVING_FOL THEN
            Status := STS_DRIVEN;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_DRIVEN : (* In inseguimento camma *)
        IF vnCarrInf_Cmd<>CMD_DRIVEN THEN
            Yinf.Cmd := AXC_STOP_ENAB; (* Sgancio inseguimento *)
            vnCarrInf_Seq := SEQ_DONE;
            Status := STS_STOPPING;
        ELSIF Yinf.Status<>AXS_MOVING_FOL THEN
            dlog( Txt:='fbCarrInf: !! Not following (%d)', Lvl:=2, Val1:=TO_DINT(Yinf.Status) );
            Yinf.Cmd := AXC_STOP_ENAB; (* Assicuro sgancio inseguimento *)
            Status := STS_ERROR;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_STOPPING : (* Waiting stop *)
        IF MoveTo<MV_WAITSTOP AND Yinf.Status<=AXS_READY THEN
            Probe1( Activate:=FALSE );
            Probe2( Activate:=FALSE );
            vnCarrInf_Cmd := CMD_STOP; (* Eat command *)
            Status := STS_IDLE;

            IF CutAreaFreed THEN (* AtRest *)
                (* Free possible acquired resources (CarrInf) *)
                IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_HEATLAMP]=TS_OFF,ID_HEATLAMP,0); END_IF;
                IF LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=0; END_IF;
                IF vbFeat_FixedCarriages AND UpperCutZone=ID_CARR_SUP THEN UpperCutZone:=0; END_IF;
            END_IF;
        ELSIF MoveTo>MV_WAITSTOP THEN
            MoveTo := MV_WAITSTOP;
        ELSIF Yinf.Cmd>AXC_STOP_ENAB THEN
            Yinf.Cmd := AXC_STOP_ENAB;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_IDLE : (* Carrello inferiore non attivo *)
        (* Rispondi ai comandi *)
        IF vnCarrInf_Cmd<>CMD_STOP THEN
            vnCarrInf_Seq := SEQ_START; (* Resetto risultato *)
            (* Comando attivo, controllo conflitti con comandi combinati?
               No, un comando combinato può usare i comandi singoli
            Durante le manovre con pinza:
                vnCarriages_Sts>=CARSTS_GRAB_INIT AND vnCarriages_Sts<=CARSTS_PARK_WAITINF
            Sarebbe bene evitare comandi non provenienti da Carriages
            IF vnCarriages_Cmd<>CMD_STOP THEN
                dlog( Txt:='fbCarrInf: !! vnCarrInf_Cmd=%d with vnCarriages_Cmd=%d', Lvl:=1, Val1:=TO_DINT(vnCarrInf_Cmd), Val2:=TO_DINT(vnCarriages_Cmd));
                Status := STS_ERROR; (* Questo assicura ad es. che l'altro carrello non sia in inseguimento *)
            IF vnCarrInf_Cmd=CMD_PARK OR
               vnCarrInf_Cmd=CARCMD_BTMPARK OR
               vnCarrInf_Cmd=CARCMD_TOPPARK OR
               vnCarrInf_Cmd=CARCMD_FULLPARK THEN
                (* Parcheggia carrello a... *)
                (* dlog( Txt:='fbCarrInf: Going to park', Lvl:=5 ); *)
                CASE vnCarrInf_Cmd OF
                    CARCMD_BTMPARK :
                        (* Parcheggio basso (coincide con 'home' se 'vbFeat_CarrHomeOnTop=FALSE') *)
                        vqCarrInf_Tgt := vqYinf_BtmParkPos;
                    CARCMD_TOPPARK :
                        (* Parcheggio alto (coincide con 'home' se 'vbFeat_CarrHomeOnTop=TRUE') *)
                        vqCarrInf_Tgt := vqYinf_TopParkPos;
                    CARCMD_FULLPARK :
                        (* Assicuro sgancio eventuale traino *)
                        IF vqECarrInf_Length>0 AND Ext.Locked>0 THEN
                            vqCarrInf_Tgt := vqYinf_LockPos - vqECarr_LockApproach;
                            IF Yinf.CurrPos>vqCarrInf_Tgt THEN vqCarrInf_Tgt := vqYinf_LockPos; END_IF;
                        (* ELSIF vqECarrInf_Length<0 AND Ext.Locked>0 THEN (* Traini in basso non supportati per ora! *)
                        ELSE
                            vqCarrInf_Tgt := Yinf.HomePos;
                        END_IF;
                    ELSE (* CMD_PARK *)
                        (* Verso quota di 'home' (coinciderà con uno dei precedenti) *)
                        vqCarrInf_Tgt := Yinf.HomePos;
                        IF vbCarr_ParkFreesCutArea THEN
                            (* Devo garantire di liberare l'area taglio? *)
                            IF vbFeat_CarrHomeOnTop THEN
                                IF (vqYinf_TopParkPos + vqCarrInf_CurrDYroomM) <= vqCarr_CutAreaYtop THEN
                                    (* Il parcheggio alto non libererebbe l'area taglio *)
                                    (* dlog( Txt:='fbCarrInf: ! Opposite park (%ld<=%ld)', Lvl:=4, Val1:=(vqYinf_TopParkPos+vqCarrInf_CurrDYroomM)/1E3, Val2:=vqCarr_CutAreaYtop/1E3 ); *)
                                    vqCarrInf_Tgt := vqYinf_BtmParkPos;
                                END_IF;
                            ELSE
                                IF (vqYinf_BtmParkPos + vqCarrInf_CurrDYroomP) >= vqCarr_CutAreaYbtm THEN
                                    (* Il parcheggio basso non libererebbe l'area taglio *)
                                    (* dlog( Txt:='fbCarrInf: ! Opposite park (%ld>=%ld)', Lvl:=4, Val1:=(vqYinf_BtmParkPos+vqCarrInf_CurrDYroomP)/1E3, Val2:=vqCarr_CutAreaYbtm/1E3 ); *)
                                    vqCarrInf_Tgt := vqYinf_TopParkPos;
                                END_IF;
                            END_IF;
                        END_IF;
                END_CASE;

                (* Gestione pinza girapezzi *)
                IF vnGrabber_Type=2 THEN
                    IF Grabber.Status=GSTS_CLOSED THEN
                        (* Pinza bassa, se asse pronto la rioriento *)
                        IF Zg.Status=AXS_READY THEN
                            IF vqCarrInf_Tgt=Yinf.HomePos THEN
                                (* Uso la quota di home indicata nei parametri assi *)
                                Zg.TgtPos := Zg.HomePos;
                            ELSE
                                (* Mi oriento lontano dall'area taglio *)
                                Zg.TgtPos := SEL(vqCarrInf_Tgt=vqYinf_TopParkPos, -90E3, 90E3); (* [mdeg] *)
                            END_IF;
                            Zg.TgtSpd := 0; (* max *)
                            Zg.AccPerc := 100; (* max [%] *)
                            Zg.DecPerc := 100; (* max [%] *)
                            Zg.OutFrc := 0; (* just move [mN] *)
                            Zg.MaxPosErr := WTR_HITDET;
                            Zg.Cmd := AXC_START_POS;
                        END_IF;
                    ELSE
                        (* Se pinza non bassa, va gestita con vnCarriages_Cmd *)
                        dlog( Txt:='fbCarrInf: !! Cannot park (Grabber %d)', Lvl:=1, Val1:=TO_DINT(Grabber.Status) );
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;
                END_IF; (* - Gestione pinza *)

                (* Verifica se siamo già in parcheggio? *)
                IF ABS(Yinf.CurrPos-vqCarrInf_Tgt)<500 AND AtRest  (* Yinf.InPosDelta *)
                   AND (vnCarrInf_Cmd<>CARCMD_FULLPARK OR vqECarrInf_Length=0 OR Ext.Locked<=0) THEN
                    (* Sono già in parcheggio! Non fare nulla e dai Ok *)
                    dlog( Txt:='fbCarrInf: Already in park at %ld mm', Lvl:=4, Val1:=Yinf.CurrPos/1E3 );
                    (* dlog( Txt:='#dbg vnCarrInf_Cmd=%d vqECarrInf_Length=%ld Ext.Locked=%d', Lvl:=4, Val1:=TO_DINT(vnCarrInf_Cmd), Val2:=vqECarrInf_Length, Val3:=TO_DINT(Ext.Locked) ); *)
                    vnCarrInf_Seq := SEQ_DONE;
                    vnCarrInf_Cmd := CMD_STOP;
                ELSE
                    (* Movimento libero verso 'vqCarrInf_Tgt' *)
                    Yend := vqCarrInf_Tgt; (* Ricorda destinazione finale *)
                    (* Assicuro un movimentino di avvicinamento se... *)
                    IF vqECarrInf_Length>0 AND vnCarrInf_Cmd=CARCMD_TOPPARK THEN
                        vqCarrInf_Tgt := vqCarrInf_Tgt - vqECarr_LockApproach;
                    END_IF;
                    MoveTo := MV_FREEMOVE;
                    Status := STS_MOVING; (* Proceed *)
                END_IF;
            ELSIF vnCarrInf_Cmd=CARCMD_FREEAREA THEN
                (* È richiesta la liberazione dell'area taglio *)
                IF NOT CutAreaFreed THEN
                    (* Sto occupando l'area taglio *)
                    (* dlog( Txt:='fbCarrInf: Freeing (%ld|%ld) (%ld|%ld)', Lvl:=4, Val1:=YroomM/1E3, Val2:=YroomP/1E3, Val3:=vqCarr_CutAreaYbtm/1E3, Val4:=vqCarr_CutAreaYtop/1E3 ); *)
                    (* Vediamo prima l'ingombro in park basso (prediligo questo), poi alto *)
                    IF (vqYinf_BtmParkPos+vqCarrInf_CurrDYroomP)<vqCarr_CutAreaYbtm THEN
                        (* Carrello+Traino in park basso libera l'area taglio, vai giù *)
                        vnCarrInf_Cmd := CARCMD_BTMPARK;
                    ELSIF (vqYinf_TopParkPos+vqCarrInf_CurrDYroomM)>vqCarr_CutAreaYtop THEN
                        (* Carrello+Traino in park alto libera l'area taglio, vai su *)
                        vnCarrInf_Cmd := CARCMD_TOPPARK;
                    ELSE
                        (* Mah, se c'è un traino, sgancialo *)
                        vnCarrInf_Cmd := CARCMD_FULLPARK;
                    END_IF;
                ELSE
                    (* Area taglio già liberata *)
                    (* dlog( Txt:='fbCarrInf: Already freed (%ld|%ld) (%ld|%ld)', Lvl:=4, Val1:=YroomM/1E3, Val2:=YroomP/1E3, Val3:=vqCarr_CutAreaYbtm/1E3, Val4:=vqCarr_CutAreaYtop/1E3 ); *)
                    vnCarrInf_Seq := SEQ_DONE;
                    vnCarrInf_Cmd := CMD_STOP;
                END_IF;
            ELSIF vnCarrInf_Cmd=CARCMD_TRAIL_LOCK OR vnCarrInf_Cmd=CARCMD_TRAIL_UNLOCK THEN
                IF vqECarrInf_Length>0 THEN
                    vqCarrInf_Tgt := vqYinf_LockPos - vqECarr_LockApproach;
                    IF Yinf.CurrPos>vqCarrInf_Tgt THEN vqCarrInf_Tgt := vqYinf_LockPos; END_IF;
                    MoveTo := MV_FREEMOVE;
                    Status := STS_MOVING; (* Proceed *)
                (* Traini in basso non supportati per ora! * )
                ELSIF vqECarrInf_Length<0 THEN
                    vqCarrInf_Tgt := vqYinf_LockPos + vqECarr_LockApproach; *)
                ELSE
                    (* Non c'è nessun traino, ignora comando *)
                    vnCarrInf_Cmd := CMD_STOP;
                    vnCarrInf_Seq := SEQ_DONE;
                END_IF;
            ELSIF vnCarrInf_Cmd=CMD_MOVETO THEN
                (* Movimento libero generico verso 'vqCarrInf_Tgt' *)
                (* Nota: il controllo pinza lo fa il servizio 'MV_FREEMOVE' *)
                MoveTo := MV_FREEMOVE;
                Status := STS_MOVING; (* Proceed *)
            ELSIF vnCarrInf_Cmd=CMD_FULLMOVETO THEN
                (* Movimento generico verso 'vqCarrInf_Tgt' *)
                Yinf.TgtSpd := vqCarrInf_Spd; (* [um/min] *)
                (* Più vado piano più parzializzo le accelerazioni? *)
                IF vbCarr_PartAcc THEN
                    Yinf.AccPerc := TO_INT( 10.0 + 100.0 * TO_LREAL(Yinf.TgtSpd) / TO_LREAL(Yinf.SpdMax) ); (* DANGER_DIVISION_BY_ZERO *)
                    Yinf.AccPerc := LIMIT(Yinf.AccPerc, 2, 100);
                    Yinf.DecPerc := Yinf.AccPerc;
                ELSE
                    Yinf.AccPerc := 100; (* max [%] *)
                    Yinf.DecPerc := 100; (* max [%] *)
                END_IF;
                Yinf.OutFrc := vqCarrInf_Frc; (* [mN] *)
                Yinf.MaxPosErr := WTR_DEFAULT;
                MoveTo := MV_TOOLMOVE;
                Status := STS_MOVING; (* Proceed *)
            ELSIF vnCarrInf_Cmd=CARCMD_SRCHGLASS OR
                  vnCarrInf_Cmd=CARCMD_SRCHGLASS_FWD OR
                  vnCarrInf_Cmd=CARCMD_SRCHGLASS_BCK THEN
                (* Sequenza di ricerca vetro *)
                (* Resetto eventuali messaggi *)
                RST_MSG_IF_ON(MSG_SEARCHERROR);
                (* Scegli opportunamente il verso della spazzata se non ancora specificato *)
                IF vnCarrInf_Cmd=CARCMD_SRCHGLASS THEN
                    vnCarrInf_Cmd := SEL(vbFeat_CarrHomeOnTop, CARCMD_SRCHGLASS_FWD, CARCMD_SRCHGLASS_BCK );
                END_IF;
                (* Devo prima andare in una certa posizione? *)
                (* Il range di ricerca: *)
                Ybegin := 0 - vqEdgeDet_Margin - vq[ivqProbe_DY+IRQ_PROBEINF]; (* [um] Sonda sotto lo zero di un certo margine *)
                Yend := vqYmax + vqEdgeDet_Margin - vq[ivqProbe_DY+IRQ_PROBEINF]; (* [um] Sonda sopra banda alta di un certo margine *)
                (* IF ABS(Yinf.CurrPos-SEL(vnCarrInf_Cmd=CARCMD_SRCHGLASS_BCK,Yend,Ybegin))<vqCut_MinLength
                    OR NOT fnInRange_DINT(Yinf.CurrPos,Ybegin,Yend)
                    OR NOT (vbCarriages_Prepos AND vbAutoMode) THEN *)
                    (* Assicura di partire dalla posizione iniziale di ricerca *)
                    vqCarrInf_Tgt := SEL(vnCarrInf_Cmd=CARCMD_SRCHGLASS_BCK, Ybegin, Yend );
                    MoveTo := MV_FREEMOVE; (* Vado alla posizione iniziale di ricerca *)
                (* ELSE
                    MoveTo := MV_DONE; (* Va bene partire da dove sono * )
                END_IF; *)
                Status := STS_MOVING; (* Proceed *)
            ELSIF vnCarrInf_Cmd=CARCMD_SCORE_FWD OR
                  vnCarrInf_Cmd=CARCMD_SCORE_BCK THEN
                (* Sequenza di incisione con carrello singolo
                   .Usa vqY_BtmEdge, vqY_TopEdge
                   .I controlli dei parametri utensile li ho già fatti in 'fbToolsParams' *)

                (* Qualora i bordi del vetro non fossero ancora noti, cerco di rilevarli "al volo" *)
                IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                    dlog( Txt:='fbCarrInf: ! Search on the fly', Lvl:=4 );
                    (* Ok, quello che voglio fare ora è:
                        1) Portarmi alla quota di inizio ricerca
                        2) Programmare la sonda/e
                        3) Eseguire il movimento di ricerca
                    *)
                    (* Determino quote di ricerca per Probe1 *)
                    Y := Yinf.CurrPos + vq[ivqProbe_DY+IRQ_PROBEINF]; (* Posizione sonda *)
                    IF vnCarrInf_Cmd=CARCMD_SCORE_FWD THEN
                        (* Lavorazione avanti *)
                        Ybegin := vqYmin - vqEdgeDet_Margin; (* Quota inizio ricerca *)
                        (* Yend := SEL( vbAutoMode, vqYmax, vqYmax-vqSubSheet_ProcHeight ) + vqEdgeDet_Margin; (* Ymax ricerca iniziale *)
                        Yend := vqYmin + (vqYmax-vqYmin)/2; (* Ymax ricerca bordo inizio *)
                        (* È necessario portarsi alla quota di inizio ricerca o possiamo partire da dove siamo? *)
                        IF Y<=Ybegin THEN Ybegin := Y; END_IF; (* Parto da dove sono *)
                    ELSE
                        (* Lavorazione indietro *)
                        Ybegin := vqYmax + vqEdgeDet_Margin; (* Quota inizio ricerca *)
                        Yend := vqYmin - vqEdgeDet_Margin; (* Ymin ricerca bordo inizio *)
                        (* È necessario portarsi alla quota di inizio ricerca o possiamo partire da dove siamo? *)
                        IF Y>=Ybegin THEN Ybegin := Y; END_IF; (* Parto da dove sono *)
                    END_IF;
                    Ybegin := Ybegin - vq[ivqProbe_DY+IRQ_PROBEINF];
                    Yend := Yend - vq[ivqProbe_DY+IRQ_PROBEINF];
                ELSE
                    (* Bordi vetro già noti *)
                    IF vnCarrInf_Cmd=CARCMD_SCORE_FWD THEN
                        (* Incisione avanti *)
                        Ybegin := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                        Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                        vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                    ELSIF vnCarrInf_Cmd=CARCMD_SCORE_BCK THEN
                        (* Incisione indietro *)
                        Ybegin := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                        Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                        vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                    END_IF;
                END_IF;
                (* Mi porto in posizione di inizio ricerca/lavorazione con un movimento libero *)
                dlog( Txt:='fbCarrInf: Score range %ld|%ld mm', Lvl:=3, Val1:=Ybegin/1E3, Val2:=Yend/1E3);
                vqCarrInf_Tgt := Ybegin; (* [um] *)
                MoveTo := MV_FREEMOVE;
                Status := STS_MOVING; (* Proceed *)

            ELSIF vnCarrInf_Cmd=CARCMD_OPEN_FWD OR
                  vnCarrInf_Cmd=CARCMD_OPEN_BCK THEN
                (* Sequenza di apertura con carrello singolo
                   .I controlli dei parametri utensile li ho già fatti in 'fbToolsParams' *)
                IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                    dlog( Txt:='fbCarrInf: !! Cannot open before searching', Lvl:=1 );
                    Status := STS_ERROR;
                    RETURN;
                ELSIF vnCarrInf_Cmd=CARCMD_OPEN_FWD THEN
                    (* Apertura con rotella inferiore avanti *)
                    Ybegin := MIN(vqY_TopEdge, vqY_BtmEdge + (vqRbrk_BtmMargin+vqMod_Rbrk_BtmMargin)) - vqRinf_DY; (* [um] *)
                    Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqRbrk_TopMargin+vqMod_Rbrk_TopMargin)) - vqRinf_DY; (* [um] *)
                    vqMod_Rbrk_BtmMargin := 0; (* Reset modificatore temporaneo *)
                    vqMod_Rbrk_TopMargin := 0; (* Reset modificatore temporaneo *)
                    vqCarrInf_Tgt := LIMIT(Ybegin + vqRbrk_StartInside, vqY_BtmEdge-vqRinf_DY, vqY_TopEdge-vqRinf_DY); (* [um] *)
                    vbRinf_SelC := FALSE; (* wheel -anticipo selezione utensile- *)
                ELSIF vnCarrInf_Cmd=CARCMD_OPEN_BCK THEN
                    (* Apertura con rotella inferiore indietro *)
                    Ybegin := MAX(vqY_BtmEdge, vqY_TopEdge - (vqRbrk_TopMargin+vqMod_Rbrk_TopMargin)) - vqRinf_DY; (* [um] *)
                    Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqRbrk_BtmMargin+vqMod_Rbrk_BtmMargin)) - vqRinf_DY; (* [um] *)
                    vqMod_Rbrk_BtmMargin := 0; (* Reset modificatore temporaneo *)
                    vqMod_Rbrk_TopMargin := 0; (* Reset modificatore temporaneo *)
                    vqCarrInf_Tgt := LIMIT(Ybegin - vqRbrk_StartInside, vqY_BtmEdge-vqRinf_DY, vqY_TopEdge-vqRinf_DY); (* [um] *)
                    vbRinf_SelC := FALSE; (* wheel -anticipo selezione utensile- *)
                END_IF;
                dlog( Txt:='fbCarrInf: Open range %ld|%ld mm', Lvl:=3, Val1:=Ybegin/1E3, Val2:=Yend/1E3);
                (* Mi porto in posizione di inizio lavorazione con un movimento libero *)
                MoveTo := MV_FREEMOVE;
                Status := STS_MOVING; (* Proceed *)

            ELSIF vnCarrInf_Cmd=CARCMD_BLADE_FWD OR
                  vnCarrInf_Cmd=CARCMD_BLADE_BCK THEN
                (* Tasteggio lametta *)
                vbBlade_Through := FALSE; (* Inizializzo segnale sfondamento plastico *)
                vbBladeInf_Jammed := FALSE; (* Inizializzo segnale lametta incagliata *)
                (* Nota: è responsabilità del chiamante:
                         -Effettuare il test lametta rotta in una posizione idonea
                         -Far partire la trazione con lo stacco *)
                IF vnCarrInf_Cmd=CARCMD_BLADE_FWD THEN
                    (* Tasteggio e taglio plastico avanti *)
                    dlog( Txt:='fbCarrInf: Blade seq from bottom to top', Lvl:=3 );
                    Ybegin := vqY_BtmEdge - vqBladeInf_DY + vqBlade_PrbMargin; (* tasteggio *)
                    Yend := Ybegin + vqBlade_SliceDelta; (* affettatura *)
                ELSE
                    (* Tasteggio e taglio plastico indietro *)
                    dlog( Txt:='fbCarrInf: Blade seq from top to bottom', Lvl:=3 );
                    Ybegin := vqY_TopEdge - vqBladeInf_DY - vqBlade_PrbMargin; (* tasteggio *)
                    Yend := Ybegin - vqBlade_SliceDelta; (* affettatura *)
                END_IF;
                (* Mi porto in posizione di inizio tasteggio con un movimento libero *)
                vqCarrInf_Tgt := Ybegin; (* [um] *)
                MoveTo := MV_FREEMOVE;
                Status := STS_MOVING; (* Proceed *)

            ELSIF vnCarrInf_Cmd=CMD_DRIVEN THEN
                (* -Aggancio camma (inseguimento vd[ivdYinf_PosRef])-
                     .Assicuro posizione iniziale di aggancio
                     .Aggancio inseguimento *)
                Y := TO_DINT(1000.0 * vd[ivdYinf_PosRef]);
                IF ABS(Yinf.CurrPos - Y)>1E3 THEN
                    vqCarrInf_Tgt := Y; (* [um] *)
                    MoveTo := MV_FREEMOVE;
                    Status := STS_MOVING;
                ELSE
                    Yinf.MasterIdx := ivdYinf_PosRef;
                    Yinf.MaxPosErr := 5E3; (* [um] Non è fondamentale che insegua perfettamente, v. anche vqRotBlk_MaxErr *)
                    Yinf.Cmd := AXC_START_FOL;
                    Status := STS_INITDRIVEN;
                END_IF;

            ELSE
                dlog( Txt:='fbCarrInf: !! Unknown cmd=%d', Lvl:=1, Val1:=TO_DINT(vnCarrInf_Cmd));
                Status := STS_ERROR;
            END_IF; (* -- See command *)
        END_IF; (* -- Comando attivo *)


    ELSE (* Errore sequenza (STS_ERROR) *)
        vbCarrInf_ParkOnEnd := FALSE; (* Eat temporary flags *)
        vnCarrInf_Seq := SEQ_ERROR; (* Risultato di errore *)
        MoveTo := MV_WAITSTOP;
        Yinf.Cmd := AXC_STOP_ENAB;
        Status := STS_STOPPING;

END_CASE; (* -- state machine *)



(* - Servizio di movimentazione -
     Visto che le sequenza sono tante, meglio separare il boilerplate
     della movimentazione, mi serve il movimento libero a utensili
     disattivati e il movimento di lavoro con utensile *)
IF Status<>STS_IDLE THEN
    CASE MoveTo OF

        MV_WAITMOVE : (* Attendi movimento verso quota obiettivo *)
            IF Yinf.Arrived THEN
                (* Ok, arrivato a destinazione *)
                dlog( Txt:='fbCarrInf: Arrived at %ld mm', Lvl:=6, Val1:=Yinf.TgtPos/1E3 );
                O_AIRBLOW_INF := FALSE;
                MoveTo := MV_DONE;
                (* Ho liberato la zona taglio? (Gestisco risorse acquisite) *)
                IF CutAreaFreed THEN (* AtRest *)
                    (* Se macchina non semplice, notifico *)
                    IF vnMach_Type>1 THEN dlog( Txt:='fbCarrInf: Freed cut area', Lvl:=5 ); END_IF;
                    (* Sono fuori da area taglio, libero eventuali risorse acquisite *)
                    (* Free possible acquired resources (CarrInf) *)
                    IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_HEATLAMP]=TS_OFF,ID_HEATLAMP,0); END_IF;
                    IF LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=0; END_IF;
                    IF vbFeat_FixedCarriages AND UpperCutZone=ID_CARR_SUP THEN UpperCutZone:=0; END_IF;
                END_IF;
                (* Se sono andato in quota 'home' controllo sensore *)
                IF Yinf.TgtPos=Yinf.HomePos AND ToolsAtRest AND NOT IFC_YINF_HOME THEN
                    dlog( Txt:='!! IFC_YINF_HOME', Lvl:=1 );
                    MoveTo := MV_ERROR;
                END_IF;
            ELSIF Yinf.Status<=AXS_READY THEN
                (* Se comando esternamente uno stop o non si attiva il bit in quota entra qui *)
                dlog( Txt:='fbCarrInf: ! Yinf move to %ld not arrived (%ld mm)', Lvl:=2, Val1:=Yinf.TgtPos/1E3, Val2:=Yinf.CurrPos/1E3 );
                O_AIRBLOW_INF := FALSE;
                MoveTo := MV_ERROR;
            ELSIF vnCarrInf_Cmd=CMD_STOP THEN (* Abort sequence *)
                dlog( Txt:='fbCarrInf: ! MoveTo aborted', Lvl:=2 );
                Yinf.Cmd := AXC_STOP_ENAB;
                MoveTo := MV_WAITSTOP;
            (* Per anticipare ulteriormente il rilascio delle risorse (evito il ritardo di asse fermo in quota) * )
            ELSIF (YroomP<vqCarr_CutAreaYbtm AND Yinf.CurrSpd<=0) OR (YroomM>vqCarr_CutAreaYtop AND Yinf.CurrSpd>=0) THEN
                (* Free possible acquired resources (CarrInf) *)
            END_IF;


        MV_WAITSTOP : (* Attendi stop asse *)
            O_AIRBLOW_INF := FALSE;
            IF Yinf.Status<=AXS_READY THEN
                MoveTo := MV_ERROR; (* Comunque non sono arrivato *)
            END_IF;


        MV_FREEMOVE,  (* Prepara movimento libero *)
        MV_TOOLMOVE : (* Prepara movimento con utensile attivo *)
            (* TODO 4: non sarebbe male una notifica di questa attesa
               SET_MSG(MSG_CARRINFWAITTOOLSUP,'MSG_CARRINFWAITTOOLSUP',0);
            *)
            (* Se è un movimento libero, disattiva utensili *)
            IF MoveTo=MV_FREEMOVE THEN
                ToolsOff := TRUE;
            END_IF;
            (* Detect null movement *)
            IF ABS(Yinf.CurrPos-vqCarrInf_Tgt)<=Yinf.InPosDelta THEN
                dlog( Txt:='fbCarrInf: Already at %ld mm (inpos=%ld um)', Lvl:=4, Val1:=Yinf.CurrPos/1E3, Val2:=Yinf.InPosDelta );
                MoveTo := MV_DONE;
            (* Detect command abort *)
            ELSIF vnCarrInf_Cmd=CMD_STOP THEN (* Abort *)
                dlog( Txt:='fbCarrInf: !! Move aborted', Lvl:=1 );
                MoveTo := MV_ERROR;
            (* Se movimento libero solo con pinza completamente chiusa o aperta *)
            (* Nota: Rilasso l'ulteriore controllo dell'orientazione orizzontale
                     orientata: ABS(Zg.CurrPos MOD 180E3)<500 (* 0.5°
                     movimento grande: ABS(Yinf.CurrPos-vqCarrInf_Tgt)>vqY_Middle *)
            ELSIF MoveTo=MV_FREEMOVE AND (vnGrabber_Type=2 AND Grabber.Status<>GSTS_CLOSED AND Grabber.Status<>GSTS_OPENED) THEN
                dlog( Txt:='fbCarrInf: !! Wont move to %ld with Grabber (%d)', Lvl:=1, Val1:=vqCarrInf_Tgt/1E3, Val2:=TO_DINT(Grabber.Status) );
                SET_MSG(MSG_GRABBER_OUT,'MSG_GRABBER_OUT',0);
                (* SET_MSG(MSG_NOTPARKED,'MSG_NOTPARKED: Grabber',0); *)
                MoveTo := MV_ERROR;
            ELSIF MoveTo<>MV_FREEMOVE OR ToolsAtRest THEN (* AND Yinf.Status=AXS_READY *)
                (* Controllo aggiuntivo? vqAlgn_CurrX>vqAlgn_XrMinSafe == Algn.InCutZone *)
                (* Cerco di acquisire le risorse necessarie *)
                (* Se carrelli vincolati posso muovermi anche con lampada fuori (e ferma!) *)
                IF vbFeat_FixedCarriages THEN
                    IF LowerCutZone_Algn<>ID AND (LowerCutZone_Algn=0 OR (LowerCutZone_Algn=ID_HEATLAMP AND NOT vbLamp_BlocksCarrInf)) THEN LowerCutZone_Algn:=ID; END_IF;
                ELSE
                    IF LowerCutZone_Algn<>ID AND LowerCutZone_Algn=0 THEN LowerCutZone_Algn:=ID; END_IF;
                END_IF;
                IF LowerCutZone_Dtch<>ID AND LowerCutZone_Dtch=0 THEN LowerCutZone_Dtch:=ID; END_IF;
                (* Se carrelli vincolati, dovrei acquisire per conto di CarrSup anche: *)
                IF vbFeat_FixedCarriages AND UpperCutZone<>ID_CARR_SUP AND UpperCutZone=0 THEN UpperCutZone:=ID_CARR_SUP; END_IF;
                (* Controlla di aver acquisito le risorse *)
                IF LowerCutZone_Algn=ID AND LowerCutZone_Dtch=ID
                   AND (NOT vbFeat_FixedCarriages OR UpperCutZone=ID_CARR_SUP)
                   AND Yinf.Status<>AXS_STOPPING THEN (* Evito errori se l'asse si sta fermando *)
                    (* Adesso puoi comandare il movimento *)
                    dlog( Txt:='fbCarrInf: Move from %ld to %ld mm', Lvl:=5, Val1:=Yinf.CurrPos/1E3, Val2:=vqCarrInf_Tgt/1E3);
                    IF Yinf.Status=AXS_READY THEN
                        (* Gli argomenti del posizionamento: *)
                        (* Yinf.TgtPos := <Già definito>; (* [um] *)
                        IF MoveTo=MV_FREEMOVE THEN
                            (* La velocità la decido in base a pericolo collisioni *)
                            Yinf.TgtSpd := SEL(vnGrabber_Type=2 AND Grabber.Status<>GSTS_CLOSED, TO_DINT(vnCarr_FreeMovPerc), vqCarr_SafeSpd);
                            Yinf.AccPerc := vnCarr_FreeMovPerc; (* [%] *)
                            Yinf.DecPerc := vnCarr_FreeMovPerc; (* [%] *)
                            Yinf.OutFrc := 0; (* just move [mN] *)
                            Yinf.MaxPosErr := WTR_HITDET;
                        (* ELSE (* Altrimenti devono essere già definiti! *)
                        END_IF;

                        (* Se c'è il traino agganciato parzializzo le accelerazioni *)
                        IF Ext.Locked>0 THEN
                            Yinf.AccPerc := fnPartializeAcc(Yinf.AccPerc, vnECarr_Acc);
                            Yinf.DecPerc := fnPartializeAcc(Yinf.DecPerc, vnECarr_Acc);
                        END_IF;

                        (* Forzo silenziosamente la quota obiettivo entro i limiti sw *)
                        IF vqCarrInf_Tgt>Yinf.PosLim THEN
                            dlog( Txt:='! Forcing tgt %ld>%ld', Lvl:=2, Val1:=vqCarrInf_Tgt/1E3, Val2:=Yinf.PosLim/1E3);
                            vqCarrInf_Tgt := Yinf.PosLim;
                        ELSIF vqCarrInf_Tgt<Yinf.NegLim THEN
                            dlog( Txt:='! Forcing tgt %ld<%ld', Lvl:=2, Val1:=vqCarrInf_Tgt/1E3, Val2:=Yinf.NegLim/1E3);
                            vqCarrInf_Tgt := Yinf.NegLim;
                        END_IF;
                        Yinf.TgtPos := vqCarrInf_Tgt; (* [um] *)
                        Yinf.Cmd := AXC_START_POS;
                        O_AIRBLOW_INF := ABS(Yinf.CurrPos-vqCarrInf_Tgt) > vqY_Middle;
                        MoveTo := MV_WAITMOVE;
                    ELSE
                        dlog( Txt:='!! Yinf not ready (%d) to move', Lvl:=1, Val1:=TO_DINT(Yinf.Status));
                        MoveTo := MV_ERROR;
                    END_IF;
                ELSE (* Altrimenti aspetta che si liberino *)
                    (* Probabilmente non sono riuscito ad acquisire una o più risorse,
                       oppure l'asse non è ancora pronto: tenterò il prossimo giro *)
                    (* Free possible acquired resources (CarrInf) *)
                    IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_HEATLAMP]=TS_OFF,ID_HEATLAMP,0); END_IF;
                    IF LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=0; END_IF;
                    IF vbFeat_FixedCarriages AND UpperCutZone=ID_CARR_SUP THEN UpperCutZone:=0; END_IF;
                END_IF;
            (*ELSE (* Notifica attesa utensili a riposo?
                SET_MSG(MSG_CARRINFWAITTOOLSUP,'',0); *)
            END_IF;

    END_CASE; (* -- servizio movimentazione *)
END_IF; (* -- Sequenza in corso *)



(* -- Deactivate all tools services -- *)
IF ToolsOff THEN
    vbTinf_Cmd := FALSE;
    vbRinf_Cmd := FALSE;
    vnBladeInf_Cmd := CMD_STOP;
    vbEdgeTrim_Cmd := FALSE;
    Probe1( Activate:=FALSE );
    Probe2( Activate:=FALSE );
    (* vnGrabber_Cmd := GCMD_NONE; (* La pinza deve rimanere nel suo stato. Nota: Potrebbe essere su traino *)
    ToolsOff := FALSE; (* Eat *)
END_IF;


(* -- Gestione soffio polvere -- *)
(* O_AIRBLOW_SUP := vbDustBlow_Cmd; *)


(* -- Grabber orientation force service --
      Per mettere l'asse orientazione pinza in folle *)
ZgSetForce( in:=vqZgSetTorqueLim<>NO_POS_UM );
IF ZgSetForce.q THEN
    dlog( Txt:='fbCarrInf: ! Zg torque service (%d)', Lvl:=1, Val1:=vqZgSetTorqueLim/1E3);
    Zg.OutFrc := vqZgSetTorqueLim; (* [mN mm/deg] *)
    Zg.Cmd := AXC_SETFORCE;
    vqZgSetTorqueLim := NO_POS_UM; (* eat *)
END_IF;

(* -- Gestione riduttore pressione di presa --
   Introdotto per non rompere il vetro nelle preincisioni *)
O_GRAB_PRESSREDUCER := Grabber.Status>=GSTS_GRABBING AND (vbSubSheet_Prescored OR vbZprescored_Done);

(* -- Eventuale traino carrello (ActiveHP) -- *)
IF vqECarrInf_Length<>0 THEN
    Ext();
END_IF;


(* -- Monitors -- *)

(* Ingombro carrello *)
(* Per l'ingombro attuale: Yinf.CurrPos, altrimenti per quello futuro: Yinf.StopPos *)
YroomM := Yinf.SafeStopPos + vqCarrInf_CurrDYroomM;
YroomP := Yinf.SafeStopPos + vqCarrInf_CurrDYroomP;

(* Ingombro pinza *)
(* Se c'è l'appendice passiva/traino la pinza è montata su di esso
   se ancorata al parcheggio l'ingombro è fissato, altrimenti segue il carrello *)
GrabberYroomP := SEL(vbGrabber_NotLocked, Yinf.SafeStopPos, vqYinf_LockPos) + vqGrabber_DY + vqGrabber_Radius;
GrabberYroomM := GrabberYroomP - vqGrabber_Radius - vqGrabber_Radius;

ToolsAtRest := Tinf.AtRest AND Rinf.AtRest AND BladeInf.AtRest (* AND Tinf2.AtRest AND Rinf2.AtRest *)
               AND (Grabber.AtRest OR (Grabber.Status=GSTS_OPENED AND vnGrabber_Type=2)); (* Permetto i movimenti liberi anche con pinza alta e aperta *)

(* Collisione stacco-carrello
   Nota: Nelle StratoS (vnMach_Type<=1) lo stacco non può collidere coi carrelli *)
CutAreaFreed := YroomM>vqCarr_CutAreaYtop OR YroomP<vqCarr_CutAreaYbtm;

(* La posizione di home corrisponde a quella a cui va l'asse dopo l'azzeramento (QuoHome);
   Se l'asse è in home si è sempre a riposo (a meno che non ci sia il traino attaccato?) *)
AtHome := IFC_YINF_HOME AND ABS(Yinf.CurrPos-Yinf.HomePos)<1E3;
          (* AND (vqECarrInf_Length=0 OR Ext.Locked<=0) (* ...E non ha il traino attaccato *)

(* Il segnale 'AtRest' significa che la zona taglio è libera
   Su alcune macchine questo avviene sia con parcheggio alto che basso.
   In ogni caso questo è sempre vero se si è nella posizione di 'Home',
   che coincide col parcheggio alto se 'vbFeat_CarrHomeOnTop' *)
AtRest := (vbAx_NoStillChkAtRest OR Yinf.Still) (* Asse fermo? *)
          AND NOT (Yinf.MovingFwd OR Yinf.MovingBck) (* vbFeat_CarrHomeOnTop *)
          AND ( AtHome (* In 'home' si è sempre "a riposo" *)
                OR CutAreaFreed ); (* Se Parcheggio diverso da 'home' *)

vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbCarriages

{ DE:"Sequenze dei carrelli" }

	VAR_IN_OUT
	Inf : fbCarrInf; { DE:"Carrello inferiore" }
	Sup : fbCarrSup; { DE:"Carrello superiore" }
	END_VAR

	VAR_INPUT
	Abort : BOOL; { DE:"Segnale di stop/annullamento sequenza" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Carrelli parcheggiati in posizione sicura" }
	Allow : BOOL; { DE:"Consenso alle operazioni dei carrelli" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vbStopSignal : BOOL; { DE:"Dispatched stop request signal to freeze/abort current operation" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vbHomingDone : BOOL; { DE:"Homing-*.src was successfully executed" }
	vnCarriages_Sts : INT; { DE:"Stato funzionamento combinato carrelli" }
	vnCarriages_Cmd : INT; { DE:"Comando carrelli coordinati (vedi 'CARCMD_*')" }
	vnCarriages_Seq : INT; { DE:"Risultato sequenza carrelli" }
	vnCarrSup_Cmd : INT; { DE:"Comando carrello superiore (vedi 'CMD_*')" }
	vnCarrSup_Seq : INT; { DE:"Risultato sequenza carrello superiore" }
	vqCarrSup_Tgt : DINT; { DE:"Posizione obiettivo carrello superiore [um]" }
	vnCarrInf_Cmd : INT; { DE:"Comando carrello inferiore (vedi 'CMD_*')" }
	vnCarrInf_Seq : INT; { DE:"Risultato sequenza carrello inferiore" }
	vqCarrInf_Tgt : DINT; { DE:"Posizione obiettivo carrello inferiore [um]" }
	vbFeat_CarrHomeOnTop : BOOL; { DE:"Macchina con parcheggio carrelli opposto ad operatore" }
	vnECarr_Acc : INT; { DE:"Parzializzazione accelerazione carrelli con traini agganciati [%]" }
	vnCarr_ChgTgtDec : INT; { DE:"Decelerazione per ricerca bordo finale vetro [%]" }
	vbCarr_ToolsOffOnErr : BOOL; { DE:"Alza subito utensili in caso di errori del movimento" }
	UpperCutZone : INT; { DE:"Spazio sopra il piano all'interno del ponte di taglio" }
	LowerCutZone_Algn : INT; { DE:"Spazio sotto il piano nell'area di taglio lato risc" }
	LowerCutZone_Dtch : INT; { DE:"Spazio sotto il piano nell'area di taglio lato stacco" }
	vbGrabber_NotLocked : BOOL; { DE:"Pinza su traino e non agganciata a carrello inferiore" }
	vbGrabber_CanBeUnlocked : BOOL; { DE:"Pinza su traino e agganciata a carrello inferiore" }
	Ysup : fbM32Axis; { DE:"Asse carrello superiore AX_YSUP" }
	Yinf : fbM32Axis; { DE:"Asse carrello inferiore AX_YINF" }
	vqYmin : DINT; { DE:"Ordinata minima del bordo vetro [um]" }
	vqYmax : DINT; { DE:"Ordinata massima del bordo vetro [um]" }
	vqYinf_GrabBtmPos : DINT; { DE:"Posizione bassa Yinf per apertura/chiusura in sicurezza [um]" }
	vqYinf_GrabTopPos : DINT; { DE:"Posizione alta Yinf per apertura/chiusura in sicurezza [um]" }
	vqYsup_BtmParkPos : DINT; { DE:"Posizione di parcheggio basso carrello superiore [um]" }
	vqYsup_TopParkPos : DINT; { DE:"Posizione di parcheggio alto carrello superiore [um]" }
	vqSubSheet_ProcHeight : DINT; { DE:"Dimensione trasversale lastra in arrivo (dopo la rotazione) [um]" }
	vqEdgeDet_Margin : DINT; { DE:"Margine per rilevazione bordo vetro [um]" }
	vqEdgeDet_OnTheFlySpd : DINT; { DE:"Velocità ricerca al volo [um/min]" }
	vbEdgeDet_AutoFlyUseDim : BOOL; { DE:"In automatico usa la dimensione lastra per il target della ricerca al volo" }
	vbFeat_HasProbeSup2 : BOOL; { DE:"Macchina con sonda secondaria per ricerca al volo durante lavorazione" }
	vqY_BtmEdge : DINT; { DE:"Quota misurata bordo vetro basso [um]" }
	vqY_TopEdge : DINT; { DE:"Quota misurata bordo vetro alto [um]" }
	vqCut_Length : DINT; { DE:"Lunghezza taglio effettiva [um]" }
	vnHoldPads_Cmd : INT; { DE:"Comando discesa tamponi fermavetro" }
	vqTscore_BtmMargin : DINT; { DE:"Margine da bordo vetro basso incisione [um]" }
	vqTscore_TopMargin : DINT; { DE:"Margine da bordo vetro alto incisione [um]" }
	vqMod_Tscore_BtmMargin : DINT; { DE:"Modifier [um]" }
	vqMod_Tscore_TopMargin : DINT; { DE:"Modifier [um]" }
	vqTscore_ScoreYforce : DINT; { DE:"Forza massima che il carrello può erogare durante incisione [mN]" }
	vqV_score : DINT; { DE:"Velocità di incisione 'V-score' [um/min]" }
	Tsup : fbTscore; { DE:"Testina di incisione superiore" }
	vbTsup_Cmd : BOOL; { DE:"Activate upper scoring head 'ID_TSUP'" }
	vqTsup_P : DINT; { DE:"Spinta incisione superiore [N]" }
	vqF_score_sup : DINT; { DE:"Forza pressione incisione superiore 'F-score-sup' [mN]" }
	vqMod_F_score_sup : DINT; { DE:"Modifier 'f-score-sup' [mN]" }
	Tinf : fbTscore; { DE:"Testina di incisione inferiore" }
	vbTinf_Cmd : BOOL; { DE:"Activate lower scoring head 'ID_TINF'" }
	vqTinf_P : DINT; { DE:"Spinta incisione inferiore [mN]" }
	vqF_score_inf : DINT; { DE:"Forza pressione incisione inferiore 'F-score-inf' [mN]" }
	vqMod_F_score_inf : DINT; { DE:"Modifier 'f-score-inf' [mN]" }
	vqRbrk_BtmMargin : DINT; { DE:"Margine da bordo vetro basso rotelle di apertura [um]" }
	vqRbrk_TopMargin : DINT; { DE:"Margine da bordo vetro alto rotelle di apertura [um]" }
	vbRbrk_DoublePass : BOOL; { DE:"Selezione doppia passata (apertura rifilo)" }
	vbRbrk_UpperLayer : BOOL; { DE:"Strato da aprire per selezione controrotella" }
	vqRbrk_StartInside : DINT; { DE:"Inizia ad aprire più internamente rispetto il margine [um]" }
	vqRbrk_OpenYforce : DINT; { DE:"Forza massima che il carrello può erogare durante apertura con rotelle [mN]" }
	vqMod_Rbrk_BtmMargin : DINT; { DE:"Modifier [um]" }
	vqMod_Rbrk_TopMargin : DINT; { DE:"Modifier [um]" }
	vqV_brkwhl_trim : DINT; { DE:"Velocità rotelle di apertura rifilo 'V-brkwhl-trim' [um/min]" }
	Rsup : fbRbrk; { DE:"Rotella di apertura superiore" }
	vqRsup_DY : DINT; { DE:"Offset rotella apertura superiore [um]" }
	vbRsup_SelC : BOOL; { DE:"Select counter-wheel" }
	vbRsup_Cmd : BOOL; { DE:"Activate upper breakout wheel" }
	vqRsup_P : DINT; { DE:"Spinta rotella di apertura superiore [mN]" }
	vqF_brkwhl_sup_trim : DINT; { DE:"Forza pressione rotella sup apertura rifilo 'F-brkwhl-sup-trim' [mN]" }
	Rinf : fbRbrk; { DE:"Rotella di apertura inferiore" }
	vqRinf_DY : DINT; { DE:"Offset rotella apertura inferiore [um]" }
	vbRinf_SelC : BOOL; { DE:"Select counter-wheel" }
	vbRinf_Cmd : BOOL; { DE:"Activate lower breakout wheel" }
	vqRinf_P : DINT; { DE:"Spinta rotella di apertura inferiore [mN]" }
	vqF_brkwhl_inf_trim : DINT; { DE:"Forza pressione rotella inf apertura rifilo 'F-brkwhl-inf-trim' [mN]" }
	IFC_YINF_ZERO : BOOL; { DE:"Sensore azzeramento carrello inferiore (0:engaged)" }
	IFC_YINF_POSLIM : BOOL; { DE:"Finecorsa (min e max) carrello inferiore (1:engaged)" }
	IFC_YINF_HOME : BOOL; { DE:"Sensore carrello inferiore in posizione di riposo (area taglio libera)" }
	IFC_YSUP_ZERO : BOOL; { DE:"Sensore azzeramento carrello superiore (0:engaged)" }
	IFC_YSUP_POSLIM : BOOL; { DE:"Finecorsa (min e max) carrello inferiore (1:engaged)" }
	IFC_YSUP_HOME : BOOL; { DE:"Sensore carrello superiore in posizione di riposo (area taglio libera)" }
	fcDtchLast : fbPhotoCell; { DE:"Ultima fotocellula su modulo stacco (IFC_DTCH_LAST)" }
	Yo : fbYo; { DE:"Profilo ordinata vertice basso per rotazioni" }
	vnIrqStatus : INT; { DE:"Lettura stato degli ingressi veloci" }
	vqProbe3_DX : DINT; { DE:"Offset X terza sonda [um]" }
	IFC_YINF_BCK_DTCH : BOOL; { DE:"!DEPRECATED! Fotocellula su carrello inferiore presenza vetro lato stacco (prevenzione collisioni pinza)" }
	Grabber : fbGrabber; { DE:"Pinza girapezzi su carrello inferiore" }
	vnGrabber_Type : INT; { DE:"Tipo girapezzi 'ID_GRABBER' (0:none 1:ventosa 2:pinza)" }
	vbExclGrbCollCtrl : BOOL; { DE:"Escludi controlli collisione pinza alta/carrello superiore" }
	Zg : fbM32Axis; { DE:"Asse orientazione pinza AX_ZG" }
	OutZone : fbOutZone; { DE:"Zona fine linea" }
	vqRot_Ymax : DINT; { DE:"Ingombro rotazione: Y massimo [um]" }
	vqRot_Xmax : DINT; { DE:"Ingombro rotazione: X massimo [um]" }
	vqRot_Xmin : DINT; { DE:"Ingombro rotazione: X minimo [um]" }
	SelectProdVents : fbSelectProdVents; { DE:"Seleziona zone cuscino aria zona riscontro" }
	SelectRemnVents : fbSelectRemnVents; { DE:"Seleziona zone cuscino aria zona rimanenza" }
	vnVents_Cmd : INT; { DE:"Maschera comando gruppi ventilatori cuscino aria" }
	vbSlantMode : BOOL; { DE:"Modalità tagli obliqui attivata" }
	vbAirCushionReady : BOOL; { DE:"Cuscino aria pronto" }
	vqAlgn_XrMinSafe : DINT; { DE:"Quota Xr limite rischio collisione riscontri-carrello inferiore [um]" }
	vqYph_DtchLast : DINT; { DE:"Ordinata ultima fotocellula su stacco [um]" }
	vqDtch_Xbegin : DINT; { DE:"Ascissa inizio zona stacco [um]" }
	vbGrab_RotWithBlock : BOOL; { DE:"Rotazione con aiuto piedino" }
	vnGrab_RotType : INT; { DE:"Tipo ultima rotazione con pinza (0:none 1:+90-algn 2:-90-dtch 3:generic)" }
	vnGrab_RotStatus : INT; { DE:"Stato rotazione in corso" }
	vnAlgn_Seq : INT; { DE:"Stato/risultato sequenze riscontri" }
	vnGrabber_Cmd : INT; { DE:"Grabber command" }
	vqGrabber_DY : DINT; { DE:"Offset asse pinza girapezzi [um]" }
	vqGrabber_Radius : DINT; { DE:"Raggio pinza girapezzi [um]" }
	vqGrab_MaxGlassThckn : DINT; { DE:"Spessore complessivo massimo agguantabile da pinza [um]" }
	vqGrab_RotVmax : DINT; { DE:"Massima velocità tangenziale lastra in rotazione [um/min]" }
	vqGrab_RotZSpdMax : DINT; { DE:"Limite velocità pinza durante rotazione vetro [deg/min]" }
	vqGrab_YSpdMax : DINT; { DE:"Velocità traslazione Y con vetro agguantato [um/min]" }
	vnGrab_YAccelMax : INT; { DE:"Massima accelerazione carrello nel riposizionamento Y [%]" }
	vqGrab_SlipTorque : DINT; { DE:"Coppia scivolamento ganasce agguantate al vetro [mNm]" }
	vnGrab_RotMaxAccel : INT; { DE:"Limite accelerazione pinza per rotazione vetro [%]" }
	vnGrab_RotBlkAccel : INT; { DE:"Accelerazione pinza per rotazione con piedino [%]" }
	vnGrab_SlantAccel : INT; { DE:"Parzializzazione accelerazioni con vetro agguantato nel taglio fuori squadra [%]" }
	vqGrab_RotTorque : DINT; { DE:"Coppia erogata durante rotazioni [mNm]" }
	vqRotBlk_DaComp : DINT; { DE:"Sotto-rotazione con piedino per compensazione riposizionamento in basso [mdeg]" }
	vbGrab_OnTheFlySearch : BOOL; { DE:"Abilita la ricerca al volo durante agguantamento" }
	vqGrab_GlassWidth : DINT; { DE:"Larghezza iniziale lastra da ruotare [um]" }
	vqGrab_GlassYbtm : DINT; { DE:"Ordinata bordo passo iniziale lastra da ruotare [um]" }
	vqGrab_GlassYtop : DINT; { DE:"Ordinata bordo alto iniziale lastra da ruotare [um]" }
	vqGrab_Agrab : DINT; { DE:"Angolo di presa [mdeg]" }
	vqGrab_Arot : DINT; { DE:"Angolo relativo di rotazione [mdeg]" }
	vqGrab_Ygrab : DINT; { DE:"Quota di presa [um]" }
	vqGrab_Yc_pre : DINT; { DE:"Quota a cui portare la presa della lastra agguantata prima della rotazione [um]" }
	vqGrab_Yc_post : DINT; { DE:"Quota a cui portare la presa della lastra agguantata dopo la rotazione [um]" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqRemn_X : DINT; { DE:"Posizione bordo avanti della rimanenza [um]" }
	CalcRotData : fbCalcRotData; { DE:"Calcoli comuni lastra in rotazione" }
	vdRot_Rmax : LREAL; { DE:"Distanza tra punto presa e vertice più lontano [m]" }
	vdRot_Dm : LREAL; { DE:"Distanza tra punto presa e centro di massa lastra in rotazione [m]" }
	vdRot_Mass : LREAL; { DE:"Massa della lastra in rotazione [Kg]" }
	vdRot_Jgrab : LREAL; { DE:"Momento d'inerzia rispetto il centro di massa della lastra in rotazione [Kg m²]" }
	CalcRotAlgn : fbCalcRotAlgn; { DE:"Calcoli per rotazione prodotto con pinza" }
	IFC_TILTOUT_BLOCKS_OUT : BOOL; { DE:"Sensore piedini fuori ribaltina scarico pezzi" }
	vqTiltOut_Xo : DINT; { DE:"Ascissa dei piedini automatici della ribaltina [um]" }
	vnClampAlgn_Cmd : INT; { DE:"Comando discesa premilastra lato riscontri" }
	vnClampAlgn_Type : INT; { DE:"Tipo premilastra riscontro (0:none 1:pneum 2:mot)" }
	vnAlgn_Cmd : INT; { DE:"Comando generale riscontri" }
	vnAlgnBlocks_Sts : INT; { DE:"Stato dei piedini di riscontro" }
	vqAlgn_CurrX : DINT; { DE:"Posizione attuale dei piedini riscontri selezionati [um]" }
	vqAlgn_Tgt : DINT; { DE:"Quota obiettivo dei riscontri [um]" }
	vbFeed_Accessible : BOOL; { DE:"Tavolo di carico accessibile" }
	vqFeed_Xend : DINT; { DE:"Ascissa bordo avanti del tavolo di carico [um]" }
	END_VAR

	VAR
	MoveBoth : EN_AXIS_MV_CMD := MV_DONE; { DE:"Servizio movimentazione carrelli in asse elettrico" }
	MoveBothKeepLock : BOOL; { DE:"Flag temporaneo: Non voglio sganciare l'inseguimento" }
	Y : DINT; { DE:"Quota y [um]" }
	Ybegin : DINT; { DE:"Quota di partenza dell'utensile [um]" }
	Yend : DINT; { DE:"Quota di arrivo dell'utensile [um]" }
	YgrabOC : DINT; { DE:"Quota di apertura/chiusura pinza [um]" }
	Agrab : DINT; { DE:"Angolo orientazione pinza normalizzato [-180E3÷180E3 mdeg]" }
	RequiredVents : INT; { DE:"Maschera dei ventilatori richiesti" }
	Probe1 : fbProbe; { DE:"Primary probe latches service" }
	Probe2 : fbProbe; { DE:"Secondary probe latches service" }
	try_count : INT; { DE:"Contatore tentativi ricerca al volo" }
	edge_latch : DINT; { DE:"Cattura bordo vetro [um]" }
	ProbeInf : fbProbe; { DE:"Probe on CarrInf latches service (used on grabbing)" }
	END_VAR

	VAR CONSTANT
	ATOLL : DINT := 30; { DE:"Tolleranza controllo angoli (0.03° ~ 5mm su 10m) [mdeg]" }
	END_VAR

	{ CODE:ST }(*    fbCarriages (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Sequenze coordinate dei carrelli.
      Risorse che possono essere occupate:
        .'UpperCutZone' (zona taglio alta - collisione pinza-carr sup)
        .'LowerCutZone_Dtch' (zona taglio bassa lato stacco - collisione stacco)
        .'LowerCutZone_Algn' (zona taglio bassa lato risc - collisione lampada)

      NOTES
      ----------------------------------------------
      I comandi di funzionamento coordinato
      'vnCarriages_Cmd' possono potenzialmente
      sovrapporsi ai comandi singoli 'vnCarrInf_Cmd',
      'vnCarrSup_Cmd', questi conflitti vanno gestiti.

      EXAMPLE OF USAGE
      ----------------------------------------------
      vnCarriages_Cmd = CMD_PARK
      WaitCond( vnCarriages_Cmd==CMD_STOP )
      if( vnCarriages_Seq!=SEQ_DONE )
          // Error
      endif
*)


(* -- Manage stop signal -- *)
IF Abort THEN
    (* dlog( Txt:='fbCarriages: !! Abort Cmd=%d', Lvl:=3, Val1:=TO_DINT(vnCarriages_Cmd) ); *)
    vnCarriages_Cmd := CMD_STOP;
(* ELSIF Suspend THEN (* Could suspend? servirebbe fermare l'asse e partire dallo step precedente *)
END_IF;
(* Notify abort *)
IF (Status>STS_STOPPING AND MoveBoth<>MV_WAITSTOP) AND vnCarriages_Cmd=CMD_STOP THEN
    dlog( Txt:='fbCarriages: !! Abort Sts=%d', Lvl:=3, Val1:=TO_DINT(Status) );
END_IF;


(* -- State machine -- *)
CASE Status OF
    (* ------------------------------------------------------------------- *)
    CARSTS_WAITBOTH : (* Attendi comando singolo di entrambi i carrelli *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            vnCarrSup_Cmd := CMD_STOP;
            vnCarrInf_Cmd := CMD_STOP;
            Status := STS_ERROR;
        ELSIF vnCarrSup_Cmd=CMD_STOP AND vnCarrInf_Cmd=CMD_STOP THEN
            (* Entrambe le sequenze sono finite, vediamo il risultato *)
            IF vnCarrInf_Seq<>SEQ_DONE THEN
                dlog( Txt:='fbCarriages: !! CarrInf error', Lvl:=1 );
                Status := STS_ERROR;
            ELSIF vnCarrSup_Seq<>SEQ_DONE THEN
                dlog( Txt:='fbCarriages: !! CarrSup error', Lvl:=1 );
                Status := STS_ERROR;
            ELSE
                (* dlog( Txt:='fbCarriages: Both carriages arrived', Lvl:=5 ); *)
                (* Ok, ora vediamo cosa fare
                   Se il comando è di lavorazione questo è il movimento iniziale
                   per portare i carrelli in quota, quindi proseguo con la
                   rispettiva sequenza; altrimenti finiamo qui (parcheggio o altro) *)
                CASE vnCarriages_Cmd OF

                    CARCMD_SCORE_FWD, CARCMD_SCORE_BCK :
                        (* Carrelli arrivati in quota *)
                        (* Aggancio carrelli - il master è CarrSup *)
                        Yinf.MasterIdx := AX_YSUP;
                        Yinf.MaxPosErr := WTR_DEFAULT;
                        Yinf.Cmd := AXC_START_FOL;
                        IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                            (* Carrelli in quota di inizio ricerca "al volo" *)
                            (* Ricerca "al volo": Preparo le sonde
                               La sonda principale Probe1 rileva con un fronte di salita
                               il bordo iniziale, e con un fronte di discesa il bordo finale.
                               Una eventuale sonda secondaria Probe2, montata più avanti,
                               aiuta a rilevare con un fronte di discesa il bordo finale
                               con maggiore anticipo *)
                            Probe1( ProbeIdx:=IRQ_PROBESUP, AxIdx:=AX_YSUP, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                            Probe2( ProbeIdx:=IRQ_PROBESUP2, AxIdx:=AX_YSUP, Activate:=TRUE, Reset:=TRUE, SweepMode:=TRUE );
                            edge_latch := NO_POS_UM; (* Bordo finale ignoto *)
                            try_count := 0; (* Inizializzo tentativi *)
                            Status := CARSTS_SRCH_FLY_INI;
                        ELSE
                            (* Carrelli in quota di inizio incisione *)
                            (* Attivo utensili *)
                            (* vbLubScore_Cmd := TRUE; *)
                            vqTinf_P := vqF_score_inf + vqMod_F_score_inf;
                            vqMod_F_score_inf := 0; (* Reset modificatore temporaneo *)
                            vqTsup_P := vqF_score_sup + vqMod_F_score_sup;
                            vqMod_F_score_sup := 0; (* Reset modificatore temporaneo *)
                            Status := CARSTS_SCORE_INIT;
                        END_IF;

                    CARCMD_OPEN_FWD, CARCMD_OPEN_BCK :
                        (* Arrivato alla quota di inizio apertura con rotelle *)
                        (* Aggancio carrelli - il master è CarrSup *)
                        Yinf.MasterIdx := AX_YSUP;
                        Yinf.MaxPosErr := WTR_DEFAULT;
                        Yinf.Cmd := AXC_START_FOL;
                        (* Preparo la prima passata
                           Abbasso e seleziono l'utensile corretto *)
                        vbRsup_SelC := vbRbrk_UpperLayer;
                        vbRinf_SelC := NOT vbRsup_SelC;
                        IF vbRsup_SelC THEN
                            (* Sto aprendo lo strato sopra: uso rotella inf e controrotella sup *)
                            vqRinf_P := vqF_brkwhl_inf_trim;
                            vqRsup_P := vqRinf_P; (* pressione antagonista controrotella *)
                        ELSE
                            (* Sto aprendo lo strato sotto: uso rotella sup e controrotella inf *)
                            vqRsup_P := vqF_brkwhl_sup_trim;
                            vqRinf_P := vqRsup_P; (* pressione antagonista controrotella *)
                        END_IF;

                        (* Vediamo dove parto ad aprire *)
                        IF vqCarrSup_Tgt<>Ybegin THEN
                            (* Inizio ad aprire dentro, vado verso il bordo iniziale *)
                            dlog( Txt:='fbCarriages: Inner opening at %ld', Lvl:=4, Val1:=vqCarrSup_Tgt/1E3 );
                            vqCarrSup_Tgt := Ybegin; (* [um] *)
                        ELSE
                            (* Sono partito dal bordo iniziale, vado direttamente alla fine *)
                            vqCarrSup_Tgt := Yend; (* [um] *)
                        END_IF;
                        Status := CARSTS_OPEN_INIT;

                ELSE (* Terminiamo qui *)
                        vnCarriages_Cmd := CMD_STOP;
                        vnCarriages_Seq := SEQ_DONE;
                        Status := STS_IDLE;
                END_CASE;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_FLY_INI : (* Preparazione ricerca "al volo" bordo inizio vetro *)
        (* Attendi sonde e asse pronto *)
        Probe1( Activate:=TRUE ); (* Sonda principale *)
        Probe2( Activate:=TRUE ); (* Eventuale sonda aggiuntiva per il bordo finale, 'vbFeat_HasProbeSup2' *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Probe1.Status>=PS_WAITMOVE AND Ysup.Status=AXS_READY AND Yinf.Status=AXS_MOVING_FOL THEN
            (* Pronto per ricercare, comando movimento master *)
            vqCarrSup_Tgt := Yend; (* [um] *)
            Ysup.TgtSpd := vqEdgeDet_OnTheFlySpd; (* [um/min] *)
            Ysup.AccPerc := 100; (* max [%] *)
            Ysup.DecPerc := 100; (* max [%] *)
            Ysup.OutFrc := 0; (* just move [mN] *)
            Ysup.MaxPosErr := WTR_HITDET;
            MoveBoth := MV_TOOLMOVE;
            MoveBothKeepLock := TRUE;
            (* Direzione ricerca *)
            Probe1.Back := vqCarrSup_Tgt < Ysup.CurrPos;
            Probe2.Back := Probe1.Back;
            (* Proceed *)
            try_count := try_count + 1;
            Status := CARSTS_SRCH_FLY;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_FLY : (* Movimento ricerca "al volo" in corso *)
        Probe1(); (* Sonda principale *)
        Probe2(); (* Eventuale sonda aggiuntiva per il bordo finale, 'vbFeat_HasProbeSup2' *)

        (* Rilevo fin da subito anche il bordo finale con la sonda secondaria *)
        IF Probe2.NewFallLatch THEN (* => Probe2.LastFallLatch *)
            dlog( Txt:='fbCarriages: Probe2 fall at %ld mm', Lvl:=4, Val1:=Probe2.LastFallLatch/1E3 );
            edge_latch := Probe2.LastFallLatch;
            Probe2( Activate:=FALSE ); (* La sonda non serve più, prendo per buono il primo ed ignoro i successivi (più sicuro?) *)
        ELSIF Probe1.NewRiseLatch THEN (* => Probe1.LastRiseLatch *)
            dlog( Txt:='fbCarriages: Probe1 rise at %ld mm', Lvl:=4, Val1:=Probe1.LastRiseLatch/1E3 );
            (* IF Probe1.SliversCount>0 THEN
                dlog( Txt:='fbCarriages: SRCH_FLY: ! Found %d chips', Lvl:=2, Val1:=TO_DINT(Probe1.SliversCount));
                SET_MSG(REQ_CLEAN_CUTFLOOR,'REQ_CLEAN_CUTFLOOR',TO_DINT(Probe1.SliversCount));
            END_IF; *)
            (* Catturato il bordo iniziale del vetro! Vediamo se non è da scartare *)
            IF Probe1.LastRiseLatch >= (vqYmin-vqEdgeDet_Margin) THEN
                (* Memorizzo il bordo iniziale misurato *)
                IF Probe1.Back THEN vqY_TopEdge := Probe1.LastRiseLatch;
                ELSE                vqY_BtmEdge := Probe1.LastRiseLatch; END_IF;

                (* - Calcolo la quota iniziale della lavorazione - *)
                (* Incisione avanti *)
                IF vnCarriages_Cmd=CARCMD_SCORE_FWD THEN
                    Ybegin := vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                (* Incisione indietro *)
                ELSIF vnCarriages_Cmd=CARCMD_SCORE_BCK THEN
                    Ybegin := vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                ELSE (* Should never be here! *)
                    Status := STS_ERROR;
                    RETURN;
                END_IF;
                (* Cambio target ricerca al volo *)
                Ysup( TgtPos:=Ybegin, Flags:=0 ); (* Voglio tornare indietro se non fattibile *)
                Status := CARSTS_SRCH_FLY_END;
            ELSE
                dlog( Txt:='fbCarriages: SRCH_FLY: ! Discarding %ld mm', Lvl:=3, Val1:=Probe1.LastRiseLatch/1E3 );
            END_IF;
        ELSIF MoveBoth<MV_WAITSTOP THEN
            (* Ehm, arrivato a destinazione senza catture! *)
            (* IF try_count>3 THEN *)
            dlog( Txt:='fbCarriages: !! Arrived to %ld without latches (Probe1.Status=%d)', Lvl:=1, Val1:=Ysup.CurrPos/1E3, Val2:=TO_DINT(Probe1.Status));
            SET_MSG(MSG_SEARCHERROR,'MSG_SEARCHERROR',0);
            Status := STS_ERROR;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_FLY_END : (* Attendo arrivo in posizione di inizio lavorazione *)
        IF MoveBoth<MV_WAITSTOP THEN
            (* Movimento terminato *)
            IF MoveBoth=MV_DONE THEN
                (* Carrelli in quota di inizio lavorazione *)

                (* Ho già catturato il bordo finale? *)
                IF edge_latch<>NO_POS_UM THEN
                    (* Memorizzo il bordo misurato *)
                    IF Probe2.Back THEN vqY_BtmEdge := edge_latch;
                    ELSE                vqY_TopEdge := edge_latch; END_IF;

                    (* Ora ho entrambi i bordi del vetro! *)
                    vqCut_Length := vqY_TopEdge - vqY_BtmEdge;
                    dlog( Txt:='fbCarriages: Fly-Measured %ld-%ld=%ld mm', Lvl:=2, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqCut_Length/1E3 );
                    (* Le sonde non servono più *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );

                    (* Controllo misura *)
                    IF vqCut_Length<=0 THEN
                        dlog( Txt:='!!Bad measure', Lvl:=1);
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;

                    (* - Calcolo la quota finale della lavorazione - *)
                    (* Incisione avanti *)
                    IF vnCarriages_Cmd=CARCMD_SCORE_FWD THEN
                        Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                    (* Incisione indietro *)
                    ELSIF vnCarriages_Cmd=CARCMD_SCORE_BCK THEN
                        Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                        vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                    ELSE (* Should never be here! *)
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;
                ELSE
                    (* Non ho ancora rilevato il bordo finale *)

                    (* - Decido la quota finale della lavorazione - *)
                    (* Incisione avanti *)
                    IF vnCarriages_Cmd=CARCMD_SCORE_FWD THEN
                        IF vbEdgeDet_AutoFlyUseDim AND vbAutoMode THEN
                            Yend := MAX(vqY_BtmEdge, (vqY_BtmEdge+vqSubSheet_ProcHeight) - (vqTscore_TopMargin+vqMod_Tscore_TopMargin));
                        ELSE
                            Yend := vqYmax;
                        END_IF;
                    (* Incisione indietro *)
                    ELSIF vnCarriages_Cmd=CARCMD_SCORE_BCK THEN
                        IF vbEdgeDet_AutoFlyUseDim AND vbAutoMode THEN
                            Yend := MIN(vqY_TopEdge, (vqY_TopEdge-vqSubSheet_ProcHeight) + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin));
                        ELSE
                            Yend := vqYmin;
                        END_IF;
                    ELSE (* Should never be here! *)
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;

                    (* Se non ci sono sonde sul vetro il bordo finale non potrà essere rilevato:
                       meglio dare errore, ci penserà il chiamante a gestire la cosa *)
                    IF (NOT Probe1.Input AND NOT vbFeat_HasProbeSup2) OR (NOT Probe2.Input AND vbFeat_HasProbeSup2) THEN
                        dlog( Txt:='fbCarriages: !! No probes on glass at %ld mm', Lvl:=2, Val1:=Ysup.CurrPos/1E3 );
                        SET_MSG(MSG_SEARCHERROR,'MSG_SEARCHERROR',0);
                        Ysup.Cmd := AXC_STOP_ENAB; (* Stop the movement *)
                        Status := STS_ERROR;
                        RETURN;
                    END_IF;
                END_IF;
                dlog( Txt:='fbCarriages: Fly range %ld|%ld mm', Lvl:=3, Val1:=Ybegin/1E3, Val2:=Yend/1E3 );

                (* - Attivo utensili - *)
                (* IF vnCarriages_Cmd=CARCMD_SCORE_FWD OR vnCarriages_Cmd=CARCMD_SCORE_BCK THEN *)
                (* Assumo incisione: *)
                vqTinf_P := vqF_score_inf + vqMod_F_score_inf;
                vqMod_F_score_inf := 0; (* Reset modificatore temporaneo *)
                vqTsup_P := vqF_score_sup + vqMod_F_score_sup;
                vqMod_F_score_sup := 0; (* Reset modificatore temporaneo *)
                vbTinf_Cmd := TRUE; (* vnT_Mask & 1 *)
                vbTsup_Cmd := TRUE; (* vnT_Mask & 2 *)
                Status := CARSTS_SCORE_INIT;
            ELSE
                dlog( Txt:='fbCarriages: !! ChgTgt to Ybegin=%ld failed', Lvl:=1, Val1:=Ybegin/1E3 );
                Status := STS_ERROR;
            END_IF;
        ELSE
            (* Movimento in corso *)
            (* Se devo ancora catturare il bordo finale... *)
            IF edge_latch=NO_POS_UM THEN
                (* ...Controllo se per caso lo leggo durante il riposizionamento! *)
                (* Sonda primaria *)
                Probe1();
                IF Probe1.NewFallLatch AND (Ysup.CurrSpd<0)=Probe1.Back THEN
                    dlog( Txt:='fbCarriages: Probe1 fall at %ld mm', Lvl:=4, Val1:=Probe1.LastFallLatch/1E3 );
                    edge_latch := Probe1.LastFallLatch;
                    (* Le sonde non servono più, prendo per buono il primo ed ignoro i successivi (più sicuro) *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;
                (* Sonda secondaria *)
                Probe2();
                IF Probe2.NewFallLatch AND (Ysup.CurrSpd<0)=Probe2.Back THEN
                    dlog( Txt:='fbCarriages: Probe2 fall at %ld mm', Lvl:=4, Val1:=Probe2.LastFallLatch/1E3 );
                    edge_latch := Probe2.LastFallLatch;
                    (* Le sonde non servono più, prendo per buono il primo ed ignoro i successivi (più sicuro) *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SCORE_INIT : (* Attesa inizio incisione: testine e inseguimento *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Assicuro comando attivazione testine di taglio *)
        ELSIF NOT vbTsup_Cmd OR NOT vbTinf_Cmd THEN
            vbTsup_Cmd := NOT Tsup.Wait; (* vnT_Mask & 2 *)
            vbTinf_Cmd := vbTsup_Cmd; (* vnT_Mask & 1 *)
        (* Attendo requisiti *)
        ELSIF (vn[ivnStatus+ID_HOLDPADS]=TS_ON OR vnHoldPads_Cmd=0) AND (* Tamponi pronti se richiesti *)
              (vb[ivbAtRest+ID_CLAMP_ALGN] OR vn[ivnStatus+ID_CLAMP_ALGN]>=CL_DOWN) AND (* Premilastra stabili *)
              (vb[ivbAtRest+ID_CLAMP_DTCH] OR vn[ivnStatus+ID_CLAMP_DTCH]>=CL_DOWN) AND
              Tsup.Status=TS_ON AND Tinf.Status=TS_ON AND (* Testine taglio pronte *)
              Yinf.Status=AXS_MOVING_FOL THEN (* Carrello slave in inseguimento *)
            (* Pronto per incidere, comando movimento master *)
            vqCarrSup_Tgt := Yend; (* [um] *)
            Ysup.TgtSpd := vqV_score; (* [um/min] *)
            Ysup.AccPerc := 100; (* max [%] *)
            Ysup.DecPerc := 100; (* max [%] *)
            Ysup.OutFrc := vqTscore_ScoreYforce; (* [mN] *)
            Ysup.MaxPosErr := WTR_DEFAULT;
            MoveBoth := MV_TOOLMOVE;
            Status := CARSTS_SCORE;
            (* Se ancora non conosco il bordo finale... *)
            (* IF (Ybegin<Yend AND vqY_TopEdge=NO_POS_UM) OR (Ybegin>Yend AND vqY_BtmEdge=NO_POS_UM) THEN *)
            IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                (* ...Assicuro sonde pronte e resettate *)
                Probe1( Activate:=TRUE, Reset:=TRUE );
                Probe2( Activate:=TRUE, Reset:=TRUE );
                (* Assicuro decelerazione necessaria alla riuscita del cambio target
                delta := fnRampSpace(V:=Ysup.TgtSpd, ta:=vq[ivqAx_DecTime+AX_YSUP-1], p:=50);
                IF delta >= ABS(vq[ivqProbe_DY+IRQ_PROBESUP2]) THEN
                    Ysup.DecPerc := vnCarr_ChgTgtDec;
                    dlog( Txt:='fbCarriages: ! DecPerc=%d%% to stop in %ld > %ld mm', Lvl:=1, Val1:=TO_DINT(Ysup.DecPerc), Val2:=delta/1E3, Val3:=vq[ivqProbe_DY+IRQ_PROBESUP2]/1E3 );
                END_IF; *)
            Ysup.DecPerc := vnCarr_ChgTgtDec;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SCORE : (* Movimento incisione *)
        IF MoveBoth<MV_WAITSTOP THEN (* Movimento terminato *)
            vbTinf_Cmd := FALSE;
            vbTsup_Cmd := FALSE;
            (* vbLubScore_Cmd := FALSE; *)
            Status := CARSTS_SCORE_END;
        (* Se qualcosa va storto nel movimento, tira via subito gli utensili *)
        ELSIF vbCarr_ToolsOffOnErr AND Ysup.Status=AXS_STOPPING AND NOT Ysup.Arrived AND vbTsup_Cmd THEN
            dlog( Txt:='fbCarriages: !! Tscore off on stop', Lvl:=2 );
            vbTinf_Cmd := FALSE;
            vbTsup_Cmd := FALSE;
        (* Supporto ricerca al volo: se ancora non so dov'è il bordo
           finale, cambio target al fronte di discesa delle sonde *)
        ELSIF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
            Probe1(); (* Sonda principale *)
            Probe2(); (* Eventuale sonda aggiuntiva per il bordo finale, 'vbFeat_HasProbeSup2' *)
            (* Se ricerca al volo almeno una sonda dovrebbe essere attiva! *)
            IF Probe1.Status<PS_WAITMOVE AND Probe2.Status<PS_WAITMOVE THEN
                dlog( Txt:='fbCarriages: !! No probes', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;

            (* Stay ready for the change target to glass end edge *)
            IF Probe2.NewFallLatch THEN (* => Probe2.LastFallLatch *)
                edge_latch := Probe2.LastFallLatch;
            ELSIF Probe1.NewFallLatch THEN (* => Probe1.LastFallLatch *)
                edge_latch := Probe1.LastFallLatch;
            ELSE
                edge_latch := NO_POS_UM; (* Sfruttato per segnalare un nuovo fronte di discesa *)
            END_IF;
            IF edge_latch<>NO_POS_UM THEN
                (* Rilevato un nuovo fronte di discesa da non ignorare *)
                (* dlog( Txt:='fbCarriages: Fall at %ld', Lvl:=4, Val1:=edge_latch/1E3 ); *)
                (* Store the measured edge and calculate the true Yend *)
                IF Ybegin<Yend THEN (* Incisione avanti *)
                    vqY_TopEdge := edge_latch;
                    Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_TopMargin := 0; (* Reset modificatore temporaneo *)
                ELSE (* Incisione indietro *)
                    vqY_BtmEdge := edge_latch;
                    Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                    vqMod_Tscore_BtmMargin := 0; (* Reset modificatore temporaneo *)
                END_IF;
                vqCut_Length := vqY_TopEdge - vqY_BtmEdge;
                dlog( Txt:='fbCarriages: Fly-Measured %ld-%ld=%ld mm (score to %ld)', Lvl:=2, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3, Val3:=vqCut_Length/1E3, Val4:=Yend/1E3 );
                (* Le sonde non servono più *)
                Probe1( Activate:=FALSE );
                Probe2( Activate:=FALSE );

                (* Controllo misura *)
                IF vqCut_Length<=0 THEN
                    dlog( Txt:='!!Bad measure', Lvl:=1);
                    Status := STS_ERROR;
                    RETURN;
                END_IF;

                (* Cambio target su bordo finale: In automatico è meno importante perché ho un'altezza teorica *)
                IF Ysup.PosPhase<>AFS_POS_DEC OR NOT vbAutoMode THEN
                    Ysup( TgtPos:=Yend, Flags:=AXCB_STRICT );
                ELSE
                    dlog( Txt:='fbCarriages: !! Ysup already decel to %ld (%ld)', Lvl:=2, Val1:=Ysup.TgtPos/1E3, Val1:=Yend/1E3 );
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SCORE_END : (* Finalizzazione incisione *)
        vbTinf_Cmd := FALSE;
        vbTsup_Cmd := FALSE;
        IF Tinf.Status=TS_OFF AND Tsup.Status=TS_OFF THEN
            IF MoveBoth=MV_DONE THEN
                dlog( Txt:='fbCarriages: Score done', Lvl:=3 );

                (* Se il bordo finale non è ancora stato rilevato
                   probabilmente si è trattato di una preincisione molto interna,
                   forse è meglio dare un valore a 'vqCut_Length'? *)
                IF vbAutoMode AND vqCut_Length<=0 THEN
                    vqCut_Length := vqSubSheet_ProcHeight;
                    (* Assicuro di resettare lo stato delle sonde *)
                    Probe1( Activate:=FALSE );
                    Probe2( Activate:=FALSE );
                END_IF;

                vnCarriages_Cmd := CMD_STOP;
                vnCarriages_Seq := SEQ_DONE;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbCarriages: !! Score Error', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_OPEN_INIT : (* Attesa inizio apertura con rotelle: discesa e inseguimento *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Assicuro comando attivazione rotelle di apertura *)
        ELSIF NOT vbRsup_Cmd OR NOT vbRinf_Cmd THEN
            vbRsup_Cmd := NOT Rsup.Wait;
            vbRinf_Cmd := vbRsup_Cmd;
        (* Attendo requisiti *)
        ELSIF (vb[ivbAtRest+ID_CLAMP_ALGN] OR vn[ivnStatus+ID_CLAMP_ALGN]>=CL_DOWN) AND (* Premilastra stabili *)
              (vb[ivbAtRest+ID_CLAMP_DTCH] OR vn[ivnStatus+ID_CLAMP_DTCH]>=CL_DOWN) AND
              Rsup.Status=TS_ON AND Rinf.Status=TS_ON AND (* Rotelle apertura pronte *)
              Yinf.Status=AXS_MOVING_FOL THEN (* Carrello slave in inseguimento *)
            (* Pronto per passata rotelle, comando movimento master *)
            (* vqCarrSup_Tgt := Yend; (* [um] *)
            Ysup.TgtSpd := vqV_brkwhl_trim; (* [um/min] *)
            Ysup.AccPerc := 100; (* max [%] *)
            Ysup.DecPerc := 100; (* max [%] *)
            Ysup.OutFrc := vqRbrk_OpenYforce; (* [mN] *)
            Ysup.MaxPosErr := WTR_DEFAULT;
            MoveBoth := MV_TOOLMOVE;
            Status := CARSTS_OPEN;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_OPEN : (* Movimento apertura con rotelle *)
        IF MoveBoth<MV_WAITSTOP THEN (* Movimento terminato *)
            (* Vediamo se devo completare l'apertura *)
            IF vqCarrSup_Tgt=Yend THEN
                (* Ho aperto fino al bordo finale, passata fatta *)
                (* Vediamo se devo fare una seconda passata *)
                IF vbRbrk_DoublePass THEN
                    vbRbrk_DoublePass := FALSE; (* First pass done *)
                    (* Scambio quote di inizio e fine *)
                    Yend := Ybegin;
                    Ybegin := vqCarrSup_Tgt;
                    (* Toggle wheels and c-wheels *)
                    IF NOT vbRsup_SelC THEN
                        vbRinf_SelC := FALSE; (* wheel *)
                        vbRinf_Cmd := TRUE;
                        vqRinf_P := vqF_brkwhl_inf_trim;
                        vbRsup_SelC := TRUE; (* c-wheel *)
                        vbRsup_Cmd:= TRUE;
                        vqRsup_P := vqRinf_P; (* pressione controrotella sup *)
                    ELSE
                        vbRsup_SelC := FALSE; (* wheel *)
                        vbRsup_Cmd:= TRUE;
                        vqRsup_P := vqF_brkwhl_sup_trim;
                        vbRinf_SelC := TRUE; (* c-wheel *)
                        vbRinf_Cmd := TRUE;
                        vqRinf_P := vqRsup_P; (* pressione controrotella inf *)
                    END_IF;
                    (* Ora torno indietro, apro fino alla quota finale *)
                    dlog( Txt:='fbCarriages: Opening trim second pass', Lvl:=5 );
                    Yinf.Cmd := AXC_START_FOL;
                    vqCarrSup_Tgt := Yend;
                    Status := CARSTS_OPEN_INIT;
                ELSE
                    (* Passes done *)
                    vbRinf_Cmd := FALSE;
                    vbRsup_Cmd := FALSE;
                    Status := CARSTS_OPEN_END;
                END_IF;
            ELSE
                (* Devo ancora arrivare al bordo finale, proseguo *)
                dlog( Txt:='fbCarriages: Prosecuting opening first pass', Lvl:=5 );
                Yinf.Cmd := AXC_START_FOL;
                vqCarrSup_Tgt := Yend;
                Status := CARSTS_OPEN_INIT;
            END_IF;
        (* Se qualcosa va storto nel movimento, tira via subito gli utensili * )
        ELSIF vbCarr_ToolsOffOnErr AND Ysup.Status=AXS_STOPPING AND NOT Ysup.Arrived AND vbRsup_Cmd THEN
            dlog( Txt:='fbCarriages: !! Rbrk off on stop', Lvl:=2 );
            vbRinf_Cmd := FALSE;
            vbRsup_Cmd := FALSE;
        (* ELSE (* Wait move *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_OPEN_END : (* Finalizzazione apertura con rotelle *)
        IF Rinf.Status=TS_OFF AND Rsup.Status=TS_OFF THEN
            (* Tolgo la contro-rotella *)
            vbRinf_SelC := FALSE;
            vbRsup_SelC := FALSE;

            IF MoveBoth=MV_DONE THEN
                dlog( Txt:='fbCarriages: Open Done', Lvl:=3 );
                vnCarriages_Cmd := CMD_STOP;
                vnCarriages_Seq := SEQ_DONE;
                Status := STS_IDLE;
            ELSE
                dlog( Txt:='fbCarriages: !! Open Error', Lvl:=1 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_SWEEP : (* Attesa sequenza 1 carrello superiore *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            vnCarrSup_Cmd := CMD_STOP;
            Status := STS_ERROR;
        ELSIF vnCarrSup_Cmd=CMD_STOP THEN
            (* La sequenza è finita, vediamo il risultato *)
            IF vnCarrSup_Seq=SEQ_DONE THEN
                (* Ok, misura pronta in vqY_BtmEdge,vqY_TopEdge *)
                IF vnCarriages_Cmd=CARCMD_GRAB THEN
                    (* Acquisisco misura *)
                    vqGrab_GlassYbtm := vqY_BtmEdge;
                    vqGrab_GlassYtop := vqY_TopEdge;
                END_IF;
                (* Ora mando CarrSup in parcheggio *)
                vnCarrSup_Cmd := CMD_PARK;
                Status := CARSTS_SRCH_END;
            ELSE
                dlog( Txt:='fbCarriages: !! Sweep error', Lvl:=2 );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_SRCH_END : (* Attesa parcheggio carrello superiore *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            vnCarrSup_Cmd := CMD_STOP;
            Status := STS_ERROR;
        ELSIF vnCarrSup_Cmd=CMD_STOP THEN
            (* La sequenza è finita, vediamo il risultato *)
            IF vnCarrSup_Seq<>SEQ_DONE THEN
                dlog( Txt:='fbCarriages: !! Search error', Lvl:=2 );
                Status := STS_ERROR;
            ELSE
                (* Ok, finito *)
                Status := STS_IDLE; (* Proseguo col comando che avevo in pancia *)
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_TRAIL_LOCK : (* Agganciando/sganciando traino passivo inferiore *)
        IF vnCarrInf_Cmd=CMD_STOP THEN (* Done *)
            (* Se è andato tutto bene proseguo col comando che avevo in pancia *)
            Status := SEL(vnCarrInf_Seq=SEQ_DONE, STS_ERROR, STS_IDLE);
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRAB_INIT : (* Preparazione rotazione con pinza *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Se l'utensile è su traino e non è agganciato, errore! *)
        ELSIF vbGrabber_NotLocked THEN
            dlog( Txt:='fbCarriages: !! Trail not locked for Grabber', Lvl:=1 );
            Status := STS_ERROR;
        (* Controllo invasione tavolo di carico non accessibile *)
        ELSIF vqRot_Xmin<vqFeed_Xend AND NOT vbFeed_Accessible THEN
            dlog( Txt:='fbCarriages: !! Cannot invade feed (%ld<%ld)', Lvl:=2, Val1:=vqRot_Xmin/1E3, Val2:=vqFeed_Xend/1E3 );
            SET_MSG(MSG_FEED_NOT_READY,'MSG_FEED_NOT_READY',0);
            Status := STS_ERROR;
        (* Prima di invadere col carrello la zona taglio attendo stacco in park e,
           nel caso di rotazione sui riscontri, fotocellula fine stacco liberata *)
        ELSIF vb[ivbAtRest+ID_DTCH] AND (vnGrab_RotType<>1 OR NOT fcDtchLast.q) THEN
            (* Procedo a vedere come e dove aprire e orientare la pinza *)
            (* Nota: La lettura di IFC_DTCH_LAST non è attendibile se:
                     (vqGrab_GlassYtop-vqGrab_GlassYbtm) < vqYph_DtchLast
                     ma ho già controllato che sia così *)
            (* Determinazione manovra di apertura pinza in base all'angolo di presa *)
            IF vqGrab_Agrab=0 THEN
                (*      +-----+
                        |  // |
                       -D--   |
                        |  // |
                        +-----+  ---> x   *)
                dlog( Txt:='fbCarriages: Grab on algn y=%ld=%ld+%ld mm', Lvl:=3, Val1:=vqGrab_Ygrab/1E3, Val2:=(vqGrab_Ygrab-vqGrab_GlassYbtm)/1E3, Val3:=vqGrab_GlassYbtm/1E3 );
                (* Qui decido dove devo alzare ed aprire la pinza *)
                Zg.TgtPos := 0; (* Orientazione preferita di apertura [mdeg] *)
                (* Comando il movimento verso posizione di apertura *)
                (* Potrei andare verso la posizione più vicina: *)
                (* YgrabOC := SEL( ABS(Yinf.CurrPos-vqYinf_GrabBtmPos) < ABS(Yinf.CurrPos-vqYinf_GrabTopPos), vqYinf_GrabTopPos, vqYinf_GrabBtmPos ); *)
                (* YgrabOC := SEL( ABS(Yinf.CurrPos<0 AND vbGrab_CanOpenDown, vqYinf_GrabTopPos, vqYinf_GrabBtmPos ); *)
                (* Poiché in genere il sensore per la prevenzione collisioni con
                   vetro è montato in basso, quindi funziona andando indietro,
                   è preferibile aprire a quote alte per sfruttarlo *)
                YgrabOC := vqYinf_GrabTopPos;
                (* Se la pinza é già giù è una vera perdita di tempo, però questo accade solo
                   con rotazioni lastra in arrivo, per le quali posso parcheggiare il carrello
                   inferiore mentre la lastra viene traslata *)
                Status := CARSTS_GRAB_OPEN;

            ELSIF ABS(vqGrab_Agrab)=180E3 THEN
                (*  +-----+
                    | //  |
                    |   --O-
                    | //  |
                    +-----+ ---> x    *)
                dlog( Txt:='fbCarriages: Grab on dtch y=%ld=%ld+%ld mm', Lvl:=3, Val1:=vqGrab_Ygrab/1E3, Val2:=(vqGrab_Ygrab-vqGrab_GlassYbtm)/1E3, Val3:=vqGrab_GlassYbtm/1E3 );
                Zg.TgtPos := 180E3; (* Orientazione preferita di apertura [mdeg] *)
                (* In genere non ho sensori di controllo, quindi vado ad aprire dove sono più vicino *)
                YgrabOC := SEL( ABS(Yinf.CurrPos-vqYinf_GrabBtmPos) < ABS(Yinf.CurrPos-vqYinf_GrabTopPos), vqYinf_GrabTopPos, vqYinf_GrabBtmPos );
                Status := CARSTS_GRAB_OPEN;

            ELSIF vqGrab_Agrab>0 AND vqGrab_Agrab<90E3 THEN
                (*    __.--''\
                    ''    //  \
                     \| .      \
                    _.O'        \
                      |\    //   \
                      | \   __..--
                      |  --'
                      +---> x        *)
                dlog( Txt:='fbCarriages: Grab btm algn Yg=%ld mm Ao=%ld deg', Lvl:=3, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_Agrab/1E3);
                Zg.TgtPos := -90E3; (* Orientazione preferita di apertura [mdeg] *)
                YgrabOC := vqYinf_GrabBtmPos;
                Status := CARSTS_GRAB_OPEN;

            ELSIF vqGrab_Agrab=90E3 THEN
                (*  +-------+
                    | //    |
                    |   ^   |
                    |   |   |
                    +---O---+
                        +-----> x  *)
                dlog( Txt:='fbCarriages: Grab btm y=%ld mm a=90 deg', Lvl:=3, Val1:=vqGrab_Ygrab/1E3 );
                Zg.TgtPos := -90E3; (* Orientazione preferita di apertura [mdeg] *)
                YgrabOC := vqYinf_GrabBtmPos;
                Status := CARSTS_GRAB_OPEN;

            ELSIF vqGrab_Agrab>90E3 AND vqGrab_Agrab<180E3 THEN
                (*  /'.._
                   /     ``-.
                  /  //   ^ /
                 /      _ |/
                /        'O._
                `-.  //  /|
                   `-._ / |
                          +---> x    *)
                dlog( Txt:='fbCarriages: Grab btm dtch Yg=%ld mm Ao=%ld deg', Lvl:=3, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_Agrab/1E3);
                Zg.TgtPos := -90E3; (* Orientazione preferita di apertura [mdeg] *)
                YgrabOC := vqYinf_GrabBtmPos;
                Status := CARSTS_GRAB_OPEN;

            ELSIF vqGrab_Agrab<0 AND vqGrab_Agrab>-90E3 THEN
                (* ^ /'.._
                 _ |/  // ``-.
                  'O._       /
                  /|        /
                 / |       /
                 `-.  //  /
                   |`-._ /
                   +-------> x     *)
                dlog( Txt:='fbCarriages: Grab top algn Yg=%ld mm Ao=%ld deg', Lvl:=3, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_Agrab/1E3);
                Zg.TgtPos := 90E3; (* Orientazione preferita di apertura [mdeg] *)
                YgrabOC := vqYinf_GrabTopPos;
                Status := CARSTS_GRAB_OPEN;

            ELSIF vqGrab_Agrab=-90E3 THEN
                (*   +---O---+
                     |   |   |
                     |       |
                     | //    |
                     |       |
                     +-------+  ---> x  *)
                dlog( Txt:='fbCarriages: Grab top y=%ld mm a=-90 deg', Lvl:=3, Val1:=vqGrab_Ygrab/1E3 );
                Zg.TgtPos := 90E3; (* Orientazione preferita di apertura [mdeg] *)
                YgrabOC := vqYinf_GrabTopPos;
                Status := CARSTS_GRAB_OPEN;

            ELSIF vqGrab_Agrab<-90E3 AND vqGrab_Agrab>-180E3 THEN
                (*   __.--''\ ^
                   ''        \| _
                    \  //   _.O'
                     \        |\
                      \   //  | \
                       \   __..--
                        --'   +----> x    *)
                dlog( Txt:='fbCarriages: Grab top dtch Yg=%ld mm Ao=%ld deg', Lvl:=3, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_Agrab/1E3);
                Zg.TgtPos := 90E3; (* Orientazione preferita di apertura [mdeg] *)
                YgrabOC := vqYinf_GrabTopPos;
                Status := CARSTS_GRAB_OPEN;

            ELSE (* Situazione non gestita *)
                dlog( Txt:='fbCarriages: !! Grab Yg=%ld mm Ao=%ld deg', Lvl:=1, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_Agrab/1E3);
                Status := STS_ERROR;
            END_IF; (* Scelta del punto di apertura pinza *)

            (* Se devo procedere ad aprire la pinza... *)
            IF Status=CARSTS_GRAB_OPEN THEN

                (* Controllo lo stato pinza (mi aspetto sia chiusa) *)
                IF Grabber.Status=GSTS_CLOSED THEN
                    dlog( Txt:='fbCarriages: Go to open grabber at Y=%ld', Lvl:=5, Val1:=YgrabOC/1E3 );

                    (* Oriento la pinza all'angolo di apertura *)
                    Zg.TgtSpd := 0; (* max *)
                    Zg.AccPerc := 100; (* max [%] *)
                    Zg.DecPerc := 100; (* max [%] *)
                    Zg.OutFrc := 0; (* just move [mN] *)
                    Zg.MaxPosErr := WTR_HITDET;
                    (* Ho una orientazione preferita di apertura a seconda di dove apro? No, già decisa prima *)
                    (* Zg.TgtPos := SEL( YgrabOC=vqYinf_GrabBtmPos, -90E3, 90E3 ); *)
                    Zg.Cmd := AXC_START_POS;

                    vnGrabber_Cmd := GCMD_PREPARE; (* Comincio ad attivare l'attuazione *)

                    (* Comando il movimento libero verso quota di apertura *)
                    vqCarrInf_Tgt := YgrabOC;
                    vnCarrInf_Cmd := CMD_MOVETO;

                ELSIF Grabber.Status=GSTS_OPENED
                      AND ABS(Zg.CurrPos-vqGrab_Agrab)<=Zg.InPosDelta
                      AND ABS(Yinf.CurrPos-YgrabOC)<10E3 THEN
                    (* Se la pinza è già aperta e nella posizione attesa procedo *)
                    dlog( Txt:='fbCarriages: ! Grabber already up', Lvl:=4 );
                    Status := CARSTS_GRAB_GRABINI;
                ELSE
                    (* Se la pinza non è chiusa meglio non andare in giro a caso *)
                    dlog( Txt:='fbCarriages: !! Grabber not closed (%d)', Lvl:=1, Val1:=TO_DINT(Grabber.Status) );
                    Status := STS_ERROR;
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRAB_OPEN : (* Salita e apertura pinza *)
        (* Attendi arrivo in posizione di apertura, poi alza e apri pinza *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnCarrInf_Cmd=CMD_STOP THEN
            (* Movimento carrello inferiore terminato, vediamo il risultato *)
            IF vnCarrInf_Seq<>SEQ_DONE THEN
                dlog( Txt:='fbCarriages: !! Cant go to grabber open pos %ld mm', Lvl:=1, Val1:=Yinf.TgtPos/1E3 );
                Status := STS_ERROR;
            ELSIF Zg.Status=AXS_READY THEN
                (* Ok, arrivato alla posizione di apertura e orientato *)
                ProbeInf( Activate:=TRUE, ProbeIdx:=IRQ_PROBEINF, AxIdx:=AX_YINF, SweepMode:=TRUE );
                (* Oriento la pinza all'angolo di presa... *)
                Zg.TgtSpd := 0; (* max *)
                Zg.AccPerc := 100; (* max [%] *)
                Zg.DecPerc := 100; (* max [%] *)
                Zg.OutFrc := 0; (* just move [mN] *)
                Zg.MaxPosErr := WTR_HITDET;
                Zg.TgtPos := vqGrab_Agrab; (* [mdeg] *)
                Zg.Cmd := AXC_START_POS;
                (* ...E comando salita e apertura pinza *)
                vnGrabber_Cmd := GCMD_OPEN;
                Status := CARSTS_GRAB_GRABINI;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRAB_GRABINI : (* Preparazione movimento per presa pinza *)
        (* Attendi pinza alta, aperta e orientata, poi vai in posizione di presa *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Zg.Cmd := AXC_STOP_ENAB;
            Status := STS_ERROR;
        ELSIF vnGrabber_Cmd=GCMD_NONE AND Zg.Status<=AXS_READY THEN
            IF Grabber.Status<>GSTS_OPENED THEN
                dlog( Txt:='fbCarriages: !! Grabber not opened (%d)', Lvl:=1, Val1:=TO_DINT(Grabber.Status) );
                Status := STS_ERROR;
            ELSIF Zg.Arrived THEN
                (* Dichiaro subito rotazione in corso (importante per avviare il calcolo camme in 'AxRefs') *)
                (* ASSERT(vnGrab_RotType<>0,'(!!) No rotation type') *)
                vnGrab_RotStatus := vnGrab_RotType;
                (* ! Occhio, da qui devo aspettare un ciclo PLC per avere pronti i riferimenti di posizione 'ivdYinf_PosRef',... *)
                (* Dò una controllata alla zona fine linea? *)
                IF vbAutoMode THEN
                    IF vnGrab_RotType=1 THEN
                        (* Rotazione riscontro, assumo bordo avanti lastra in 'vqGrab_GlassWidth' *)
                        OutZone.XcheckIfBusy := vqGrab_GlassWidth;
                    ELSE
                        (* Assumo bordo avanti lastra in zero? *)
                        OutZone.XcheckIfBusy := 0;
                    END_IF;
                    (* Tra un ciclo PLC sono pronti 'Xbusy' e 'Free' *)
                END_IF;

                (* Procedo e vado in posizione di presa *)
                vqCarrInf_Tgt := vqGrab_Ygrab - vqGrabber_DY; (* == vd[ivdYinf_PosRef] *)
                ProbeInf.Back := vqCarrInf_Tgt < Yinf.CurrPos;
                edge_latch := NO_POS_UM;
                vnCarrInf_Cmd := CMD_MOVETO; (* Poiché pinza alta andrà a vqCarr_SafeSpd *)
                Status := CARSTS_GRAB_GRAB;
            ELSE
                (* dlog( Txt:='fbCarriages: !! Grabber orient err Zg=%ld<>%ld deg', Lvl:=1, Val1:=Zg.CurrPos/1E3, Val2:=Zg.TgtPos/1E3 ); *)
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRAB_GRAB : (* Agguantamento del vetro *)
        (* Attendi arrivo in posizione di presa, poi agguanta e prepara il trascinamento *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnCarrInf_Cmd=CMD_STOP THEN
            (* Movimento carrello inferiore terminato, vediamo il risultato *)
            IF vnCarrInf_Seq<>SEQ_DONE THEN
                dlog( Txt:='fbCarriages: !! Unable to reach grab pos %ld mm', Lvl:=1, Val1:=Yinf.TgtPos/1E3 );
                Status := STS_ERROR;
            (* Se a questo punto mi trovo ancora i piedini di riscontro alti, mi arrabbio *)
            ELSIF vnAlgnBlocks_Sts<>TS_OFF THEN
                dlog( Txt:='fbCarriages: !! Rot abort for align blocks still high', Lvl:=1 );
                Status := STS_ERROR;
            (* Se devo fare una rotazione prodotto con piedino... *)
            ELSIF vnGrab_RotType=1 AND vbGrab_RotWithBlock AND (vn[ivnStatus+ID_ALGN]<>STS_IDLE OR vnAlgn_Cmd<>CMD_STOP) THEN
                (* ...Attendo eventuale preposizionamento riscontri *)
            (* Se ci sono richieste in corso... *)
            ELSIF IS_MSG(REQ_TAKE_PROD) OR IS_MSG(REQ_DUMP_PROD) OR
                  IS_MSG(REQ_TAKE_REMN) OR IS_MSG(REQ_DUMP_REMN) OR
                  IS_MSG(REQ_BACK_REMN) OR IS_MSG(REQ_STACK_REMN) THEN
                (* ...Attendi che l'operatore le resetti *)
                (* Probabilmente l'operatore deve entrare in zona sicurezza per
                   prendere il vetro *)
                IF vnClampAlgn_Type=1 THEN
                    (* Se i premilastra sono pneumatici è bene alzarli altrimenti
                       la centralina di sicurezza lancerà una emergenza! *)
                    vnClampAlgn_Cmd := CMD_STOP;
                END_IF;
                (* vnClampDtch_Cmd := CMD_STOP; *)
            (* Attendo che si liberi la zona a fine linea se coinvolta
              (subito, per non bloccare la pinza) *)
            ELSIF NOT OutZone.Free AND vqRot_Xmax>=OutZone.Xbusy THEN
                IF NOT IS_MSG(REQ_FREE_OUTZONE) THEN
                    dlog( Txt:='fbCarriages: Grab waits out zone Xmax=%ld > %ld mm', Lvl:=4, Val1:=vqRot_Xmax/1E3, Val2:=OutZone.Xbusy/1E3 );
                    SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',0); (* Grab rotation *)
                END_IF;
            ELSE
                (* Ok, arrivato alla posizione di presa *)

                (* Preparazione per rotazione riscontro *)
                IF vnGrab_RotType=1 THEN
                    (* !SUPER-ATTENZIONE!
                       I comandi CMD_DRIVEN usano le quote in ivdYinf_PosRef, ivdXr_PosRef,
                       quindi qui deve essere già attivo il calcolo in 'AxRefs' *)

                    (* Aggancio camma elettronica CarrInf *)
                    vnCarrInf_Cmd := CMD_DRIVEN; (* Inf.Status=STS_DRIVEN, Yinf.Status=AXS_MOVING_FOL *)

                    (* Eventuale piedino ausiliario *)
                    IF vbGrab_RotWithBlock THEN
                        (* Prepara il piedino di aiuto rotazione (aggancio vetro e asse elettrico)
                           Questo alzerà il piedino in zona taglio, ma se sono qui ho già aspettato
                           che si liberasse la fotocellula a fine stacco, quindi tutto ok *)
                        IF vnAlgn_Cmd<>CMD_STOP THEN
                            dlog( Txt:='fbCarriages: !! Align not ready for rot (cmd=%d)', Lvl:=1, Val1:=TO_DINT(vnAlgn_Cmd) );
                            Status := STS_ERROR;
                            RETURN;
                        END_IF;
                        vnAlgn_Cmd := CMD_DRIVEN; (* vn[ivnStatus+ID_ALGN]=ALSTS_DRIVEN, vnAlgn_Seq=ALSEQ_LOCKED *)
                    END_IF;
                (* ELSIF vnGrab_RotType=2 THEN (* TODO 3: rotazione stacco *)
                (* ELSE (* TODO 3: rotazione generica *)
                END_IF;

                (* Decido il cuscino aria che mi serve in base all'ingombro rotazione *)
                SelectProdVents( Xfwd:=vqRot_Xmax, Ytop:=vqRot_Ymax );
                SelectRemnVents( Xbck:=vqRot_Xmin );
                RequiredVents := SelectProdVents.Mask OR SelectRemnVents.Mask;

                (* Agguanto il vetro e procedo *)
                vnGrabber_Cmd := GCMD_GRAB;

                (* Vedo se c'è una pre-traslazione da fare *)
                IF vqGrab_Yc_pre<>NO_POS_UM AND ABS(vqGrab_Yc_pre-vqGrabber_DY-Yinf.CurrPos)>200 THEN
                    (* Prima di ruotare trasliamo la lastra agguantata portando pinza a 'vqGrab_Yc_pre' *)
                    dlog( Txt:='fbCarriages: Pre move grabber from Y=%ld to %ld mm', Lvl:=4, Val1:=(Yinf.CurrPos+vqGrabber_DY)/1E3, Val2:=vqGrab_Yc_pre/1E3 );
                    Status := CARSTS_GRAB_DYPREINI;
                ELSE
                    (* Iniziamo a ruotare *)
                    Status := CARSTS_GRAB_ROTZINI;
                END_IF;
            END_IF;
        ELSE
            (* Spostamento per presa in corso *)
            (* -Misura al volo del vetro- *)
            ProbeInf();
            IF vbGrab_OnTheFlySearch AND ProbeInf.NewRiseLatch AND edge_latch=NO_POS_UM THEN
                edge_latch := ProbeInf.LastRiseLatch;
                (* Memorizzo il bordo misurato *)
                IF ProbeInf.Back THEN
                    vqY_TopEdge := edge_latch;
                    vqY_BtmEdge := vqY_TopEdge - (vqGrab_GlassYtop-vqGrab_GlassYbtm);
                ELSE
                    vqY_BtmEdge := edge_latch;
                    vqY_TopEdge := vqY_BtmEdge + (vqGrab_GlassYtop-vqGrab_GlassYbtm);
                END_IF;
                dlog( Txt:='fbCarriages: ! FlyMeas glass: y=%ld-%ld', Lvl:=3, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3 );
                (* Acquisisco misura *)
                vqGrab_GlassYbtm := vqY_BtmEdge;
                vqGrab_GlassYtop := vqY_TopEdge;
                (* Ricalcolo la rotazione *)
                CalcRotAlgn(); (* Nota: Usa ultimo What impostato *)
                IF CalcRotAlgn.Ok THEN
                    vqCarrInf_Tgt := vqGrab_Ygrab - vqGrabber_DY;
                    dlog( Txt:='fbCarriages: ! Change grab tgt: %ld => %ld (%ld)', Lvl:=3, Val1:=Yinf.TgtPos/1E3, Val2:=vqCarrInf_Tgt/1E3, Val3:=Yinf.CurrPos/1E3 );
                    Yinf( TgtPos:=vqCarrInf_Tgt ); (* Cambio target *)
                ELSE
                    (* dlog( Txt:='fbCarriages: !! Rot not Ok', Lvl:=1 ); *)
                    Status := STS_ERROR;
                END_IF;
            END_IF;
            (* -Controllo anticollisione pinza-vetro- *)
            IF Yinf.MovingBck AND Zg.TgtPos=0 AND (Yinf.CurrPos+vq[ivqProbe_DY+IRQ_PROBEINF])>(Yinf.TgtPos+vqGrabber_DY-vqGrabber_Radius) THEN
                (* Se vado indietro con pinza orientata verso riscontro, non ci deve essere vetro lato stacco *)
                IF (vqProbe3_DX<0 AND (vnIrqStatus & SHL(INT#1, IRQ_PROBEINF-1))<>0) OR (* Usa ingresso veloce sonda inferiore per controllo collisioni pinza se sonda montata verso stacco *)
                    IFC_YINF_BCK_DTCH THEN (* !DEPRECATED! Ingresso dedicato *)
                    dlog( Txt:='fbCarriages: !! Coll grab-glass (dtch) y=%ld mm spd=%ld m/min', Lvl:=1, Val1:=(Yinf.CurrPos+vq[ivqProbe_DY+IRQ_PROBEINF])/1E3, Val2:=Yinf.CurrSpd/1E6 );
                    (* ThrowEmg(Idx:=EMG_COLLISION, Txt:='Detected collision grabber-glass on dtch'); *)
                    SET_MSG(MSG_GRABBER_COLL,'MSG_GRABBER_COLL',0);
                    Yinf.Cmd := AXC_STOP_FREE; (* Quickstop *)
                    Status := STS_ERROR;
                END_IF;
            (* ELSIF Yinf.MovingBck AND Zg.TgtPos=180E3 THEN
                ( * Se vado indietro con pinza orientata verso stacco, non ci deve essere vetro lato riscontro * )
                IF IFC_YINF_BCK_ALGN THEN
                    dlog( Txt:='fbCarriages: !! Coll grab-glass (algn) y=%ld mm spd=%ld m/min', Lvl:=1, Val1:=Yinf.CurrPos/1E3, Val2:=Yinf.CurrSpd/1E6 );
                    SET_MSG(MSG_GRABBER_COLL,'MSG_GRABBER_COLL',0);
                    Yinf.Cmd := AXC_STOP_FREE; (* Quickstop
                    Status := STS_ERROR;
                END_IF;
            ELSIF Yinf.MovingFwd AND Zg.TgtPos=0 THEN
            ELSIF Yinf.MovingFwd AND Zg.TgtPos=180E3 THEN *)
            END_IF; (* Controllo anticollisione pinza-vetro *)


            (* Assicuro niente aria in zona premilastra riscontro per evitare che si muova il vetro *)
            vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_ALGN_C;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRAB_ROTZINI : (* Preparazione rotazione lastra agguantata *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Intercetta problemi di agguantamento *)
        ELSIF vnGrabber_Cmd=GCMD_NONE AND Grabber.Status<>GSTS_GRABBED THEN
            dlog( Txt:='fbCarriages: !! GRAB_ROTZINI: Not grabbing (Grabber.Status=%d)', Lvl:=1, Val1:=TO_DINT(Grabber.Status) );
            Status := STS_ERROR;
        (* Avvio l'aria appena sono sicuro che il vetro non scappa *)
        ELSIF (vnVents_Cmd AND RequiredVents)<>RequiredVents (* Non sto dando il comando aria *)
              (* vdRot_Rmax<1000.0 OR vdRot_Mass<30.0 *)
              AND ( (Grabber.ClampStatus>=GSTS_GRABBING AND NOT vbSlantMode) (* La pinza sta agguantando *)
                     OR Grabber.ClampStatus>GSTS_GRABBING) THEN (* Pinza agguantata *)
            vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Dò comando aria *)
        (* Intercetta problemi con l'eventuale piedino ausiliario * )
        ELSIF vnGrab_RotType=1 AND vbGrab_RotWithBlock AND vnAlgn_Cmd<>CMD_DRIVEN THEN
            dlog( Txt:='fbCarriages: !! No rot block', Lvl:=1 );
            Status := STS_ERROR; *)
        (* Attendo che si liberi la zona a fine linea se coinvolta *)
        ELSIF NOT OutZone.Free AND vqRot_Xmax>=OutZone.Xbusy THEN
            IF NOT IS_MSG(REQ_FREE_OUTZONE) THEN
                dlog( Txt:='fbCarriages: Rot waits out zone Xmax=%ld > %ld mm', Lvl:=4, Val1:=vqRot_Xmax/1E3, Val2:=OutZone.Xbusy/1E3 );
                SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',0); (* Grab rotation *)
            END_IF;
        (* Gestisci premilastra basso in caso di pezzo a rischio caduta *)
        ELSIF Grabber.Status>=GSTS_GRABBING AND NOT vb[ivbAtRest+ID_CLAMP_ALGN] THEN
            (* Assicuro premilastra alto, tanto ora tengo io il vetro *)
            vnClampAlgn_Cmd := CMD_STOP;
        (* Attendo precondizioni - TODO 4: separarle con diagnostica? *)
        ELSIF Grabber.Status=GSTS_GRABBED (* Pinza agguantata *)
              AND vbAirCushionReady (* Cuscino aria pronto *)
              AND ((vnGrab_RotType<>1 AND vnGrab_RotType<>2) OR Yinf.Status=AXS_MOVING_FOL) (* Carrello inferiore in inseguimento se uso camma *)
              AND (vnGrab_RotType<>1 OR NOT vbGrab_RotWithBlock OR (vn[ivnStatus+ID_ALGN]=ALSTS_DRIVEN AND vnAlgn_Seq=ALSEQ_LOCKED)) (* Piedino ausiliario per rotazione riscontri *)
              AND (vnGrab_RotType<>1 OR vqRemn_X=NO_POS_UM OR vqRemn_X<vqRot_Xmin ) (* Se rotazione riscontro, rimanenza via *)
              AND (vnGrab_RotType<>2 OR (NOT IS_MSG(REQ_TAKE_PROD) AND NOT IS_MSG(REQ_DUMP_PROD)) ) (* Se rotazione stacco, attendo che sia stato portato via prodotto! *)
              AND (vqRot_Xmax<vqTiltOut_Xo OR NOT IFC_TILTOUT_BLOCKS_OUT) (* Piedini automatici ribaltina bassi se ci devo passare sopra *)
              AND vb[ivbAtRest+ID_BELTS_DTCH] AND vb[ivbAtRest+ID_ROLLS_ALGN] (* Cinghie stacco e rulli bassi *)
              AND (vb[ivbAtRest+ID_BELTS_BUF] OR vqRot_Xmin>=vqDtch_Xbegin) (* Cinghie polmone basse se zona coinvolta *)
              AND vb[ivbAtRest+ID_CLAMP_ALGN] AND vb[ivbAtRest+ID_CLAMP_DTCH] (* Premilastra alti *)
              AND vb[ivbAtRest+ID_HOLDPADS] THEN (* Tamponi alti *)
            (* Lancio la movimentazione del master rotazione pinza *)
            IF Zg.Status=AXS_READY THEN

                (* Calcolo le inerzie della lastra in rotazione *)
                CalcRotData( W:=TO_LREAL(vqGrab_GlassWidth)/1.0E6,
                             H:=TO_LREAL(vqGrab_GlassYtop-vqGrab_GlassYbtm)/1.0E6,
                             D:=TO_LREAL(vqGlass_Thckn)/1.0E6,
                             DXc:=TO_LREAL(MAX(vqGrab_GlassWidth-vqAlgn_Tgt,0))/1.0E6,
                             DYc:=TO_LREAL(vqGrab_Ygrab-vqGrab_GlassYbtm)/1.0E6 );
                (* Calculated: vdRot_Dm, vdRot_Rmax, vdRot_Mass, vdRot_Jgrab *)

                (* -Movimento di rotazione- *)
                (* Per la velocità il criterio è la massima vel dello spigolo più lontano v=r·Ω
                   Ω[mdeg/min] = 180/π · V[μm/min]/d[mm] *)
                ASSERT(vdRot_Rmax > 0.001, '(!!) Rot with null dist max')
                Zg.TgtSpd := TO_DINT( 57.29578E-3 * TO_LREAL(vqGrab_RotVmax) / vdRot_Rmax ); (* [mdeg/min] *)
                (* Assicuro la velocità in un intervallo accettabile,
                   il limite inferiore è importante perché potrebbe essere interpretata come percentuale! *)
                Zg.TgtSpd := LIMIT( IN:=Zg.TgtSpd, MN:=500E3, MX:=vqGrab_RotZSpdMax ); (* ossia tra 5°/s e il massimo *)
                IF vqGrab_RotTorque>vqGrab_SlipTorque THEN vqGrab_RotTorque := vqGrab_SlipTorque; END_IF;

                ASSERT(vdRot_Jgrab > 0.001, '(!!) Rot with null J')
                (* Per l'accelerazione consideriamo l'equazione di moto:
                       Trot = Jd·Ω' + (Kfr + Kv·Ω)·d
                   Limitiamo l'accelerazione in modo che la coppia erogata
                   stia sotto quella di perdita di aderenza ganasce
                   (vqGrab_RotTorque, vqGrab_SlipTorque), v. anche vq[ivqAx_MaxForce+AX_ZG-1] [mN mm/deg]
                   Trascurando gli attriti: Ω' = Trot / Jd
                   Trascurando il profilo parabolico: tacc = Ωmax / Ω'
                   La parzializzazione dell'accelerazione: AccPerc = 100 · tacc_org / tacc
                   Quindi: AccPerc = 100 · tacc_org · Trot / (Jd · Ωmax)
                   Oppure, visto che: Zg.AccMax := TO_LREAL(Zg.SpdMax) / (60.0 * TO_LREAL(vq[ivqAx_AccTime+AX_ZG-1]) );
                   AccPerc = 100 · Ω' / Zg.AccMax = 100 · (Trot/Jd) / Zg.AccMax = 100 · Trot/Tjacc_max
                   Infatti la coppia d'inerzia ad accelerazione 100% è:
                   Tjacc_max = Jd · Ω'max = Jd [Kg m²] · 360 [deg/s²] · pi/180
                   Ωmax=Zg.SpdMax, tacc_org=vq[ivqAx_AccTime+(AX_ZG-1)], tdec_org=vq[ivqAx_DecTime+(AX_ZG-1)] *)
                (*  [%]                             [N mm]                   [Kg m²]      [deg/s²]   *)
                Zg.DecPerc := TO_INT( TO_LREAL(vqGrab_RotTorque) / (10.0 * vdRot_Jgrab * Zg.AccMax * DEG2RAD) ); (* DANGER_DIVISION_BY_ZERO *)
                (* Ad esempio:  200E3 / (10 · 780 · 360 · pi/180) ~= 200E3 / 49000 ~= 4 *)
                IF vbSlantMode THEN Zg.DecPerc := fnPartializeAcc(Zg.DecPerc, vnGrab_SlantAccel); END_IF;
                Zg.DecPerc := LIMIT( IN:=Zg.DecPerc, MN:=2, MX:=vnGrab_RotMaxAccel );

                (* Con piedino ausiliario posso accelerare di più *)
                Zg.AccPerc := SEL( vbGrab_RotWithBlock, Zg.DecPerc, vnGrab_RotBlkAccel );
                Zg.OutFrc := -1; (* max *)
                Zg.MaxPosErr := WTR_DEFAULT;
                Zg.TgtPos := vqGrab_Agrab + vqGrab_Arot; (* [mdeg] *)
                (* Sotto-rotazione per compensazione scivolamenti pinza nel riposizionamento in basso *)
                IF vbGrab_RotWithBlock AND vqRotBlk_DaComp>0 AND vqGrab_Yc_post<>NO_POS_UM THEN
                    Y := TO_DINT(fnLinterp(x:=Yo.yof - (1.0E-3 * TO_LREAL(vqGrab_Yc_post)),
                                           x1:=0.0, x2:=70.0,
                                           y1:=0.0, y2:=TO_LREAL(vqRotBlk_DaComp) ));
                    Zg.TgtPos := Zg.TgtPos - Y;
                    dlog( Txt:='fbCarriages: ! DaComp: %ld mdeg', Lvl:=4, Val1:=Y );
                END_IF;
                dlog( Txt:='fbCarriages: Rot to %ld deg spd=%ld deg/s acc=%d%% dec=%d%%', Lvl:=4, Val1:=Zg.TgtPos/1E3, Val2:=Zg.TgtSpd/60E3, Val3:=TO_DINT(Zg.AccPerc), Val4:=TO_DINT(Zg.DecPerc) );
                Zg.Cmd := AXC_START_POS;
                Status := CARSTS_GRAB_ROTZ;
            ELSE
                dlog( Txt:='fbCarriages: !! Zg not ready (%d) to rot', Lvl:=1, Val1:=TO_DINT(Zg.Status) );
                Status := STS_ERROR;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRAB_ROTZ : (* Rotazione lastra agguantata in corso *)
        (* Attendi arrivo, poi finalizza il trascinamento *)
        IF Zg.Arrived THEN
            (* TODO 2: Anticipare set limite di coppia pinza?? *)
            (* Lastra completamente ruotata *)
            dlog( Txt:='fbCarriages: Rot done to %ld deg, err=%ld mdeg', Lvl:=4, Val1:=Zg.CurrPos/1E3, Val2:=Zg.CurrPosErr );
            (* Assicuro sgancio degli eventuali inseguimenti camma *)
            vnCarrInf_Cmd := CMD_STOP;
            Yinf.Cmd := AXC_STOP_ENAB;
            IF vnAlgn_Cmd=CMD_DRIVEN THEN vnAlgn_Cmd := CMD_STOP; END_IF; (* Piedino riscontri *)
            (* Yb.Cmd := AXC_STOP_ENAB; (* Piedino ausiliario su polmone *)
            vnGrab_RotStatus := 0; (* Rotazione terminata *)

            (* Nota: Se ho ruotato una lastra lato riscontri con piedino,
                     l'ordinata di arrivo è vincolata dal piedino stesso
                     e probabilmente sarà diversa dalla posizione ideale *)

            (* Vedo se c'è una post-traslazione da fare *)
            IF vqGrab_Yc_post<>NO_POS_UM AND ABS(vqGrab_Yc_post-vqGrabber_DY-Yinf.CurrPos)>200 THEN
                (* Trasliamo la lastra agguantata portando la pinza a 'vqGrab_Yc_post' *)
                dlog( Txt:='fbCarriages: Post move grabber from Y=%ld to %ld mm', Lvl:=4, Val1:=(Yinf.CurrPos+vqGrabber_DY)/1E3, Val2:=vqGrab_Yc_post/1E3 );
                Status := CARSTS_GRAB_DYPOSTINI;
            ELSE
                (* -Finalizzo rotazione- vedi anche 'STS_ERROR' *)
                (* Assicuro sgancio inseguimenti (non mi interessa uno stop sincrono) *)
                Zg.Cmd := AXC_STOP_ENAB; (* Master rotazione *)
                IF Yinf.Status=AXS_MOVING_FOL THEN Yinf.Cmd := AXC_STOP_ENAB; END_IF; (* Slave rotazione *)
                IF vnAlgn_Cmd=CMD_DRIVEN THEN vnAlgn_Cmd := CMD_STOP; END_IF; (* Piedino ausiliario lato riscontri *)
                (* IF Yb.Status=AXS_MOVING_FOL THEN Yb.Cmd := AXC_STOP_ENAB; END_IF; (* Piedino ausiiario lato stacco *)
                (* Fatto *)
                Status := CARSTS_GRAB_DONE;
            END_IF;
        ELSIF Zg.Status<=AXS_READY OR vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            (* Rotazione non completata, vedi quanto è stata ruotata *)
            dlog( Txt:='fbCarriages: !! Grab rot aborted, rotated %ld mdeg', Lvl:=1, Val1:=(Zg.CurrPos-vqGrab_Agrab) );
            (* IF ABS(Zg.CurrPos-vqGrab_Agrab) < ATOLL THEN
                (* TODO 5: Se la lastra non si è spostata, possibilità di riprovare subito la sequenza? * )
            ELSE
                (* TODO 5: Marca lastra come spostata? * )
            END_IF; *)

            (* Sequenza non terminata *)
            SET_MSG(REQ_ROTATEBYHAND,'Rot fail',0);
            Status := STS_ERROR;
        ELSE (* -Durante la rotazione: *)
            (* Assicura cuscino aria *)
            vnVents_Cmd := vnVents_Cmd OR RequiredVents;
            (* Intercetta se qualcuno ha spento l'aria
            IF NOT vbAirCushionReady THEN
                dlog( Txt:='fbCarriages: !! GRAB_ROTZ: No air (Status=%d)', Lvl:=1, Val1:=TO_DINT(Grabber.Status) );
                Status := STS_ERROR;
            END_IF; *)

            (* Controlla condizioni rotazione *)
            IF Yinf.Cmd=AXC_START_FOL AND NOT Yinf.Status=AXS_MOVING_FOL THEN
                dlog( Txt:='fbCarriages: !! Rot abort, CarrInf not following', Lvl:=1 );
                vnCarriages_Cmd := CMD_STOP;
            ELSIF NOT vb[ivbAtRest+ID_BELTS_DTCH] OR NOT vb[ivbAtRest+ID_ROLLS_ALGN] THEN
                dlog( Txt:='fbCarriages: !! Rot abort, Belts on', Lvl:=1 );
                vnCarriages_Cmd := CMD_STOP;
            ELSIF NOT vb[ivbAtRest+ID_CLAMP_ALGN] OR NOT vb[ivbAtRest+ID_CLAMP_DTCH] OR NOT vb[ivbAtRest+ID_HOLDPADS] THEN
                dlog( Txt:='fbCarriages: !! Rot abort, Clamps/Pads on', Lvl:=1 );
                vnCarriages_Cmd := CMD_STOP;
            (* ELSIF NOT vbAirCushionReady THEN
                dlog( Txt:='fbCarriages: !! Rot abort, vbAirCushionReady off', Lvl:=1 );
                vnCarriages_Cmd := CMD_STOP; *)
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRAB_DYPREINI,
    CARSTS_GRAB_DYPOSTINI : (* Preparazione trascinamento Y post rotazione lastra agguantata *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Intercetta problemi di agguantamento *)
        ELSIF vnGrabber_Cmd=GCMD_NONE AND Grabber.Status<>GSTS_GRABBED THEN
            dlog( Txt:='fbCarriages: !! GRAB_DY*INI: Not grabbing (Status=%d)', Lvl:=1, Val1:=TO_DINT(Grabber.Status) );
            Status := STS_ERROR;
        (* Avvio l'aria appena sono sicuro che il vetro non scappa *)
        ELSIF (vnVents_Cmd AND RequiredVents)<>RequiredVents (* Non sto dando il comando aria *)
              AND ( (Grabber.ClampStatus>=GSTS_GRABBING AND NOT vbSlantMode) (* La pinza sta agguantando *)
                     OR Grabber.ClampStatus>GSTS_GRABBING) THEN (* Pinza agguantata *)
            vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Dò comando aria *)
        (* Attendo precondizioni *)
        ELSIF Grabber.Status=GSTS_GRABBED AND (* Pinza agguantata *)
              Zg.Status=AXS_READY AND (* Pinza ferma e in coppia *)
              Yinf.Status=AXS_READY AND (* Carrello inferiore pronto *)
              vbAirCushionReady AND (* Aria pronta *)
              vb[ivbAtRest+ID_ALGN] AND (* Piedini riscontri bassi *)
              vb[ivbAtRest+ID_BELTS_DTCH] AND vb[ivbAtRest+ID_ROLLS_ALGN] AND (* Cinghie stacco e rulli bassi *)
              vb[ivbAtRest+ID_CLAMP_ALGN] AND vb[ivbAtRest+ID_CLAMP_DTCH] AND (* Premilastra alti *)
              vb[ivbAtRest+ID_HOLDPADS] THEN (* Tamponi alti *)

            (* Traslazione Y lastra agguantata pre/post-rotazione *)
            Yinf.TgtSpd := vqGrab_YSpdMax; (* [um/min] *)
            (* L'accelerazione dovrebbe dipendere da:
               .Coppia scivolamento pinza-vetro: vqGrab_RotTorque (DINT, N·mm)
               .Distanza tra punto di presa e baricentro: L=MAX(w,h)/2 (DINT, um)
               .Massa lastra: vdRot_Mass (LREAL, Kg)
                                   L·M·a <= Tmax
               La parzializzazione dell'accelerazione: AccPerc = 100 · a / Yinf.AccMax *)
            (*  [%]                                       [N mm]                                       [um]                                       [Kg]        [mm/s²]   *)
            Yinf.AccPerc := TO_INT( 2.0E8 * TO_LREAL(vqGrab_RotTorque) / (TO_LREAL(MAX(vqGrab_GlassWidth,vqGrab_GlassYtop-vqGrab_GlassYbtm)) * vdRot_Mass * Yinf.AccMax) ); (* DANGER_DIVISION_BY_ZERO *)
            (* ex:  35 = 2.0E8 * 70.0 / (1000E3 * 50.0 * 7.86) *)
            IF vbSlantMode THEN Yinf.AccPerc := fnPartializeAcc(Yinf.AccPerc, vnGrab_SlantAccel); END_IF;
            Yinf.AccPerc := LIMIT(Yinf.AccPerc, 2, vnGrab_YAccelMax );
            Yinf.DecPerc := Yinf.AccPerc;
            Yinf.OutFrc := -1; (* max *)
            Yinf.MaxPosErr := WTR_DEFAULT;
            IF Status=CARSTS_GRAB_DYPREINI THEN
                (* La posizione Y alla quale portare la lastra da ruotare *)
                Yinf.TgtPos := LIMIT(vqGrab_Yc_pre-vqGrabber_DY, Yinf.NegLim, Yinf.PosLim); (* [um] *)
                Status := CARSTS_GRAB_DYPRE;
            ELSE
                (* La posizione Y alla quale portare la lastra appena ruotata *)
                Yinf.TgtPos := LIMIT(vqGrab_Yc_post-vqGrabber_DY, Yinf.NegLim, Yinf.PosLim); (* [um] *)
                Status := CARSTS_GRAB_DYPOST;
            END_IF;
            dlog( Txt:='fbCarriages: Drag Y to %ld mm spd=%ld mm/min a=%d%%', Lvl:=4, Val1:=Yinf.TgtPos/1E3, Val2:=Yinf.TgtSpd/1E3, Val3:=TO_DINT(Yinf.AccPerc) );
            Yinf.Cmd := AXC_START_POS;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRAB_DYPRE,
    CARSTS_GRAB_DYPOST : (* Traslazione Y lastra agguantata in corso *)
        (* Attendi arrivo, poi finalizza il trascinamento *)
        IF Yinf.Arrived OR (Yinf.Status<=AXS_READY AND NOT vbSlantMode) THEN (* Tollerante se rotazione normale *)
            (* Lastra traslata *)
            IF Status=CARSTS_GRAB_DYPRE THEN
                (* Proseguo con la rotazione *)
                Status := CARSTS_GRAB_ROTZINI;
            ELSE
                (* Finito *)
                Status := CARSTS_GRAB_DONE;

                (* A volte se il punto di presa è decentrato e ci sono impuntamenti,
                   la lastra si storta durante questo trascinamento in basso.
                   Vediamo se vedo qualcosa sull'encoder della pinza *)
                IF ABS(Zg.CurrPosErr) > 500 THEN
                    dlog( Txt:='fbCarriages: ! GRAB_DY Zg=%ld mdeg (err=%ld)', Lvl:=3, Val1:=Zg.CurrPos, Val2:=Zg.CurrPosErr );
                END_IF;
            END_IF;
        ELSIF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            (* Traslazione Y non completata/sequenza abortita *)
            SET_MSG(REQ_ROTATEBYHAND,'DragY fail',0);
            Status := STS_ERROR;
        ELSE (* Durante la la traslazione Y *)
            (* Assicura cuscino aria *)
            vnVents_Cmd := vnVents_Cmd OR RequiredVents;
            (* Intercetta se qualcuno ha spento l'aria
            IF NOT vbAirCushionReady THEN
                dlog( Txt:='fbCarriages: !! GRAB_DY*: No air (Status=%d)', Lvl:=1, Val1:=TO_DINT(Grabber.Status) );
                Status := STS_ERROR;
            END_IF; *)

            (* Controlla condizioni *)
            IF NOT vb[ivbAtRest+ID_BELTS_DTCH] OR NOT vb[ivbAtRest+ID_ROLLS_ALGN] THEN
                dlog( Txt:='fbCarriages: !! GRAB_DY*: Abort, Belts on', Lvl:=1 );
                vnCarriages_Cmd := CMD_STOP;
            ELSIF NOT vb[ivbAtRest+ID_CLAMP_ALGN] OR NOT vb[ivbAtRest+ID_CLAMP_DTCH] OR NOT vb[ivbAtRest+ID_HOLDPADS] THEN
                dlog( Txt:='fbCarriages: !! GRAB_DY*: Abort, Clamps/Pads on', Lvl:=1 );
                vnCarriages_Cmd := CMD_STOP;
            (* ELSIF NOT vbAirCushionReady THEN
                dlog( Txt:='fbCarriages: !! GRAB_DY*: Abort, vbAirCushionReady off', Lvl:=1 );
                vnCarriages_Cmd := CMD_STOP; *)
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_GRAB_DONE : (* Finalizzo rotazione -vedi anche 'STS_ERROR'- *)
        vnVents_Cmd := vnVents_Cmd & NOT RequiredVents; (* Fermo cuscino aria *)
        (* Normalmente apro la pinza, a meno che non sia in modalità tagli obliqui *)
        IF NOT vbSlantMode THEN
            vnGrabber_Cmd := GCMD_OPEN; (* Apro la pinza (sono fermo) *)
        END_IF;
        (* Sequenza terminata *)
        vnCarriages_Cmd := CMD_STOP;
        vnCarriages_Seq := SEQ_DONE;
        Status := STS_IDLE;


    (* ------------------------------------------------------------------- *)
    CARSTS_PARK_WAITSUP : (* Parcheggio del carrello superiore *)
        (* Attendi carrello superiore in parcheggio *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnCarrSup_Cmd=CMD_STOP THEN
            (* Movimento carrello superiore terminato, vediamo il risultato *)
            IF vnCarrSup_Seq<>SEQ_DONE THEN
                dlog( Txt:='fbCarriages: !! PARK_WAITSUP: Error', Lvl:=1 );
                Status := STS_ERROR;
            ELSE
                (* Ok, arrivato in parcheggio, proseguo col carrello inferiore *)
                Status := CARSTS_PARK_INITINF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PARK_INITINF : (* Attesa condizioni inizio parcheggio inferiore con pinza alta *)
        (* Attendi condizioni, poi vai in posizione di chiusura *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnGrabber_Cmd=GCMD_NONE THEN
            IF Grabber.Status<>GSTS_OPENED THEN
                dlog( Txt:='fbCarriages: !! Grabber not opened (Status=%d)', Lvl:=1, Val1:=TO_DINT(Grabber.Status) );
                Status := STS_ERROR;
            ELSIF Yinf.Status=AXS_READY AND Zg.Status=AXS_READY THEN (* Inseguimenti sganciati *)
                (* Procedo e vado in posizione di chiusura già decisa in 'YgrabOC' *)
                IF YgrabOC=vqYinf_GrabBtmPos OR YgrabOC=vqYinf_GrabTopPos THEN
                    Ybegin := Yinf.CurrPos; (* Voglio vedere di quanto mi sposto *)
                    vqCarrInf_Tgt := YgrabOC;
                    vnCarrInf_Cmd := CMD_MOVETO;
                    Status := CARSTS_PARK_GOTODWN;
                ELSE
                    dlog( Txt:='fbCarriages: !! Invalid grabber close pos %ld mm', Lvl:=1, Val1:=YgrabOC/1E3 );
                    Status := STS_ERROR;
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PARK_GOTODWN : (* Movimento verso posizione di chiusura pinza *)
        (* Attendi arrivo in posizione di chiusura, poi abbassa e chiudi la pinza *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnCarrInf_Cmd=CMD_STOP THEN
            (* Movimento carrello inferiore terminato, vediamo il risultato *)
            IF vnCarrInf_Seq<>SEQ_DONE THEN
                dlog( Txt:='fbCarriages: !! Grabber not in closing pos %ld mm', Lvl:=1, Val1:=Yinf.TgtPos/1E3 );
                Status := STS_ERROR;
            ELSE
                (* Ok, arrivato in posizione di chiusura *)
                (* Vediamo se sicuramente ho lasciato il vetro, lo spostamento minimo è: *)
                IF ABS(Zg.CurrPos MOD 180E3) < 500 THEN (* 0.5° *)
                    (* Se sono praticamente orizzontale, non potrò mai allontanarmi abbastanza *)
                    Yend := Yinf.PosLim;
                ELSE
                    (* Altrimenti basta essermi allontanato di R/sina *)
                    Yend := TO_DINT( TO_LREAL(vqGrabber_Radius) / SIN(MDEG2RAD * TO_LREAL(Zg.CurrPos)) );
                END_IF;
                IF ABS(Yinf.CurrPos-Ybegin)<=ABS(Yend) THEN
                    (* Se mi sono spostato di poco, prima di chiudere preferisco
                       orientare la pinza verso l'esterno: +90 se sono in alto, -90 se sono in basso *)
                    Zg.TgtSpd := 0; (* max *)
                    Zg.AccPerc := 100; (* max [%] *)
                    Zg.DecPerc := 100; (* max [%] *)
                    Zg.OutFrc := 0; (* just move [mN] *)
                    Zg.MaxPosErr := WTR_HITDET;
                    Zg.TgtPos := SEL(YgrabOC=vqYinf_GrabBtmPos, 90E3, -90E3); (* [mdeg] *)
                    Zg.Cmd := AXC_START_POS;

                    Status := CARSTS_PARK_INITDWN;
                ELSE
                    (* Chiudo senza prima riorientare verso l'esterno *)
                    vnGrabber_Cmd := GCMD_CLOSE;
                    Status := CARSTS_PARK_GRABDWN;
                END_IF;
            END_IF;
        ELSE
            (* Movimento verso chiusura in corso *)
            (* -Controllo anticollisione pinza-vetro-
                Controllo solo fino al punto di arrivo dell'ingombro pinza *)
            IF Yinf.MovingBck AND (Yinf.CurrPos+vq[ivqProbe_DY+IRQ_PROBEINF])>(Yinf.TgtPos+vqGrabber_DY-vqGrabber_Radius) THEN
                (* Se vado indietro, non ci deve essere -mai- vetro *)
                IF (vqProbe3_DX<0 AND (vnIrqStatus & SHL(INT#1, IRQ_PROBEINF-1))<>0) OR (* Usa ingresso veloce sonda inferiore per controllo collisioni pinza se sonda montata verso stacco *)
                   IFC_YINF_BCK_DTCH THEN (* !DEPRECATED! Ingresso dedicato *)
                    dlog( Txt:='fbCarriages: !! Coll grab-glass y=%ld mm spd=%ld m/min', Lvl:=1, Val1:=(Yinf.CurrPos+vq[ivqProbe_DY+IRQ_PROBEINF])/1E3, Val2:=Yinf.CurrSpd/1E6 );
                    (* ThrowEmg(Idx:=EMG_COLLISION, Txt:='Detected collision grabber-glass'); *)
                    SET_MSG(MSG_GRABBER_COLL,'MSG_GRABBER_COLL',0);
                    Yinf.Cmd := AXC_STOP_FREE; (* Quickstop *)
                    Status := STS_ERROR;
                END_IF;
            (* ELSIF Yinf.MovingFwd THEN *)
            END_IF; (* Controllo anticollisione pinza-vetro *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PARK_INITDWN : (* Operazione di riorientazione pinza prima di chiusura *)
        (* Attendi pinza opportunamente orientata *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF Zg.Status<=AXS_READY THEN
            (* Posizionamento terminato *)
            IF NOT Zg.Arrived THEN
                dlog( Txt:='fbCarriages: !! Grabber didnt turn to %ld deg', Lvl:=1, Val1:=Zg.TgtPos/1E3 );
                Status := STS_ERROR;
            ELSE
                (* Procedo alla chiusura *)
                vnGrabber_Cmd := GCMD_CLOSE;
                Status := CARSTS_PARK_GRABDWN;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PARK_GRABDWN : (* Attesa chiusura pinza *)
        (* Attendi chiusura, poi termina sequenza *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnGrabber_Cmd=GCMD_NONE THEN
            IF Grabber.Status<>GSTS_CLOSED THEN
                dlog( Txt:='fbCarriages: !! Grabber not closed (%d)', Lvl:=1, Val1:=TO_DINT(Grabber.Status) );
                Status := STS_ERROR;
            ELSE
                (* Visto che la pinza è chiusa e bassa, non c'è
                   problema nel ripristinarne l'orientazione *)
                IF Zg.Status<=AXS_READY THEN
                    Zg.TgtSpd := 0; (* max *)
                    Zg.AccPerc := 100; (* max [%] *)
                    Zg.DecPerc := 100; (* max [%] *)
                    Zg.OutFrc := 0; (* just move [mN] *)
                    Zg.MaxPosErr := WTR_HITDET;
                    (* Poichè la pinza a volte è letta dalla sonda superiore, se
                       il carrello è lato operatore è bene orientarla a -90° per
                       offrire meno ingombro (la parte posteriore è "tagliata") *)
                    Zg.TgtPos := SEL(Yinf.CurrPos<500E3, Zg.HomePos, -90E3 ); (* [mdeg] *)
                    (* dlog( Txt:='fbCarriages: Orienting grabber to %ld', Lvl:=5, Val1:=Zg.TgtPos/1E3 ); *)
                    Zg.Cmd := AXC_START_POS;
                END_IF;
                (* Ora il carrello inferiore è in posizione bassa con pinza chiusa.
                   Sono qui perché è stato dato un comando parcheggio con pinza alta,
                   a questo punto rilancio il medesimo comando per effettuare le
                   operazioni desiderate (parcheggio basso, alto, home, completo) *)

                (* Nelle macchine con pinza integrata e parcheggio in alto (StratoW)
                   potrei volerlo lasciare lì dov'è in basso*)
                IF vnCarriages_Cmd=CMD_PARK AND YgrabOC=vqYinf_GrabBtmPos AND vbFeat_CarrHomeOnTop THEN
                    (* Macchine StratoW, lascio il carrello inferiore in basso per essere
                       pronto col taglio successivo (sperando non debba arrivare un pezzo
                       stretto che richieda l'avvicinamento dello stacco) *)
                    (* dlog( Txt:='fbCarriages: Grabber at btm, staying there', Lvl:=5 ); *)
                    (* Sequenza terminata *)
                    vnCarriages_Cmd := CMD_STOP;
                    vnCarriages_Seq := SEQ_DONE;
                    Status := STS_IDLE;
                (* Nelle macchine con pinza su traino (ActiveHP) voglio sempre
                   sganciare il traino della pinza *)
                ELSIF vbGrabber_CanBeUnlocked THEN
                    (* Macchine ActiveHP, voglio sempre sganciare pinza e tornare in home *)
                    vnCarrInf_Cmd := CARCMD_FULLPARK;
                    Status := CARSTS_PARK_WAITINF;
                ELSE
                    (* Ora che sono riuscito ad abbassare la pinza torno
                       ad eseguire il comando originario 'vnCarriages_Cmd' *)
                    Status := STS_IDLE;
                END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    CARSTS_PARK_WAITINF : (* Parcheggio carrello inferiore *)
        (* Attendi CarrInf in parcheggio *)
        IF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnCarrInf_Cmd=CMD_STOP THEN
            (* Movimento carrello inferiore terminato, vediamo il risultato *)
            IF vnCarrInf_Seq<>SEQ_DONE THEN
                dlog( Txt:='fbCarriages: !! PARK_WAITINF: Error', Lvl:=1 );
                Status := STS_ERROR;
            ELSE
                (* Ok, arrivato in parcheggio, sequenza terminata *)
                vnCarriages_Cmd := CMD_STOP;
                vnCarriages_Seq := SEQ_DONE;
                Status := STS_IDLE;
            END_IF;
        END_IF;

    (* ------------------------------------------------------------------- *)
    CARSTS_FOLLOW_INI : (* Preparazione inseguimento *)
        IF MoveBoth=MV_LOCKED THEN
            Status := CARSTS_FOLLOWING;
        ELSIF vnCarriages_Cmd=CMD_STOP OR MoveBoth<>MV_LOCKMOVE THEN
            Status := STS_ERROR;
        END_IF;

    (* ------------------------------------------------------------------- *)
    CARSTS_FOLLOWING : (* Carrello inferiore in inseguimento *)
        IF MoveBoth<>MV_LOCKED THEN
            Status := STS_ERROR;
        END_IF;

    (* ------------------------------------------------------------------- *)
    STS_IDLE : (* Sequenza combinata carrelli non attiva *)
        (* Rispondi ai comandi *)
        IF vnCarriages_Cmd<>CMD_STOP AND (vnCarrSup_Cmd=CMD_STOP AND vnCarrInf_Cmd=CMD_STOP) THEN
            vnCarriages_Seq := SEQ_START; (* Resetto risultato sequenza *)
            (* Eventuali messaggi non più pertinenti *)
            RST_MSG_IF_ON(MSG_GRABBER_COLL);
            (* Notifica conflitto con comando singolo dei carrelli superiore/inferiore * )
            IF vnCarrSup_Cmd<>CMD_STOP OR vnCarrInf_Cmd<>CMD_STOP THEN
                dlog( Txt:='fbCarriages: ! Cmd %d conflicts with %d,%d', Lvl:=1, Val1:=TO_DINT(vnCarriages_Cmd), Val2:=TO_DINT(vnCarrSup_Cmd), Val3:=TO_DINT(vnCarrInf_Cmd) );
            END_IF; *)
            IF vnCarriages_Cmd>=CMD_PARK AND vnCarriages_Cmd<=CARCMD_FULLPARK THEN
                (* Sequenza di parcheggio *)
                IF Grabber.AtRest OR vnGrabber_Type=0 THEN
                    (* Posso dare simultaneamente il comando di parcheggio ai carrelli singoli *)
                    vnCarrSup_Cmd := vnCarriages_Cmd;
                    vnCarrInf_Cmd := vnCarriages_Cmd;
                    Status := CARSTS_WAITBOTH;
                ELSE (* vnGrabber_Type=2 *)
                    (* Pinza non bassa e chiusa *)
                    dlog( Txt:='fbCarriages: Parking Grabber (sts=%d, %ld deg, Yinf=%ld, Ysup=%ld)', Lvl:=2, Val1:=TO_DINT(Grabber.Status), Val2:=Zg.CurrPos/1E3, Val3:=Yinf.CurrPos/1E3, Val4:=Ysup.CurrPos/1E3 );
                    (* Per prima cosa se la pinza è agguantata la apriamo *)
                    IF Grabber.Status>=GSTS_GRABBING THEN vnGrabber_Cmd:=GCMD_OPEN; END_IF;

                    (* Vediamo la situazione:
                       Ho pinza alta: potrebbe collidere sia col carrello superiore che col vetro
                       (mi aspetto ci sia del vetro da qualche parte).
                       L'ideale è chiuderla subito: si può fare se sono sicuro non ci sia
                       vetro sottostante, ad es. se fuori dall'area taglio (vqYmin÷vqYmax).
                       Altrimenti posso dedurre da che parte è il vetro guardando l'orientazione
                       della pinza e la sua posizione Y:
                          -Se la pinza è quasi fuori dall'area vetro in basso (alto) il vetro sarà sopra (sotto)
                          -Altrimenti il vetro sarà nella zona verso cui è orientata la pinza
                       Se la pinza è a 0° o 180° assumo non ci possano essere collisioni col vetro.
                       In genere si predilige andare a chiudere in alto (StratoW il parcheggio è in alto,
                       ActiveHP la pinza è sul traino che viene parcheggiato in alto)
                       Se devo muovermi con pinza alta è bene evitare collisioni col carrello
                       superiore (Sup.YroomM|Sup.YroomP) *)
                    Agrab := fnAngle180_mdeg(Zg.CurrPos); (* Orientazione della pinza (-180E3÷180E3] *)

                    IF (Inf.GrabberYroomP<vqYmin OR Inf.GrabberYroomM>vqYmax) AND vnGrabber_Cmd<=GCMD_PREPARE THEN
                        (* La pinza è fuori dall'area vetro (sopra o sotto) e non agguantata:
                           La posso chiudere immediatamente senza danni *)
                        dlog( Txt:='Closing Grabber (%ld|%ld) outside (%ld|%ld)', Lvl:=4, Val1:=Inf.GrabberYroomM/1E3, Val2:=Inf.GrabberYroomP/1E3, Val3:=vqYmin/1E3, Val4:=vqYmax/1E3 );
                        vnGrabber_Cmd := GCMD_CLOSE;
                        Status := CARSTS_PARK_GRABDWN;

                    ELSIF Inf.GrabberYroomM<Sup.YroomP AND Inf.GrabberYroomP>Sup.YroomM AND NOT vbExclGrbCollCtrl THEN
                        (* Mah, la pinza è sovrapposta al carrello superiore! *)
                        dlog( Txt:='!! Overlap Grabber(%ld|%ld) CarrSup(%ld|%ld)', Lvl:=1, Val1:=Inf.GrabberYroomM/1E3, Val2:=Inf.GrabberYroomP/1E3, Val3:=Sup.YroomM/1E3, Val4:=Sup.YroomP/1E3 );
                        Status := STS_ERROR; (* Se ne esce solo mediante operazioni manuali *)

                    ELSIF Yinf.CurrPos >= (vqYinf_GrabTopPos - 2*vqGrabber_Radius) OR (* Quasi in posizione di chiusura alta *)
                          Inf.GrabberYroomP >= vqYmax OR (* Pinza quasi fuori in alto *)
                          ( Inf.GrabberYroomM > (vqYmin+50E3) AND (* Pinza ben sopra lo zero e... *)
                            ( (ABS(Agrab)<ATOLL OR ABS(Agrab)>(DINT#180000-ATOLL)) OR (* ...Pinza a 0° o 180° *)
                              Agrab<-ATOLL ) ) THEN (* ...Pinza rivolta verso il basso *)
                        (* Voglio/devo andare a chiudere verso l'alto:
                             ═╦═ top          ═╦═ top         ═╦═ top
                             ╔═╗↑             ╔═╗↑            ╔═╗↑
                             ╚═╝              ╚═╝             ╚═╝
                              ║                ║              ╔║╗
                             ╔║╗▒▒▒▒      ▒▒▒▒╔║╗             ║▼║↑
                             ║►║↑▒▒▒      ▒▒▒▒║◄║↑            ╚║╝
                             ╚║╝▒▒▒▒      ▒▒▒▒╚║╝            ▒▒║▒▒▒▒
                              ║                ║             ▒▒║▒▒▒▒
                             ═╩═ btm          ═╩═ btm         ═╩═ btm  *)
                        dlog( Txt:='Grabber top close', Lvl:=4 );
                        YgrabOC := vqYinf_GrabTopPos;
                        Status := CARSTS_PARK_INITINF; (* Default: Prosegui a muovere CarrInf *)

                        (* Ci possono essere collisioni col carrello superiore? *)
                        IF NOT vbExclGrbCollCtrl THEN
                            IF Inf.GrabberYroomP <= Sup.YroomM THEN
                                (* Il carrello superiore si trova verso il lato opposto *)
                                (* Mi bloccherebbe anche se in parcheggio alto? *)
                                IF (vqYsup_TopParkPos + Sup.YroomM-Ysup.CurrPos) >
                                   (vqYinf_GrabTopPos + Inf.GrabberYroomP-Yinf.CurrPos) THEN
                                    (* Ok, non mi blocca in parcheggio alto *)
                                    IF ABS(Ysup.CurrPos-vqYsup_TopParkPos)>1E3 THEN
                                        (* Mando prima CarrSup in park alto *)
                                        vnCarrSup_Cmd := CARCMD_TOPPARK;
                                        Status := CARSTS_PARK_WAITSUP;
                                    (* ELSE (* CarrSup già in parcheggio, prosegui *)
                                    END_IF;
                                ELSE
                                    (* Il carrello superiore mi bloccherebbe anche se in parcheggio alto! *)
                                    dlog( Txt:='!! Cant close Grabber at top', Lvl:=1 );
                                    Status := STS_ERROR; (* Se ne esce solo forzando una chiusura della pinza *)
                                END_IF;
                            (* ELSIF Inf.GrabberYroomM >= Sup.YroomP THEN
                                (* Il carrello superiore si trova verso il lato operatore, non mi blocca. *)
                                (* Potrei assicurarlo in parcheggio basso:
                                IF ABS(Ysup.CurrPos-vqYsup_BtmParkPos)>1E3 THEN vnCarrSup_Cmd:=CARCMD_BTMPARK; END_IF; *)
                            END_IF; (* Where is CarrSup *)
                        END_IF; (* CarrSup coll checks *)

                    ELSE
                        (* Devo andare a chiudere verso il basso *)
                        (* ═╦═ top
                          ▒▒║▒▒▒▒
                          ▒▒║▒▒▒▒
                           ║▲║↓
                           ╚║╝
                           ╔═╗↓
                           ╚═╝
                           ═╩═ btm *)
                        dlog( Txt:='Grabber btm close', Lvl:=4 );
                        YgrabOC := vqYinf_GrabBtmPos;
                        Status := CARSTS_PARK_INITINF; (* Default: Prosegui a muovere CarrInf *)

                        (* Ci possono essere collisioni col carrello superiore? *)
                        IF NOT vbExclGrbCollCtrl THEN
                            IF Inf.GrabberYroomM >= Sup.YroomP THEN
                                (* Il carrello superiore si trova verso il lato operatore *)
                                (* Mi bloccherebbe anche se in parcheggio basso? *)
                                IF (vqYsup_BtmParkPos + Sup.YroomP-Ysup.CurrPos) <
                                   (vqYinf_GrabBtmPos + Inf.GrabberYroomM-Yinf.CurrPos) THEN
                                    (* Ok, non mi blocca in parcheggio basso *)
                                    IF ABS(Ysup.CurrPos-vqYsup_BtmParkPos)>=1E3 THEN
                                        (* Mando prima CarrSup in park basso *)
                                        vnCarrSup_Cmd := CARCMD_BTMPARK;
                                        Status := CARSTS_PARK_WAITSUP;
                                    (* ELSE (* CarrSup già in parcheggio, prosegui *)
                                    END_IF;
                                ELSE
                                    (* Il carrello superiore mi bloccherebbe anche se in parcheggio basso! *)
                                    dlog( Txt:='!! Cant close Grabber at btm', Lvl:=1 );
                                    Status := STS_ERROR; (* Se ne esce solo forzando una chiusura della pinza *)
                                END_IF;
                            (* ELSIF Inf.GrabberYroomP <= Sup.YroomM THEN
                                (* Il carrello superiore si trova verso il lato opposto, non mi blocca *)
                                (* Potrei assicurarlo in parcheggio alto:
                                IF ABS(Ysup.CurrPos-vqYsup_TopParkPos)>1E3 THEN vnCarrSup_Cmd:=CARCMD_TOPPARK; END_IF; *)
                            END_IF; (* Where is CarrSup *)
                        END_IF; (* CarrSup coll checks *)
                    END_IF;
                END_IF; (* - Grabber not at rest *)

            ELSIF vnCarriages_Cmd=CARCMD_SCORE_FWD OR
                  vnCarriages_Cmd=CARCMD_SCORE_BCK THEN
                (* Sequenza di incisione con entrambi i carrelli *)
                (* Qualora i bordi del vetro non fossero ancora noti, cerco di rilevarli "al volo" *)
                IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                    dlog( Txt:='fbCarriages: ! Search on the fly', Lvl:=4 );
                    (* Ok, quello che voglio fare ora è:
                        1) Allineare le testine alla quota di inizio ricerca
                        2) Programmare la sonda/e
                        3) Agganciare i carrelli
                        4) Eseguire il movimento di ricerca
                    *)
                    (* Determino quote di ricerca per Probe1 *)
                    Y := Ysup.CurrPos + vq[ivqProbe_DY+IRQ_PROBESUP]; (* Posizione sonda *)
                    IF vnCarriages_Cmd=CARCMD_SCORE_FWD THEN
                        (* Incisione avanti *)
                        Ybegin := vqYmin - vqEdgeDet_Margin; (* Quota inizio ricerca *)
                        (* Yend := SEL( vbAutoMode, vqYmax, vqYmax-vqSubSheet_ProcHeight ) + vqEdgeDet_Margin; (* Ymax ricerca iniziale *)
                        Yend := vqYmin + (vqYmax-vqYmin)/2; (* Ymax ricerca bordo inizio *)
                        (* È necessario portarsi alla quota di inizio ricerca o possiamo partire da dove siamo? *)
                        IF Y<=Ybegin THEN Ybegin := Y; END_IF; (* Parto da dove sono *)
                    ELSE
                        (* Incisione indietro *)
                        Ybegin := vqYmax + vqEdgeDet_Margin; (* Quota inizio ricerca *)
                        Yend := vqYmin - vqEdgeDet_Margin; (* Ymin ricerca bordo inizio *)
                        (* È necessario portarsi alla quota di inizio ricerca o possiamo partire da dove siamo? *)
                        IF Y>=Ybegin THEN Ybegin := Y; END_IF; (* Parto da dove sono *)
                    END_IF;
                    Ybegin := Ybegin - vq[ivqProbe_DY+IRQ_PROBESUP];
                    Yend := Yend - vq[ivqProbe_DY+IRQ_PROBESUP];
                    (* Procediamo *)
                    vqCarrSup_Tgt := Ybegin;
                    vqCarrInf_Tgt := Ybegin;
                    vnCarrSup_Cmd := CMD_MOVETO;
                    vnCarrInf_Cmd := CMD_MOVETO;
                    Status := CARSTS_WAITBOTH;
                ELSE
                    (* Bordi vetro già noti *)
                    IF vnCarriages_Cmd=CARCMD_SCORE_FWD THEN
                        (* Incisione avanti *)
                        Ybegin := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                        Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                    ELSIF vnCarriages_Cmd=CARCMD_SCORE_BCK THEN
                        (* Incisione indietro *)
                        Ybegin := MAX(vqY_BtmEdge, vqY_TopEdge - (vqTscore_TopMargin+vqMod_Tscore_TopMargin)); (* [um] L'offset delle testine è zero *)
                        Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqTscore_BtmMargin+vqMod_Tscore_BtmMargin)); (* [um] L'offset delle testine è zero *)
                    END_IF;
                    dlog( Txt:='fbCarriages: Score range %ld|%ld mm', Lvl:=3, Val1:=Ybegin/1E3, Val2:=Yend/1E3);
                    (* Reset modificatori temporanei *)
                    vqMod_Tscore_BtmMargin := 0;
                    vqMod_Tscore_TopMargin := 0;
                    (* L'offset delle testine di incisione è per definizione zero *)
                    vqCarrSup_Tgt := Ybegin;
                    vqCarrInf_Tgt := Ybegin;
                    (* Comando un movimento libero indipendente ad entrambi i
                       carrelli per portarli sulla posizione di partenza del lavoro.
                       Nota: non faccio controlli, ci pensano i vincoli macchina *)
                    vnCarrSup_Cmd := CMD_MOVETO;
                    vnCarrInf_Cmd := CMD_MOVETO;
                    Status := CARSTS_WAITBOTH;
                END_IF;

            ELSIF vnCarriages_Cmd=CARCMD_OPEN_FWD OR
                  vnCarriages_Cmd=CARCMD_OPEN_BCK THEN
                (* Sequenza di apertura con entrambi i carrelli
                   .Usa posizione vetro: vqY_BtmEdge, vqY_TopEdge
                   .I controlli dei parametri utensile li ho già fatti in 'fbToolsParams'
                   .Altri argomenti: vbRbrk_DoublePass, vbRbrk_UpperLayer *)
                (* Vedi se bisogna ricercare la lastra *)
                IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                    dlog( Txt:='fbCarriages: Searching sheet before open', Lvl:=4 );
                    IF vnCarrSup_Cmd=0 THEN
                        vnCarrSup_Cmd := CARCMD_SRCHGLASS;
                        Status := CARSTS_SRCH_SWEEP; (* Attendo ricerca con carrello superiore *)
                    ELSE
                        dlog( Txt:='fbCarriages: !! Cannot search sheet (vnCarrSup_Cmd=%d)', Lvl:=2, Val1:=TO_DINT(vnCarrSup_Cmd) );
                        Status := STS_ERROR;
                    END_IF;
                ELSE
                    IF vnCarriages_Cmd=CARCMD_OPEN_FWD THEN
                        (* Apertura con rotelle avanti *)
                        Ybegin := MIN(vqY_TopEdge, vqY_BtmEdge + (vqRbrk_BtmMargin+vqMod_Rbrk_BtmMargin)) - vqRsup_DY; (* [um] *)
                        Yend := MAX(vqY_BtmEdge, vqY_TopEdge - (vqRbrk_TopMargin+vqMod_Rbrk_TopMargin)) - vqRsup_DY; (* [um] *)
                        vqCarrSup_Tgt := LIMIT(Ybegin + vqRbrk_StartInside, vqY_BtmEdge-vqRsup_DY, vqY_TopEdge-vqRsup_DY);
                        vqCarrInf_Tgt := vqCarrSup_Tgt + vqRsup_DY - vqRinf_DY;
                    ELSIF vnCarriages_Cmd=CARCMD_OPEN_BCK THEN
                        (* Apertura con rotelle indietro *)
                        Ybegin := MAX(vqY_BtmEdge, vqY_TopEdge - (vqRbrk_TopMargin+vqMod_Rbrk_TopMargin)) - vqRsup_DY; (* [um] *)
                        Yend := MIN(vqY_TopEdge, vqY_BtmEdge + (vqRbrk_BtmMargin+vqMod_Rbrk_BtmMargin)) - vqRsup_DY; (* [um] *)
                        vqCarrSup_Tgt := LIMIT(Ybegin - vqRbrk_StartInside, vqY_BtmEdge-vqRsup_DY, vqY_TopEdge-vqRsup_DY);
                        vqCarrInf_Tgt := vqCarrSup_Tgt + vqRsup_DY - vqRinf_DY;
                    END_IF;
                    dlog( Txt:='fbCarriages: Open range %ld|%ld mm', Lvl:=3, Val1:=Ybegin/1E3, Val2:=Yend/1E3);
                    (* Reset modificatori temporanei *)
                    vqMod_Rbrk_BtmMargin := 0;
                    vqMod_Rbrk_TopMargin := 0;
                    (* Seleziono subito la contro-rotella opportuna *)
                    vbRsup_SelC := vbRbrk_UpperLayer;
                    vbRinf_SelC := NOT vbRsup_SelC;
                    (* Comando un movimento libero indipendente ad entrambi i
                       carrelli per portarli sulla posizione di partenza del lavoro.
                       Nota: non faccio controlli, ci pensano i vincoli macchina *)
                    vnCarrSup_Cmd := CMD_MOVETO;
                    vnCarrInf_Cmd := CMD_MOVETO;
                    Status := CARSTS_WAITBOTH;
                END_IF;

            ELSIF vnCarriages_Cmd=CARCMD_GRAB THEN
                (* Sequenza di presa lastra a 'vqGrab_Ygrab' con angolo iniziale 'vqGrab_Agrab' [-180÷180 mdeg] e rotazione 'vqGrab_Arot' *)
                vqGrab_Agrab := fnAngle180_mdeg(vqGrab_Agrab); (* Normalizzo angolo (-180E3÷180E3] *)
                dlog( Txt:='fbCarriages: GrabRot %ldx%ld A=%ld + %ld deg', Lvl:=4, Val1:=vqGrab_GlassWidth/1E3, Val2:=(vqGrab_GlassYtop-vqGrab_GlassYbtm)/1E3, Val3:=vqGrab_Agrab/1E3, Val4:=vqGrab_Arot/1E3 );

                ProbeInf( Activate:=FALSE ); (* Possibilità di ricerca al volo con sonda su CarrInf (cambio target) *)

                (* Controllo dei requisiti *)
                (* Angolo di rotazione *)
                IF ABS(vqGrab_Arot)>180E3 THEN
                    dlog( Txt:='!! Invalid rot Da=%ld>180 deg', Lvl:=1, Val1:=vqGrab_Arot/1E3 );
                    Status := STS_ERROR;
                (* La larghezza lastra deve essere valida *)
                ELSIF vqGrab_GlassWidth<vqGrabber_Radius THEN
                    dlog( Txt:='!! Cannot rot W=%ld mm', Lvl:=1, Val1:=vqGrab_GlassWidth/1E3 );
                    Status := STS_ERROR;
                (* Lo spessore deve essere agguantabile dalla pinza *)
                ELSIF vqGlass_Thckn > vqGrab_MaxGlassThckn THEN
                    dlog( Txt:='!! Thick sheet %ld > %ld mm not grabbable', Lvl:=1, Val1:=vqGlass_Thckn/1E3, Val2:=vqGrab_MaxGlassThckn/1E3 );
                    Status := STS_ERROR;
                (* Il carrello superiore deve essere in parcheggio *)
                ELSIF NOT Sup.AtRest THEN
                    dlog( Txt:='!! Cannot rot with CarrSup not at rest', Lvl:=1 );
                    SET_MSG(MSG_NOTPARKED,'MSG_NOTPARKED: CarrSup',0);
                    (* vnCarrSup_Cmd := CMD_PARK; *)
                    Status := STS_ERROR;
                (* Lo stacco deve essere in parcheggio?
                ELSIF NOT vb[ivbAtRest+ID_DTCH] THEN
                    dlog( Txt:='fbCarriages: !! Non inizio a ruotare con Stacco non in park', Lvl:=1 );
                    SET_MSG(MSG_NOTPARKED,'MSG_NOTPARKED: Dtch',0);
                    Status := STS_ERROR; *)
                (* Vedi se bisogna ricercare la lastra (se non la ricerco al volo) *)
                ELSIF (vqGrab_GlassYtop<=vqGrab_GlassYbtm OR vqGrab_GlassYbtm=NO_POS_UM OR vqGrab_GlassYtop=NO_POS_UM)
                      AND NOT vbGrab_OnTheFlySearch THEN
                    (* dlog( Txt:='fbCarriages: !! Invalid edges (%ld-%ld mm)', Lvl:=1, Val1:=vqGrab_GlassYbtm/1E3, Val2:=vqGrab_GlassYtop/1E3 );
                    Status := STS_ERROR; *)
                    dlog( Txt:='Searching before grab', Lvl:=4 );
                    IF vnCarrSup_Cmd=0 THEN
                        vnCarrSup_Cmd := CARCMD_SRCHGLASS;
                        Status := CARSTS_SRCH_SWEEP; (* Attendo ricerca con carrello superiore *)
                    ELSE
                        dlog( Txt:='!! Cannot search sheet (%d)', Lvl:=2, Val1:=TO_DINT(vnCarrSup_Cmd) );
                        Status := STS_ERROR;
                    END_IF;
                (* L'altezza lastra, se nota, deve essere valida *)
                ELSIF (vqGrab_GlassYtop-vqGrab_GlassYbtm)<vqYph_DtchLast
                      AND vqGrab_GlassYbtm<>NO_POS_UM AND vqGrab_GlassYtop<>NO_POS_UM THEN
                    dlog( Txt:='!! Cannot rot H=%ld < %ld mm', Lvl:=1, Val1:=(vqGrab_GlassYtop-vqGrab_GlassYbtm)/1E3, Val2:=vqYph_DtchLast/1E3 );
                    Status := STS_ERROR;
                (* Se la lastra è posizionata troppo in alto, non ha senso *)
                ELSIF vqGrab_GlassYtop>(vqYinf_GrabTopPos+vqGrabber_DY-vqGrabber_Radius) THEN
                    dlog( Txt:='!! Wont rot Ytop=%ld mm', Lvl:=1, Val1:=vqGrab_GlassYtop/1E3 );
                    Status := STS_ERROR;
                (* Vedi se bisogna agganciare la pinza *)
                ELSIF vbGrabber_NotLocked THEN
                    (* ASSERTING(vnCarrInf_Cmd=0,'vnCarrInf_Cmd!=0') *)
                    dlog( Txt:='Locking grabber', Lvl:=4 );
                    vnCarrInf_Cmd := CARCMD_TRAIL_LOCK;
                    Status := CARSTS_TRAIL_LOCK; (* Attendo sequenza di aggancio *)
                ELSE
                    (* Ci sono i requisiti base *)
                    (* -Calcoli camme e valutazione fattibilità rotazione- *)
                    IF vqGrab_Agrab=0 AND vqGrab_Arot=90E3 THEN
                        vnGrab_RotType := 1; (* Rotazione +90° prodotto lato riscontro *)
                        dlog( Txt:='Algn rot %ldx%ld, %ld Kg', Lvl:=3, Val1:=vqGrab_GlassWidth/1E3, Val2:=(vqGrab_GlassYtop-vqGrab_GlassYbtm)/1E3, Val3:=TO_DINT(vdRot_Mass) );
                        CalcRotAlgn(); (* Ricalcolo la rotazione (Nota: Usa ultimo What impostato) *)
                        IF NOT CalcRotAlgn.Ok THEN
                            dlog( Txt:='!! Cannot rot on algn', Lvl:=1 );
                            Status := STS_ERROR;
                        END_IF;
                    ELSIF vqGrab_Agrab=0 AND vqGrab_Arot=-90E3 THEN
                        vnGrab_RotType := 2; (* Rotazione -90° lastra lato stacco *)
                        dlog( Txt:='!! Dtch rot %ldx%ld, %ld Kg not avail', Lvl:=1, Val1:=vqGrab_GlassWidth/1E3, Val2:=(vqGrab_GlassYtop-vqGrab_GlassYbtm)/1E3, Val3:=TO_DINT(vdRot_Mass) );
                        (* TODO 4: supporta rotazioni stacco? *)
                        Status := STS_ERROR;
                    ELSE
                        vnGrab_RotType := 3; (* Rotazione generica *)
                        (* Sarebbe più sicuro fare i calcoli di fattibilità qui,
                           per ora sono fatti in 'Rotate-Slant.src' *)
                        (* CalcRotGen( A0:=vqGrab_Agrab, DA:=vqGrab_Arot ); *)
                        IF NOT vbSlantMode THEN
                            dlog( Txt:='!! Generic rot %ldx%ld A=%ld+%ld deg not avail', Lvl:=1, Val1:=vqGrab_GlassWidth/1E3, Val2:=(vqGrab_GlassYtop-vqGrab_GlassYbtm)/1E3, Val3:=vqGrab_Agrab/1E3, Val4:=vqGrab_Arot/1E3 );
                            Status := STS_ERROR;
                        END_IF;
                    END_IF; (* Calcoli camme e fattibilità rotazione *)

                    (* Il punto presa 'vqGrab_Ygrab' deve essere sul vetro,
                       con una certa tolleranza per eventuali compensazioni *)
                    IF (vqGrab_GlassYbtm<vqGrab_GlassYtop AND vqGrab_GlassYbtm<>NO_POS_UM AND vqGrab_GlassYtop<>NO_POS_UM) AND
                       (vqGrab_Ygrab>(vqGrab_GlassYtop+10E3) OR vqGrab_Ygrab<(vqGrab_GlassYbtm-10E3)) THEN (* vqGrabber_DX *)
                        dlog( Txt:='Ygrab=%ld outside glass (%ld|%ld)', Lvl:=2, Val1:=vqGrab_Ygrab/1E3, Val2:=vqGrab_GlassYbtm/1E3, Val3:=vqGrab_GlassYtop/1E3 );
                        Status := STS_ERROR;
                    END_IF;

                    (* Se ci sono i riscontri fermi e alti in zona rotazione, resettiamoli *)
                    IF vnAlgnBlocks_Sts>=TS_GOINGON AND vqAlgn_CurrX<vqRot_Xmax AND vnAlgn_Cmd=0 THEN
                        dlog( Txt:='! Resetting align blcks to rotate', Lvl:=5 );
                        vnAlgn_Cmd := CMD_PARK;
                    (* Se userò il piedino di aiuto, lo mando in zona per guadagnare tempo *)
                    ELSIF vbGrab_RotWithBlock THEN
                        vqAlgn_Tgt := vqAlgn_XrMinSafe + 10E3;
                        vnAlgn_Cmd := CMD_MOVETO;
                    END_IF;

                    (* -Se tutto ok, procedo- *)
                    IF Status<>STS_ERROR THEN
                        Status := CARSTS_GRAB_INIT;
                    END_IF; (* Procedo con la sequenza *)
                END_IF; (* -- Controllo requisiti sequenza presa pinza *)

            ELSIF vnCarriages_Cmd=CARCMD_FOLLOW THEN
                dlog( Txt:='fbCarriages: Follow (Ysup=%ld Yinf=%ld)', Lvl:=4, Val1:=Ysup.CurrPos/1E3, Val2:=Yinf.CurrPos/1E3 );
                MoveBoth := MV_LOCKMOVE;
                Status := CARSTS_FOLLOW_INI;
            ELSE
                dlog( Txt:='fbCarriages: !! Unknown cmd=%d', Lvl:=1, Val1:=TO_DINT(vnCarriages_Cmd));
                Status := STS_ERROR;
            END_IF; (* -- See command *)
        END_IF; (* -- Comando attivo *)


    (* ------------------------------------------------------------------- *)
    ELSE (* Errore sequenza (STS_ERROR) *)
        IF MoveBoth<MV_WAITSTOP THEN (* Movimento terminato *)
            Probe1( Activate:=FALSE );
            Probe2( Activate:=FALSE );
            ProbeInf( Activate:=FALSE );
            (* Assicuro sgancio eventuali inseguimenti *)
            (* Yinf.Cmd := AXC_STOP_ENAB; (* Slave movimenti: già fatto sotto *)

            (* -Finalizzo eventuale rotazione- vedi anche 'CARSTS_GRAB_DONE' *)
            (* Assicuro sgancio inseguimenti (non mi interessa uno stop sincrono) *)
            Zg.Cmd := AXC_STOP_ENAB; (* Master rotazione *)
            (* IF Yinf.Status=AXS_MOVING_FOL THEN *) Yinf.Cmd := AXC_STOP_ENAB; (* Slave movimenti/rotazione *)
            IF vnAlgn_Cmd=CMD_DRIVEN THEN vnAlgn_Cmd := CMD_STOP; END_IF; (* Piedino ausiliario lato riscontri *)
            (* IF Yb.Status=AXS_MOVING_FOL THEN Yb.Cmd := AXC_STOP_ENAB; END_IF; (* Piedino ausiliario polmone *)
            (* Se pinza agguantata e sono fermo la apro *)
            IF Grabber.Status=GSTS_GRABBED AND Zg.Still THEN vnGrabber_Cmd := GCMD_OPEN; END_IF;
            (* ELSE (* Altrimenti sarà il chiamante a dare parcheggio per chiudere la pinza *)
            vnGrab_RotStatus := 0; (* Assicuro di resettarlo *)
            (* Fermo eventuale cuscino aria *)
            vnVents_Cmd := vnVents_Cmd & NOT RequiredVents;
            RequiredVents := 0;

            (* Abortisci comandi e setta errore *)
            vnCarriages_Seq := SEQ_ERROR; (* Risultato di errore *)
            vnCarriages_Cmd := CMD_STOP; (* Eat command *)
            vnCarrSup_Cmd := CMD_STOP;
            vnCarrInf_Cmd := CMD_STOP;
            vnGrabber_Cmd := GCMD_NONE;
            Status := STS_IDLE;
        ELSIF MoveBoth>MV_WAITSTOP THEN
            (* Abortisci movimento *)
            MoveBoth := MV_WAITSTOP;
        END_IF;

END_CASE; (* -- state machine *)


(* - Servizio di movimentazione -
     movimenti in asse elettrico con utensili attivati *)
IF Status<>STS_IDLE THEN
    CASE MoveBoth OF

        MV_WAITMOVE : (* Attendi movimento verso quota obiettivo *)
            IF Ysup.Arrived AND Ysup.Cmd<>AXC_START_POS THEN
                (* Ok, master arrivato a destinazione *)
                IF MoveBothKeepLock THEN
                    MoveBothKeepLock := FALSE; (* Flag temporaneo: Non voglio sganciare l'inseguimento *)
                    MoveBoth := MV_DONE;
                ELSE
                    Yinf.Cmd := AXC_STOP_ENAB; (* Sgancio inseguimento *)
                    (* Attendo sgancio inseguimento *)
                    IF Yinf.Status=AXS_READY THEN (* Inseguimento sganciato *)
                        dlog( Txt:='fbCarriages: Both arrived (%ld mm)', Lvl:=6, Val1:=Ysup.TgtPos/1E3);
                        MoveBoth := MV_DONE;
                    END_IF;
                END_IF;
            ELSIF Ysup.Status<=AXS_READY THEN
                dlog( Txt:='fbCarriages: !! Ysup move aborted', Lvl:=1 );
                MoveBoth := MV_WAITSTOP;
            ELSIF vnCarriages_Cmd=CMD_STOP THEN (* Abort sequence *)
                dlog( Txt:='fbCarriages: !! MoveTo aborted', Lvl:=2 );
                Ysup.Cmd := AXC_STOP_ENAB; (* Stop asse master *)
                MoveBoth := MV_WAITSTOP;
            END_IF;

        MV_LOCKED : (* Carrello inferiore agganciato *)
            IF Yinf.Status<>AXS_MOVING_FOL THEN
                dlog( Txt:='fbCarriages: !! Yinf unlocked (Yinf=%ld Ysup=%ld)', Lvl:=1, Val1:=Yinf.CurrPos/1E3, Val2:=Ysup.CurrPos/1E3 );
                MoveBoth := MV_WAITSTOP;
            ELSIF Ysup.Status<AXS_READY THEN
                dlog( Txt:='fbCarriages: !! Ysup not ready (%d)', Lvl:=1, Val1:=TO_DINT(Ysup.Status) );
                MoveBoth := MV_WAITSTOP;
            ELSIF vnCarriages_Cmd<>CARCMD_FOLLOW THEN (* Abort sequence *)
            (* ELSIF vnCarriages_Cmd=CMD_STOP THEN *)
                (* dlog( Txt:='fbCarriages: ! Lock aborted', Lvl:=2 ); *)
                Ysup.Cmd := AXC_STOP_ENAB; (* Stop asse master *)
                MoveBoth := MV_WAITSTOP;
            END_IF;

        MV_WAITSTOP : (* Attendi stop asse master + sgancio inseguimento *)
            IF Ysup.Status<=AXS_READY THEN (* Asse master fermo? *)
                Yinf.Cmd := AXC_STOP_ENAB; (* Sgancio inseguimento *)
                IF Yinf.Status<=AXS_READY THEN
                    (* Ok entrambi gli assi sono fermi, notifico l'abort del posizionamento *)
                    MoveBoth := MV_ERROR;
                END_IF;
            END_IF;

        MV_LOCKMOVE, (* Prepara inseguimento *)
        MV_TOOLMOVE : (* Prepara movimento con utensile attivo *)
            (* Utensile già basso, assicura di aver acquisito risorse *)
            IF vnCarriages_Cmd=CMD_STOP THEN (* Abort *)
                dlog( Txt:='fbCarriages: !! Tool move init aborted', Lvl:=1 );
                MoveBoth := MV_WAITSTOP;
            ELSE (* ELSIF Ysup.Status=AXS_READY *)

                (* Aggancio carrelli - il master è CarrSup *)
                Yinf.MasterIdx := AX_YSUP;
                Yinf.MaxPosErr := WTR_DEFAULT;
                Yinf.Cmd := AXC_START_FOL;

                (* Cerco di acquisire le risorse necessarie *)
                IF UpperCutZone<>ID_CARR_SUP AND UpperCutZone=0 THEN UpperCutZone:=ID_CARR_SUP; END_IF;
                IF LowerCutZone_Algn<>ID_CARR_INF AND LowerCutZone_Algn=0 THEN LowerCutZone_Algn:=ID_CARR_INF; END_IF;
                IF LowerCutZone_Dtch<>ID_CARR_INF AND LowerCutZone_Dtch=0 THEN LowerCutZone_Dtch:=ID_CARR_INF; END_IF;
                (* Controlla di aver acquisito le risorse *)
                IF UpperCutZone=ID_CARR_SUP AND LowerCutZone_Algn=ID_CARR_INF AND LowerCutZone_Dtch=ID_CARR_INF THEN
                    (* Verifica se agganciato *)
                    IF Yinf.Status=AXS_MOVING_FOL AND Ysup.Status<>AXS_STOPPING THEN
                        (* Slave agganciato *)
                        IF Ysup.Status=AXS_READY THEN
                            (* Master pronto *)
                            IF MoveBoth=MV_TOOLMOVE THEN
                                dlog( Txt:='fbCarriages: Tool move to %ld mm', Lvl:=5, Val1:=vqCarrSup_Tgt/1E3);
                                (* Gli argomenti del posizionamento devo averli dati prima! *)
                                (* Ysup.TgtSpd := ...; (* [um/min] *)
                                (* Ysup.AccPerc := ...; (* [%] *)
                                (* Ysup.DecPerc := ...; (* [%] *)
                                (* Ysup.OutFrc := -1; (* max *)
                                (* Ysup.MaxPosErr := WTR_DEFAULT; *)
                                (* Se c'è il traino agganciato a uno dei due parzializzo le accelerazioni *)
                                IF Sup.Ext.Locked>0 OR Inf.Ext.Locked>0 THEN
                                    Ysup.AccPerc := fnPartializeAcc(Ysup.AccPerc, vnECarr_Acc);
                                    Ysup.DecPerc := fnPartializeAcc(Ysup.DecPerc, vnECarr_Acc);
                                END_IF;
                                (* Forzo silenziosamente la quota obiettivo entro i limiti sw *)
                                IF vqCarrSup_Tgt>Ysup.PosLim THEN
                                    dlog( Txt:='! Forcing tgt %ld>%ld', Lvl:=2, Val1:=vqCarrSup_Tgt/1E3, Val2:=Ysup.PosLim/1E3);
                                    vqCarrSup_Tgt := Ysup.PosLim;
                                ELSIF vqCarrSup_Tgt<Ysup.NegLim THEN
                                    dlog( Txt:='! Forcing tgt %ld<%ld', Lvl:=2, Val1:=vqCarrSup_Tgt/1E3, Val2:=Ysup.NegLim/1E3);
                                    vqCarrSup_Tgt := Ysup.NegLim;
                                END_IF;
                                Ysup.TgtPos := vqCarrSup_Tgt; (* [um] *)
                                Ysup.Cmd := AXC_START_POS;
                                MoveBoth := MV_WAITMOVE;
                            ELSE (* ELSIF MoveBoth=MV_LOCKMOVE THEN *)
                                Ysup.OutFrc := -1; (* vqYsup_OutFrc *)
                                Ysup.MaxPosErr := WTR_DEFAULT;
                                MoveBoth := MV_LOCKED;
                            END_IF;
                        ELSE
                            dlog( Txt:='!! Ysup not ready (%d)', Lvl:=1, Val1:=TO_DINT(Ysup.Status));
                            MoveBoth := MV_WAITSTOP;
                        END_IF;
                    (* ELSE dlog( Txt:='fbCarriages: Yinf (%d) not ready for tool move', Lvl:=1, Val1:=TO_DINT(Yinf.Status)); (* Attendi aggancio Yinf *)
                    END_IF;
                ELSE (* Altrimenti aspetta che si liberino *)
                    IF UpperCutZone=ID_CARR_SUP THEN UpperCutZone:=0; END_IF;
                    IF LowerCutZone_Algn=ID_CARR_INF THEN LowerCutZone_Algn:=0; END_IF;
                    IF LowerCutZone_Dtch=ID_CARR_INF THEN LowerCutZone_Dtch:=0; END_IF;
                END_IF;
            END_IF;

    END_CASE; (* -- servizio movimentazione *)
END_IF; (* -- Sequenza in corso *)



(* -- Carrello inferiore 'ID_CARR_INF' -- *)
Inf( Abort:=vbStopSignal OR NOT Inf.Allow ); (* vnCarrInf_Cmd *)

(* -- Carrello superiore 'ID_CARR_SUP' -- *)
Sup( Abort:=vbStopSignal OR NOT Sup.Allow ); (* vnCarrSup_Cmd *)


(* -- Monitors -- *)
(* GrabberUnderSup := Inf.GrabberYroomM<Sup.YroomP AND Inf.GrabberYroomP>Sup.YroomM; *)
Allow := Inf.Allow AND Sup.Allow;
AtRest := Inf.AtRest AND Sup.AtRest;
vnCarriages_Sts := Status;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbDetachMot

{ DE:"Detachment module (motorized)" }

	VAR_INPUT
	Allow : BOOL; { DE:"Consenso alle operazioni dei riscontri" }
	Abort : BOOL; { DE:"Segnale di stop/annullamento sequenza" }
	END_VAR

	VAR_OUTPUT
	ID : INT := ID_DTCH; { DE:"Identificativo componente" }
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Stacco parcheggiato in posizione sicura" }
	END_VAR

	VAR_EXTERNAL
	LowerCutZone_Algn : INT; { DE:"Spazio sotto il piano nell'area di taglio lato risc" }
	LowerCutZone_Dtch : INT; { DE:"Spazio sotto il piano nell'area di taglio lato stacco" }
	UpperCutZone : INT; { DE:"Spazio sopra il piano all'interno del ponte di taglio" }
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vbAx_NoStillChkAtRest : BOOL; { DE:"Non controllare asse fermo nella condizione di parcheggio" }
	vbHeartBeat : BOOL; { DE:"Battito di vita ogni secondo" }
	Xs : fbM32Axis; { DE:"Asse stacco AX_XS" }
	IFC_XS_ZERO : BOOL; { DE:"Sensore azzeramento movimento stacco (0:engaged)" }
	IFC_XS_POSLIM : BOOL; { DE:"Finecorsa (min e max) movimento stacco (1:engaged)" }
	IFC_XS_PARK : BOOL; { DE:"Sensore stacco in posizione di riposo (completamente indietro, area taglio libera)" }
	vnDtch_Cmd : INT; { DE:"Comando stacco (vedi 'DTC_*')" }
	vnDtch_Seq : INT; { DE:"Risultato sequenza stacco" }
	vqDtch_Tgt : DINT; { DE:"Posizione obiettivo stacco [um]" }
	vqDtch_GlassWidth : DINT; { DE:"Larghezza lastra da trascinare con lo stacco [um]" }
	vqDtch_GlassXbck : DINT; { DE:"Ascissa bordo indietro lastra da trascinare con lo stacco [um]" }
	vqDtch_PullDx : DINT; { DE:"Incremento spostamenti durante trazione [um]" }
	vqDtch_FinalPullDx : DINT; { DE:"Ultima trazione prima del taglio con lametta [um]" }
	vqDtch_PullForce : DINT; { DE:"Forza di trazione stacco [mN]" }
	vqDtch_PullSpeed : DINT; { DE:"Velocità massima durante trazione [um/min]" }
	vqDtch_PullDwell : DINT; { DE:"Pausa tra un movimentino e l'altro [ms]" }
	vqDtch_FastPullSpd : DINT; { DE:"Velocità trazione plastico senza riscaldamento [um/min]" }
	vqDtch_MoveForce : DINT; { DE:"Limite forza nei movimenti liberi dello stacco [mN]" }
	vqDtch_MaxErrSep : DINT; { DE:"Soglia reset errore di inseguimento stacco durante separazione [um]" }
	vqDtch_DragSpd : DINT; { DE:"Velocità movimenti trascinamento vetro [um/min]" }
	vnDtch_PullAcc : INT; { DE:"Parzializzazione accelerazione durante trazione [%]" }
	vnDtch_DragAcc : INT; { DE:"Parzializzazione accelerazione trascinamento vetro [%]" }
	vqDtch_FwdSpur : DINT; { DE:"Sporgenza delle rotelline anteriori dello stacco [um]" }
	vqDtch_CurrX : DINT; { DE:"Posizione attuale del modulo di stacco [um]" }
	vqDtch_Xpull : DINT; { DE:"Distacco durante trazione [um]" }
	Carriages : fbCarriages; { DE:"Carrelli" }
	vnCarriages_Cmd : INT; { DE:"Comando carrelli coordinati (vedi CARCMD_SCORE_FWD,...)" }
	vnCarriages_Seq : INT; { DE:"Risultato sequenza combinata carrelli" }
	vnCarrSup_Cmd : INT; { DE:"Comando carrello superiore" }
	vnCarrInf_Cmd : INT; { DE:"Comando carrello inferiore" }
	vqCarrSup_CurrXroomM : DINT; { DE:"Posizione limite collisione con carrello superiore [um]" }
	vqCarrInf_CurrXroomM : DINT; { DE:"Posizione limite collisione con carrello inferiore [um]" }
	vqLamp_XroomM : DINT; { DE:"Posizione limite collisione con lampada [um]" }
	vnClampAlgn_Cmd : INT; { DE:"Comando discesa premilastra lato riscontri" }
	vqClampAlgn_P : DINT; { DE:"Spinta desiderata premilastra lato riscontri [mN]" }
	vqClamps_Phold : DINT; { DE:"Spinta premilastra per tenere il vetro durante il taglio [mN]" }
	vnClampDtch_Cmd : INT; { DE:"Comando discesa premilastra lato stacco" }
	vbClampDtch_AlmostUp : BOOL; { DE:"Segnale per anticipo attesa premilastra alto" }
	vqClampDtch_P : DINT; { DE:"Spinta desiderata premilastra lato stacco [mN]" }
	vnHoldPads_Cmd : INT; { DE:"Comando discesa tamponi fermavetro" }
	vqDtch_GrabMinWidth : DINT; { DE:"Minimo vetro pinzabile [um]" }
	vnAlgn_Cmd : INT; { DE:"Comando generale riscontri" }
	vqAlgn_CurrX : DINT; { DE:"Posizione attuale dei piedini riscontri selezionati [um]" }
	vqX_ClampAlgnP : DINT; { DE:"Quota X fine premilastra riscontri [um]" }
	BladeSup : fbPvbBladeSup; { DE:"Lametta superiore taglio plastico" }
	BladeInf : fbPvbBladeInf; { DE:"Lametta inferiore taglio plastico" }
	vbDtch_BladeSynch : BOOL; { DE:"Sincronizza i movimenti di trazione con tasteggio lametta" }
	vbBlade_Through : BOOL; { DE:"Segnale sfondamento plastico" }
	vbDtch_WithBlade : BOOL; { DE:"Separazione con lametta" }
	vqDtch_TearPull_Dx : DINT; { DE:"Ampiezza movimenti snervamento [um]" }
	vnDtch_TearPull_N : INT; { DE:"Numero di movimenti snervamento avanti indietro" }
	SelectRemnVents : fbSelectRemnVents; { DE:"Seleziona zone cuscino aria zona rimanenza" }
	vnVents_Cmd : INT; { DE:"Maschera comando gruppi ventilatori cuscino aria" }
	vbAirCushionReady : BOOL; { DE:"Stato complessivo del cuscino d'aria" }
	vbDtch_HoldGlassAlgn : BOOL; { DE:"Tieni fermo vetro su riscontri" }
	vqRemn_Width : DINT; { DE:"Dimensione longitudinale rimanenza del taglio [um]" }
	END_VAR

	VAR
	RequiredVents : INT; { DE:"Maschera dei ventilatori richiesti" }
	TPullDwell : Ton; { DE:"Pausa dopo un movimentino" }
	Xo : DINT; { DE:"Posizione di inizio trazione/pinzatura [um]" }
	Dx : DINT; { DE:"Incremento corrente della trazione [um]" }
	Xbck_o : DINT; { DE:"Posizione bordo indietro iniziale [um]" }
	Xbck_t : DINT; { DE:"Posizione bordo indietro desiderata di arrivo [um]" }
	TearPullCount : INT; { DE:"Contatore movimenti di trazione con strappo" }
	PrevStatus : INT; { DE:"Stato precedente" }
	END_VAR

	{ CODE:ST }(*    fbDetachMot (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Gestione sequenze del modulo di stacco motorizzato.
      Lo stacco motorizzato può occupare:
        .'UpperCutZone' (zona taglio alta - collisione carr sup)
        .'LowerCutZone_Dtch' (zona taglio bassa lato stacco - collisione carr inf)
        .'LowerCutZone_Algn' (zona taglio bassa lato risc - collisione lampada)

      DETAILS
      ----------------------------------------------
      Lo stacco motorizzato può invadere la zona di taglio
      e può collidere in ordine con:
       .Il carrello inferiore (posizione limite 'vqCarrInf_CurrXroomM')
       .Il carrello superiore (posizione limite 'vqCarrSup_CurrXroomM')
       .La lampada (posizione limite 'vqLamp_XroomM')
               ──────┐   │ │  ┌
                     │   └─┘CarrSup
               Dtch  │ ┌───┐  │
                 ►   │ │   │CarrInf
                     │ └───┘  │
               ──────┘     ●=Lamp
      La barra di troncaggio è solidale allo stacco:
      la posizione di parcheggio è funzionale all'
      allineamento della barra all'asse di taglio.
      Per quanto riguarda la separazione, il meccanismo
      degli spostamentini e i suoi vari parametri
      vqDtch_PullDxStd, vqDtch_PullDwell, ...
      servono solo perché spesso non si riesce davvero
      a controllare la trazione effettiva dello stacco.

      EXAMPLE OF USAGE
      ----------------------------------------------
      vqDtch_Tgt = -50 // [mm]
      vqDtch_PullForce = 5000 // [N]
      vqDtch_PullDx = vqDtch_PullDxStd // Spostamentini standard
      vqDtch_FinalPullDx = vqDtch_FinalPullStd
      vnDtch_Cmd = DTCMD_PULL
      WaitCond( vnDtch_Cmd==CMD_STOP ) // vn[ivnStatus+ID_DTCH]==STS_IDLE
      if( vnDtch_Seq!=SEQ_DONE )
          // Error
      endif
*)


(* -- Manage stop signal -- *)
IF Abort THEN
    vnDtch_Cmd := CMD_STOP;
(* ELSIF Suspend THEN (* Could suspend? servirebbe fermare l'asse e partire dallo step precedente *)
END_IF;
(* Notify abort *)
IF Status>STS_STOPPING AND vnDtch_Cmd=CMD_STOP THEN
    dlog( Txt:='fbDtchMot: !! Abort Sts=%d', Lvl:=3, Val1:=TO_DINT(Status) );
END_IF;


(* -- State machine -- *)
TPullDwell( in:=Status=DTSTS_PULLDWELL, pt:=TO_UDINT(vqDtch_PullDwell) );

CASE Status OF

    (* ------------------------------------------------------------------- *)
    DTSTS_WAITCARR : (* Attendendo sequenza positiva carrelli *)
        IF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF vnCarriages_Cmd=CMD_STOP THEN
            Status := SEL(vnCarriages_Seq=SEQ_DONE, STS_ERROR, PrevStatus );
        (* ELSIF vnCarrInf_Cmd=CMD_STOP THEN
            Status := SEL(vnCarrInf_Seq=SEQ_DONE, STS_ERROR, PrevStatus );
            END_IF; *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_MOVEINIT : (* Comando movimento libero con premilastra stacco alto *)
        IF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Se sto devo tenere fermo il vetro sui riscontri... *)
        ELSIF vbDtch_HoldGlassAlgn AND ( vn[ivnStatus+ID_CLAMP_ALGN]<CL_DOWN OR
                                         NOT vbAirCushionReady OR
                                         vn[ivnStatus+ID_BELTS_DTCH]>BLT_DISABLED OR
                                         vn[ivnStatus+ID_BELTS_DTCH]>ID_ROLLS_ALGN ) THEN
            (* ...Attendo premil risc basso, aria e trasportatori a riposo *)
            (* Comando i premilastra solo se cinghie/rulli riscontro bassi *)
            IF vn[ivnStatus+ID_ROLLS_ALGN]=BLT_DISABLED THEN
                vqClampAlgn_P := vqClamps_Phold; (* Traz * vqClamps_Kslip *)
                vnClampAlgn_Cmd := CLCMD_HOLD;
            END_IF;
        (* Prosegui solo quando premilastra stacco alto (o in salita) *)
        ELSIF vbClampDtch_AlmostUp THEN
            (* Se devo impegnare delle risorse, cerca di acquisirle *)
            IF vqDtch_Tgt>vqCarrInf_CurrXroomM AND LowerCutZone_Dtch<>ID THEN
                IF LowerCutZone_Dtch=ID_CARR_INF OR NOT Carriages.Inf.CutAreaFreed THEN
                    (* Il carrello inferiore mi sta bloccando... *)
                    (* ...Se è tutto fermo gli chiedo di liberare la zona taglio *)
                    IF vnCarriages_Cmd=CMD_STOP AND vnCarrInf_Cmd=CMD_STOP THEN
                        (* IF vnGrabber_Type=2 AND Grabber.Status<>GSTS_CLOSED THEN *)
                        dlog( Txt:='fbDtchMot: ! Clearing Carriages', Lvl:=3 );
                        vnCarriages_Cmd := CARCMD_FREEAREA;
                        (* dlog( Txt:='fbDtchMot: ! Parking CarrInf', Lvl:=3 );
                        vnCarrInf_Cmd := CARCMD_FREEAREA; *)
                        PrevStatus := Status;
                        Status := DTSTS_WAITCARR;
                    END_IF;
                (* Per velocizzare, acquisisco risorsa anche quando barra sta rientrando *)
                ELSIF LowerCutZone_Dtch=0 OR (LowerCutZone_Dtch=ID_BRKBAR AND vn[ivnStatus+ID_BRKBAR]<=TS_WAITOFF) THEN
                    LowerCutZone_Dtch:=ID;
                END_IF;
            END_IF;
            IF vqDtch_Tgt>vqLamp_XroomM AND LowerCutZone_Algn<>ID THEN
                (* Per velocizzare, acquisisco risorsa anche quando barra sta rientrando *)
                IF LowerCutZone_Algn=0 OR (LowerCutZone_Algn=ID_BRKBAR AND vn[ivnStatus+ID_BRKBAR]<=TS_WAITOFF) THEN
                    LowerCutZone_Algn:=ID;
                END_IF;
            END_IF;
            IF vqDtch_Tgt>vqCarrSup_CurrXroomM AND UpperCutZone<>ID THEN
                IF UpperCutZone=ID_CARR_SUP OR NOT Carriages.Sup.CutAreaFreed THEN
                    (* Il carrello superiore mi sta bloccando... *)
                    (* ...Se è tutto fermo gli chiedo di liberare la zona taglio *)
                    IF vnCarriages_Cmd=CMD_STOP AND vnCarrSup_Cmd=CMD_STOP THEN
                        dlog( Txt:='fbDtchMot: ! Clearing CarrSup', Lvl:=3 );
                        vnCarrSup_Cmd := CARCMD_FREEAREA;
                    END_IF;
                ELSIF UpperCutZone=0 THEN
                    UpperCutZone:=ID;
                END_IF;
            END_IF;
            (* Controlla di aver acquisito le risorse necessarie *)
            IF (vqDtch_Tgt<=vqCarrSup_CurrXroomM OR UpperCutZone=ID) AND
               (vqDtch_Tgt<=vqCarrInf_CurrXroomM OR LowerCutZone_Dtch=ID) AND
               (vqDtch_Tgt<=vqLamp_XroomM OR LowerCutZone_Algn=ID) THEN
                (* Posso comandare il movimento *)
                dlog( Txt:='fbDtchMot: Free move from %ld to %ld mm', Lvl:=5, Val1:=Xs.CurrPos/1E3, Val2:=vqDtch_Tgt/1E3);
                IF Xs.Status=AXS_READY THEN
                    Xs.TgtPos := vqDtch_Tgt; (* [um] *)
                    Xs.TgtSpd := 0; (* 0:max [um/min] *)
                    Xs.AccPerc := 100; (* max [%] *)
                    Xs.DecPerc := 100; (* max [%] *)
                    IF Xs.TgtPos<=Xs.HomePos THEN (* Xs.TgtPos<Xs.CurrPos *)
                        (* Nota: vqDtch_MoveForce deve essere tale da consentire il movimento
                                 di parcheggio con sopra un vetro pesante *)
                        Xs.OutFrc := vqDtch_MoveForce;
                        Xs.MaxPosErr := WTR_HITDET; (* ivqAx_LooseMaxPosErr *)
                    ELSE
                        (* Ci può essere sopra un vetro, devo spingere! *)
                        (* TODO 3: Adesso spingo al massimo, valutare forza tangenziale necessaria per limitare? *)
                        Xs.OutFrc := -1; (* max *)
                        Xs.MaxPosErr := WTR_DEFAULT; (* ivqAx_StrictMaxPosErr *)
                    END_IF;
                    Xs.Cmd := AXC_START_POS;
                    Status := STS_MOVING;
                ELSE
                    dlog( Txt:='!! Xs not ready (%d) to move', Lvl:=1, Val1:=TO_DINT(Xs.Status) );
                    Status := STS_ERROR;
                END_IF;
            ELSE
                (* Probabilmente non sono riuscito ad acquisire una o più risorse,
                   tenterò il prossimo giro *)
                IF UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
                IF LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
                IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_MOVING : (* Movimento libero *)
        IF Xs.Arrived THEN

            (* Se stavo tenendo fermo il vetro sui riscontri, via aria e alzo il premilastra *)
            IF vbDtch_HoldGlassAlgn THEN
                vbDtch_HoldGlassAlgn := FALSE; (* eat *)
                vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_DTCH;
                dlog( Txt:='fbDtchMot: Rising Algn Clamp', Lvl:=3 );
                vnClampAlgn_Cmd := CMD_STOP;
            END_IF;

            IF Xs.TgtPos=Xs.HomePos THEN
                (* Intendevo andare in parcheggio *)
                IF IFC_XS_PARK THEN
                    dlog( Txt:='fbDtchMot: Parked', Lvl:=5 );
                    (* RST_MSG_IF(MSG_DTCH_NOTATHOME); *)
                    vnDtch_Cmd := CMD_STOP;
                    vnDtch_Seq := SEQ_DONE;
                    Status := STS_IDLE;
                ELSE
                    dlog( Txt:='fbDtchMot: !! No IFC_XS_PARK at Home (%ld)', Lvl:=1, Val1:=Xs.TgtPos/1E3 );
                    (* SET_MSG(MSG_DTCH_NOTATHOME,'MSG_DTCH_NOTATHOME',0); *)
                    Status := STS_ERROR;
                END_IF;
            ELSE
                dlog( Txt:='fbDtchMot: Arrived (%ld)', Lvl:=5, Val1:=vqDtch_CurrX/1E3 );

                IF vnDtch_Cmd=DTCMD_MOVEGLASS THEN
                    (* Sequenza di movimentazione vetro:
                       Sono arrivato in quota di pinzatura, procedo a trascinare il vetro *)
                    (* Sono in posizione di pinzatura: Xo === vqDtch_Tgt === Xs.CurrPos *)
                    vqDtch_Tgt := Xo + (Xbck_t - Xbck_o); (* Posizione stacco di arrivo del trascinamento *)
                    vnClampAlgn_Cmd := CMD_STOP; (* Assicuro vetro libero lato riscontro *)
                    vnHoldPads_Cmd := 0;
                    vqClampDtch_P := vqClamps_Phold; (* In teoria dovrebbe essere vqClamps_Pgrab *)
                    vnClampDtch_Cmd := CLCMD_PRESS; (* Pinzo lato stacco *)
                    vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Accendo i ventilatori riscontro che servono *)
                    Status := DTSTS_DRAGINIT; (* Procedo a trascinare *)
                ELSE
                    (* Semplice comando di movimento *)
                    vnDtch_Cmd := CMD_STOP;
                    vnDtch_Seq := SEQ_DONE;
                    Status := STS_IDLE;
                END_IF;
            END_IF;

            (* Free possible acquired resources *)
            IF Xs.CurrPos<vqCarrSup_CurrXroomM AND UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
            IF Xs.CurrPos<vqLamp_XroomM AND LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
            IF Xs.CurrPos<vqCarrInf_CurrXroomM AND LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;

        ELSIF Xs.Status <= AXS_READY THEN
            dlog( Txt:='fbDtchMot: !! MOVING: Xs not ready', Lvl:=1 );
            Status := STS_ERROR;

        ELSIF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Xs.Cmd := AXC_STOP_ENAB;
            Status := STS_ERROR;
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_DRAGINIT : (* Comando movimento con vetro pinzato *)
        (* Attendo premilastra basso prima di comandare il movimento *)
        IF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Condizioni per trascinare il vetro: *)
        ELSIF vn[ivnStatus+ID_CLAMP_DTCH]>=CL_DOWN AND (* Vetro pinzato da stacco *)
              (vnDtch_Cmd<>DTCMD_MOVEGLASS OR (vb[ivbAtRest+ID_CLAMP_ALGN] AND vb[ivbAtRest+ID_HOLDPADS])) AND (* Vetro sbloccato lato riscontri se devo muoverlo *)
              vbAirCushionReady THEN (* Eventuale cuscino aria pronto *)
            (* Se devo impegnare delle risorse, cerca di acquisirle *)
            IF vqDtch_Tgt>vqCarrInf_CurrXroomM AND LowerCutZone_Dtch<>ID THEN
                IF LowerCutZone_Dtch=ID_CARR_INF OR NOT Carriages.Inf.CutAreaFreed THEN
                    (* Il carrello inferiore mi sta bloccando... *)
                    (* ...Se è tutto fermo gli chiedo di liberare la zona taglio *)
                    IF vnCarriages_Cmd=CMD_STOP AND vnCarrInf_Cmd=CMD_STOP THEN
                        (* IF vnGrabber_Type=2 AND Grabber.Status<>GSTS_CLOSED THEN *)
                        dlog( Txt:='fbDtchMot: ! Clearing Carriages', Lvl:=3 );
                        vnCarriages_Cmd := CARCMD_FREEAREA;
                        (* dlog( Txt:='fbDtchMot: ! Parking CarrInf', Lvl:=3 );
                        vnCarrInf_Cmd := CARCMD_FREEAREA; *)
                        PrevStatus := Status;
                        Status := DTSTS_WAITCARR;
                    END_IF;
                (* Per velocizzare, acquisisco risorsa anche quando barra sta rientrando *)
                ELSIF LowerCutZone_Dtch=0 OR (LowerCutZone_Dtch=ID_BRKBAR AND vn[ivnStatus+ID_BRKBAR]<=TS_WAITOFF) THEN
                    LowerCutZone_Dtch:=ID;
                END_IF;
            END_IF;
            IF vqDtch_Tgt>vqLamp_XroomM AND LowerCutZone_Algn<>ID THEN
                (* Per velocizzare, acquisisco risorsa anche quando barra sta rientrando *)
                IF LowerCutZone_Algn=0 OR (LowerCutZone_Algn=ID_BRKBAR AND vn[ivnStatus+ID_BRKBAR]<=TS_WAITOFF) THEN
                    LowerCutZone_Algn:=ID;
                END_IF;
            END_IF;
            IF vqDtch_Tgt>vqCarrSup_CurrXroomM AND UpperCutZone<>ID THEN
                IF UpperCutZone=ID_CARR_SUP OR NOT Carriages.Sup.CutAreaFreed THEN
                    (* Il carrello superiore mi sta bloccando... *)
                    (* ...Se è tutto fermo gli chiedo di liberare la zona taglio *)
                    IF vnCarriages_Cmd=CMD_STOP AND vnCarrSup_Cmd=CMD_STOP THEN
                        dlog( Txt:='fbDtchMot: ! Clearing CarrSup', Lvl:=3 );
                        vnCarrSup_Cmd := CARCMD_FREEAREA;
                    END_IF;
                ELSIF UpperCutZone=0 THEN
                    UpperCutZone:=ID;
                END_IF;
            END_IF;
            (* Controlla di aver acquisito le risorse necessarie *)
             IF (vqDtch_Tgt<=vqCarrSup_CurrXroomM OR UpperCutZone=ID) AND
                (vqDtch_Tgt<=vqCarrInf_CurrXroomM OR LowerCutZone_Dtch=ID) AND
                (vqDtch_Tgt<=vqLamp_XroomM OR LowerCutZone_Algn=ID) THEN
                (* Posso comandare il movimento *)
                dlog( Txt:='fbDtchMot: Dragging glass to %ld mm', Lvl:=5, Val1:=vqDtch_Tgt/1E3);
                IF Xs.Status=AXS_READY THEN
                    Xs.TgtPos := vqDtch_Tgt; (* [um] *)
                    Xs.TgtSpd := vqDtch_DragSpd; (* [um/min] *)
                    Xs.AccPerc := vnDtch_DragAcc; (* [%] *)
                    Xs.DecPerc := vnDtch_DragAcc; (* [%] *)
                    Xs.OutFrc := -1; (* max *)
                    Xs.MaxPosErr := WTR_DEFAULT;
                    Xs.Cmd := AXC_START_POS;
                    Status := DTSTS_DRAGGING;
                ELSE
                    dlog( Txt:='fbDtchMot: !! Xs not ready (%d) to drag', Lvl:=1, Val1:=TO_DINT(Xs.Status) );
                    Status := STS_ERROR;
                END_IF;
            ELSE
                (* Probabilmente non sono riuscito ad acquisire una o più risorse,
                   tenterò il prossimo giro *)
                IF UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
                IF LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
                IF LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_DRAGGING :
        IF Xs.Arrived THEN
            dlog( Txt:='fbDtchMot: Dragged (%ld mm)', Lvl:=5, Val1:=Xs.CurrPos/1E3 );
            (* Free possible acquired resources *)
            IF Xs.CurrPos<vqCarrSup_CurrXroomM AND UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
            IF Xs.CurrPos<vqCarrInf_CurrXroomM AND LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
            IF Xs.CurrPos<vqLamp_XroomM AND LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
            IF vnDtch_Cmd=DTCMD_MOVEGLASS THEN
                (* Sequenza di movimentazione vetro:
                   Ho trascinato il vetro, lo mollo e torno in parcheggio *)
                vqDtch_GlassXbck := Xbck_o + (Xs.CurrPos - Xo); (* Aggiorno la posizione *)
                (* Spengo l'aria e mollo il vetro *)
                (* vnVents_Cmd := vnVents_Cmd & NOT RequiredVents; *)
                vnVents_Cmd := vnVents_Cmd & BIT_VENT_OUTZONE; (* Spegnamo tutto *)
                vnClampDtch_Cmd := CMD_STOP;
                (* Proseguo tornando in parcheggio, tenendo il vetro se necessario *)
                vqDtch_Tgt := Xs.HomePos; (* [um] *)
                vbDtch_HoldGlassAlgn := vqDtch_GlassWidth<2000E3; (* Tengo il vetro se si può muovere *)
                vnDtch_Cmd := CMD_MOVETO;
            ELSE
                (* Semplice comando di trascinamento *)
                vnDtch_Cmd := CMD_STOP;
                vnDtch_Seq := SEQ_DONE;
                (* Nota: Ventilatori e premilastra sono gestiti dal chiamante *)
            END_IF;
            Status := STS_IDLE;
        ELSIF Xs.Status <= AXS_READY THEN
            dlog( Txt:='fbDtchMot: !! DRAGGING: Xs not ready', Lvl:=1 );
            Status := STS_ERROR;
        ELSIF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Xs.Cmd := AXC_STOP_ENAB;
            Status := STS_ERROR;
        (* Monitora movimento? Sarebbe solo per DTCMD_MOVEGLASS *)
        ELSIF Xs.CurrPos>vqDtch_GlassXbck THEN (* Prevedo situazioni in cui spingo avanti senza pinzare *)
            vqDtch_GlassXbck := Xbck_o + (Xs.CurrPos - Xo);
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_PULLINIT :
        vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Assicuro cuscino aria *)
        (* Attendo premilastra basso prima di comandare il movimento *)
        IF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Se sono arrivato alla corsa minima termino con errore,
           perché probabilmente è scivolato il vetro *)
        ELSIF Xs.CurrPos<(Xs.NegLim+vqDtch_PullDx) THEN (* LowerCutZone_Dtch<>ID_CARR_INF *)
            dlog( Txt:='fbDtchMot: !! No more pull space at %ld mm', Lvl:=2, Val1:=Xs.CurrPos/1E3 );
            Status := STS_ERROR;
        (* Attendo asse stacco pronto, premilastra pronto ed eventuale sync con lametta
           Nota: preferisco non attendere i ventilatori qui, non è così importante *)
        ELSIF Xs.Status=AXS_READY AND Xs.Cmd=AXC_STOP_ENAB AND
              vn[ivnStatus+ID_CLAMP_DTCH]>=CL_DOWN AND vn[ivnStatus+ID_CLAMP_ALGN]>=CL_DOWN AND
              (NOT vbDtch_BladeSynch OR (BladeSup.Stable AND BladeInf.Stable)) THEN
            (* Se qui possono muovere lo stacco pinzato al vetro
               Qualche osservazione per portare il vetro in trazione:
               .Poiché il movimento è sempre verso indietro, non devo impegnare
                alcuna risorsa, casomai si potrebbero liberare!
               .Non comando un unico movimento perché c'è il pericolo che
                l'errore dell'anello di posizione accumulato faccia
                muovere l'asse in modo incontrollato alla fine del
                movimento, proprio quando ripristino la coppia max

               Comando quindi un piccolo spostamento alla volta,
               azzerando di volta in volta l'errore di posizione.
               Poiché c'è poco controllo della forza di trazione e
               all'inizio il plastico è freddo, può essere furbo
               iniziare con movimenti piccoli per poi incrementarli
               progressivamente *)

            IF vnDtch_Cmd=DTCMD_DRAGTO THEN
                (* Dalla trazione possiamo passare direttamente al trascinamento
                   vetro, questo è il completamento naturale della separazione.
                   Il premilastra stacco è già basso: *)
                Status := DTSTS_DRAGINIT;

            ELSIF NOT vbBlade_Through THEN
                (* Proseguiamo con un altro movimento *)
                IF vnDtch_TearPull_N>0 AND vqDtch_TearPull_Dx>vqDtch_PullDx AND NOT vbDtch_WithBlade THEN
                    (* Niente lametta: Ricetta tira/molla per snervare il plastico *)
                    (* Tira/molla per N volte dopo aver separato un certo Dx *)
                    IF vqDtch_Xpull>vqDtch_TearPull_Dx AND TearPullCount<vnDtch_TearPull_N THEN
                        IF (Xo - Xs.CurrPos) > vqDtch_TearPull_Dx/2 THEN
                            (* Mollo: Torno quasi alla posizione di presa Xo *)
                            Dx := Xs.CurrPos - (Xo - vqDtch_PullDx);
                        ELSE
                            (* Tiro: Vado alla massima trazione raggiunta *)
                            Dx := Xs.CurrPos - (Xo - vqDtch_Xpull);
                            TearPullCount := TearPullCount + INT#1;
                        END_IF;
                    ELSE
                        Dx := vqDtch_PullDx; (* Normale movimentino di indietreggiamento *)
                    END_IF;
                    (* Tira/molla continuo con incremento posizioni * )
                    IF (Xo - Xs.CurrPos) < MAX(2*vqDtch_PullDx, vqDtch_Xpull-vqDtch_PullDx) THEN
                        (* Tiro: Vado un po' oltre la massima trazione raggiunta * )
                        Dx := Xs.CurrPos - (Xo - vqDtch_PullDx - vqDtch_Xpull);
                    ELSE
                        (* Mollo: Torno quasi alla posizione di presa Xo * )
                        Dx := Xs.CurrPos - (Xo - vqDtch_PullDx);
                    END_IF; *)
                ELSE
                    (* Normali movimentini incrementali *)
                    Dx := vqDtch_PullDx; (* Movimentino di indietreggiamento *)
                    (* TODO 3: Progressivo? Dx := SEL( vqDtch_Xpull>1E3, vqDtch_PullDx/2, vqDtch_PullDx ); *)
                    (* Dx := MIN(Dx, Xs.PosErrWnd); (* Già garantito se <= vqDtch_PullDx *)
                END_IF;

                IF Dx>0 THEN
                    (* Tiro: vado piano *)
                    Xs.TgtSpd := vqDtch_PullSpeed; (* [um/min] *)
                    Xs.AccPerc := vnDtch_PullAcc; (* [%] *)
                    Xs.DecPerc := vnDtch_PullAcc; (* [%] *)
                ELSE
                    (* Mollo: vado veloce *)
                    Xs.TgtSpd := vqDtch_FastPullSpd; (* [um/min] *)
                    Xs.AccPerc := 100; (* [%] *)
                    Xs.DecPerc := 100; (* [%] *)
                END_IF;
                Xs.OutFrc := vqDtch_PullForce; (* [mN] *)
                Xs.MaxPosErr := WTR_DISABLE;
                Xs.TgtPos := MAX( Xs.NegLim, Xs.CurrPos - Dx );
                Xs.Cmd := AXC_START_POS;
                Status := DTSTS_PULLING;
            ELSE
                (* Se la lametta ha sfondato, completo con una ultima trazione prima di tagliare *)
                Xs.TgtSpd := 2 * vqDtch_PullSpeed; (* [um/min] *)
                Xs.AccPerc := 100; (* max [%] *)
                Xs.DecPerc := 100; (* max [%] *)
                (* TODO 3: Potremmo aumentare leggermente la trazione dell'ultimo movimento? *)
                Xs.OutFrc := vqDtch_PullForce; (* [mN] *)
                Xs.MaxPosErr := WTR_DISABLE;
                Xs.TgtPos := Xs.CurrPos - MAX(0,vqDtch_FinalPullDx); (* Assicuro spostamento indietro *)
                Xs.Cmd := AXC_START_POS;
                dlog( Txt:='fbDtchMot: Blade through at %ld, final pull: %ld mm', Lvl:=4, Val1:=vqDtch_Xpull/1E3, Val2:=(Xs.CurrPos-Xs.TgtPos)/1E3 );
                Status := DTSTS_FINALPULL;
            END_IF; (* Rileva comando trascinamento o sfondamento lametta *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_PULLING :
        vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Assicuro cuscino aria *)
        vqDtch_Xpull := MAX(vqDtch_Xpull, Xo - Xs.CurrPos); (* Monitora lo scostamento del vetro *)
        IF Xs.Arrived OR Xs.Cmd<>AXC_START_POS THEN
            (* Free possible acquired resources *)
            IF Xs.CurrPos<vqCarrSup_CurrXroomM AND UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
            IF Xs.CurrPos<vqCarrInf_CurrXroomM AND LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
            IF Xs.CurrPos<vqLamp_XroomM AND LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;

            dlog( Txt:='fbDtchMot: Detached %ld um (%ld mm, err=%ld um, F=%ld N)', Lvl:=4, Val1:=vqDtch_Xpull, Val2:=Xs.CurrPos/1E3, Val3:=Xs.CurrPosErr, Val4:=Xs.OutFrc/1E3 );

            (* Resetto l'errore di inseguimento se necessario *)
            IF ABS(Xs.CurrPosErr) > vqDtch_MaxErrSep THEN
                Xs.Cmd := AXC_RESET; (* Nota: l'asse si fermerà con limite di coppia impostato e
                                              tornerà 'AXS_READY' dopo non meno di tre cicli PLC *)
            END_IF;
            (* PullCount := PullCount + INT#1; *)
            Status := DTSTS_PULLDWELL; (* Pause a little *)
        ELSIF Xs.Status<AXS_READY THEN
            dlog( Txt:='fbDtchMot: !! Xs not ready, pulled %ld mm', Lvl:=1, Val1:=vqDtch_Xpull/1E3);
            Status := STS_ERROR;
        ELSIF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            dlog( Txt:='fbDtchMot: !! Pull aborted after %ld mm', Lvl:=1, Val1:=vqDtch_Xpull/1E3);
            Xs.Cmd := AXC_STOP_ENAB;
            Status := STS_ERROR;
        (* La lametta ha sfondato? *)
        ELSIF vbBlade_Through THEN
            (* Se la lametta ha sfondato e sta tagliando il plastico, è
               desiderabile smettere di tirare, altrimenti accade questo:
               .Il tratto di plastico non ancora tagliato cede, strappandosi
               .Lo stacco si fionda al riferimento di posizione che non poteva raggiungere *)
            (* Resetto l'errore di inseguimento *)
            Xs.Cmd := AXC_RESET; (* Nota: l'asse si fermerà con limite di coppia impostato e
                                          tornerà 'AXS_READY' dopo non meno di tre cicli PLC *)
            Status := DTSTS_PULLINIT; (* Last pull *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_PULLDWELL : (* Pausa dopo un movimentino *)
        vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Assicuro cuscino aria *)
        IF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        ELSIF TPullDwell.q THEN
            Status := DTSTS_PULLINIT; (* See what to do next *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_FINALPULL : (* Ultima trazione prima del taglio lametta *)
        vqDtch_Xpull := MAX(vqDtch_Xpull, Xo - Xs.CurrPos); (* Monitora lo scostamento del vetro *)
        IF Xs.Arrived THEN
            (* Free possible acquired resources *)
            IF Xs.CurrPos<vqCarrSup_CurrXroomM AND UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
            IF Xs.CurrPos<vqCarrInf_CurrXroomM AND LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
            IF Xs.CurrPos<vqLamp_XroomM AND LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;

            dlog( Txt:='fbDtchMot: Final pull done, detached %ld mm (%ld mm, err=%ld um, F=%ld N)', Lvl:=4, Val1:=vqDtch_Xpull, Val2:=Xs.CurrPos/1E3, Val3:=Xs.CurrPosErr, Val4:=Xs.OutFrc/1E3 );
            (* Spegnere qui i ventilatori significa poi trascinare il vetro ad aria spenta! *)
            (* vnVents_Cmd := vnVents_Cmd & NOT RequiredVents; *)
            vnDtch_Cmd := CMD_STOP;
            vnDtch_Seq := SEQ_DONE;
            Status := STS_IDLE; (* Will respond to 'DTCMD_DRAGTO' command *)
        ELSIF Xs.Status < AXS_READY THEN
            dlog( Txt:='fbDtchMot: !! Xs not ready on final pull', Lvl:=1 );
            Status := STS_ERROR;
        ELSIF vnDtch_Cmd=CMD_STOP OR Xs.Cmd<>AXC_START_POS THEN (* Abort sequence *)
            Xs.Cmd := AXC_STOP_ENAB;
            Status := STS_ERROR;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_IDLE : (* Stacco non attivo *)
        (* Rispondi ai comandi *)
        IF vnDtch_Cmd<>CMD_STOP THEN
            RequiredVents := 0; (* Inizializzo settaggi *)
            vnDtch_Seq := SEQ_START; (*  Resetto risultato *)
            (* Vedi comando *)
            IF vnDtch_Cmd=CMD_PARK THEN
                IF AtRest THEN
                    (* Sono già in parcheggio! Non fare nulla e dai Ok *)
                    dlog( Txt:='fbDtchMot: Already in park at pos %ld mm', Lvl:=4, Val1:=Xs.CurrPos/1E3);
                    vnDtch_Seq := SEQ_DONE;
                    vnDtch_Cmd := CMD_STOP;

                    (* Free possible acquired resources *)
                    IF Xs.CurrPos<vqCarrSup_CurrXroomM AND UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
                    IF Xs.CurrPos<vqCarrInf_CurrXroomM AND LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
                    IF Xs.CurrPos<vqLamp_XroomM AND LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
                ELSE
                    (* Il parcheggio è un normale posizionamento, sempre indietro *)
                    vqDtch_Tgt := Xs.HomePos; (* [um] *)
                    (* vbDtch_HoldGlassAlgn è stato eventualmente settato *)
                    vnDtch_Cmd := CMD_MOVETO;
                END_IF;

            ELSIF vnDtch_Cmd=CMD_MOVETO THEN
                (* Movimento libero con premilastra alto *)
                (* Forzo la quota obiettivo entro i limiti sw *)
                IF vqDtch_Tgt>Xs.PosLim THEN
                    dlog( Txt:='fbDtchMot: ! Forcing tgt %ld>%ld', Lvl:=2, Val1:=vqDtch_Tgt/1E3, Val2:=Xs.PosLim/1E3);
                    vqDtch_Tgt := Xs.PosLim;
                ELSIF vqDtch_Tgt<Xs.NegLim THEN
                    dlog( Txt:='fbDtchMot: ! Forcing tgt %ld<%ld', Lvl:=2, Val1:=vqDtch_Tgt/1E3, Val2:=Xs.NegLim/1E3);
                    vqDtch_Tgt := Xs.NegLim;
                END_IF;

                vnClampDtch_Cmd := CMD_STOP; (* Assicuro premilastra stacco alto *)

                (* Posso richiedere di muovermi tenendo fermo il vetro sui riscontri *)
                IF vbDtch_HoldGlassAlgn THEN
                    (* Se ho i piedini di riscontro sotto il premilastra, li tolgo di mezzo *)
                    IF vqAlgn_CurrX<vqX_ClampAlgnP AND vnAlgn_Cmd=0 THEN (* See also Algn.UnderClamp *)
                        dlog( Txt:='fbDtchMot: Reset algn blks to clamp', Lvl:=3 );
                        vnAlgn_Cmd := CMD_PARK;
                    END_IF;

                    (* Comando subito i premilastra solo se cinghie/rulli riscontro già bassi *)
                    vqClampAlgn_P := vqClamps_Phold; (* Traz * vqClamps_Kslip *)
                    IF vn[ivnStatus+ID_ROLLS_ALGN]=BLT_DISABLED THEN
                        vnClampAlgn_Cmd := CLCMD_HOLD;
                    END_IF;

                    vnVents_Cmd := vnVents_Cmd OR BIT_VENT_DTCH;
                END_IF;

                Status := STS_MOVEINIT;

            ELSIF vnDtch_Cmd=DTCMD_PULL THEN
                (* Trazione vetro verso indietro *)
                (* Nota: è responsabilità del chiamante:
                        -Impostare la pressione del premilastra 'vqClampDtch_P'
                        -Impostare la forza di trazione 'vqDtch_PullForce'
                        -Impostare l'incremento di trazione 'vqDtch_PullDx' *)
                dlog( Txt:='fbDtchMot: Pull back glass at %ld mm F=%ld N', Lvl:=3, Val1:=Xs.CurrPos/1E3, Val2:=vqDtch_PullForce/1E3);
                vnClampDtch_Cmd := CLCMD_PRESS; (* vqClampDtch_P impostato esternamente! *)
                Xo := Xs.CurrPos; (* Ricorda la posizione iniziale di pinzatura *)
                vqDtch_Xpull := 0; (* [um] Distacco vetro/allungamento plastico *)
                vbBlade_Through := FALSE; (* Segnale usato per terminare la trazione *)
                (* Determino quali ventilatori piloterò e comincio ad accenderli *)
                SelectRemnVents( Xbck:= -vqRemn_Width - 90E3 );
                RequiredVents := SelectRemnVents.Mask & NOT BIT_VENT_DTCH;
                vnVents_Cmd := vnVents_Cmd OR RequiredVents;
                (* Per non incorrere in errori di inseguimento, mi assicuro
                   che gli incrementi siano entro la massima finestra *)
                IF ABS(vqDtch_PullDx) > Xs.PosErrWnd THEN
                    dlog( Txt:='fbDtchMot: Limit PullDx=%ld um to %ld um', Lvl:=1, Val1:=vqDtch_PullDx, Val2:=Xs.PosErrWnd );
                    vqDtch_PullDx := Xs.PosErrWnd;
                END_IF;
                (* Se l'asse non è pronto abortisco subito *)
                IF Xs.Status<>AXS_READY THEN
                    dlog( Txt:='fbDtchMot: !! Xs not ready (%d) for pulling', Lvl:=1, Val1:=TO_DINT(Xs.Status));
                    Status := STS_ERROR;
                ELSE
                    TearPullCount := 0;
                    Status := DTSTS_PULLINIT;
                END_IF;

            ELSIF vnDtch_Cmd=DTCMD_DRAGTO THEN
                (* Spostamento con premilastra chiuso *)
                (* Nota: è responsabilità del chiamante:
                         -Impostare la pressione del premilastra 'vqClampDtch_P'
                         -Accendere i ventilatori opportuni *)
                dlog( Txt:='fbDtchMot: Drag glass in %ld to %ld', Lvl:=3, Val1:=Xs.CurrPos/1E3, Val2:=vqDtch_Tgt/1E3);
                (* RequiredVents := vnVents_Cmd; (* Mi ricordo l'aria necessaria? *)
                vnClampDtch_Cmd := CLCMD_PRESS; (* vqClampDtch_P impostato esternamente! *)
                Status := DTSTS_DRAGINIT;

            ELSIF vnDtch_Cmd=DTCMD_MOVEGLASS THEN
                (* Servizio ad alto livello per movimentare del vetro di
                   dimensioni e posizione note (vqDtch_GlassWidth, vqDtch_GlassXbck)
                    .Valutazione pinzatura
                    .Pinzatura stando attenti a non muovere il vetro
                    .Movimento di trascinamento
                    .Parcheggio finale stando attenti a non muovere il vetro *)
                Xbck_o := vqDtch_GlassXbck; (* Posizione bordo indietro iniziale *)
                Xbck_t := vqDtch_Tgt; (* Posizione bordo indietro finale desiderata *)
                dlog( Txt:='fbDtchMot: Move glass from %ld to %ld', Lvl:=3, Val1:=Xbck_o/1E3, Val2:=Xbck_t/1E3);

                (* -Verifica precondizioni- *)
                (* Intercetto già arrivato *)
                IF ABS(Xbck_t-Xbck_o)<1E3 THEN
                    vnDtch_Cmd := CMD_STOP;
                    vnDtch_Seq := SEQ_DONE;
                    Status := STS_IDLE;
                (* Supporto solo la spinta vetro in avanti *)
                ELSIF Xbck_t<Xbck_o THEN
                    (* dlog( Txt:='fbDtchMot: !! Cannot pull back glass', Lvl:=1 ); *)
                    Status := STS_ERROR;
                ELSE
                    (* -Precondizioni ok- *)
                    (* Ventilatori riscontro che servono durante il trascinamento *)
                    RequiredVents := SEL(vqDtch_GlassWidth>=2000E3, BIT_VENT_ALGN_C, BIT_VENT_ALGN_C OR BIT_VENT_ALGN_M);
                    (* -Valuto pinzatura- *)
                    IF Xbck_o<(Xs.CurrPos-vqDtch_GrabMinWidth) OR vnClampDtch_Cmd<>CMD_STOP THEN
                        (* Il vetro è direttamente pinzabile dove sono, evito quindi la manovra di pinzaggio *)
                        (* Se il premilastra è già basso assumo che qualcuno abbia
                           fatto le debite considerazioni e il vetro sia già pinzato *)
                        Xo := Xs.CurrPos; (* Ricorda la posizione iniziale di pinzatura *)
                        vqDtch_Tgt := Xo + (Xbck_t - Xbck_o); (* Posizione stacco di arrivo del trascinamento *)
                        (* La posizione finale è raggiungibile? Se no potrei farla in due tempi... * )
                        IF vqDtch_Tgt>Xs.PosLim THEN
                            vqDtch_Tgt := Xs.PosLim;
                        END_IF; *)
                        vnClampAlgn_Cmd := CMD_STOP; (* Assicuro vetro libero lato riscontro *)
                        vnHoldPads_Cmd := 0;
                        vqClampDtch_P := vqClamps_Phold; (* In teoria dovrebbe essere vqClamps_Pgrab *)
                        vnClampDtch_Cmd := CLCMD_PRESS; (* Pinzo lato stacco *)
                        vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Accendo i ventilatori riscontro che servono *)
                        Status := DTSTS_DRAGINIT; (* Procedo a trascinare *)
                    ELSIF Xbck_o<Xs.CurrPos THEN
                        (* È sotto il premilastra ma non immediatamente pinzabile,
                           vediamo la posizione ottimale di pinzatura *)
                        (* Il massimo vetro pinzabile è: Xs.PosLim-Xbck_t
                           Tuttavia per minimizzare i vari spostamenti posso accontentarmi *)
                        Xo := Xbck_o + MIN(Xs.PosLim-Xbck_t-1E3, 2*vqDtch_GrabMinWidth);
                        (* Procedo con la manovra di pinzatura: se vetro non pensante è bene
                           tenerlo fermo col premilastra riscontro *)
                        (* Proseguo tornando in parcheggio, tenendo il vetro se necessario *)
                        vnClampDtch_Cmd := CMD_STOP; (* Assicuro premilastra stacco alto *)
                        vbDtch_HoldGlassAlgn := vqDtch_GlassWidth<2000E3; (* Tengo il vetro se si può muovere *)
                        vqDtch_Tgt := Xo; (* [um] *)
                        (* Stesse operazioni che faccio in CMD_MOVETO: *)
                        IF vbDtch_HoldGlassAlgn THEN
                            IF vqAlgn_CurrX<vqX_ClampAlgnP AND vnAlgn_Cmd=0 THEN vnAlgn_Cmd := CMD_PARK; END_IF;
                            vqClampAlgn_P := vqClamps_Phold; (* Traz * vqClamps_Kslip *)
                            vnClampAlgn_Cmd := CLCMD_HOLD;
                            vnVents_Cmd := vnVents_Cmd OR BIT_VENT_DTCH;
                        END_IF;
                        Status := STS_MOVEINIT;
                    ELSE
                        (* Se fuori dal premilastra può essere pinzabile o non pinzabile;
                           se devo portare il vetro avanti procedo comunque evitando la pinzatura
                           abbassando il premilastra e spingendo il vetro con l'estremità di esso.
                           Attenzione: Il vetro potrebbe essere spinto un po' di più dalle rotelline (vqDtch_FwdSpur) *)
                        Xo := Xbck_o; (* Per calcolare in modo corretto la posizione *)
                        (* vqDtch_Tgt := Xbck_t; (* - vqDtch_FwdSpur; *) (* No, lo setta il chiamante! *)
                        vnClampAlgn_Cmd := CMD_STOP; (* Assicuro vetro libero lato riscontro *)
                        vnHoldPads_Cmd := 0;
                        vqClampDtch_P := 0; (* Non mi serve schiacciare, devo solo abbassarlo *)
                        vnClampDtch_Cmd := CLCMD_CLOSE; (* Abbasso premil stacco per spingere *)
                        vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Accendo i ventilatori riscontro che servono *)
                        Status := DTSTS_DRAGINIT; (* Procedo a spingere *)
                    END_IF;

    	            (* La posizione finale è raggiungibile? *)
                    IF vqDtch_Tgt>Xs.PosLim OR vqDtch_Tgt<Xs.NegLim THEN
                        dlog( Txt:='fbDtchMot: !! tgt=%ld outside %ld|%ld', Lvl:=1, Val1:=vqDtch_Tgt/1E3, Val2:=Xs.NegLim/1E3, Val3:=Xs.PosLim/1E3 );
                        Status := STS_ERROR;
                    END_IF;
                END_IF; (* Precondizioni ok *)

                (* Notifico errore? *)
                IF Status=STS_ERROR THEN
                    dlog( Txt:='fbDtchMot: !! Cannot move glass from %ld to %ld', Lvl:=1, Val1:=Xbck_o/1E3, Val2:=Xbck_t/1E3 );
                END_IF;
            ELSE
                dlog( Txt:='fbDtchMot: !! Unknown cmd=%d', Lvl:=1, Val1:=TO_DINT(vnDtch_Cmd));
                Status := STS_ERROR;
            END_IF; (* -- See command *)
        END_IF; (* -- Comando attivo *)


    (* ------------------------------------------------------------------- *)
    ELSE (* Errore richiesta (STS_ERROR) *)
        vnDtch_Cmd := CMD_STOP; (* Resetto io il comando *)
        vnDtch_Seq := SEQ_ERROR; (* Risultato *)
        Status := STS_IDLE;
        (* Se stavo tenendo fermo il vetro sui riscontri *)
        IF vbDtch_HoldGlassAlgn THEN
            vbDtch_HoldGlassAlgn := FALSE; (* eat *)
            vnClampAlgn_Cmd := CMD_STOP;
            vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_DTCH;
        END_IF;
        (* Se stavo pilotando dei ventilatori *)
        IF RequiredVents>0 THEN
            vnVents_Cmd := vnVents_Cmd & NOT RequiredVents;
            RequiredVents := 0;
        END_IF;
        (* Free possible acquired resources *)
        IF Xs.CurrPos<vqCarrSup_CurrXroomM AND UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
        IF Xs.CurrPos<vqCarrInf_CurrXroomM AND LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;
        IF Xs.CurrPos<vqLamp_XroomM AND LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=SEL(vn[ivnStatus+ID_BRKBAR]=TS_OFF,ID_BRKBAR,0); END_IF;

END_CASE; (* -- state machine *)


(* -- Task a bassa priorità -- *)
IF vbHeartBeat THEN

    (* Messaggio attendendo stacco a riposo *)
    IF IS_MSG(MSG_DTCH_WAITATHOME) AND AtRest THEN
        RST_MSG(MSG_DTCH_WAITATHOME);
    END_IF;
    (* RST_MSG(MSG_DTCH_NOTATHOME); *)

END_IF; (* vbHeartBeat *)


(* -- Monitors -- *)
(* Segnali per prevenzione collisioni
    Entering_CarrInfZone := Xs.StopPos>vqCarrInf_CurrXroomM; (* LowerCutZone_Dtch
    Entering_CarrSupZone := Xs.StopPos>vqCarrSup_CurrXroomM; (* UpperCutZone
    Entering_LampZone := Xs.StopPos>vqLamp_XroomM; (* LowerCutZone_Algn
    Entering_AlgnZone := Xs.StopPos>Xr.CurrPos; (* LowerCutZone_Algn
*)
vqDtch_CurrX := Xs.CurrPos; (* Same as vq[ivqAx_CurrPos+AX_XS-1] *)
AtRest := IFC_XS_PARK AND (vbAx_NoStillChkAtRest OR Xs.Still) AND Xs.CurrPos<=vqCarrInf_CurrXroomM AND ABS(Xs.CurrPos-Xs.HomePos)<1E3 AND Status=STS_IDLE;

vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbDetachPneum

{ DE:"Detachment module (pneumatic)" }

	VAR_INPUT
	Allow : BOOL; { DE:"Consenso alle operazioni dei riscontri" }
	Abort : BOOL; { DE:"Segnale di stop/annullamento sequenza" }
	END_VAR

	VAR_OUTPUT
	ID : INT := ID_DTCH; { DE:"Identificativo componente" }
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Stacco parcheggiato in posizione sicura" }
	Pressure : DINT; { DE:"Pressione da richiedere alla proporzionale [mbar]" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vbHeartBeat : BOOL; { DE:"Battito di vita ogni secondo" }
	IFC_XS_PARK : BOOL; { DE:"Sensore stacco in posizione di riposo (completamente indietro, area taglio libera)" }
	IFC_XS_FORWARD : BOOL; { DE:"Stacco in posizione avanti per presa vetro (stacco pneumatico)" }
	IFC_XS_DETACHED : BOOL; { DE:"Stacco in posizione per taglio plastico (stacco pneumatico)" }
	O_XS_FORWARD : BOOL; { DE:"Cilindro stacco direzione avanti (stacco pneumatico)" }
	O_XS_BRAKE : BOOL; { DE:"Aziona freno cilindro stacco (stacco pneumatico)" }
	vnDtch_Cmd : INT; { DE:"Comando stacco (vedi 'DTC_*')" }
	vnDtch_Seq : INT; { DE:"Risultato sequenza stacco" }
	vqDtch_Tgt : DINT; { DE:"Posizione obiettivo stacco [um]" }
	vqDtch_PullForce : DINT; { DE:"Forza di trazione stacco [mN]" }
	vqDtch_MoveForce : DINT; { DE:"Limite forza nei movimenti liberi dello stacco [mN]" }
	vqDtch_PullDwell : DINT; { DE:"Pausa tra un movimentino e l'altro [ms]" }
	vqDtch_CurrX : DINT; { DE:"Posizione attuale del modulo di stacco [um]" }
	vqDtch_Xpull : DINT; { DE:"Distacco durante trazione [um]" }
	vqDtch_CylArea : DINT; { DE:"Area cilindri stacco [um mm]" }
	vnDtch_Pcyl_FreeMove : INT; { DE:"Pressione movimenti liberi [0.1bar]" }
	vnDtch_Pcyl_Braked : INT; { DE:"Pressione durante freno [0.1bar]" }
	vqXs_MaxForce : DINT; { DE:"Max sforzo strutturale asse stacco [mN]" }
	vqXs_Friction : DINT; { DE:"Forza resistente/attriti asse stacco [mN]" }
	vnClampAlgn_Cmd : INT; { DE:"Comando discesa premilastra lato riscontri" }
	vqClampAlgn_P : DINT; { DE:"Spinta desiderata premilastra lato riscontri [mN]" }
	vqClamps_Phold : DINT; { DE:"Spinta premilastra per tenere il vetro durante il taglio [mN]" }
	vnClampDtch_Cmd : INT; { DE:"Comando discesa premilastra lato stacco" }
	vbClampDtch_AlmostUp : BOOL; { DE:"Segnale per anticipo attesa premilastra alto" }
	vnHoldPads_Cmd : INT; { DE:"Comando discesa tamponi fermavetro" }
	vnAlgn_Cmd : INT; { DE:"Comando generale riscontri" }
	vqAlgn_CurrX : DINT; { DE:"Posizione attuale dei piedini riscontri selezionati [um]" }
	vqX_ClampAlgnP : DINT; { DE:"Quota X fine premilastra riscontri [um]" }
	BladeSup : fbPvbBladeSup; { DE:"Lametta superiore taglio plastico" }
	BladeInf : fbPvbBladeInf; { DE:"Lametta inferiore taglio plastico" }
	vbDtch_BladeSynch : BOOL; { DE:"Sincronizza i movimenti di trazione con tasteggio lametta" }
	vqBlade_StartDisp : DINT; { DE:"Soglia scostamento stacco per inizio tasteggio [um]" }
	vbBlade_Through : BOOL; { DE:"Segnale sfondamento plastico" }
	SelectRemnVents : fbSelectRemnVents; { DE:"Seleziona zone cuscino aria zona rimanenza" }
	vnVents_Cmd : INT; { DE:"Maschera comando gruppi ventilatori cuscino aria" }
	vbAirCushionReady : BOOL; { DE:"Stato complessivo del cuscino d'aria" }
	vbDtch_HoldGlassAlgn : BOOL; { DE:"Tieni fermo vetro su riscontri" }
	vqRemn_Width : DINT; { DE:"Dimensione longitudinale rimanenza del taglio [um]" }
	END_VAR

	VAR
	RequiredVents : INT; { DE:"Maschera dei ventilatori richiesti" }
	MovingFwd : BOOL; { DE:"Muovendo in avanti" }
	TBrakeReleased : Toff; { DE:"Freno rilasciato" }
	TArrived : Ton; { DE:"Arrivato in quota" }
	TLastPull : Ton; { DE:"Tempo ultima trazione" }
	END_VAR

	{ CODE:ST }(*    fbDetachPneum (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Gestione sequenze del modulo di stacco pneumatico.
      Introdotto per le macchine StratoS/ActiveE, abbiamo
      un cilindro sotto proporzionale e dei sensori
      per capire la posizione.

      DETAILS
      ----------------------------------------------
      La barra di troncaggio è solidale allo stacco:
      la posizione di parcheggio è funzionale all'
      allineamento della barra all'asse di taglio.
      Per quanto riguarda la separazione:
        -Si porta avanti lo stacco alla posizione di presa 'IFC_XS_FORWARD'
        -Si tira verso indietro con una certa pressione
        -Dopo un certo tempo si cambia pressione
        -Quando si arriva a 'IFC_XS_DETACHED' la lametta taglia
                           │---------------│
          IFC_XS_PARK    _┌─┐_             │
          IFC_XS_FORWARD                 _┌─┐_
          IFC_XS_DETACHED ─────────────┐____ _

      Assumo misure Active-E:
                                 -62 ←‒‒‒‒‒│‒‒‒‒→ 75
                                    -30 ←‒‒│
                                ─ ───┐ ─┐  │    ┌─── ─
                              Stacco │  │  │    │ Riscontri
                                ─ ───┘ ─┘  │    └─── ─
      Con queste misure, perché il vetro non cada ho
      che deve essere più largo di 2·(75+62)=274
      Nota: impostare queste quote negli opportuni parametri,
            la posizione stacco indietro è in vq[ivqAx_HomePos+AX_XS-1]
*)


(* -- Manage stop signal -- *)
IF Abort THEN
    vnDtch_Cmd := CMD_STOP;
(* ELSIF Suspend THEN (* Could suspend? servirebbe fermare l'asse e partire dallo step precedente *)
END_IF;
(* Notify abort *)
IF Status>STS_STOPPING AND vnDtch_Cmd=CMD_STOP THEN
    dlog( Txt:='fbDtchPneum: !! Abort Sts=%d', Lvl:=3, Val1:=TO_DINT(Status) );
END_IF;



(* -- State machine -- *)
(* TBrakeActivated( in:=O_XS_BRAKE, pt:=200 ); *)
TBrakeReleased( in:=O_XS_BRAKE, pt:=200 );
TArrived( in:=(O_XS_FORWARD AND IFC_XS_FORWARD) OR (NOT O_XS_FORWARD AND IFC_XS_PARK), pt:=300 );
(* TPullChange( in:=Status=DTSTS_PULLING, pt:=TO_UDINT(vqDtch_PullChange) ); *)
TLastPull( in:=Status=DTSTS_FINALPULL, pt:=1000 );

CASE Status OF

    (* ------------------------------------------------------------------- *)
    STS_MOVEINIT : (* Comando movimento libero con premilastra alto *)
        (* Attendo premilastra alto prima di comandare il movimento *)
        IF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Se sto tenendo fermo il vetro sui riscontri... *)
        ELSIF vbDtch_HoldGlassAlgn AND ( vn[ivnStatus+ID_CLAMP_ALGN]<CL_DOWN OR
                                         NOT vbAirCushionReady OR
                                         vn[ivnStatus+ID_BELTS_DTCH]>BLT_DISABLED ) THEN
            (* ...Attendo premil risc basso, aria e trasportatori a riposo *)
            (* Comando i premilastra solo se cinghie/rulli riscontro bassi *)
            IF vn[ivnStatus+ID_ROLLS_ALGN]=BLT_DISABLED THEN
                vqClampAlgn_P := vqClamps_Phold; (* Traz * vqClamps_Kslip *)
                vnClampAlgn_Cmd := CLCMD_HOLD;
            END_IF;
        (* Prosegui solo quando premilastra stacco alto e freno rilasciato *)
        ELSIF vbClampDtch_AlmostUp AND TBrakeReleased.q THEN
            (* Posso comandare il movimento *)
            dlog( Txt:='fbDtchPneum: Free move from %ld to %ld mm', Lvl:=5, Val1:=vqDtch_CurrX/1E3, Val2:=vqDtch_Tgt/1E3);

            (* Pressione da dare alla proporzionale P[bar] = (10 * F[N]) / A[mm²] *)
            (* Pressure := (100 * (LIMIT(Push,0,PushMax) + Fr) ) / (vqDtch_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)
            Pressure := 100 * TO_DINT(vnDtch_Pcyl_FreeMove); (* [mbar] *)

            O_XS_FORWARD := MovingFwd;

            Status := STS_MOVING;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_MOVING : (* Movimento *)
        IF TArrived.q THEN

            dlog( Txt:='fbDtchPneum: Moved ok (%ld)', Lvl:=5, Val1:=vqDtch_CurrX/1E3 );
            vnDtch_Cmd := CMD_STOP;
            vnDtch_Seq := SEQ_DONE;
            Status := STS_IDLE;

            (* A check * )
            IF IFC_XS_FORWARD AND IFC_XS_DETACHED THEN
                dlog( Txt:='fbDtchPneum: ! IFC_XS_DETACHED engaged', Lvl:=5 );
            END_IF; *)

            (* Se stavo tenendo fermo il vetro sui riscontri, spegni l'aria e alza il premilastra *)
            IF vbDtch_HoldGlassAlgn THEN
                vbDtch_HoldGlassAlgn := FALSE; (* eat *)
                vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_DTCH;
                dlog( Txt:='fbDtchPneum: Rising Algn Clamp', Lvl:=3 );
                vnClampAlgn_Cmd := CMD_STOP;
            END_IF;

            (* Free possible acquired resources * )
            IF vqDtch_CurrX<vqLamp_XroomM AND LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=0; END_IF;
            IF vqDtch_CurrX<vqCarrSup_CurrXroomM AND UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
            IF vqDtch_CurrX<vqCarrInf_CurrXroomM AND LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=0; END_IF; *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_DRAGINIT : (* Comando movimento con premilastra basso *)
        IF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Prosegui solo quando premilastra stacco basso e freno rilasciato *)
        ELSIF vn[ivnStatus+ID_CLAMP_DTCH]>=CL_DOWN AND TBrakeReleased.q THEN
            (* Posso comandare il movimento *)
            dlog( Txt:='fbDtchPneum: Dragging from %ld to %ld mm', Lvl:=5, Val1:=vqDtch_CurrX/1E3, Val2:=vqDtch_Tgt/1E3);

            (* Pressione da dare alla proporzionale P[bar] = (10 * F[N]) / A[mm²] *)
            (* Pressure := (100 * (LIMIT(Push,0,PushMax) + Fr) ) / (vqDtch_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)
            Pressure := 100 * TO_DINT(vnDtch_Pcyl_FreeMove); (* [mbar] *)

            O_XS_FORWARD := MovingFwd;

            Status := DTSTS_DRAGGING;
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_DRAGGING :
        IF TArrived.q THEN
            dlog( Txt:='fbDtchPneum: Drag done', Lvl:=5 );
            vnDtch_Cmd := CMD_STOP;
            vnDtch_Seq := SEQ_DONE;
            Status := STS_IDLE;

            (* Nota: Ventilatori e premilastra sono gestiti dal chiamante *)

            (* Free possible acquired resources * )
            IF vqDtch_CurrX<vqLamp_XroomM AND LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=0; END_IF;
            IF vqDtch_CurrX<vqCarrSup_CurrXroomM AND UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
            IF vqDtch_CurrX<vqCarrInf_CurrXroomM AND LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=0; END_IF; *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_PULLINIT :
        vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Assicuro cuscino aria *)
        (* Attendo premilastra basso prima di comandare il movimento *)
        IF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            Status := STS_ERROR;
        (* Se sono arrivato alla corsa minima termino con errore,
           perché probabilmente è scivolato il vetro *)
        ELSIF IFC_XS_PARK THEN
            dlog( Txt:='fbDtchPneum: !! PULLINIT: IFC_XS_PARK', Lvl:=2 );
            Status := STS_ERROR;
        (* Attendo premilastra pronto ed eventuale sync con lametta
           Nota: preferisco non attendere i ventilatori qui, non è così importante *)
        ELSIF vn[ivnStatus+ID_CLAMP_DTCH]>=CL_DOWN AND vn[ivnStatus+ID_CLAMP_ALGN]>=CL_DOWN AND
              TBrakeReleased.q AND (NOT vbDtch_BladeSynch OR (BladeSup.Stable AND BladeInf.Stable)) THEN
            (* Pressione da dare alla proporzionale P[bar] = (10 * F[N]) / A[mm²] *)
            Pressure := (100 * (LIMIT(vqDtch_PullForce,0,vqXs_MaxForce) + vqXs_Friction) ) / (vqDtch_CylArea/100); (* DANGER_DIVISION_BY_ZERO *)
            O_XS_FORWARD := FALSE; (* Tira indietro *)
            Status := DTSTS_PULLING;
        END_IF;


    (* ------------------------------------------------------------------- *)
    DTSTS_PULLING :
        vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Assicuro cuscino aria *)

        IF vnDtch_Cmd=DTCMD_DRAGTO THEN
            (* Dalla trazione possiamo passare direttamente al trascinamento
               vetro, questo è il completamento naturale della separazione.
               Il premilastra stacco è già basso: *)
            O_XS_BRAKE := FALSE;
            MovingFwd := FALSE;
            vnVents_Cmd := vnVents_Cmd OR RequiredVents; (* Assicuro cuscino aria *)
            Status := DTSTS_DRAGINIT;

        ELSIF vbBlade_Through THEN
            (* La lametta ha "sfondato" il plastico *)
            dlog( Txt:='fbDtchPneum: Blade passed through', Lvl:=4 );
            IF vqDtch_FinalPullDx>0 THEN
                (* Completo con una ultima trazione prima di tagliare *)
                Status := DTSTS_FINALPULL;
            ELSE
                (* Blocco lo stacco col freno *)
                Pressure := 100 * TO_DINT(vnDtch_Pcyl_Braked); (* [mbar] *)
                O_XS_BRAKE := TRUE;
                Status := DTSTS_PULLDWELL;
            END_IF;

        ELSIF vnDtch_Cmd=CMD_STOP THEN (* Abort sequence *)
            dlog( Txt:='fbDtchPneum: !! Pull aborted after %ld mm', Lvl:=1, Val1:=vqDtch_Xpull/1E3);
            Pressure := 0;
            Status := STS_ERROR;
        ELSE
            (* Monitora lo scostamento del vetro *)
            (* Nota: La lametta parte a tasteggiare quando: vqDtch_Xpull >= vqBlade_StartDisp
                     E parte a tagliare allo sfondamento; se vbBlade_WaitFinalPull attende
                     anche stacco in Status=STS_IDLE *)
            IF IFC_XS_DETACHED AND vqDtch_Xpull<vqBlade_StartDisp THEN
                dlog( Txt:='fbDtchPneum: Detached', Lvl:=4 );
                (* Fai partire il tasteggio lametta *)
                vqDtch_Xpull := vqBlade_StartDisp;
            END_IF;

            (* Cambio pressione di trazione dopo un certo tempo *)
            (* IF TPullChange.q THEN Pressure := ... *)
        END_IF; (* Rileva comando trascinamento o sfondamento lametta *)


    (* ------------------------------------------------------------------- *)
    DTSTS_PULLDWELL : (* Freno tirato durante taglio plastico *)
        (* IF TBrakeActivated.q THEN *)
        Status := STS_IDLE; (* Dovrei attendere lametta *)


    (* ------------------------------------------------------------------- *)
    DTSTS_FINALPULL : (* Ultima trazione prima del taglio lametta *)
        IF TLastPull.q THEN
            (* Blocco lo stacco col freno *)
            Pressure := 100 * TO_DINT(vnDtch_Pcyl_Braked); (* [mbar] *)
            O_XS_BRAKE := TRUE;
            Status := DTSTS_PULLDWELL;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STS_IDLE : (* Stacco non attivo *)
        (* Rispondi ai comandi *)
        IF vnDtch_Cmd<>CMD_STOP THEN
            RequiredVents := 0; (* Inizializzo settaggi *)
            vnDtch_Seq := SEQ_START; (*  Resetto risultato *)
            (* Vedi comando *)
            IF vnDtch_Cmd=CMD_PARK THEN
                IF AtRest THEN
                    (* Sono già in parcheggio! Non fare nulla e dai Ok *)
                    dlog( Txt:='fbDtchPneum: Already in park at pos %ld mm', Lvl:=4, Val1:=vqDtch_CurrX/1E3);
                    vnDtch_Seq := SEQ_DONE;
                    vnDtch_Cmd := CMD_STOP;

                    (* Free possible acquired resources
                    IF vqDtch_CurrX<vqLamp_XroomM AND LowerCutZone_Algn=ID THEN LowerCutZone_Algn:=0; END_IF;
                    IF vqDtch_CurrX<vqCarrSup_CurrXroomM AND UpperCutZone=ID THEN UpperCutZone:=0; END_IF;
                    IF vqDtch_CurrX<vqCarrInf_CurrXroomM AND LowerCutZone_Dtch=ID THEN LowerCutZone_Dtch:=0; END_IF; *)
                ELSE
                    (* Il parcheggio è un normale posizionamento, sempre indietro *)
                    vqDtch_Tgt := -62E3; (* [um] Xs.HomePos *)
                    vnDtch_Cmd := CMD_MOVETO;
                END_IF;

            ELSIF vnDtch_Cmd=CMD_MOVETO THEN
                (* Movimento libero con premilastra alto *)

                vnClampDtch_Cmd := CMD_STOP; (* Assicuro premilastra alto *)
                vnHoldPads_Cmd := 0; (* Assicuro tamponi alti *)

                (* Posso richiedere di muovermi tenendo fermo il vetro sui riscontri *)
                IF vbDtch_HoldGlassAlgn THEN
                    (* Se ho i piedini di riscontro sotto il premilastra, li tolgo di mezzo *)
                    IF vqAlgn_CurrX<vqX_ClampAlgnP AND vnAlgn_Cmd=0 THEN (* See also Algn.UnderClamp *)
                        dlog( Txt:='fbDtchPneum: Reset algn blks to clamp', Lvl:=5 );
                        vnAlgn_Cmd := CMD_PARK;
                    END_IF;

                    (* Comando subito i premilastra solo se cinghie/rulli riscontro già bassi *)
                    vqClampAlgn_P := vqClamps_Phold; (* Traz * vqClamps_Kslip *)
                    IF vn[ivnStatus+ID_ROLLS_ALGN]=BLT_DISABLED THEN
                        vnClampAlgn_Cmd := CLCMD_HOLD;
                    END_IF;

                    vnVents_Cmd := vnVents_Cmd OR BIT_VENT_DTCH;
                END_IF;

                O_XS_BRAKE := FALSE; (* Ovviamente via freno *)

                (* Tipicamente per andare avanti alla quota di presa, comunque: *)
                MovingFwd := vqDtch_Tgt>-50E3; (* vqDtch_CurrX *)

                Status := STS_MOVEINIT;

            ELSIF vnDtch_Cmd=DTCMD_PULL THEN
                (* Trazione vetro verso indietro *)
                (* Nota: è responsabilità del chiamante:
                         -Impostare la pressione del premilastra 'vqClampDtch_P'
                         -Impostare la forza di trazione 'vqDtch_PullForce' *)
                dlog( Txt:='fbDtchPneum: Pull back glass at %ld mm F=%ld N', Lvl:=3, Val1:=vqDtch_CurrX/1E3, Val2:=vqDtch_PullForce/1E3);
                vnClampDtch_Cmd := CLCMD_PRESS; (* Pinzo il vetro *)
                vqDtch_Xpull := 0; (* [um] Distacco vetro/allungamento plastico *)
                vbBlade_Through := FALSE; (* Segnale usato per terminare la trazione *)
                (* Determino quali ventilatori piloterò e comincio ad accenderli *)
                SelectRemnVents( Xbck:= -vqRemn_Width - 90E3 );
                RequiredVents := SelectRemnVents.Mask & NOT BIT_VENT_DTCH;
                vnVents_Cmd := vnVents_Cmd OR RequiredVents;

                (* Se l'attuazione non è pronta abortisco subito * )
                IF PneumNotReady THEN
                    dlog( Txt:='fbDtchPneum: !! Not ready for pulling! (Status=%d)', Lvl:=1, Val1:=TO_DINT(Xs.Status));
                    Status := STS_ERROR;
                ELSE *)
                O_XS_BRAKE := FALSE; (* Ovviamente via freno *)

                Status := DTSTS_PULLINIT;

            ELSIF vnDtch_Cmd=DTCMD_DRAGTO THEN
                (* Spostamento con premilastra chiuso *)
                (* Nota: è responsabilità del chiamante:
                         -Impostare la pressione del premilastra 'vqClampDtch_P'
                         -Accendere i ventilatori opportuni *)
                dlog( Txt:='fbDtchPneum: Drag glass in %ld to %ld', Lvl:=3, Val1:=vqDtch_CurrX/1E3, Val2:=vqDtch_Tgt/1E3);

                vnClampDtch_Cmd := CLCMD_PRESS; (* Assicuro premilastra basso *)

                O_XS_BRAKE := FALSE; (* Ovviamente via freno *)

                (* Tipicamente per andare avanti alla quota di presa, comunque: *)
                MovingFwd := vqDtch_Tgt>-50E3; (* vqDtch_CurrX *)

                Status := DTSTS_DRAGINIT;
            (* ELSIF vnDtch_Cmd=DTCMD_MOVEGLASS THEN (* Not supported for pneumatic detach *)
            ELSE
                dlog( Txt:='fbDtchPneum: !! Unknown cmd=%d', Lvl:=1, Val1:=TO_DINT(vnDtch_Cmd));
                Status := STS_ERROR;
            END_IF; (* -- See command *)
        END_IF; (* -- Comando attivo *)


    (* ------------------------------------------------------------------- *)
    ELSE (* Errore richiesta (STS_ERROR) *)
        vnDtch_Cmd := CMD_STOP; (* Resetto io il comando *)
        vnDtch_Seq := SEQ_ERROR; (* Risultato *)
        (* Pressure := 0; *)
        Status := STS_IDLE;
        (* Se stavo tenendo fermo il vetro sui riscontri *)
        IF vbDtch_HoldGlassAlgn THEN
            vbDtch_HoldGlassAlgn := FALSE; (* eat *)
            vnClampAlgn_Cmd := CMD_STOP;
            vnVents_Cmd := vnVents_Cmd & NOT BIT_VENT_DTCH;
        END_IF;
        (* Se stavo pilotando dei ventilatori *)
        IF RequiredVents>0 THEN
            vnVents_Cmd := vnVents_Cmd & NOT RequiredVents;
            RequiredVents := 0;
        END_IF;

END_CASE; (* -- state machine *)


(* -- Task a bassa priorità -- *)
IF vbHeartBeat THEN

    (* Messaggio attendendo stacco a riposo *)
    IF IS_MSG(MSG_DTCH_WAITATHOME) AND AtRest THEN
        RST_MSG(MSG_DTCH_WAITATHOME);
    END_IF;

    (* RST_MSG(MSG_DTCH_NOTATHOME); *)

END_IF; (* vbHeartBeat *)


(* -- Monitors -- *)

(* Emulating position, assuming StratoS: *)
IF IFC_XS_PARK THEN
    vqDtch_CurrX := -62E3; (* [um] Park position: vq[ivqAx_HomePos+AX_XS-1] StratoS:-62E3 *)
ELSIF IFC_XS_FORWARD THEN
    vqDtch_CurrX := vqCarrSup_CurrXroomM; (* [um] Forward position StratoS:-30E3 *)
(* ELSIF NOT IFC_XS_DETACHED THEN
    vqDtch_CurrX := vqCarrSup_CurrXroomM - 1E3; (* [um] Somewhere near forward * )
ELSE
    vqDtch_CurrX := vqCarrSup_CurrXroomM - 10E3; (* [um] Somewhere in between *)
END_IF;
AtRest := IFC_XS_PARK AND NOT O_XS_FORWARD AND Status=STS_IDLE;

vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbTiltOut

{ DE:"Ribaltina scarico pezzi" }

	VAR_INPUT
	Allow : BOOL; { DE:"Consensi all'attuazione" }
	Abort : BOOL; { DE:"Segnale di stop/annullamento sequenza" }
	SelAutoMode : BOOL; { DE:"Attiva la modalità automatica" }
	NoBlocks : BOOL; { DE:"Forza temporaneamente piedini bassi" }
	END_VAR

	VAR_OUTPUT
	Requesting : BOOL; { DE:"Richiesta movimento in corso" }
	AutoReady : BOOL; { DE:"Pronta per basculamento automatico, piedini su" }
	GlassRemoved : BOOL; { DE:"Tolto vetro da ribaltina (impulso)" }
	Angle : DINT; { DE:"Inclinazione corrente [mdeg]" }
	Emerging : BOOL; { DE:"Uscendo fuori" }
	Descending : BOOL; { DE:"Abbassando con braccia piuttosto alte" }
	Status : INT; { DE:"Stato della ribaltina" }
	AtRest : BOOL; { DE:"Ribaltina bassa" }
	ID : INT := ID_TILTOUT; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vbHeartBeat : BOOL; { DE:"Battito di vita ogni secondo" }
	vdPlcScanTime : LREAL; { DE:"Tempo di scansione del PLC [s]" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	ivnStatus : INT; { DE:"Array stato sottosistemi !MAX_SUBSYS!" }
	ivbAtRest : INT; { DE:"Array sottosistemi a riposo !MAX_SUBSYS!" }
	vqTiltOut_Angle : DINT; { DE:"Inclinazione stimata ribaltina scarico pezzi [mdeg]" }
	fcOutzoneEnd : fbPhotoCell; { DE:"Fotocellula a fine linea (IFC_OUTZONE_END)" }
	fcOutzoneNearEnd : fbPhotoCell; { DE:"Fotocellula prossimità fine linea (IFC_OUTZONE_NEAREND)" }
	IFC_TILTOUT_GLASS : BOOL; { DE:"Sensore presenza vetro su ribaltina scarico pezzi" }
	IPR_TILTOUT : BOOL; { DE:"Protezione attuatore ribaltina scarico pezzi (0:OK)" }
	O_TILTOUT_ON : BOOL; { DE:"Accensione attuatore ribaltina scarico pezzi (pompa)" }
	O_TILTOUT_ON2 : BOOL; { DE:"Attivazione attuatore ribaltina scarico pezzi (olio in torretta)" }
	IFC_TILTOUT_BLOCKS_OUT : BOOL; { DE:"Sensore piedini fuori ribaltina scarico pezzi" }
	IFC_TILTOUT_UP : BOOL; { DE:"Sensore ribaltina scarico pezzi completamente alzata" }
	IFC_TILTOUT_DWN : BOOL; { DE:"Sensore ribaltina scarico pezzi a riposo" }
	ICM_TILTOUT_UP : BOOL; { DE:"Comando richiesta salita ribaltina scarico pezzi" }
	ICM_TILTOUT_DWN : BOOL; { DE:"Comando richiesta discesa ribaltina scarico pezzi" }
	O_TILTOUT_UP : BOOL; { DE:"Aziona salita ribaltina scarico pezzi" }
	O_TILTOUT_DWN : BOOL; { DE:"Aziona discesa ribaltina scarico pezzi" }
	I_SCU_POW_TILTOUT : BOOL; { DE:"Ribaltina scarico pezzi alimentata (1:Ok)" }
	O_SCU_TILTOUT_AUTO : BOOL; { DE:"Attiva evacuazione con ribaltina scarico pezzi" }
	vnTiltOut_Cmd : INT; { DE:"Comando ribaltina scarico pezzi (neg:descend 0:idle pos:raise)" }
	vbTiltOut_CanAutoUp : BOOL; { DE:"Permetti comando salita manuale ribaltina non mantenuto" }
	vqTiltOut_RemoveDelay : DINT; { DE:"Ritardo per vetro rimosso [ms]" }
	vnTiltOutArms_N : INT; { DE:"Numero delle braccia ribaltina" }
	vqTiltOut_Xbegin : DINT; { DE:"Inizio zona braccia ribaltina [um]" }
	vqTiltOut_OffDelay : DINT; { DE:"Ritardo spegnimento attuazione [ms]" }
	vqTiltOut_OnDelay : DINT; { DE:"Ritardo apertura olio in torretta [ms]" }
	vqTiltOut_CmdDelay : DINT; { DE:"Ritardo attivazione completa [ms]" }
	vqTiltOut_BumpDelay : DINT; { DE:"Ritardo per andare in battuta [ms]" }
	vqTiltOut_Speed : DINT; { DE:"Velocità di movimento [mdeg/s]" }
	vqTiltOut_MidAngle : DINT; { DE:"Soglia angolo per controllo fotocellule [mdeg]" }
	vnTiltOut_MinSpd : INT; { DE:"Velocità minima pompa oleodinamica ribaltina scarico pezzi [rpm]" }
	vnTiltOut_MaxSpd : INT; { DE:"Velocità massima pompa oleodinamica ribaltina scarico pezzi [rpm]" }
	vnTiltOut_AreadMin : INT; { DE:"Lettura inclinometro con ribaltina orizzontale [mV]" }
	vnTiltOut_AreadMax : INT; { DE:"Lettura inclinometro con ribaltina alta [mV]" }
	vqTiltOut_AnearLow : DINT; { DE:"Inclinazione rallentamento discesa ribaltina scarico pezzi [mdeg]" }
	vqTiltOut_AnearHigh : DINT; { DE:"Inclinazione rallentamento salita ribaltina scarico pezzi [mdeg]" }
	vqTiltOut_AngleMax : DINT; { DE:"Inclinazione massima ribaltina scarico pezzi [mdeg]" }
	END_VAR

	VAR
	OilActuation : fbOilActuation; { DE:"Centralina oleodinamica" }
	TBumpedDown : Ton; { DE:"Battuta bassa ben raggiunta" }
	TAutoCmdUp : Ton; { DE:"Comando salita automatica" }
	GlassWasOnFc : BOOL; { DE:"Vetro occupava IFC_TILTOUT_GLASS al momento della salita" }
	GlassRemovedDelayedPulse : fbDelayedRise; { DE:"Glass removed delayed event" }
	SelAutoModeOn : RiseEdge; { DE:"Changes of SelAutoMode" }
	FtcReadFilt : fbDebounceOn; { DE:"Filtering photocells for safety descend checks" }
	Inclination : fbAnalogInputNotNull; { DE:"Inclinometro" }
	TiltPump : fbECatInverter; { DE:"Inverter su EtherCAT, opportunamente mappato in par2kecat.txt" }
	END_VAR

	{ CODE:ST }(*    fbTiltOut (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa le logiche riguardanti la ribaltina
      scarico pezzi a fine linea.

      DETAILS
      ----------------------------------------------
      La ribaltina può essere usata manualmente ma
      è anche dotata di piedini per il basculamento
      automatico dei pezzi in uscita.
      Questa modalità va attivata con una uscita
      alla centralina di sicurezza, la quale
      gestisce l'uscita dei piedini automatici.

      USAGE
      ----------------------------------------------
      TiltOut : fbTiltOut; { DE:"Ribaltina scarico pezzi" }
*)

(* -- State machine -- *)
TBumpedDown( in:=Status=TL_BUMPDOWN AND O_TILTOUT_DWN, pt:=TO_UDINT(vqTiltOut_BumpDelay) );
CASE Status OF

    TL_FULLUP : (* Bumped up *)
        IF O_TILTOUT_DWN THEN
            dlog( Txt:='fbTiltOut: Descending', Lvl:=5 );
            Status := TL_GOINGDOWN;
        ELSIF vnTiltOut_Cmd>0 THEN
            vnTiltOut_Cmd := 0; (* Reset automatic rise command *)
        (* ELSIF NOT IFC_TILTOUT_UP THEN
            dlog( Txt:='fbTiltOut: ! Lost IFC_TILTOUT_UP while up', Lvl:=1 );
            Status := TL_STILL; *)
        END_IF;


    TL_BUMPUP : (* Bumping up *)
        Angle := vqTiltOut_AngleMax; (* Posizione alta [mdeg] *)
        IF IFC_TILTOUT_UP THEN (* TBumpedUp.q *)
            dlog( Txt:='fbTiltOut: Full Up', Lvl:=5 );
            Status := TL_FULLUP;
        ELSIF NOT O_TILTOUT_UP THEN
            Status := TL_STILL;
        END_IF;


    TL_GOINGUP : (* Rising *)
        (* Tengo aggiornata la stima dell'inclinazione corrente *)
        Angle := Angle + TO_DINT(TO_LREAL(vqTiltOut_Speed) * vdPlcScanTime); (* [mdeg] *)
        IF IFC_TILTOUT_UP THEN
            vnTiltOut_Cmd := 0; (* Reset automatic rise command *)
            dlog( Txt:='fbTiltOut: Up (%ld deg)', Lvl:=5, Val1:=Angle/1E3 );
            Status := TL_BUMPUP;
        ELSIF NOT O_TILTOUT_UP THEN
            dlog( Txt:='fbTiltOut: ! Stop up (%ld deg)', Lvl:=5, Val1:=Angle/1E3 );
            Status := TL_STILL;
        END_IF;


    TL_STILL : (* Standing somewhere still *)
        IF O_TILTOUT_UP THEN
            dlog( Txt:='fbTiltOut: Rising (%ld deg)', Lvl:=5, Val1:=Angle/1E3 );
            GlassWasOnFc := IFC_TILTOUT_GLASS;
            Status := TL_GOINGUP;
        ELSIF O_TILTOUT_DWN THEN
            dlog( Txt:='fbTiltOut: Descending (%ld deg)', Lvl:=5, Val1:=Angle/1E3 );
            Status := TL_GOINGDOWN;
        END_IF;


    TL_GOINGDOWN : (* Descending *)
        (* Tengo aggiornata la stima dell'inclinazione corrente *)
        Angle := Angle - TO_DINT(TO_LREAL(vqTiltOut_Speed) * vdPlcScanTime); (* [mdeg] *)
        IF IFC_TILTOUT_DWN THEN
            vnTiltOut_Cmd := 0; (* Reset automatic down command *)
            dlog( Txt:='fbTiltOut: Down (%ld deg)', Lvl:=5, Val1:=Angle/1E3 );
            Status := TL_BUMPDOWN;
        ELSIF NOT O_TILTOUT_DWN THEN
            dlog( Txt:='fbTiltOut: ! Stop down (%ld deg)', Lvl:=5, Val1:=Angle/1E3 );
            Status := TL_STILL;
        END_IF;


    TL_BUMPDOWN : (* Bumping down *)
        Angle := 0; (* Posizione bassa [mdeg] *)
        IF TBumpedDown.q THEN
            vnTiltOut_Cmd := 0; (* Ensure command reset *)
            IF IFC_TILTOUT_DWN THEN
                dlog( Txt:='fbTiltOut: Full down', Lvl:=5 );
                Status := TL_FULLDOWN;
            ELSE
                dlog( Txt:='fbTiltOut: ! Not bumped down', Lvl:=2 );
                Status := TL_STILL;
            END_IF;
        END_IF;


    TL_FULLDOWN : (* Bumped down *)
        IF O_TILTOUT_UP THEN
            dlog( Txt:='fbTiltOut: Emerging', Lvl:=5 );
            GlassWasOnFc := IFC_TILTOUT_GLASS;
            Status := TL_GOINGUP;
        ELSIF vnTiltOut_Cmd<0 THEN
            (* Si richiede impulso per andare in battuta *)
            Status := TL_BUMPDOWN;
            vnTiltOut_Cmd := 0; (* Eat *)
        ELSIF NOT IFC_TILTOUT_DWN THEN
            dlog( Txt:='fbTiltOut: ! Lost ICM_TILTOUT_DWN', Lvl:=2 );
            Angle := 10E3; (* [mdeg] *)
            Status := TL_STILL;
        END_IF;

END_CASE; (* -- state machine *)



(* -- Gestione inclinometro -- *)
IF AI_TILTOUT_TILTANG>0 THEN
    (* Lettura inclinometro *)
    Inclination( Index:=AI_TILTOUT_TILTANG, ReadMin:=vnTiltOut_AreadMin,
                                            ReadMax:=vnTiltOut_AreadMax,
                                            ValueMin:=0,
                                            ValueMax:=vqTiltOut_AngleMax,
                                            a:=0.007 ); (* 284÷568 ms *)
    IF Inclination.Ok THEN
        Angle := Inclination.Value; (* [mdeg] *)
    END_IF;
(* ELSE (* Non c'è inclinometro, la stima di 'Angle' è fatta nella macchina a stati *)
END_IF;



(* Salita automatica *)
TAutoCmdUp( in:=ICM_TILTOUT_UP AND Status<>TL_FULLUP AND vbTiltOut_CanAutoUp, pt:=1E3 );
IF TAutoCmdUp.q AND vnTiltOut_Cmd<>1 THEN
    dlog( Txt:='fbTiltOut: ! Auto up', Lvl:=3 );
    vnTiltOut_Cmd := 1;
END_IF;



(* -- Attivazione attuazione del basculamento -- *)
Requesting := vnTiltOut_Cmd<>0 OR ICM_TILTOUT_UP OR ICM_TILTOUT_DWN OR Status=TL_BUMPDOWN OR Status=TL_BUMPUP;
OilActuation( Request:=Requesting,
              Allow:=I_SCU_POW_TILTOUT,
              OffDelay:=TO_UDINT(vqTiltOut_OffDelay),
              OnDelay:=TO_UDINT(vqTiltOut_OnDelay),
              CmdDelay:=TO_UDINT(vqTiltOut_CmdDelay) );
O_TILTOUT_ON := OilActuation.PumpOutput;
O_TILTOUT_ON2 := OilActuation.OilOutput;



(* -- Attuazione basculamento braccia -- *)
O_TILTOUT_UP  := OilActuation.Ready AND  (* Attuazione pronta *)
                 Allow AND               (* Consensi ok *)
                 NOT O_TILTOUT_DWN AND   (* ...e non sta scendendo *)
                 ( (ICM_TILTOUT_UP AND NOT IFC_TILTOUT_UP) OR   (* Comando manuale (se non alta)... *)
                   Status=TL_BUMPUP OR   (* ...O andando in battuta alta *)
                   (vnTiltOut_Cmd>0 AND I_SCU_POW_TILTOUT) ); (* ...O comando automatico con sicurezze ok *)


O_TILTOUT_DWN := OilActuation.Ready AND  (* Attuazione pronta *)
                 Allow AND               (* Consensi ok *)
                 NOT O_TILTOUT_UP AND    (* ...e non sta salendo *)
                 ( ICM_TILTOUT_DWN OR    (* Comando manuale... *)
                   Status=TL_BUMPDOWN OR (* ...O andando in battuta bassa *)
                   (vnTiltOut_Cmd<0 AND I_SCU_POW_TILTOUT) ); (* ...O comando automatico con sicurezze ok *)


(* -- Reset dell'inibizione temporanea dei piedini automatici -- *)
SelAutoModeOn( in:=SelAutoMode );
IF SelAutoModeOn.q THEN
    dlog( Txt:='fbTiltOut: Auto On', Lvl:=5 );
    NoBlocks := FALSE;
END_IF;
(* Ai comandi manuali? * )
IF NoBlocks AND (ICM_TILTOUT_UP OR ICM_TILTOUT_DWN) THEN
    NoBlocks := FALSE;
END_IF; *)


(* -- Attivazione del funzionamento automatico --
   Richiesta alla centralina, è lei che gestisce opportunamente
   i piedini automatici, li fa uscire e rientrare solo in
   orizzontale, altrimenti è pericoloso: se ho un vetro sui
   piedini manuali... *)
(* TODO 4: Non sarebbe male evitare di rialzare i piedini
         se va via NoBlocks con IFC_OUTZONE_END
IF fcOutzoneEnd.q AND AtRest AND NOT O_SCU_TILTOUT_AUTO AND SelAutoMode AND NOT NoBlocks THEN
    O_SCU_TILTOUT_AUTO := NOT fcOutzoneEnd.q;
ELSE
    O_SCU_TILTOUT_AUTO := SelAutoMode AND NOT NoBlocks;
END_IF;
*)
O_SCU_TILTOUT_AUTO := SelAutoMode AND NOT NoBlocks;

(* Pronta per basculamento automatico, piedini su (gestiti da centralina di sicurezza) *)
AutoReady := O_SCU_TILTOUT_AUTO AND IFC_TILTOUT_BLOCKS_OUT;
(* I_SCU_POW_TILTOUT: È normale che vada via se l'operatore è in zona fine linea *)

(* Rileva se tolto vetro da ribaltina alta *)
GlassRemovedDelayedPulse( in:=(GlassWasOnFc AND NOT IFC_TILTOUT_GLASS AND Angle>30E3), pt:=TO_UDINT(vqTiltOut_RemoveDelay) );
GlassRemoved := GlassRemovedDelayedPulse.q;

(* - Abort comando automatico - *)
(* Salita automatica *)
IF vnTiltOut_Cmd>0 THEN
    IF Abort OR (* Ferma su stop... *)
       (ICM_TILTOUT_UP AND NOT vbTiltOut_CanAutoUp) OR ICM_TILTOUT_DWN OR (* ...O comandi manuali *)
       ( (NOT O_SCU_TILTOUT_AUTO OR NOT IFC_TILTOUT_BLOCKS_OUT) (* Automatico non selezionato o piedini non alti *)
          AND NOT vbTiltOut_CanAutoUp ) THEN
        dlog( Txt:='fbTiltOut: ! Rise aborted (Auto=%d Blocks=%d)', Lvl:=2, Val1:=TO_DINT(O_SCU_TILTOUT_AUTO), Val2:=TO_DINT(IFC_TILTOUT_BLOCKS_OUT));
        vnTiltOut_Cmd := 0;
    END_IF;
(* Discesa automatica *)
ELSIF vnTiltOut_Cmd<0 THEN
    IF Abort OR (* Ferma su stop... *)
       ICM_TILTOUT_UP OR ICM_TILTOUT_DWN THEN (* ...O comandi manuali *)
        dlog( Txt:='fbTiltOut: ! Descend aborted', Lvl:=2);
        vnTiltOut_Cmd := 0;
    (* Se sono alto voglio fotocellule sotto libere *)
    ELSIF Angle>vqTiltOut_MidAngle THEN
        (* Filtro perché capita di avere impulsi spurii *)
        FtcReadFilt( in:=fcOutzoneEnd.q OR fcOutzoneNearEnd.q, N:=25 ); (* 100ms/4ms or [0.1s]·vqPlcCyclesPerS *)
        IF FtcReadFilt.q THEN
            dlog( Txt:='fbTiltOut: !! Ftc read', Lvl:=2);
            vnTiltOut_Cmd := 0;
        END_IF;
    END_IF;
END_IF;



(* --- Gestione con inverter --- *)
IF INV_TILTOUT>0 THEN
    (* Inverter su EtherCAT, deve essere opportunamente mappato in par2kecat.txt *)
    TiltPump( Idx:=INV_TILTOUT );

    (* Abilitazione e gestione fault *)
    IF TiltPump.Fault THEN
        (* Inverter in allarme *)
        IPR_TILTOUT := TRUE; (* Lo sfrutto per alzare messaggio *)
        (* Dò reset se abilitato *)
        IF TiltPump.Enable THEN
            dlog( Txt:='fbTiltOut: !! TiltPump fault occurrence', Lvl:=1 );
            TiltPump.Enable := FALSE;
        END_IF;
        (* Forzo velocità nulla *)
        TiltPump.TgtSpd := 0;
    ELSE
        (* Inverter ok *)
        TiltPump.Enable := O_TILTOUT_ON;

        (* Applicazione velocità del basculamento, positiva sale *)
        IF O_TILTOUT_UP THEN
            (* TiltPump.TgtSpd := vnTiltOut_MaxSpd; (* [rpm] == 100% *)
            (* Voglio andare sempre più lento fino a fermarmi a vqTiltOut_AngleMax
               Potrei usare un profilo lineare:  MaxSpd |-->--.
                                                        |     ·`.
                                                        |     ·  `.
                                                 MinSpd-+-----+-----+---->
                                                        |AnearHigh AngleMax *)
            TiltPump.TgtSpd := TO_INT( fnLinterp( x := TO_LREAL(Angle),
                                                 x1 := TO_LREAL(vqTiltOut_AnearHigh),
                                                 y1 := TO_LREAL(vnTiltOut_MaxSpd),
                                                 x2 := TO_LREAL(vqTiltOut_AngleMax),
                                                 y2 := TO_LREAL(vnTiltOut_MinSpd) ) );
            (* Oppure un profilo più aggressivo: coseno o polinomio, tuttavia
               assume sempre meno importanza aumentando vqTiltOut_AnearHigh *)
        ELSIF O_TILTOUT_DWN THEN
            (* TiltPump.TgtSpd := -vnTiltOut_MaxSpd; (* [rpm] == 100% *)
            (* Rallento anche in discesa:               |    ,--<-- MaxSpd
                                                        |  ,' ·
                                                        |,'   ·
                                                 MinSpd +-----+------>
                                                        |  AnearLow         *)
            TiltPump.TgtSpd := TO_INT( fnLinterp( x := TO_LREAL(Angle),
                                                 x1 := 0.0,
                                                 y1 := TO_LREAL(-vnTiltOut_MinSpd),
                                                 x2 := TO_LREAL(vqTiltOut_AnearLow),
                                                 y2 := TO_LREAL(-vnTiltOut_MaxSpd) ) );
        ELSE
            TiltPump.TgtSpd := 0;
        END_IF;
    END_IF;
END_IF;



(* -- Task a bassa priorità -- *)
IF vbHeartBeat THEN

    (* Reset messaggio ribaltina bloccata
    IF IS_MSG(MSG_TILTOUT_LOCKED) AND Allow THEN
        RST_MSG(MSG_TILTOUT_LOCKED);
    END_IF; *)

    (* Se l'attuatore è in protezione
    SET_MSG_IF(IPR_TILTOUT,MSG_TILTOUT_HWFAULT,'IPR_TILTOUT',0); *)

    (* Messaggio ribaltina non alimentata - operatore in barriera fine linea *)
    IF OilActuation.Request AND NOT I_SCU_POW_TILTOUT THEN
        SET_MSG(MSG_TILTOUT_NOTREADY,'MSG_TILTOUT_NOTREADY',0);
    ELSIF IS_MSG(MSG_TILTOUT_NOTREADY) AND I_SCU_POW_TILTOUT THEN
        RST_MSG(MSG_TILTOUT_NOTREADY);
    END_IF;

    (* Messaggio ribaltina non pronta per basculamento automatico *)
    IF O_SCU_TILTOUT_AUTO AND NOT IFC_TILTOUT_BLOCKS_OUT AND vn[ivnStatus+ID_MACHINE]>MS_READY THEN
        SET_MSG(MSG_TILTOUT_NOAUTO,'MSG_TILTOUT_NOAUTO',0);
    ELSIF IS_MSG(MSG_TILTOUT_NOAUTO) THEN
        RST_MSG(MSG_TILTOUT_NOAUTO);
    END_IF;

END_IF; (* vbHeartBeat *)


(* -- Monitors -- *)
vqTiltOut_Angle := Angle; (* Inclinazione stimata *)
Emerging := IFC_TILTOUT_DWN AND O_TILTOUT_UP;
Descending := Status=TL_GOINGDOWN AND Angle>vqTiltOut_MidAngle;
AtRest := Status=TL_FULLDOWN;
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbOutZone

{ DE:"Zona fine linea" }

	VAR_INPUT
	Ybtm : DINT; { DE:"Posizione bordo basso del pezzo [um]" }
	Ytop : DINT; { DE:"Posizione bordo alto del pezzo [um]" }
	Xbck : DINT; { DE:"Posizione bordo indietro del pezzo [um]" }
	Xfwd : DINT; { DE:"Posizione bordo avanti del pezzo [um]" }
	Prescored : BOOL; { DE:"Il pezzo contiene preincisioni" }
	NewPiece : EN_OUTZONE_CMD; { DE:"Notify new piece, see 'OZ_NONE, ...' enum constants" }
	XcheckIfBusy : DINT; { DE:"Controllo stato effettivo data la pos del bordo avanti lastra [um]" }
	TryFreeZone : BOOL; { DE:"Servizio di liberazione area fine linea" }
	END_VAR

	VAR_OUTPUT
	Xbusy : DINT := 100E6; { DE:"Coordinata X inizio zona correntemente occupata [um]" }
	Free : BOOL; { DE:"La zona è libera" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vbHeartBeat : BOOL; { DE:"Battito di vita 1s" }
	vbBlink2Hz : BOOL; { DE:"Lampeggio 0.25s ogni 0.5s" }
	vqWorkSettings : DINT; { DE:"Selettori ritentivi di lavorazione" }
	vnPieceDelivering : INT; { DE:"Identificativo pezzo in consegna" }
	vnPieceTaken : INT; { DE:"Identificativo ultimo pezzo prelevato" }
	ICM_OUTZONE_PEDAL : BOOL; { DE:"Pedaliera blu a fine linea (ribaltina scarico pezzi)" }
	ICM_OUTZONE_BUTTON : BOOL; { DE:"Pulsante a fine linea" }
	O_OUTZONE_LIGHT : BOOL; { DE:"Segnalazione luminosa a fine linea" }
	fcOutzoneEnd : fbPhotoCell; { DE:"Fotocellula a fine linea (IFC_OUTZONE_END)" }
	fcOutzoneNearEnd : fbPhotoCell; { DE:"Fotocellula prossimità fine linea (IFC_OUTZONE_NEAREND)" }
	IFC_TILTOUT_GLASS : BOOL; { DE:"Sensore presenza vetro su ribaltina scarico pezzi" }
	vqXph_OutZoneNearEnd : DINT; { DE:"Posizione fotocellula prossimità fine zona fine linea [um]" }
	vqXph_OutZoneEnd : DINT; { DE:"Ascissa fotocellula fine zona fine linea [um]" }
	vqYph_OutZoneEnd : DINT; { DE:"Ordinata fotocellula fine zona fine linea [um]" }
	vqX_OutZoneBegin : DINT; { DE:"Ascissa inizio zona fine linea [um]" }
	vqX_OutZoneEnd : DINT; { DE:"Quota X piedini ribaltina/fine linea [um]" }
	vqX_AlgnTableEnd : DINT; { DE:"Ascissa legno fine modulo riscontri [um]" }
	vqOutZone_Xbusy : DINT; { DE:"Limite indietro zona occupata a fine linea [um]" }
	vbOutZone_SafeConfirm : BOOL; { DE:"Conferma pezzo prelevato solo con pedale" }
	vbOutZone_PedalToFree : BOOL; { DE:"Richiedi sempre pedale per liberare la zona" }
	vbOutZone_FreeTiltOut : BOOL; { DE:"Libera la zona con ribaltina alta" }
	vnTiltOut_Type : INT; { DE:"Tipo ribaltina scarico pezzi" }
	TiltOut : fbTiltOut; { DE:"Ribaltina scarico pezzi" }
	Tiltable : fbTiltable; { DE:"Controllo basculabilità con ribaltina fine linea" }
	vnTiltOut_Cmd : INT; { DE:"Comando ribaltina scarico pezzi" }
	vbTiltOut_AutoDown : BOOL; { DE:"Fai scendere la ribaltina appena tolto il vetro" }
	vqTiltOut_ArmLength : DINT; { DE:"Lunghezza delle braccia ribaltina [um]" }
	vqTiltOut_Xbegin : DINT; { DE:"Inizio zona braccia ribaltina [um]" }
	vqTiltOut_MidAngle : DINT; { DE:"Soglia angolo per controllo fotocellule [mdeg]" }
	vqTiltOut_MinWidth : DINT; { DE:"Minima larghezza da ribaltare [um]" }
	vqTiltOut_MaxWidth : DINT; { DE:"Massima larghezza ribaltabile automaticamente [um]" }
	vnTiltOut_NoBlocks : INT; { DE:"Abbassa i piedini della ribaltina in certe condizioni (bit0:small bit1:big bit2:unable bit3:prescored)" }
	vbOutTable_Present : BOOL; { DE:"Presenza di un tavolo a valle" }
	vnAlgn_DeliverCmd : INT; { DE:"Servizio generico estrazione/consegna pezzo a valle" }
	vbAlgnEvac_Scheduled : BOOL; { DE:"Prenotazione evacuazione fuori" }
	vqAlgnEvac_Xbck : DINT; { DE:"Posizione bordo indietro vetro da evacuare fuori [um]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vbStepValid : BOOL; { DE:"Passo di lavorazione valido e caricato" }
	vbBtnStartStep : BOOL; { DE:"Esegui il passo di lavorazione" }
	vbBtnOutFwdSheet : BOOL; { DE:"Comando evacuazione lastra a valle" }
	vbFloatStripesBreak : BOOL; { DE:"Troncaggio traversi monolitico (vedi BIT_STRIPES)" }
	vnEbrk_Type : INT; { DE:"Tipo modulo troncaggio esterno 'ID_EBRK' (0:none 1:generic)" }
	vbShift_NoRolls : BOOL; { DE:"Modificatore temporaneo: inibisci rulli riscontro" }
	vbShift_KeepAirOn : BOOL; { DE:"Modificatore temporaneo: non spegnere aria riscontri" }
	vnVents_Cmd : INT; { DE:"Maschera comando gruppi ventilatori cuscino aria" }
	vbVent_OutZoneOnDlvr : BOOL; { DE:"Accendi i ventilatori zona fine linea alla consegna pezzo" }
	vbVent_IndepOutZone : BOOL; { DE:"Zona aria fine linea indipendente" }
	END_VAR

	VAR
	TiltOutAtRest : fbEdges; { DE:"Evento ribaltina a riposo" }
	CmdOutZone : fbCmdHeld; { DE:"Pedaliera/pulsante a fine linea" }
	ReqFreeOutZone : fbEdges; { DE:"Fronti della richiesta REQ_FREE_OUTZONE" }
	Pedal_Clicked : BOOL; { DE:"Conferma pedale data per liberare la zona" }
	END_VAR

	{ CODE:ST }(*    fbOutZone (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Implementa le logiche riguardanti la zona
      a fine linea, dove escono i vetri processati
      dalla macchina.
      I servizi sono:
        .Presa in carico del pezzo in arrivo (area occupata)
        .Prelievo/evacuazione pezzo e liberazione area fine linea

      DETAILS
      ----------------------------------------------
      I comportamenti variano a seconda di quale
      dispositivo a fine linea è presente:
        .Ribaltina scarico pezzi
        .Tavolo di troncaggio a valle
        .Sistema di accodamento/stoccaggio pezzi in uscita
        .Nessun dispositivo

      USAGE
      ----------------------------------------------
      OutZone : fbOutZone; { DE:"Zona fine linea" }
*)

(* --- Servizio presa in carico pezzo ---
       .Viene aggiornata la zona occupata
       .Vengono attivati eventuali dispositivi per processare il pezzo arrivato *)
IF NewPiece<>OZ_NONE THEN

    IF NewPiece=OZ_NOTIFY THEN
        (* Just notifying an incoming piece *)
        (* === A seconda del dispositivo presente === *)

        (* ______ Ribaltina scarico pezzi ______ *)
        IF vnTiltOut_Type>0 THEN
            (* Decido se usare i piedini automatici: in certi casi è comodo abbassare
               temporaneamente i piedini per permettere il prelievo a mano frontale *)
            IF (vqWorkSettings & BIT_AUTOTILTOUT)<>0 THEN
                (* Se il pezzo non sarà ribaltato perché preinciso *)
                IF (vnTiltOut_NoBlocks&8)<>0 AND Prescored THEN
                    dlog( Txt:='fbOutZone: ! No tilt prescored', Lvl:=4 );
                    TiltOut.NoBlocks := TRUE;
                (* Se pezzo non sarà ribaltato perché largo *)
                ELSIF (vnTiltOut_NoBlocks&2)<>0 AND NOT Prescored AND
                      (Xfwd-Xbck)>vqTiltOut_MaxWidth THEN (* Pezzo grosso da non ribaltare *)
                    dlog( Txt:='fbOutZone: ! No tilt w=%ld>%ld', Lvl:=4, Val1:=(Xfwd-Xbck)/1E3, Val2:=vqTiltOut_MaxWidth/1E3 );
                    TiltOut.NoBlocks := TRUE;
                (* Se il pezzo non deve essere ribaltato perchè stretto *)
                ELSIF (vnTiltOut_NoBlocks&1)<>0 AND NOT Prescored AND
                      (Xfwd-Xbck)<vqTiltOut_MinWidth THEN (* Pezzo piccolo da non ribaltare *)
                    dlog( Txt:='fbOutZone: ! No tilt w=%ld<%ld', Lvl:=4, Val1:=(Xfwd-Xbck)/1E3, Val2:=vqTiltOut_MinWidth/1E3 );
                    TiltOut.NoBlocks := TRUE;
                    (* fnGlassMass_g(Xfwd-Xbck,Ytop-Ybtm,vqGlass_Thckn) (* Massa [g] *)
                (* Gestisci i piedini in base a ribaltabilità? *)
                ELSIF (vnTiltOut_NoBlocks&4)<>0 AND NOT Prescored THEN
                    (* Sarà ribaltabile? *)
                    Tiltable( ybtm:=Ybtm, ytop:=Ytop, xbck:=vqX_OutZoneEnd-(Xfwd-Xbck), xfwd:=vqX_OutZoneEnd );
                    (* dlog( Txt:='fbOutZone: ! Basing on tiltability', Lvl:=4 ); *)
                    TiltOut.NoBlocks := NOT Tiltable.q;
                ELSE
                    TiltOut.NoBlocks := FALSE; (* Gestisci i piedini normalmente *)
                END_IF;
            END_IF;

        (* ______ Tavolo a fine linea ______ *)
        (* ELSIF vbOutTable_Present THEN *)

        (* ______ Coda stoccaggio a fine linea ______ *)
        (* ELSIF ... THEN *)

        (* ______ Nessun dispositivo ______ *)
        (* ELSE *)
        END_IF; (* -- A seconda del dispositivo presente *)

    ELSIF NewPiece>=OZ_UPDATE THEN
        (* Updating the used zone *)
        dlog( Txt:='fbOutZone: -> Update Xbusy=%ld => %ld mm', Lvl:=5, Val1:=Xbusy/1E3, Val2:=Xbck/1E3 );

        (* Occupa la zona, 'Free' diventa falso
           In caso di preincisioni, assicuro di occupare almeno tutta la zona fine linea *)
        IF Prescored THEN (* AND vbPrescore_OccupiesAllOutZone *)
            Xbusy := MIN(Xbck, vqX_OutZoneBegin);
        ELSE
            Xbusy := Xbck;
        END_IF;

        (* See if must also process piece *)
        IF NewPiece=OZ_TAKE THEN
            dlog( Txt:='fbOutZone: Delivered w=%ld|%ld h=%ld|%ld', Lvl:=5, Val1:=Xbck/1E3, Val2:=Xfwd/1E3, Val3:=Ybtm/1E3, Val4:=Ytop/1E3 );

            (* Accendo automaticamente i ventilatori della zona fine linea se richiesto *)
            IF Prescored AND vbVent_OutZoneOnDlvr AND vbVent_IndepOutZone THEN
                vnVents_Cmd := vnVents_Cmd OR BIT_VENT_OUTZONE;
            END_IF;

            (* Alzo richiesta di prelevare il pezzo *)
            SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',0); (* Outzone New piece *)

            IF Prescored THEN
                SET_MSG(REQ_WORK_PRESCORED,'REQ_WORK_PRESCORED',0);
            END_IF;

            (* Notifica se la fotocellula a fine linea, sempre presente, non è impegnata *)
            IF NOT fcOutzoneEnd.q AND
               fnInRange_DINT(vqXph_OutZoneEnd,Xbck,Xfwd) AND
               fnInRange_DINT(vqYph_OutZoneEnd,Ybtm,Ytop) THEN
                dlog( Txt:='fbOutZone: !! No IFC_OUTZONE_END', Lvl:=2 );
                SET_MSG(MSG_OUTZONE_NOPHTC,'MSG_OUTZONE_NOPHTC',0);
            END_IF;

            (* === A seconda del dispositivo presente === *)
            (* ______ Ribaltina scarico pezzi ______ *)
            IF vnTiltOut_Type>0 THEN

                (* Se si desidera il ribaltamento automatico... *)
                IF TiltOut.SelAutoMode AND NOT TiltOut.NoBlocks AND NOT Prescored AND NOT IS_MSG(MSG_OUTZONE_NOPHTC) THEN
                    (* ...Controllo se ribaltina pronta... *)
                    IF TiltOut.AutoReady THEN
                        (* Vedo se è da ribaltare *)
                        Tiltable( ybtm:=Ybtm, ytop:=Ytop, xbck:=Xbck, xfwd:=Xfwd );
                        IF Tiltable.q THEN
                            dlog( Txt:='fbOutZone: Tilting %ldx%ld with arms %d and %d', Lvl:=5, Val1:=(Tiltable.xfwd-Tiltable.xbck)/1E3, Val2:=(Tiltable.ytop-Tiltable.ybtm)/1E3, Val3:=TO_DINT(Tiltable.idx_btm), Val4:=TO_DINT(Tiltable.idx_top) );
                            vnTiltOut_Cmd := 1; (* Sali *)
                        (* ELSE (* Nota: Troppo tardi abbassare i piedini qui perché potrebbero essere bloccati dal vetro *)
                        END_IF;
                    ELSE
                        dlog( Txt:='fbOutZone: ! Tiltout not ready', Lvl:=2 );
                    END_IF; (* Ribaltina pronta *)
                (*ELSE dlog( Txt:='fbOutZone: ! Skipping Tilt', Lvl:=2 ); *)
                END_IF; (* Dovrei usare ribaltina *)

            (* ______ Tavolo a fine linea ______ *)
            ELSIF vbOutTable_Present THEN
                (* Preferisco ricordare il bordo lastra da evacuare con
                   'vqAlgnEvac_Xbck' perché 'Xbusy' è piuttosto volatile *)
                (* Nota: potrei essere più elastico e settarlo sempre anche nel primo movimento *)
                vqAlgnEvac_Xbck := Xbck; (* Usato da 'vbAlgnEvac_Scheduled' *)

            (* ______ Coda stoccaggio a fine linea ______ *)
            (* ELSIF ... THEN *)

            (* ______ Nessun dispositivo ______ *)
            (* ELSE *)
            END_IF; (* -- A seconda del dispositivo presente *)
        END_IF; (* OZ_TAKE *)
    END_IF; (* See NewPiece command *)

    NewPiece := OZ_NONE; (* Eat *)
END_IF; (* -Servizio presa in carico pezzo- *)



(* --- Gestione comando a fine linea (pedale) ---
   A seconda del dispositivo, la funzione è:
   .Ribaltina: conferma prelievo pezzo, start
   .Troncaggio: trasferimento pezzo, conferma prelievo pezzo, start
   .Stoccaggio: -
   .Nessuno: conferma prelievo pezzo, start  *)

(* Fronti del comando  *)
CmdOutZone( in:=ICM_OUTZONE_PEDAL, pt:=1000 ); (* OR ICM_OUTZONE_BUTTON *)

(* Fronti della richiesta di liberazione zona fine linea (reset da pulpito) *)
ReqFreeOutZone( in:=IS_MSG(REQ_FREE_OUTZONE) );


(* -Gestione comune- *)
(* Fronte del pedale: resetta richieste prelievo o dai start *)
IF CmdOutZone.click THEN

    (* === Effetti comuni del click singolo === *)
    IF IS_MSG(REQ_FREE_OUTZONE) OR IS_MSG(REQ_WORK_PRESCORED) THEN (* OR NOT Free *)
        dlog( Txt:='fbOutZone: Pedal (confirm)', Lvl:=2 );
        RST_MSG(REQ_FREE_OUTZONE);
        RST_MSG(REQ_WORK_PRESCORED);
        (* Nota: l'effettiva liberazione del fine linea avviene altrove con 'TryFreeZone' *)
        Pedal_Clicked := TRUE; (* Usato con vbOutZone_PedalToFree *)

    (* Reset richiesta prelievo prodotto? *)
    (* ELSIF IS_MSG(REQ_TAKE_PROD) OR IS_MSG(REQ_DUMP_PROD) THEN
        dlog( Txt:='fbOutZone: Prod manually removed (pedal)', Lvl:=2 );
        RST_MSG(REQ_TAKE_PROD);
        RST_MSG(REQ_DUMP_PROD); *)

    (* Dò start automatico se zona libera e macchina pronta con un passo auto caricato *)
    ELSIF Free AND vbAutoMode AND vbStepValid AND vn[ivnStatus+ID_STEPSEQ]=STS_IDLE THEN
        dlog( Txt:='fbOutZone: Pedal (start)', Lvl:=4 );
        vbBtnStartStep := TRUE;
    END_IF;


    (* === A seconda del dispositivo presente === *)

    (* ______ Ribaltina scarico pezzi ______ *)
    IF vnTiltOut_Type>0 THEN
        TiltOut.NoBlocks := FALSE; (* Resetta eventuale forzatura piedini bassi? *)

        (* Manda giù la ribaltina o prova a liberare la zona *)
        (* Se la ribaltina è già bassa... *)
        IF TiltOut.AtRest THEN
            TryFreeZone := TRUE; (* ...Prova a liberare la zona *)
        (* Se la ribaltina sta scendendo... *)
        ELSIF TiltOut.Status=TL_GOINGDOWN THEN
            vnTiltOut_Cmd := 0; (* ...Fermala *)
        ELSE (* In ogni altro caso... *)
            vnTiltOut_Cmd := -1; (* ...Porta la ribaltina giù *)
        END_IF;

    (* ______ Tavolo a fine linea ______ *)
    ELSIF vbOutTable_Present THEN
        (* Se sto troncando i traversi di un monolitico, avanza al traverso dopo *)
        IF vbFloatStripesBreak THEN
            (* Reset richiesta prelievo prodotto per far avanzare il troncaggio traversi *)
            (* Nota: nel troncaggio traversi float senza trascinamento si alza REQ_TAKE_PROD *)
            (* Per ora lo metto qui visto che mi serve far avanzare col pedale il troncaggio traversi "semplice" di VPM *)
            IF IS_MSG(REQ_TAKE_PROD) THEN (* AND Free *)
                dlog( Txt:='fbOutZone: Prod removed', Lvl:=2 );
                RST_MSG(REQ_TAKE_PROD);
                (* Più drastico: vbBtnAckn := TRUE; *)
            END_IF;
            TryFreeZone := TRUE;
        ELSIF NOT Free THEN
            (* Se zona occupata prenota evacuazione, altrimenti se
               non c'è una evacuazione in corso, prova a liberare la zona *)
            IF vqAlgnEvac_Xbck<>NO_POS_UM AND vnAlgn_DeliverCmd=CMD_STOP AND fcOutzoneEnd.q THEN
                dlog( Txt:='fbOutZone: Evac scheduled', Lvl:=3 );
                vnAlgn_DeliverCmd := DLVCMD_OUT;
            ELSIF vnAlgn_DeliverCmd<>DLVCMD_OUT AND NOT vbAlgnEvac_Scheduled THEN
                (* Prova a liberare la zona se non c'è un'evacuazione in corso *)
                TryFreeZone := TRUE;
            END_IF;
        END_IF;

    (* ______ Coda stoccaggio a fine linea ______ *)
    (* ELSIF ... THEN *)

    (* ______ Nessun dispositivo ______ *)
    ELSE
        (* Prova a liberare la zona *)
        TryFreeZone := TRUE; (* ...Prova a liberare la zona *)

    END_IF; (* -- A seconda del dispositivo presente *)

ELSIF CmdOutZone.held_pls THEN

    (* === Effetti comuni del mantenimento === *)
    (* Provo a liberare la zona a fine linea *)
    TryFreeZone := TRUE;

    (* === A seconda del dispositivo presente === *)

    (* ______ Ribaltina scarico pezzi ______ *)
    IF vnTiltOut_Type>0 THEN

    (* ______ Tavolo a fine linea ______ *)
    ELSIF vbOutTable_Present THEN
        (* Un comando per traslare una lastra monolitico sul troncaggio *)
        IF Free AND (* Zona fine linea libera *)
           vnEbrk_Type>1 AND (* Il tavolo a valle è di troncaggio *)
           NOT vbStepValid AND (* OR vbFloatStripesBreak) de-sincronizzato *)
           vn[ivnStatus+ID_STEPSEQ]=STS_IDLE AND (* Macchina ferma *)
           vn[ivnStatus+ID_MACHINE]=MS_READY THEN
           (* Poiché si tratta di un monolitico già inciso: *)
           vbShift_NoRolls := TRUE; (* Niente rulli per non aprire i tagli *)
           vbShift_KeepAirOn := TRUE; (* Non spengo i ventilatori dei riscontri *)
           vnVents_Cmd := vnVents_Cmd OR MSK_VENT_LAMI; (* Accendo subito i ventilatori *)

           vbBtnOutFwdSheet := TRUE;
        END_IF;

    (* ______ Coda stoccaggio a fine linea ______ *)
    (* ELSIF ... THEN *)

    (* ______ Nessun dispositivo ______
    ELSE  *)

    END_IF; (* -- A seconda del dispositivo presente *)
END_IF; (* --- Fronte comando a fine linea (pedale) *)




(* ----- Altre logiche ----- *)

(* === A seconda del dispositivo presente === *)

(* ______ Ribaltina scarico pezzi ______ *)
IF vnTiltOut_Type>0 THEN
    (* Con ribaltina scarico pezzi:
         .Prendi in carico un nuovo pezzo in arrivo e tiralo su
         .La zona occupata dipende dallo stato della ribaltina *)

    (* Fronti evento di ribaltina a riposo *)
    TiltOutAtRest( in:=TiltOut.AtRest );

    (* Appena la ribaltina si abbassa libero la zona? *)
    IF TiltOutAtRest.rise THEN
        (* Questo accade anche con i comandi manuali!
           Se liberassi la zona con un vetro che non copre le fotocellule
           arriverebbe il vetro dopo: questo è pericolosamente sorprendente *)
        (* Meglio liberare solo se si è premuto esplicitamente il pedale? *)
        IF Pedal_Clicked OR NOT vbOutZone_PedalToFree THEN
            TryFreeZone := TRUE; (* ...Prova a liberare la zona *)
        END_IF;

        (*
        IF fcOutzoneNearEnd.q OR fcOutzoneEnd.q OR IFC_TILTOUT_GLASS THEN
            dlog( Txt:='fbOutZone: ! Tiltout not freed (%ld mm)', Lvl:=2, Val1:=Xbusy/1E3 );
        ELSE
            dlog( Txt:='fbOutZone: Tiltout freed', Lvl:=4 );
            RST_MSG(REQ_FREE_OUTZONE);
            Xbusy := vqX_AlgnTableEnd;
        END_IF; *)

    (* Appena la ribaltina si alza assicuro zona occupata *)
    ELSIF TiltOutAtRest.fall THEN
        (* Subito se la zona occupata era oltre le braccia *)
        IF Xbusy>vqTiltOut_Xbegin THEN
            dlog( Txt:='fbOutZone: Tilt arms out Xbusy=%ld => %ld mm', Lvl:=4, Val1:=Xbusy/1E3, Val2:=vqTiltOut_Xbegin/1E3 );
            Xbusy := vqTiltOut_Xbegin; (* Zona braccia occupata *)
        END_IF;
    (* Quando il vetro è ben alto, la zona occupata è quella delle braccia *)
    ELSIF TiltOut.Angle>vqTiltOut_MidAngle AND Xbusy<>vqTiltOut_Xbegin THEN
        dlog( Txt:='fbOutZone: Glass up Xbusy=%ld => %ld mm', Lvl:=4, Val1:=Xbusy/1E3, Val2:=vqTiltOut_Xbegin/1E3 );
        Xbusy := vqTiltOut_Xbegin;
    END_IF;

    (* Rilevazione di pezzo prelevato e auto-discesa *)
    IF TiltOut.GlassRemoved AND vbTiltOut_AutoDown AND TiltOut.AutoReady AND IS_MSG(REQ_FREE_OUTZONE) THEN
        dlog( Txt:='fbOutZone: Glass removed from TiltOut', Lvl:=3 );
        vnTiltOut_Cmd := -1; (* Scendi *)
        Pedal_Clicked := TRUE; (* Emulo pedale per liberare la zona *)
        RST_MSG(REQ_FREE_OUTZONE);
    END_IF;

    (* -Conferma liberazione da pulpito (unsafe)- *)
    IF ReqFreeOutZone.fall AND NOT vbOutZone_SafeConfirm THEN
        TryFreeZone := TRUE; (* ...Prova a liberare la zona *)
    END_IF;

(* ______ Tavolo a fine linea ______ *)
ELSIF vbOutTable_Present THEN
    (* Con troncaggio a fine linea:
         .Il pezzo si ferma prima di entrare
         .L'operatore dà l'ok per trasferire il
          pezzo mediante spinta coi riscontri *)

    (* -Conferma liberazione da pulpito (unsafe)- *)
    IF ReqFreeOutZone.fall AND NOT vbOutZone_SafeConfirm AND
       vnAlgn_DeliverCmd<>DLVCMD_OUT AND NOT vbAlgnEvac_Scheduled THEN (* Solo se non sta evacuando *)
        TryFreeZone := TRUE; (* ...Prova a liberare la zona *)
    END_IF;

(* ______ Coda stoccaggio a fine linea ______ *)
(* ELSIF ... THEN *)


(* ______ Nessun dispositivo ______ *)
ELSE
    (* Niente ribaltina o altro:
         .Se non c'è nulla il pezzo in arrivo si ferma in zona e basta,
          l'operatore preme il pedale per confermare di averlo prelevato *)

    (* -Conferma liberazione da pulpito (unsafe)- *)
    IF ReqFreeOutZone.fall AND NOT vbOutZone_SafeConfirm THEN
        TryFreeZone := TRUE; (* ...Prova a liberare la zona *)
    END_IF;

END_IF; (* --- A seconda del dispositivo presente *)



(* --- Servizio di liberazione area fine linea (TryFreeZone) ---
   Cerca di dichiarare libera l'area considerata occupata,
   controllando però se è effettivamente liberata *)
IF TryFreeZone THEN
    IF NOT Free THEN
        dlog( Txt:='fbOutZone: TryFreeZone', Lvl:=3 );

        (* Segnata come occupata, proviamo a liberarla *)
        IF vnTiltOut_Type>0 AND NOT TiltOut.AtRest AND (NOT vbOutZone_FreeTiltOut OR TiltOut.Angle<45E3) THEN
            (* SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',Xbusy); (* OutZone.TryFreeZone *)
            dlog( Txt:='! Busy by TiltOut at %ld (%ld)', Lvl:=4, Val1:=TiltOut.Angle/1E3, Val2:=Xbusy/1E3 );
        ELSIF fcOutzoneNearEnd.q THEN
            SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',Xbusy); (* OutZone.TryFreeZone *)
            dlog( Txt:='! Busy by IFC_OUTZONE_NEAREND (%ld)', Lvl:=4, Val1:=Xbusy/1E3 );
        ELSIF fcOutzoneEnd.q THEN
            SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',Xbusy); (* OutZone.TryFreeZone *)
            dlog( Txt:='! Busy by IFC_OUTZONE_END (%ld)', Lvl:=4, Val1:=Xbusy/1E3 );
        ELSIF IFC_TILTOUT_GLASS AND vnTiltOut_Type>0 THEN
            SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',Xbusy); (* OutZone.TryFreeZone *)
            dlog( Txt:='! Busy by IFC_TILTOUT_GLASS (%ld)', Lvl:=4, Val1:=Xbusy/1E3 );
        ELSE (* Is free! *)
            dlog( Txt:='Freed (was %ld mm)', Lvl:=5, Val1:=Xbusy/1E3 );
            Xbusy := vqX_AlgnTableEnd; (* Ok, zona liberata *)
            RST_MSG(REQ_FREE_OUTZONE);
        END_IF;
    END_IF; (* Try to free *)

    (* Reset notifiche correlate *)
    RST_MSG_IF_ON(MSG_OUTZONE_NOPHTC);

    TryFreeZone := FALSE; (* eat *)
END_IF; (* --- TryFreeZone *)


(* --- Servizio di controllo area libera (XcheckIfBusy) ---
   Controlla l'effettiva occupazione della zona a fine linea,
   'XcheckIfBusy' è usato per escludere la possibilità di avere
   le fotocellule occupate dalla lastra stessa per cui si controlla.
   Servizio usato prima di posizionare o ruotare una lastra.
   Una volta settato, aspetta un ciclo e poi controlla 'Free' o 'Xbusy' *)
IF XcheckIfBusy<>NO_POS_UM THEN
    IF Free THEN
        (* Segnata come libera, controlliamo se in realtà è occupata
           guardando lo stato effettivo fotocellule e ribaltina *)
        IF vnTiltOut_Type>0 AND NOT TiltOut.AtRest THEN
            Xbusy := vqTiltOut_Xbegin; (* Zona braccia occupata *)
            SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE: TiltOut',Xbusy); (* OutZone XcheckIfBusy *)
            dlog( Txt:='fbOutZone: ! Busy by TiltOut (%ld)', Lvl:=4, Val1:=Xbusy/1E3 );
        ELSIF vnTiltOut_Type>0 AND fcOutzoneNearEnd.q AND (XcheckIfBusy < vqXph_OutZoneNearEnd) THEN
            Xbusy := vqTiltOut_Xbegin; (* Zona braccia occupata *)
            SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',Xbusy); (* OutZone XcheckIfBusy *)
            dlog( Txt:='fbOutZone: ! Busy by IFC_OUTZONE_NEAREND (%ld<%ld)', Lvl:=4, Val1:=XcheckIfBusy/1E3, Val2:=Xbusy/1E3 );
        ELSIF fcOutzoneEnd.q AND (XcheckIfBusy < vqXph_OutZoneEnd) THEN
            Xbusy := vqXph_OutZoneNearEnd; (* Zona fotocellule occupata *)
            SET_MSG(REQ_FREE_OUTZONE,'REQ_FREE_OUTZONE',Xbusy); (* OutZone XcheckIfBusy *)
            dlog( Txt:='fbOutZone: ! Busy by IFC_OUTZONE_END (%ld<%ld)', Lvl:=4, Val1:=XcheckIfBusy/1E3, Val2:=Xbusy/1E3 );
        (* ELSE (* Is free! *)
        END_IF;
    END_IF; (* Check of busy *)
    XcheckIfBusy := NO_POS_UM; (* Eat *)
END_IF; (* --- XcheckIfBusy *)


(* -- Monitors occupazione zona -- *)
Free := Xbusy>=vqX_OutZoneEnd;
vqOutZone_Xbusy := Xbusy;


(* -- Evento di zona a fine linea liberata -- *)
IF ReqFreeOutZone.fall
   AND NOT IS_MSG(REQ_FREE_OUTZONE) (* Potrei averla rialzata qui in mezzo *)
   AND Free THEN

    Pedal_Clicked := FALSE; (* Riarma per prossima liberazione *)
    TiltOut.NoBlocks := FALSE; (* Resetta eventuale forzatura piedini bassi? *)

    (* -Evento di pezzo prelevato- *)
    IF vnPieceDelivering>0 THEN
        dlog( Txt:='fbOutZone: -> Piece %d taken', Lvl:=2, Val1:=TO_DINT(vnPieceDelivering) );
        vnPieceTaken := vnPieceDelivering;
        vnPieceDelivering := INT#0; (* eat *)
    END_IF;
END_IF;


(* -- Luce a fine linea --
   Segnalo fine linea occupata, intermittente se bisogna aprire una preincisione *)
O_OUTZONE_LIGHT := NOT Free AND (vbBlink2Hz OR NOT IS_MSG(REQ_WORK_PRESCORED));


(* -- Task a bassa priorità -- *)
IF vbHeartBeat THEN

    (* Reset messaggio di zona fine linea occupata *)
    IF IS_MSG(MSG_OUTZONE_BUSY) AND Free THEN
        RST_MSG(MSG_OUTZONE_BUSY);
    END_IF;

END_IF; (* -- vbHeartBeat *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbMatParams

{ DE:"Materials work parameters manager" }

	VAR_IN_OUT
	Set : BOOL; { DE:"Applica i valori nel buffer" }
	Reset : BOOL; { DE:"Reset dei valori" }
	END_VAR

	VAR_OUTPUT
	Valid : BOOL; { DE:"Parametri di lavorazione materiale pronti e validi" }
	IsStrato : BOOL; { DE:"Loaded material is laminated" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vnBuf_SheetType : INT; { DE:"Buffer valore da Hmi" }
	vnBuf_WheelAngle : INT; { DE:"Buffer valore da Hmi" }
	vnBuf_CutRecipe : INT; { DE:"Buffer valore da Hmi" }
	vqBuf_SupThckn : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_InfThckn : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_PvbThckn : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_F_score_inf : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_F_score_sup : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_V_score : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_F_lowe : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_V_lowe : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_H_brkbar : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_T_brkbar : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_F_clamps_brk : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_F_brkwhl_sup : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_V_brkwhl_sup : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_F_brkwhl_sup_trim : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_F_brkwhl_inf_trim : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_V_brkwhl_trim : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_F_dtch_pull : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_V_dtch_pull : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_F_clamps_max : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_T_heat_pre : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_T_heat_pull : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_T_heat_add : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_T_heat_cut : DINT; { DE:"Buffer valore da Hmi" }
	vnSheetType : INT; { DE:"Tipologia materiale 'sheet-type'" }
	vnWheelAngle : INT; { DE:"Gradazione rotelle di incisione 'wheel-angle' [deg]" }
	vnCutRecipe : INT; { DE:"Sequenza di taglio preferita 'cut-recipe' [bit0:no-blade bit1:no-lamp bit2:stressed-glass]" }
	vqSupThckn : DINT; { DE:"Spessore dichiarato strato superiore [um]" }
	vqInfThckn : DINT; { DE:"Spessore dichiarato strato inferiore [um]" }
	vqPvbThckn : DINT; { DE:"Spessore dichiarato plastico [um]" }
	vqF_score_inf : DINT; { DE:"Forza pressione incisione inferiore 'f-score-inf' [mN]" }
	vqF_score_sup : DINT; { DE:"Forza pressione incisione superiore 'f-score-sup' [mN]" }
	vqV_score : DINT; { DE:"Velocità di incisione 'v-score' [um/min]" }
	vqF_lowe : DINT; { DE:"Forza pressione mola basso emissivo 'f-lowe' [mN]" }
	vqV_lowe : DINT; { DE:"Velocità mola basso emissivo 'v-lowe' [um/min]" }
	vqH_brkbar : DINT; { DE:"Altezza barra di troncaggio (0:auto 1:normal 2:high) 'h-brkbar'" }
	vqT_brkbar : DINT; { DE:"Tempo barra di troncaggio (0:auto) 't-brkbar' [ms]" }
	vqF_clamps_brk : DINT; { DE:"Forza pressione premilastra durante apertura con barra 'f-clamps-brk' [mN]" }
	vqF_brkwhl_sup : DINT; { DE:"Forza pressione rotella di apertura singola 'f-brkwhl-sup' [mN]" }
	vqV_brkwhl_sup : DINT; { DE:"Velocità rotella di apertura singola 'v-brkwhl-sup' [um/min]" }
	vqF_brkwhl_sup_trim : DINT; { DE:"Forza pressione rotella sup apertura rifilo 'f-brkwhl-sup-trim' [mN]" }
	vqF_brkwhl_inf_trim : DINT; { DE:"Forza pressione rotella inf apertura rifilo 'f-brkwhl-inf-trim' [mN]" }
	vqV_brkwhl_trim : DINT; { DE:"Velocità rotelle di apertura rifilo 'v-brkwhl-trim' [um/min]" }
	vqF_dtch_pull : DINT; { DE:"Forza di trazione del plastico durante la separazione 'f-dtch-pull' [mN/m]" }
	vqV_dtch_pull : DINT; { DE:"Velocità di trazione del plastico durante il riscaldamento 'v-dtch-pull' [um/min]" }
	vqF_clamps_max : DINT; { DE:"Massima spinta premilastra ammessa 'f-clamps-max' [mN]" }
	vqT_heat_pre : DINT; { DE:"Tempo pre-riscaldamento prima di tirare 't-heat-pre' [ms]" }
	vqT_heat_pull : DINT; { DE:"Tempo riscaldamento durante trazione 't-heat-pull' [ms]" }
	vqT_heat_add : DINT; { DE:"Tempo riscaldamento addizionale per ciclo rifilo 't-heat-add' [ms]" }
	vqT_heat_cut : DINT; { DE:"Tempo riscaldamento taglio per cicliche speciali vetro tensionato 't-heat-cut' [ms]" }
	vqF_lowe_curv : DINT; { DE:"Forza pressione mola basso emissivo 'f-lowe-curv' [mN]" }
	vqV_lowe_curv : DINT; { DE:"Velocità mola basso emissivo 'v-lowe-curv' [um/min]" }
	vqF_score_curv_sup : DINT; { DE:"Forza pressione incisione superiore sagomato 'f-score-curv-sup' [mN]" }
	vqF_score_curv_inf : DINT; { DE:"Forza pressione incisione inferiore sagomato 'f-score-curv-inf' [mN]" }
	vqV_score_curv : DINT; { DE:"Velocità di incisione sagomato 'v-score-curv' [um/min]" }
	vqF_brk_curv_sup : DINT; { DE:"Forza pressione utensile apertura superiore sagomato 'f-brk-curv-sup' [mN]" }
	vqF_brk_curv_inf : DINT; { DE:"Forza pressione utensile apertura inferiore sagomato 'f-brk-curv-inf' [mN]" }
	vqV_brk_curv : DINT; { DE:"Velocità di apertura sagomato 'v-brk-curv' [um/min]" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqGlass_ActualThckn : DINT; { DE:"Spessore complessivo misurato [um]" }
	vqMinLayer_Thckn : DINT; { DE:"Spessore dello strato più sottile [um]" }
	vqMaxLayer_Thckn : DINT; { DE:"Spessore dello strato più spesso [um]" }
	vqClamps_PressPull : DINT; { DE:"Pressione su vetro spinta premilastra per trazione [N/m²]" }
	vqBlade_StartDisp : DINT; { DE:"Soglia scostamento stacco per inizio tasteggio [um]" }
	vqBlade_AbortDisp : DINT; { DE:"Limite scostamento stacco di fallimento tasteggio [um]" }
	vqTscore_PushMax : DINT; { DE:"Spinta massima attuatore testine di incisione [mN]" }
	vqTscore_SpdMax : DINT; { DE:"Velocità massima incisione [um/min]" }
	vqGrLe_PushMax : DINT; { DE:"Spinta massima mola basso emissivo [mN]" }
	vqGrLe_SpdMax : DINT; { DE:"Velocità massima mola basso emissivo [um/min]" }
	vqGrLe_StdSpd : DINT; { DE:"Velocità tipica rimozione low-E [um/min]" }
	vqGrLe_StdForce : DINT; { DE:"Spinta tipica per rimozione low-E [mN]" }
	vqRbrk_SpdMax : DINT; { DE:"Velocità massima rotelle apertura [um/min]" }
	vqRbrk_PushMax : DINT; { DE:"Spinta massima rotelle di apertura [mN]" }
	vqBlade_StartDisp_2mm : DINT; { DE:"Soglia scostamento stacco per inizio tasteggio [um]" }
	vqBlade_StartDisp_12mm : DINT; { DE:"Soglia scostamento stacco per inizio tasteggio [um]" }
	vqBlade_AbortDispK : DINT; { DE:"Limite scostamento stacco di fallimento tasteggio (multiplo)" }
	vqDtch_CutStretchMod : DINT; { DE:"Modificatore allargamento del taglio durante separazione [um]" }
	vnGrLe_Type : INT; { DE:"Tipo mola asportazione basso emissivo 'ID_GRLE' (0:none)" }
	vqClamps_PushMax : DINT; { DE:"Spinta massima ammessa dei premilastra [mN]" }
	vqClamps_Pbrk_6mm : DINT; { DE:"Spinta premilastra per apertura con barra 3+3 [mN/m]" }
	vqClamps_Pbrk_20mm : DINT; { DE:"Spinta premilastra per apertura con barra 10+10 [mN/m]" }
	vqClamps_Kslip : DINT; { DE:"Scivolosità vetro-gomma premilastra" }
	vqBrkBar_MinTime : DINT; { DE:"Tempo minimo di apertura [ms]" }
	vqBrkBar_OpenTime : DINT; { DE:"Tempo di apertura per ogni mm vetro [ms/mm]" }
	vqDtch_HowMuchPull : DINT; { DE:"Trazione tipica per metro e per ogni decimo di plastico [mN/m·0.1mm]" }
	vqDtch_PullSpdStd : DINT; { DE:"Velocità tipica trazione plastico durante riscaldamento [um/min]" }
	vqWorkSettings : DINT; { DE:"Selettori ritentivi di lavorazione" }
	vnTheat_Incr : INT; { DE:"Maggiorazione tempi riscaldamento durante periodo invernale [%]" }
	vbInitMatCutRecipe : BOOL; { DE:"Inizializza ricetta preferita da dati materiale" }
	vnEnabledRecipes : INT; { DE:"Ricette abilitate" }
	vqCut_LayerThcknMax : DINT; { DE:"Spessore singolo strato vetro massimo tagliabile [um]" }
	vqCut_PvbThcknMax : DINT; { DE:"Spessore plastico massimo tagliabile [um]" }
	vqLamp_MaxTimeOut : DINT; { DE:"Massimo tempo di accensione con lampada fuori [ms]" }
	vqCut_FloatThcknMax : DINT; { DE:"Spessore vetro monolitico massimo tagliabile [um]" }
	vnClampAlgn_Type : INT; { DE:"Tipo premilastra riscontro (2:mot)" }
	vnClampDtch_Type : INT; { DE:"Tipo premilastra stacco (2:mot)" }
	END_VAR

	VAR
	Prev_WheelAngle : INT := 0; { DE:"To detect cutting wheels change" }
	END_VAR

	{ CODE:ST }(*    fbMatParams (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Gestisce la valorizzazione dei parametri di
      lavorazione materiale delle macchine per
      vetro laminato.
      Questi valori arrivano da un buffer in
      genere scritto dalla comunicazione con
      l'interfaccia utente.

      DETAILS
      ----------------------------------------------
      I comandi sono immediati, non necessita attese.
      In caso di valori invalidi (in genere <0)
      procede con la valorizzazione automatica
      mediante funzioni che interpolano i valori
      tipici in base allo spessore dichiarato.

      EXAMPLE OF USAGE
      ----------------------------------------------
      MatPars : fbMatParams; { DE:"Parametri di lavorazione del materiale" }
      MatPars( Set:=TRUE );
      IF MatPars.Valid THEN ...
*)

(* --- Servizio di reset dei parametri materiale ---
   Out: vnSheetType, ..., vqF_score_inf, ...
  Cond: Passo non in esecuzione *)
IF Reset THEN
    dlog( Txt:='[[Material: Null]]', Lvl:=3 );
    Valid := FALSE; (* Invalido lo stato *)

    (* Valori nel buffer (per valorizzazione automatica) *)
    (* Questi no, sono usati per la valorizzazione automatica!
        vnBuf_SheetType := 0;
        vnBuf_WheelAngle := 0;
        vnBuf_CutRecipe := 0;
        vqBuf_SupThckn := 0;
        vqBuf_InfThckn := 0;
        vqBuf_PvbThckn := 0;
    *)
    vqBuf_F_score_inf := 0;
    vqBuf_F_score_sup := 0;
    vqBuf_V_score := 0;
    vqBuf_F_lowe := 0;
    vqBuf_V_lowe := 0;
    vqBuf_T_brkbar := 0;
    vqBuf_H_brkbar := 0;
    vqBuf_F_clamps_brk := -1;
    vqBuf_F_brkwhl_sup := 0;
    vqBuf_V_brkwhl_sup := 0;
    vqBuf_F_brkwhl_sup_trim := 0;
    vqBuf_F_brkwhl_inf_trim := 0;
    vqBuf_V_brkwhl_trim := 0;
    vqBuf_F_dtch_pull := 0;
    vqBuf_V_dtch_pull := 0;
    vqBuf_F_clamps_max := 0;
    vqBuf_T_heat_pre := -1;
    vqBuf_T_heat_pull := -1;
    vqBuf_T_heat_add := -1;
    vqBuf_T_heat_cut := -1;


    (* Valori effettivi *)
    vnSheetType := 0;
    vnWheelAngle := 0;
    (* vnCutRecipe := 0; (* Mah, forse meglio mantenere? *)
    vqSupThckn := 0;
    vqInfThckn := 0;
    vqPvbThckn := 0;
    vqF_score_inf := 0;
    vqF_score_sup := 0;
    vqV_score := 0;
    vqF_lowe := 0;
    vqV_lowe := 0;
    vqH_brkbar := 0;
    vqT_brkbar := 0;
    vqF_clamps_brk := 0;
    vqF_brkwhl_sup := 0;
    vqV_brkwhl_sup := 0;
    vqF_brkwhl_sup_trim := 0;
    vqF_brkwhl_inf_trim := 0;
    vqV_brkwhl_trim := 0;
    vqF_dtch_pull := 0;
    vqV_dtch_pull := 0;
    vqF_clamps_max := 0;
    vqT_heat_pre := 0;
    vqT_heat_pull := 0;
    vqT_heat_add := 0;
    vqT_heat_cut := 0;
    (* ShapeCurv *)
    vqF_lowe_curv := 0;
    vqV_lowe_curv := 0;
    vqF_score_curv_sup := 0;
    vqF_score_curv_inf := 0;
    vqV_score_curv := 0;
    vqF_brk_curv_sup := 0;
    vqF_brk_curv_inf := 0;
    vqV_brk_curv := 0;

    (* Quantità derivate *)
    vqGlass_Thckn := 0;
    vqGlass_ActualThckn := 0;
    vqMinLayer_Thckn := 0;
	vqMaxLayer_Thckn := 0;
    vqClamps_PressPull := 0;
    vqBlade_StartDisp := 0;
    vqBlade_AbortDisp := 0;

    (* Finally *)
    Reset := FALSE; (* eat *)

(* --- Servizio di set Parametri materiale ---
    In: vnBuf_SheetType, ..., vqBuf_F_score_inf, ...
   Out: vnSheetType, ..., vqF_score_inf, ...
  Cond: sempre possibile cambiare materiale
  Acts: Sovrascrivo i valori correnti       *)
ELSIF Set THEN

    Valid := FALSE; (* Invalido lo stato *)
    RST_MSG_IF_ON(MSG_INVALIDMAT);
    RST_MSG_IF_ON(MSG_GLASSTOOTHICK);
    RST_MSG_IF_ON(MSG_PVBTOOTHICK);

    dlog( Txt:='fbMatParam: -> Set glass %ld+%ld+%ld 0x%X', Lvl:=4, Val1:=vqBuf_SupThckn/1E3, Val2:=vqBuf_PvbThckn/1E3, Val3:=vqBuf_InfThckn/1E3, Val4:=TO_DINT(vnSheetType) );

    (* -- Tipologia materiale 'sheet-type' -- *)
    vnSheetType := vnBuf_SheetType;
    (* vnSheetType & BIT_LOWE, BIT_STRATO, BIT_FILMSUP, BIT_FILMINF *)
    IsStrato := (vnSheetType & BIT_STRATO)<>0;

    (* Potrei capirlo dagli spessori:
    IF (vqBuf_SupThckn==0 AND vqBuf_InfThckn>0) OR
       (vqBuf_InfThckn==0 AND vqBuf_SupThckn>0) THEN
        IsStrato := FALSE;
    END_IF; *)

    (* Se sta caricando un materiale basso emissivo su macchine senza mola... *)
    IF (vnSheetType & BIT_LOWE)<>0 AND vnGrLe_Type=0 THEN
        (* ...Mi rifiuto di lavorare: una sequenza di passi per basso emissivo
           contiene manovre di sola molatura, inutili se non ho la mola.
           Meglio togliere il flag dal materiale e rimandare il progetto *)
        dlog( Txt:='!! No Low-E grinder', Lvl:=1 );
        SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',0);
    END_IF;

    (* Tipologia vetro *)
    IF IsStrato THEN
        (* ---Vetro laminato--- *)
        dlog( Txt:='[[Material: Strato %ld%ld.%ld]]', Lvl:=4, Val1:=vqSupThckn/1E3, Val2:=vqInfThckn/1E3, Val3:=vqPvbThckn/300 );

        (* -- Spessori [um] 'h-glass-sup', 'h-glass-inf', 'h-plast' -- *)
        (* Controllo coerenza spessori: mi aspetto tutti gli spessori valorizzati *)
        IF vqBuf_SupThckn<=0 THEN
            dlog( Txt:='!! Invalid upper thickness %ld mm', Lvl:=1, Val1:=vqBuf_SupThckn/1E3 );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqBuf_SupThckn);
        END_IF;

        IF vqBuf_InfThckn<=0 THEN
            dlog( Txt:='!! Invalid lower thickness %ld mm', Lvl:=1, Val1:=vqBuf_InfThckn/1E3 );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqBuf_InfThckn);
        END_IF;

        IF vqBuf_PvbThckn<=0 OR vqBuf_PvbThckn>vqBuf_SupThckn OR vqBuf_PvbThckn>vqBuf_InfThckn THEN
            dlog( Txt:='!! Invalid PVB thickness %ld um', Lvl:=1, Val1:=vqBuf_PvbThckn );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqBuf_PvbThckn);
        END_IF;

        vqSupThckn := vqBuf_SupThckn;
        vqInfThckn := vqBuf_InfThckn;
        vqPvbThckn := vqBuf_PvbThckn;

        (* Quantità derivate: spessori massimo e minimo *)
        IF vqSupThckn > vqInfThckn THEN
            vqMinLayer_Thckn := vqInfThckn;
            vqMaxLayer_Thckn := vqSupThckn;
        ELSE
            vqMinLayer_Thckn := vqSupThckn;
            vqMaxLayer_Thckn := vqInfThckn;
        END_IF;

        (* Quantità derivata: spessore totale *)
        vqGlass_Thckn := vqSupThckn + vqPvbThckn + vqInfThckn;
        IF vqGlass_Thckn<1E3 OR vqGlass_Thckn>100E3 THEN
            dlog( Txt:='!! Invalid sheet thickness (%ld mm)', Lvl:=1, Val1:=vqGlass_Thckn/1E3 );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqGlass_Thckn);
        END_IF;

        (* Segnalo subito se sono troppo alti *)
        IF vqSupThckn>vqCut_LayerThcknMax THEN
            dlog( Txt:='!! Upper layer too thick! %ld>%ld', Lvl:=1, Val1:=vqSupThckn/1E3, Val2:=vqCut_LayerThcknMax/1E3 );
            SET_MSG(MSG_GLASSTOOTHICK,'MSG_GLASSTOOTHICK',vqSupThckn);
            (* SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqSupThckn); (* Invalido il materiale) *)
        END_IF;
        IF vqInfThckn>vqCut_LayerThcknMax THEN
            dlog( Txt:='!! Lower layer too thick! %ld>%ld', Lvl:=1, Val1:=vqInfThckn/1E3, Val2:=vqCut_LayerThcknMax/1E3 );
            SET_MSG(MSG_GLASSTOOTHICK,'MSG_GLASSTOOTHICK',vqInfThckn);
            (* SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqInfThckn); (* Invalido il materiale) *)
        END_IF;
        IF vqPvbThckn>vqCut_PvbThcknMax THEN
            dlog( Txt:='!! PVB too thick! %ld>%ld um', Lvl:=1, Val1:=vqPvbThckn, Val2:=vqCut_PvbThcknMax );
            SET_MSG(MSG_PVBTOOTHICK,'MSG_PVBTOOTHICK',vqPvbThckn);
            (* SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqPvbThckn); (* Invalido il materiale) *)
        END_IF;

    ELSE
        (* ---Vetro monolitico--- *)
        dlog( Txt:='[[Material: Float %ld (film %ld um)]]', Lvl:=4, Val1:=vqSupThckn/1E3, Val2:=vqPvbThckn );

        (* -- Spessori [um] 'h-glass-sup', 'h-glass-inf', 'h-plast' -- *)

        (* Controllo coerenza spessori: Pretendo uno dei due nullo?
        Nah, troppo rigido
        IF (vqBuf_SupThckn<>0 AND vqBuf_InfThckn<>0) OR
           (vqBuf_SupThckn<0 OR vqBuf_InfThckn<0 ) THEN
            dlog( Txt:='!! Invalid float thickness: %ld+%ld', Lvl:=1, Val1:=vqBuf_SupThckn/1E3, Val2:=vqBuf_InfThckn/1E3 );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',0);
        END_IF; *)

        (* Diciamo che considero quello maggiore *)
        (* Per avere compatibilità massima assegno lo spessore del vetro monolitico
           a tutti i registri: 'vqSupThckn', 'vqInfThckn' e 'vqGlass_Thckn' *)
        vqSupThckn := MAX( vqBuf_SupThckn, vqBuf_InfThckn );
        vqInfThckn := vqSupThckn;

        IF (vnSheetType & (BIT_FILMSUP OR BIT_FILMINF))<>0 THEN
            (* Want film thickness *)
            IF vqBuf_PvbThckn>0 THEN
                vqPvbThckn := vqBuf_PvbThckn; (* Se non nullo è lo spessore del film *)
            ELSE
                dlog( Txt:='! Null film', Lvl:=1 );
                vqPvbThckn := 0;
            END_IF;
        ELSE
            IF vqBuf_PvbThckn<>0 THEN
                dlog( Txt:='! Unexpected film: %ld um', Lvl:=2, Val1:=vqBuf_PvbThckn );
                vqPvbThckn := 0;
            END_IF;
        END_IF;

        (* Quantità derivate: spessori massimo e minimo *)
        vqMinLayer_Thckn := vqSupThckn;
        vqMaxLayer_Thckn := vqSupThckn;

        (* Quantità derivata: spessore totale *)
        vqGlass_Thckn := vqPvbThckn + vqSupThckn; (* vqSupThckn == vqInfThckn *)
        IF vqGlass_Thckn<1E3 THEN
            dlog( Txt:='!! Invalid float thickness %ld mm', Lvl:=1, Val1:=vqGlass_Thckn/1E3 );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqGlass_Thckn);
        END_IF;

        (* Segnalo subito se lo spessore è troppo alto  *)
        IF vqSupThckn>vqCut_FloatThcknMax THEN
            dlog( Txt:='!! Float glass too thick! %ld>%ld', Lvl:=1, Val1:=vqSupThckn/1E3, Val2:=vqCut_FloatThcknMax/1E3 );
            SET_MSG(MSG_GLASSTOOTHICK,'MSG_GLASSTOOTHICK',vqSupThckn);
        END_IF;

    END_IF; (* Tipologia vetro *)


    (* ---- Common part ---- *)
    (* -- Gradazione rotelle di incisione [deg] 'wheel-angle' -- *)
    IF vnBuf_WheelAngle<60 THEN
        (* Assumo rotella in base a spessore strato massimo *)
        IF vqMaxLayer_Thckn < 4E3 THEN    vnWheelAngle := 145; (* Fino a 3mm usiamo la 145° *)
        ELSIF vqMaxLayer_Thckn < 8E3 THEN vnWheelAngle := 155; (* Da 4mm in su usiamo la 152°gold/155° *)
                                     ELSE vnWheelAngle := 165; END_IF; (* Da 8mm in su usiamo la 160°/165° *)
        dlog( Txt:='Assuming score wheel %d (for %ld mm)', Lvl:=3, Val1:=TO_DINT(vnWheelAngle), Val2:=vqMaxLayer_Thckn/1E3 );
    ELSE
        vnWheelAngle := vnBuf_WheelAngle;
    END_IF;

    (* - Rileva cambio di spessore -
    IF ABS(vqInfThckn-Prev_InfThckn)>2E3 OR ABS(vqSupThckn-Prev_SupThckn)>2E3 THEN
        dlog( Txt:='Glass thickness changed %ld => %ld', Lvl:=4, Val1:=Prev_SupThckn/1E3, Val2:=vqSupThckn/1E3 );
    (* Remember last thickness
    Prev_InfThckn := vqInfThckn;
    Prev_SupThckn := vqSupThckn; *)

    (* Alza richiesta controllo gradazione rotelle taglio montate se necessario *)
    IF ABS(vnWheelAngle-Prev_WheelAngle)>5 THEN
        (* dlog( Txt:='Cutting wheel changed %d => %d', Lvl:=4, Val1:=TO_DINT(Prev_WheelAngle), Val2:=TO_DINT(vnWheelAngle) ); *)
        SET_MSG(REQ_CHK_CUTWHEELS,'REQ_CHK_CUTWHEELS',0);
        (* Remember adopted cutting wheels *)
        Prev_WheelAngle := vnWheelAngle;
    END_IF;

    (* -- Sequenza di taglio preferita 'cut-recipe' -- *)
    (* vnCutRecipe & BIT_NOBLADE, BIT_NOHEAT, BIT_STRESSED *)
    (* Non ci sono configurazioni di bit incoerenti *)
    (* Chiaramente deve essere gestita da chi valorizza il materiale,
       altrimenti meglio lasciarla 'appesa', l'operatore decide *)
    IF vbInitMatCutRecipe THEN
        (* Force a recipe: IF Force THEN vnCutRecipe := BIT_STRESSED; END_IF; *)
        vnCutRecipe := vnBuf_CutRecipe & vnEnabledRecipes; (* JobData( Cmd:=BIT_SETRECIPE); *)
        dlog( Txt:='-> vnCutRecipe set to 0x%X', Lvl:=4, Val1:=TO_DINT(vnCutRecipe) );
    END_IF;


    (* --SCORING-- *)

    (* vnWheelAngle *)
    (* vqSupThckn, vqInfThckn, vqPvbThckn *)

    (* -Spinte di incisione- 'f-score-*' *)
    IF vqBuf_F_score_inf<=0 AND vqBuf_F_score_sup<=0 THEN
        (* Valorizzazione automatica in base alla rotella *)
        IF vnWheelAngle<150 THEN
            vqF_score_inf := fnF_score_145(vqInfThckn);
            vqF_score_sup := fnF_score_145(vqSupThckn);
        ELSIF vnWheelAngle<160 THEN
            vqF_score_inf := fnF_score_155(vqInfThckn);
            vqF_score_sup := fnF_score_155(vqSupThckn);
        ELSE
            vqF_score_inf := fnF_score_165(vqInfThckn);
            vqF_score_sup := fnF_score_165(vqSupThckn);
        END_IF;
        dlog( Txt:='! Default f-score-sup=%ld inf=%ld N (%ld mm wheel %d)', Lvl:=4, Val1:=vqF_score_sup/1E3, Val2:=vqF_score_inf/1E3, Val3:=vqInfThckn/1E3, Val4:=TO_DINT(vnWheelAngle) );
    ELSE
        (* Una delle due è stata specificata, le prendo così come sono *)
        vqF_score_inf := vqBuf_F_score_inf;
        vqF_score_sup := vqBuf_F_score_sup;
    END_IF;
    (* Controllo dei valori *)
    IF vqF_score_sup<0 THEN
        dlog( Txt:='!! Invalid f-score-sup (%ld mN)', Lvl:=2, Val1:=vqF_score_sup );
        SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqF_score_sup);
    ELSIF vqF_score_sup>vqTscore_PushMax THEN
        dlog( Txt:='! Limit f-score-sup %ld>%ld N', Lvl:=4, Val1:=vqF_score_sup/1E3, Val2:=vqTscore_PushMax/1E3 );
        vqF_score_sup := vqTscore_PushMax;
    END_IF;
    IF vqF_score_inf<0 THEN
        dlog( Txt:='!! Invalid f-score-inf (%ld mN)', Lvl:=2, Val1:=vqF_score_inf );
        SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqF_score_inf);
    ELSIF vqF_score_inf>vqTscore_PushMax THEN
        dlog( Txt:='! Limit f-score-inf %ld>%ld N', Lvl:=4, Val1:=vqF_score_inf/1E3, Val2:=vqTscore_PushMax/1E3 );
        vqF_score_inf := vqTscore_PushMax;
    END_IF;


    (* -Velocità di incisione- 'v-score' *)
    IF vqBuf_V_score<=0 THEN
        (* Valorizzazione automatica *)
        vqV_score := fnV_score(vqMaxLayer_Thckn); (* [um/min] *)
        dlog( Txt:='! Default v-score=%ld m/min', Lvl:=4, Val1:=vqV_score/1E6 );
    ELSE
        vqV_score := vqBuf_V_score;
    END_IF;
    (* Controllo del valore *)
    IF vqV_score<=0 THEN
        dlog( Txt:='!! Invalid v-score (%ld um/min)', Lvl:=2, Val1:=vqV_score );
        SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqV_score);
    ELSIF vqV_score>vqTscore_SpdMax THEN
        dlog( Txt:='! Limit v-score %ld>%ld m/min', Lvl:=4, Val1:=vqV_score/1E6, Val2:=vqTscore_SpdMax/1E6 );
        vqV_score := vqTscore_SpdMax;
    END_IF;


    (* --LOWE-- *)
    IF (vnSheetType & BIT_LOWE)<>0 THEN
        (* -Spinta asportazione basso emissivo- 'f-lowe' *)
        IF vqBuf_F_lowe<=0 THEN
            vqF_lowe := vqGrLe_StdForce; (* mN *)
            dlog( Txt:='! Default f-lowe=%ld N', Lvl:=4, Val1:=vqF_lowe/1E3 );
        ELSE
            vqF_lowe := vqBuf_F_lowe;
        END_IF;
        (* Controllo del valore *)
        IF vqF_lowe<0 THEN
            dlog( Txt:='!! Invalid f-lowe (%ld mN)', Lvl:=2, Val1:=vqF_lowe );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqF_lowe);
        ELSIF vqF_lowe>vqGrLe_PushMax THEN
            dlog( Txt:='! Limit f-lowe %ld>%ld N', Lvl:=4, Val1:=vqF_lowe/1E3, Val2:=vqGrLe_PushMax/1E3 );
            vqF_lowe := vqGrLe_PushMax;
        END_IF;

        (* -Velocità asportazione basso emissivo- 'v-lowe' *)
        IF vqBuf_V_lowe<=0 THEN
            (* Valorizzazione automatica *)
            vqV_lowe := vqGrLe_StdSpd; (* [um/min] *)
            dlog( Txt:='! Default v-lowe=%ld m/min', Lvl:=4, Val1:=vqV_lowe/1E6 );
        ELSE
            vqV_lowe := vqBuf_V_lowe;
        END_IF;
        (* Controllo del valore *)
        IF vqV_lowe<=0 THEN
            dlog( Txt:='!! Invalid v-lowe (%ld um/min)', Lvl:=2, Val1:=vqV_lowe );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqV_lowe);
        ELSIF vqV_lowe>vqGrLe_SpdMax THEN
            dlog( Txt:='! Limit v-lowe %ld>%ld m/min', Lvl:=4, Val1:=vqV_lowe/1E6, Val2:=vqGrLe_SpdMax/1E6 );
            vqV_lowe := vqGrLe_SpdMax;
        END_IF;
    ELSE
        vqF_lowe := 0;
        vqV_lowe := 0;
    END_IF; (* Devo molare il basso emissivo? *)


    (* --OPEN-- *)

    (* -Tempo barra di troncaggio- 't-brkbar' *)
    IF vqBuf_T_brkbar<=0 THEN
        (* Valorizzazione automatica *)
        vqT_brkbar := vqBrkBar_MinTime + (vqBrkBar_OpenTime/10) * (vqGlass_Thckn/100);
        dlog( Txt:='! Default t-brkbar=%ld ms (%ld mm)', Lvl:=4, Val1:=vqT_brkbar, Val2:=vqGlass_Thckn/1E3 );
    ELSE
        vqT_brkbar := vqBuf_T_brkbar;
    END_IF;
    (* Controllo del valore *)
    IF vqT_brkbar<0 THEN
        dlog( Txt:='!! Invalid t-brkbar (%ld ms)', Lvl:=2, Val1:=vqT_brkbar );
        SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqT_brkbar);
    ELSIF vqT_brkbar>10E3 THEN
        dlog( Txt:='! Limit t-brkbar %ld>%ld s', Lvl:=4, Val1:=vqT_brkbar/1E3, Val2:=10 );
        vqT_brkbar := 10E3;
    END_IF;

    (* -Selettore altezza barra di troncaggio- 'h-brkbar' *)
    IF vqBuf_H_brkbar<=0 THEN
        (* Valorizzazione automatica *)
        vqH_brkbar := SEL(vqGlass_Thckn>12E3, DINT#1, DINT#2); (* threshold: 6+6 *)
        dlog( Txt:='! Default h-brkbar=%ld (%ld mm)', Lvl:=4, Val1:=vqH_brkbar, Val2:=vqGlass_Thckn/1E3 );
    ELSE
        vqH_brkbar := vqBuf_H_brkbar;
    END_IF;

    (* -Spinta premilastra durante apertura con barra- 'f-clamps-brk' *)
    IF vqBuf_F_clamps_brk<0 THEN
        (* Dovrei differenziare per il monolitico? IF IsStrato ... *)
        (* Valorizzazione automatica    vqClamps_PushMax |· · · · · ,-----
                                      vqClamps_Pbrk_20mm |· · · · +'
                                                         |      ,'|
                                       vqClamps_Pbrk_6mm |· · +'  |
                                                        -+---'|---|------->
                                                         |    6   20     thckn [mm] *)
        vqF_clamps_brk := TO_DINT( TO_LREAL(vqClamps_Pbrk_20mm - vqClamps_Pbrk_6mm) * TO_LREAL(vqGlass_Thckn-6000) / 14000.0  ); (* 14=20-6 *)
        vqF_clamps_brk := LIMIT( vqF_clamps_brk, 0, vqClamps_PushMax );
        dlog( Txt:='! Default f-clamps-brk=%ld N (%ld mm)', Lvl:=4, Val1:=vqF_clamps_brk/1E3, Val2:=vqGlass_Thckn/1E3 );
    ELSE
        vqF_clamps_brk := vqBuf_F_clamps_brk;
    END_IF;
    (* Controllo valore *)
    IF vqF_clamps_brk<0 THEN
        dlog( Txt:='!! Invalid f-clamps-brk (%ld mN)', Lvl:=2, Val1:=vqF_clamps_brk );
        SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqF_clamps_brk);
    ELSIF vqF_clamps_brk>vqClamps_PushMax THEN
        dlog( Txt:='! Limit f-clamps-brk %ld>%ld N', Lvl:=4, Val1:=vqF_clamps_brk/1E3, Val2:=vqClamps_PushMax/1E3 );
        vqF_clamps_brk := vqClamps_PushMax;
    END_IF;

    (* -Massima spinta premilastra ammessa- 'f-clamps-max' *)
    IF vqBuf_F_clamps_max<=0 OR vqBuf_F_clamps_max>vqClamps_PushMax THEN
        (* Valorizzazione automatica *)
        vqF_clamps_max := vqClamps_PushMax; (* [mN] *)
        dlog( Txt:='! Default f-clamps-max=%ld N', Lvl:=1, Val1:=vqF_clamps_max/1E3 );
    ELSE
        vqF_clamps_max := vqBuf_F_clamps_max;
    END_IF;

    (* Parametri specifici tipologia vetro *)
    IF IsStrato THEN
        (* -Forza pressione rotella di apertura singola- 'f-brkwhl-sup' *)
        IF vqBuf_F_brkwhl_sup<=0 THEN
            (* Valorizzazione automatica *)
            vqF_brkwhl_sup := fnF_brkwhl(vqInfThckn,vqPvbThckn); (* vqGlass_Thckn, vqSupThckn, vqInfThckn *)
            dlog( Txt:='! Default f-brkwhl-sup=%ld N (%ld mm)', Lvl:=4, Val1:=vqF_brkwhl_sup/1E3, Val2:=vqInfThckn/1E3 );
        ELSE
            vqF_brkwhl_sup := vqBuf_F_brkwhl_sup;
        END_IF;
        (* Controllo valore *)
        IF vqF_brkwhl_sup<0 THEN
            dlog( Txt:='!! Invalid f-brkwhl-sup (%ld mN)', Lvl:=2, Val1:=vqF_brkwhl_sup );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqF_brkwhl_sup);
        ELSIF vqF_brkwhl_sup>vqRbrk_PushMax THEN
            dlog( Txt:='! Limit f-brkwhl-sup %ld>%ld N', Lvl:=4, Val1:=vqF_brkwhl_sup/1E3, Val2:=vqRbrk_PushMax/1E3 );
            vqF_brkwhl_sup := vqRbrk_PushMax;
        END_IF;

        (* -Velocità rotella di apertura singola- 'v-brkwhl-sup' *)
        IF vqBuf_V_brkwhl_sup<=0 THEN
            (* Valorizzazione automatica *)
            vqV_brkwhl_sup := fnV_brkwhl(vqMaxLayer_Thckn); (* [um/min] *)
            dlog( Txt:='! Default v-brkwhl-sup=%ld m/min', Lvl:=4, Val1:=vqV_brkwhl_sup/1E6 );
        ELSE
            vqV_brkwhl_sup := vqBuf_V_brkwhl_sup;
        END_IF;
        (* Controllo del valore *)
        IF vqV_brkwhl_sup<=0 THEN
            dlog( Txt:='!! Invalid v-brkwhl-sup (%ld um/min)', Lvl:=2, Val1:=vqV_brkwhl_sup );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqV_brkwhl_sup);
        ELSIF vqV_brkwhl_sup>vqRbrk_SpdMax THEN
            dlog( Txt:='! Limit v-brkwhl-sup %ld>%ld m/min', Lvl:=4, Val1:=vqV_brkwhl_sup/1E6, Val2:=vqRbrk_SpdMax/1E6 );
            vqV_brkwhl_sup := vqRbrk_SpdMax;
        END_IF;

        (* -Forza pressione rotella sup apertura rifilo- 'f-brkwhl-sup-trim'
            Nota: La pressione antagonista è uguale e opposta *)
        IF vqBuf_F_brkwhl_sup_trim<=0 THEN
            (* Valorizzazione automatica *)
            (* vqF_brkwhl_sup_trim := fnF_brkwhl_trim_1st(vqInfThckn, vqSupThckn, vqPvbThckn); (* Prima passata che apre 'vqInfThckn' con 'vqSupThckn' non ancora aperto *)
            vqF_brkwhl_sup_trim := fnF_brkwhl_trim_2nd(vqInfThckn, vqPvbThckn); (* Seconda passata che apre 'vqInfThckn' con l'altro strato già aperto *)
            dlog( Txt:='! Default f-brkwhl-sup-trim=%ld N (%ld+%ld)', Lvl:=4, Val1:=vqF_brkwhl_sup_trim/1E3, Val2:=vqSupThckn/1E3, Val3:=vqInfThckn/1E3 );
        ELSE
            vqF_brkwhl_sup_trim := vqBuf_F_brkwhl_sup_trim;
        END_IF;
        (* Controllo valore *)
        IF vqF_brkwhl_sup_trim<0 THEN
            dlog( Txt:='!! Invalid f-brkwhl-sup-trim (%ld mN)', Lvl:=2, Val1:=vqF_brkwhl_sup_trim );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqF_brkwhl_sup_trim);
        ELSIF vqF_brkwhl_sup_trim>vqRbrk_PushMax THEN
            dlog( Txt:='! Limit f-brkwhl-sup-trim %ld>%ld N', Lvl:=4, Val1:=vqF_brkwhl_sup_trim/1E3, Val2:=vqRbrk_PushMax/1E3 );
            vqF_brkwhl_sup_trim := vqRbrk_PushMax;
        END_IF;

        (* -Forza pressione rotella inf apertura rifilo- 'f-brkwhl-inf-trim'
            Nota: La pressione antagonista è uguale e opposta *)
        IF vqBuf_F_brkwhl_inf_trim<=0 THEN
            (* Valorizzazione automatica *)
            vqF_brkwhl_inf_trim := fnF_brkwhl_trim_1st(vqSupThckn, vqInfThckn, vqPvbThckn); (* Prima passata che apre 'vqSupThckn' con 'vqInfThckn' non ancora aperto *)
            (* vqF_brkwhl_inf_trim := fnF_brkwhl_trim_2nd(vqSupThckn, vqPvbThckn); (* Seconda passata che apre 'vqSupThckn' con l'altro strato già aperto *)
            dlog( Txt:='! Default f-brkwhl-inf-trim=%ld N (%ld mm)', Lvl:=4, Val1:=vqF_brkwhl_inf_trim/1E3, Val2:=vqSupThckn/1E3 );
        ELSE
            vqF_brkwhl_inf_trim := vqBuf_F_brkwhl_inf_trim;
        END_IF;
        (* Controllo valore *)
        IF vqF_brkwhl_inf_trim<0 THEN
            dlog( Txt:='!! Invalid f-brkwhl-inf-trim (%ld mN)', Lvl:=2, Val1:=vqF_brkwhl_inf_trim );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqF_brkwhl_inf_trim);
        ELSIF vqF_brkwhl_inf_trim>vqRbrk_PushMax THEN
            dlog( Txt:='! Limit f-brkwhl-inf-trim %ld>%ld N', Lvl:=4, Val1:=vqF_brkwhl_inf_trim/1E3, Val2:=vqRbrk_PushMax/1E3 );
            vqF_brkwhl_inf_trim := vqRbrk_PushMax;
        END_IF;

        (* -Velocità rotelle di apertura rifilo- 'v-brkwhl-trim' *)
        IF vqBuf_V_brkwhl_trim<=0 THEN
            (* Valorizzazione automatica *)
            vqV_brkwhl_trim := fnV_brkwhl_trim(vqMaxLayer_Thckn); (* [um/min] *)
            dlog( Txt:='! Default v-brkwhl-trim=%ld m/min', Lvl:=4, Val1:=vqV_brkwhl_trim/1E6 );
        ELSE
            vqV_brkwhl_trim := vqBuf_V_brkwhl_trim;
        END_IF;
        (* Controllo del valore *)
        IF vqV_brkwhl_trim<=0 THEN
            dlog( Txt:='!! Invalid v-brkwhl-trim (%ld um/min)', Lvl:=2, Val1:=vqV_brkwhl_trim );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqV_brkwhl_trim);
        ELSIF vqV_brkwhl_trim>vqRbrk_SpdMax THEN
            dlog( Txt:='! Limit v-brkwhl-trim %ld>%ld m/min', Lvl:=4, Val1:=vqV_brkwhl_trim/1E6, Val2:=vqRbrk_SpdMax/1E6 );
            vqV_brkwhl_trim := vqRbrk_SpdMax;
        END_IF;


        (* --DETACH-- *)

        (* -Trazione plastico- 'f-dtch-pull' *)
        IF vqBuf_F_dtch_pull<=0 THEN
            (* Valorizzazione automatica *)
            vqF_dtch_pull := vqDtch_HowMuchPull * vqPvbThckn/100; (* [mN/m] *)
            dlog( Txt:='! Default f-dtch-pull=%ld N/m', Lvl:=4, Val1:=vqF_dtch_pull/1E3 );
        ELSE
            vqF_dtch_pull := vqBuf_F_dtch_pull;
        END_IF;

        (* -Velocità trazione plastico durante riscaldamento- 'v-dtch-pull' *)
        IF vqBuf_V_dtch_pull<=0 THEN
            (* Valorizzazione automatica *)
            vqV_dtch_pull := vqDtch_PullSpdStd; (* [um/min] *)
            dlog( Txt:='! Default v-dtch-pull=%ld mm/min', Lvl:=4, Val1:=vqV_dtch_pull/1E3 );
        ELSE
            vqV_dtch_pull := vqBuf_V_dtch_pull;
        END_IF;


        (* -Tempi riscaldamento- *)

        (* -Tempo pre-riscaldamento prima di tirare- 't-heat-pre' *)
        IF vqBuf_T_heat_pre<0 THEN
            (* Valorizzazione automatica *)
            vqT_heat_pre := MAX(0,fnT_heat_pre(vqInfThckn, vqPvbThckn)); (* [ms] *)
            dlog( Txt:='! Default t-heat-pre=%ld s', Lvl:=4, Val1:=vqT_heat_pre/1E3 );
        ELSE
            vqT_heat_pre := vqBuf_T_heat_pre;
        END_IF;
        (* Controllo valore *)
        IF vqT_heat_pre<0 THEN
            dlog( Txt:='!! Invalid t-heat-pre (%ld ms)', Lvl:=2, Val1:=vqT_heat_pre );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqT_heat_pre);
        ELSIF vqT_heat_pre>vqLamp_MaxTimeOut THEN
            dlog( Txt:='! Limit t-heat-pre %ld>%ld s', Lvl:=4, Val1:=vqT_heat_pre/1E3, Val1:=vqLamp_MaxTimeOut/1E3 );
            vqT_heat_pre := vqLamp_MaxTimeOut;
        END_IF;

        (* -Tempo riscaldamento durante trazione- 't-heat-pull' *)
        IF vqBuf_T_heat_pull<0 THEN
            (* Valorizzazione automatica *)
            vqT_heat_pull := MAX(0,fnT_heat_pull(vqInfThckn, vqPvbThckn)); (* [ms] *)
            dlog( Txt:='! Default t-heat-pull=%ld s', Lvl:=4, Val1:=vqT_heat_pull/1E3 );
        ELSE
            vqT_heat_pull := vqBuf_T_heat_pull;
        END_IF;
        (* Controllo valore *)
        IF vqT_heat_pull<0 THEN
            dlog( Txt:='!! Invalid t-heat-pull (%ld ms)', Lvl:=2, Val1:=vqT_heat_pull );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqT_heat_pull);
        ELSIF vqT_heat_pull>vqLamp_MaxTimeOut THEN
            dlog( Txt:='! Limit t-heat-pull %ld>%ld s', Lvl:=4, Val1:=vqT_heat_pull/1E3, Val1:=vqLamp_MaxTimeOut/1E3 );
            vqT_heat_pull := vqLamp_MaxTimeOut;
        END_IF;

        (* -Tempo riscaldamento addizionale per ciclo rifilo- 't-heat-add' *)
        IF vqBuf_T_heat_add<0 THEN
            (* Valorizzazione automatica *)
            vqT_heat_add := MAX(0,fnT_heat_add(vqInfThckn, vqPvbThckn)); (* [ms] *)
            dlog( Txt:='! Default t-heat-add=%ld s', Lvl:=4, Val1:=vqT_heat_add/1E3 );
        ELSE
            vqT_heat_add := vqBuf_T_heat_add;
        END_IF;
        (* Controllo valore *)
        IF vqT_heat_add<0 THEN
            dlog( Txt:='!! Invalid t-heat-add (%ld ms)', Lvl:=2, Val1:=vqT_heat_add );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqT_heat_add);
        ELSIF vqT_heat_add>vqLamp_MaxTimeOut THEN (* In teoria dovrebbe essere: vqLamp_MaxTimeOut-vqT_heat_pre *)
            dlog( Txt:='! Limit t-heat-add %ld>%ld s', Lvl:=4, Val1:=vqT_heat_add/1E3, Val1:=vqLamp_MaxTimeOut/1E3 );
            vqT_heat_add := vqLamp_MaxTimeOut;
        END_IF;

        (* -Tempo riscaldamento taglio per cicliche speciali vetro tensionato- 't-heat-cut' *)
        IF vqBuf_T_heat_cut<0 THEN
            (* Valorizzazione automatica *)
            vqT_heat_cut := MAX(0,fnT_heat_cut(vqInfThckn, vqPvbThckn)); (* [ms] *)
            dlog( Txt:='! Default t-heat-cut=%ld s', Lvl:=4, Val1:=vqT_heat_cut/1E3 );
        ELSE
            vqT_heat_cut := vqBuf_T_heat_cut;
        END_IF;
        (* Controllo valore *)
        IF vqT_heat_cut<0 THEN
            dlog( Txt:='!! Invalid t-heat-cut (%ld ms)', Lvl:=2, Val1:=vqT_heat_cut );
            SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',vqT_heat_cut);
        ELSIF vqT_heat_cut>vqLamp_MaxTimeOut THEN
            dlog( Txt:='! Limit t-heat-cut %ld>%ld s', Lvl:=4, Val1:=vqT_heat_cut/1E3, Val1:=vqLamp_MaxTimeOut/1E3 );
            vqT_heat_cut := vqLamp_MaxTimeOut;
        END_IF;

        (* -Incremento dei tempi per periodo invernale- *)
        IF (vqWorkSettings & BIT_MOREHEAT)<>0 THEN
            dlog( Txt:='! Increasing heat times of %d%%', Lvl:=1, Val1:=TO_DINT(vnTheat_Incr) );
            vqT_heat_pre  := MIN(vqLamp_MaxTimeOut, (TO_DINT(vnTheat_Incr) * vqT_heat_pre) / 100);
            vqT_heat_pull := MIN(vqLamp_MaxTimeOut, (TO_DINT(vnTheat_Incr) * vqT_heat_pull) / 100);
            vqT_heat_add  := MIN(vqLamp_MaxTimeOut, (TO_DINT(vnTheat_Incr) * vqT_heat_add) / 100);
            vqT_heat_cut  := MIN(vqLamp_MaxTimeOut, (TO_DINT(vnTheat_Incr) * vqT_heat_cut) / 100);
        END_IF;


        (* -- Quantità derivate -- *)
        (* -Spinta premilastra durante trazione separazione-
           La questione è più complessa di quanto non sembri:
               .Schiacciare troppo stressa la macchina
               .Se la macchina non è in piano si rompono vetri tensionati e si creano conchiglie in quelli spessi
           Quindi moduliamo la spinta premilastra a seconda della trazione
           La trazione stacco e la pressione premilastra sono legati dal coeff. di attrito gomma/vetro
                      |   Fp  |    Affinchè non scivoli:
                      |___V___|       Ft <= Kfr Fp   quindi Fp = (Ft+Delta)/Kfr
            Ft <-  =============
           Inoltre non voglio regolare tanto la forza totale quanto la pressione sul vetro:
           se c'è poco vetro voglio spingere di meno per non rovinare la gomma dei premilastra
           e per evitare stress meccanici localizzati: le forze di attrito dipendono dalla
           spinta per superficie. Determino quindi una pressione desiderata (in prima approx
           potrebbe essere per lunghezza vetro pinzato e non per area pinzata dal premilastra): *)
        vqClamps_PressPull := (vqF_dtch_pull/100) * (vqClamps_Kslip/10);
        (* Nota: nel caso di (vnCutRecipe & BIT_MAXPULL) viene ignorata *)


        (* -Soglia scostamento stacco per inizio tasteggio lametta-
           In base a spessore dello strato più spesso, limita con funzione sigma
                                 ^      _______
          vqBlade_StartDisp_12mm |     /
                                 |    /
          vqBlade_StartDisp_2mm  |___/
                              ---+-------------->
                                 |  2  12      thickness [mm] *)
        (* vqBlade_StartDisp := TO_DINT(fnLinterp(x:=TO_LREAL(vqMaxLayer_Thckn), x1:=2.0E3, x2:=12.0E3,
                                                  y1:=TO_LREAL(vqBlade_StartDisp_2mm), y2:=TO_LREAL(vqBlade_StartDisp_12mm) )); *)
        IF vqMaxLayer_Thckn <= 2E3 THEN
            vqBlade_StartDisp := vqBlade_StartDisp_2mm;
        ELSIF vqMaxLayer_Thckn >= 12E3 THEN
            vqBlade_StartDisp := vqBlade_StartDisp_12mm;
        ELSE
            vqBlade_StartDisp := TO_DINT( TO_LREAL(vqBlade_StartDisp_12mm - vqBlade_StartDisp_2mm) * TO_LREAL(vqMaxLayer_Thckn-2E3) / 10.0E3  ) + vqBlade_StartDisp_2mm; (* 10=12-2 *)
        END_IF;
        (* Applico correttore *)
        vqBlade_StartDisp := vqBlade_StartDisp + vqDtch_CutStretchMod;
        (* Lo scostamento massimo è un multiplo di quello iniziale *)
        vqBlade_AbortDisp := ((vqBlade_AbortDispK/10) * vqBlade_StartDisp) / 100;

    ELSE
        (* Vetro monolitico: Sovrascrivi parametri non usati *)
        vqF_brkwhl_sup := 0;
        vqV_brkwhl_sup := 0;
        vqF_brkwhl_sup_trim := 0;
        vqF_brkwhl_inf_trim := 0;
        vqV_brkwhl_trim := 0;
        vqF_dtch_pull := 0;
        vqV_dtch_pull := 0;
        vqT_heat_pre := 0;
        vqT_heat_pull := 0;
        vqT_heat_add := 0;
        vqT_heat_cut := 0;
        (* -- Quantità derivate -- *)
        vqClamps_PressPull := 0;
        vqBlade_StartDisp := 0;
        vqBlade_AbortDisp := 0;
    END_IF;

    (* - ShapeCurv -
         Parametri aggiuntivi per sagomato curvilineo *)
    (* IF (vnSheetType & BIT_LOWE)<>0 THEN *)
    vqF_lowe_curv := LIMIT( vqF_lowe_curv, 0, vqGrLe_PushMax );
    vqV_lowe_curv := LIMIT( vqV_lowe_curv, 0, vqGrLe_SpdMax );
    vqF_score_curv_sup := LIMIT( vqF_score_curv_sup, 0, vqTscore_PushMax );
    vqF_score_curv_inf := LIMIT( vqF_score_curv_inf, 0, vqTscore_PushMax );
    vqV_score_curv := LIMIT( vqV_score_curv, 0, vqTscore_SpdMax );
    vqF_brk_curv_sup := LIMIT( vqF_brk_curv_sup, 0, vqRbrk_PushMax );
    vqF_brk_curv_inf := LIMIT( vqF_brk_curv_inf, 0, vqRbrk_PushMax );
    vqV_brk_curv := LIMIT( vqV_brk_curv, 0, vqRbrk_SpdMax );
    (* Eventuali valorizzazioni di default
    IF vqF_lowe_curv=0 THEN vqF_lowe_curv := vqGrLe_StdForce; END_IF;
    IF vqV_lowe_curv=0 THEN vqV_lowe_curv := vqGrLe2_DefSpd; END_IF;
    IF vqF_score_curv_sup=0 THEN vqF_score_curv_sup := (vqF_score_sup * 120) / 100; END_IF;
    IF vqF_score_curv_inf=0 THEN vqF_score_curv_inf := (vqF_score_inf * 120) / 100; END_IF;
    IF vqV_score_curv=0 THEN vqV_score_curv := vqTscore2_DefSpd; END_IF;
    IF vqF_brk_curv_sup=0 THEN vqF_brk_curv_sup := 10 * vqSupThckn; END_IF;
    IF vqF_brk_curv_inf=0 THEN vqF_brk_curv_inf := 10 * vqInfThckn; END_IF;
    IF vqV_brk_curv=0 THEN vqV_brk_curv := vqRbrk2_DefSpd; END_IF;
    *)


    (* - Misura spessore effettivo - *)
    vqGlass_ActualThckn := 0; (* Invalida misure precedenti *)
    (* Meglio richiedere misura se i premilastra sono motorizzati?
       Sarebbe pericoloso basarsi sul materiale dichiarato,
       l'operatore può sbagliare a sincronizzare il lavoro! *)
    IF vnClampAlgn_Type=2 OR vnClampDtch_Type=2 THEN
        vqWorkSettings := vqWorkSettings OR BIT_CHECKTHCKN;
    END_IF;


    (* ---- Finally ---- *)
    Set := FALSE; (* eat *)
    Valid := NOT IS_MSG(MSG_INVALIDMAT);
END_IF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbJobData

{ DE:"Job data manager" }

	VAR_IN_OUT
	Cmd : INT; { DE:"Command" }
	MatPars : fbMatParams; { DE:"Parametri di lavorazione del materiale" }
	Scheme : fbUdfData; { DE:"Steps sequence of loaded scheme" }
	END_VAR

	VAR_OUTPUT
	Valid : BOOL; { DE:"Argomenti passo di lavorazione pronti e validi" }
	EmptyStep : BOOL; { DE:"Da caricare/caricato un passo vuoto" }
	JustValid : BOOL; { DE:"Attivo un solo scan" }
	JustInvalid : BOOL; { DE:"Attivo un solo scan" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	CalcAlgnDelta : fbCalcAlgnDelta; { DE:"Calcola delta riscontro" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	vnBuf_SchemesCount : INT; { DE:"Buffer valore da Hmi" }
	vnSheetIndex : INT; { DE:"Indice lastra (ripetizione) dello schema corrente" }
	vnBuf_StepIndex : INT; { DE:"Buffer valore da Hmi" }
	vnBuf_StepSettings : INT; { DE:"Buffer valore da Hmi" }
	vnBuf_StackedSheets : INT; { DE:"Buffer valore da Hmi" }
	vqBuf_SubSheet_Width : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_SubSheet_Height : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_SubSheet_MoveInfo : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_Proc_Algn : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_Prod_MoveInfo : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_Remn_MoveInfo : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_Proc_Ybtm : DINT; { DE:"Buffer valore da Hmi" }
	vqBuf_Proc_Ytop : DINT; { DE:"Buffer valore da Hmi" }
	vnSchemesCount : INT; { DE:"Numero di schemi della commessa" }
	vaProjName : VASTR; { DE:"Nome progetto caricato" }
	vaSchemeFile : VASTR; { DE:"Nome file schema selezionato" }
	vnSchemeIndex : INT; { DE:"Indice schema di taglio corrente" }
	vnSheetsCount : INT; { DE:"Numero lastre (ripetizioni) dello schema corrente" }
	vnPiecesCount : INT; { DE:"Numero pezzi finiti dello schema" }
	vnSchemeType : INT; { DE:"Tipologia schema" }
	vnStep_NoMoreIns : INT; { DE:"Indice passo oltre il quale il tavolo di carico si libera" }
	vqSheetWidth : DINT; { DE:"Dimensione orizzontale dichiarata lastra completa [um]" }
	vqSheetHeight : DINT; { DE:"Dimensione verticale dichiarata lastra completa [um]" }
	vaSchemeInfo : VASTR; { DE:"Descrizione schema caricato !UDF!" }
	vnTotSteps : INT; { DE:"Numero dei passi caricati" }
	vnStepIndex : INT; { DE:"Indice passo dello schema corrente [1-TotSteps]" }
	vnSheetType : INT; { DE:"Tipologia materiale 'sheet-type'" }
	vqGlass_Thckn : DINT; { DE:"Spessore complessivo dichiarato della lastra in lavorazione [um]" }
	vqGlass_ActualThckn : DINT; { DE:"Spessore complessivo misurato [um]" }
	vnCutRecipe : INT; { DE:"Sequenza di taglio preferita 'cut-recipe'" }
	vnBuf_CutRecipe : INT; { DE:"Buffer valore da Hmi" }
	vnStepSettings : INT; { DE:"Flags del passo di lavorazione" }
	vnStackedSheets : INT; { DE:"Numero sottolastre accumulate sul carico" }
	vqSubSheet_Width : DINT; { DE:"Dimensione longitudinale lastra in arrivo [um]" }
	vqSubSheet_Height : DINT; { DE:"Dimensione trasversale lastra in arrivo [um]" }
	vqSubSheet_MoveInfo : DINT; { DE:"Dati movimentazione sottolastra in arrivo" }
	vqProc_Algn : DINT; { DE:"Quota riscontro per taglio/processazione [um]" }
	vqProd_MoveInfo : DINT; { DE:"Dati movimentazione del prodotto" }
	vqRemn_MoveInfo : DINT; { DE:"Dati movimentazione della rimanenza" }
	vqProc_Ybtm : DINT; { DE:"Quota Y basso processazione [um]" }
	vqProc_Ytop : DINT; { DE:"Quota Y alto processazione [um]" }
	vbStepValid : BOOL; { DE:"Passo di lavorazione valido e caricato" }
	vbLastStep : BOOL; { DE:"Ultimo passo dello schema" }
	vbMustAlign : BOOL; { DE:"È necessario riscontrare la sottolastra da processare" }
	vnSubSheet_Id : INT; { DE:"Identificativo sottolastra" }
	vbSubSheet_HasShape : BOOL; { DE:"La sottolastra in arrivo va lavorata come sagoma" }
	vbSubSheet_Prescored : BOOL; { DE:"La sottolastra in arrivo contiene preincisioni" }
	vnSubSheet_From : INT; { DE:"Provenienza sottolastra" }
	vnSubSheet_Rot : INT; { DE:"Rotazione sottolastra" }
	vnSubSheet_To : INT; { DE:"Destinazione sottolastra" }
	vnProd_Id : INT; { DE:"Identificativo prodotto" }
	vbProd_HasShape : BOOL; { DE:"Il prodotto contiene sagome" }
	vbProd_Prescored : BOOL; { DE:"Il prodotto contiene preincisioni" }
	vnProd_From : INT; { DE:"Provenienza prodotto" }
	vnProd_Rot : INT; { DE:"Rotazione prodotto" }
	vnProd_To : INT; { DE:"Destinazione prodotto" }
	vnRemn_Id : INT; { DE:"Identificativo rimanenza" }
	vbRemn_HasShape : BOOL; { DE:"La rimanenza contiene sagome" }
	vbRemn_Prescored : BOOL; { DE:"La rimanenza contiene preincisioni" }
	vnRemn_From : INT; { DE:"Provenienza rimanenza" }
	vnRemn_Rot : INT; { DE:"Rotazione rimanenza" }
	vnRemn_To : INT; { DE:"Destinazione rimanenza" }
	vqCut_Height : DINT; { DE:"Lunghezza taglio/altezza pezzi dichiarata [um]" }
	vqY_BtmEdge : DINT; { DE:"Quota misurata bordo vetro basso [um]" }
	vqY_TopEdge : DINT; { DE:"Quota misurata bordo vetro alto [um]" }
	vqCut_Length : DINT; { DE:"Lunghezza taglio effettiva [um]" }
	vqProd_Width : DINT; { DE:"Dimensione longitudinale prodotto del taglio [um]" }
	vqRemn_Width : DINT; { DE:"Dimensione longitudinale rimanenza del taglio [um]" }
	vqSubSheet_ProcWidth : DINT; { DE:"Dimensione longitudinale lastra in arrivo (dopo la rotazione) [um]" }
	vqSubSheet_ProcHeight : DINT; { DE:"Dimensione trasversale lastra in arrivo (dopo la rotazione) [um]" }
	vqProc_AlgnDelta : DINT; { DE:"Spostamento di riscontro lastra [um]" }
	vqProcArea_Xmax : DINT; { DE:"Zona occupata da sottolastra in arrivo [um]" }
	vqProcArea_Xmin : DINT; { DE:"Zona da liberare lato stacco [um]" }
	vqProcArea_XmaxMrg : DINT; { DE:"Margine avanti per area X occupata da un passo di lavorazione [um]" }
	vbAlgn_FloatStripesBreak : BOOL; { DE:"Riscontra il troncaggio traversi monolitico" }
	vbFloatStripesBreak : BOOL; { DE:"Troncaggio traversi monolitico (vedi BIT_STRIPES)" }
	vbFrontTrim : BOOL; { DE:"Rifilo di testa da non riscontrare" }
	vbZprescore : BOOL; { DE:"Il passo corrente è una preincisione di un taglio annidato" }
	vbZprescored_Done : BOOL; { DE:"Il passo precedente è stato una preincisione eseguita con successo" }
	vdSubSheet_Mass : LREAL; { DE:"Massa della sottolastra corrente [Kg]" }
	vdRemn_Mass : LREAL; { DE:"Massa della rimanenza corrente [Kg]" }
	vdProd_Mass : LREAL; { DE:"Massa del prodotto corrente [Kg]" }
	vdSubSheet_Jm : LREAL; { DE:"Momento d'inerzia rispetto il centro di massa sottolastra corrente [Kg m²]" }
	vdProd_Jm : LREAL; { DE:"Momento d'inerzia rispetto il centro di massa del prodotto [Kg m²]" }
	vdRemn_Jm : LREAL; { DE:"Momento d'inerzia rispetto il centro di massa della rimanenza [Kg m²]" }
	vqAlgn_UpMargin : DINT; { DE:"Margine per salita piedini al riscontro [um]" }
	vqAlgnMax : DINT; { DE:"Massima quota riscontrabile (senza margine) [um]" }
	vqDtch_Xbegin : DINT; { DE:"Ascissa inizio zona stacco [um]" }
	vqX_OutTableEnd : DINT; { DE:"Ascissa legno fine tavolo a valle [um]" }
	vqAlgnBlk_ForeOppDist : DINT; { DE:"Distanza del punto di appoggio opposto dei piedini anteriori [um]" }
	vqAlgnBlk_RearOppDist : DINT; { DE:"Distanza del punto di appoggio opposto dei piedini posteriori [um]" }
	vqAlgn_DragForeMargin : DINT; { DE:"Margine di aggancio con piedini anteriori [um]" }
	vqAlgn_DragRearMargin : DINT; { DE:"Margine di inizio spinta con piedini posteriori [um]" }
	vqCut_MinLength : DINT; { DE:"Lunghezza minima taglio [um]" }
	vqRemn_OpenMinWidth : DINT; { DE:"Rimanenza minima apribile automaticamente [um]" }
	vqRemn_DtchMinWidth : DINT; { DE:"Rimanenza minima separabile automaticamente [um]" }
	vqProd_OpenMinWidth : DINT; { DE:"Prodotto minimo apribile automaticamente [um]" }
	vqProd_DtchMinWidth : DINT; { DE:"Prodotto minimo separabile automaticamente [um]" }
	vqXs_MaxForce : DINT; { DE:"Max sforzo strutturale trasmissione asse stacco [mN]" }
	vqLamp_MaxTimeOut : DINT; { DE:"Massimo tempo di accensione con lampada fuori [ms]" }
	vqX_CutZoneP : DINT; { DE:"Quota X inizio piano di appoggio/premilastra riscontri [um]" }
	vqCarrInf_CurrXroomM : DINT; { DE:"Ingombro X (lato stacco) carrello inferiore [um]" }
	vnEnabledRecipes : INT; { DE:"Ricette abilitate" }
	vqFallWidth : DINT; { DE:"Soglia larghezza per pericolo caduta vetro [um]" }
	vqFall_MaxMargin : DINT; { DE:"Margine massimo sui controlli caduta vetro [um]" }
	vbExtractDone : BOOL; { DE:"Sottolastra in arrivo estratta da carico" }
	vbPreRotDone : BOOL; { DE:"Sottolastra in arrivo già ruotata" }
	vbEdgeTrimmed : BOOL; { DE:"Bava plastico rimossa" }
	vbProcDone : BOOL; { DE:"Taglio processato" }
	vbDetachDone : BOOL; { DE:"Sottolastra separata" }
	vnPieceDelivering : INT; { DE:"Identificativo pezzo in consegna" }
	vnPieceTaken : INT; { DE:"Identificativo ultimo pezzo prelevato" }
	vqRemn_X : DINT; { DE:"Posizione bordo avanti della rimanenza [um]" }
	vqSubSheet_X : DINT; { DE:"Posizione X bordo avanti della lastra in arrivo [um]" }
	vqSubSheet_Y : DINT; { DE:"Posizione Y bordo basso della lastra in arrivo [um]" }
	vqInsSheet_Y : DINT; { DE:"Posizione Y bordo basso dell'ultima lastra inserita nel carico [um]" }
	vbNextStep_Valid : BOOL; { DE:"Passo successivo valido" }
	vqNextStep_FirstAlgn : DINT; { DE:"Prossima quota riscontri (per rotazione o processazione) [um]" }
	vqNextProcArea_Xmin : DINT; { DE:"Prossima area processazione vetro: X minimo (lato stacco) [um]" }
	vqNextProcArea_Xmax : DINT; { DE:"Prossima area processazione vetro: X massimo [um]" }
	vbNextStep_Zprescore : BOOL; { DE:"Il passo successivo è una preincisione" }
	vbStep_RotSheetOnAlgn : BOOL; { DE:"Ruota sempre la lastra in arrivo portandola sui riscontri" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vbFeat_FullAuto : BOOL; { DE:"Macchina con movimentazione completamente automatica del vetro" }
	vbSchemeDone : BOOL; { DE:"Schema completamente eseguito" }
	vbSchemeAlmostDone : BOOL; { DE:"Schema quasi terminato" }
	vqProjectsCount : DINT; { DE:"Contatore progetti trasmessi" }
	vqSchemesCount : DINT; { DE:"Contatore schemi eseguiti" }
	vbAlgnEvac_Scheduled : BOOL; { DE:"Prenotazione evacuazione fuori" }
	vqAlgnEvac_Xbck : DINT; { DE:"Posizione bordo indietro vetro da evacuare fuori [um]" }
	vbSheet_WasUpRight : BOOL; { DE:"La lastra caricata è stata squadrata con le rotelle" }
	vqProd_TrimWidth : DINT; { DE:"Soglia larghezza prodotto per sequenza separazione rifilo di testa [um]" }
	vqJustScore_MaxHeight : DINT; { DE:"Altezza massima per sola incisione rifilo [um]" }
	vqJustScore_RemnMaxWidth : DINT; { DE:"Larghezza rimanenza massima per sola incisione rifilo [um]" }
	vbAlgn_AutoInd : BOOL; { DE:"Porta subito i riscontri in quota sincronizzando in manuale" }
	vnAlgnBlocks_Sts : INT; { DE:"Stato dei piedini di riscontro" }
	vbSelAlgnInd : BOOL; { DE:"Seleziona indicatore della quota riscontri programmata" }
	vbBtnStartAlgn : BOOL; { DE:"Esegui la sequenza di riscontro" }
	vbWillTiltOutPiece : BOOL; { DE:"Almeno un pezzo sarà mandato alla ribaltina" }
	vnTiltOut_Type : INT; { DE:"Tipo ribaltina scarico pezzi" }
	vqWorkSettings : DINT; { DE:"Selettori ritentivi di lavorazione" }
	vnHmi_SendData : INT; { DE:"Richiesta a Hmi trasmissione dati" }
	END_VAR

	VAR
	D : DINT; { DE:"Temporaneo per calcoli" }
	END_VAR

	{ CODE:ST }(*    fbJobData (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Gestisce la valorizzazione dei dati di taglio:
        .Schemi (sequenze passi) in automatico
        .Dati di lavorazione del materiale
        .Argomenti della singola sequenza di taglio
      Questi valori arrivano in genere dalla
      comunicazione con l'interfaccia utente.
      In modalità automatica carica i dati dello
      schema selezionato e del passo corrente, in
      modalità manuale gestisce i dati del taglio
      in arrivo da PC.

      DETAILS
      ----------------------------------------------
      Per le sequenze dei passi della lavorazione
      automatica utilizza la funzione di caricamento
      dati 'fbUdfData' che incorpora il meccanismo
      di Sipro dei dati utente.
      Le condizioni dei comandi devono essere
      controllate dal chiamante.

      EXAMPLE OF USAGE
      ----------------------------------------------
      JobData : fbJobData; { DE:"Dati e argomenti della lavorazione" }
      JobData();
      IF JobData.Valid THEN ...
*)

IF Scheme.Load THEN
    (* Loading a scheme data file, waiting completion *)
    Scheme();
    (* Rileva immediatamente se ha terminato *)
    IF NOT Scheme.Load THEN
        IF Scheme.Loaded THEN
            vbSchemeDone := FALSE;

            (* Verifica dati schema caricati *)
            (*
            IF vaSchemeInfo<>vaProjName THEN
                dlog( Txt:=CONCAT('fbJobData: scheme %ld has different project ',vaSchemeInfo), Lvl:=4, Val1:=TO_DINT(vnSchemeIndex) );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',0);
            END_IF;
            *)

            IF vqSheetWidth<1E3 THEN
                dlog( Txt:='fbJobData: !! Invalid sheet width %ld mm', Lvl:=1, Val1:=vqSheetWidth/1E3 );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',vqSheetWidth);
            END_IF;

            IF vqSheetHeight<1E3 THEN
                dlog( Txt:='fbJobData: !! Invalid sheet height %ld mm', Lvl:=1, Val1:=vqSheetHeight/1E3 );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',vqSheetHeight);
            END_IF;

            (* Finally *)
            IF IS_MSG(MSG_BAD_JOBARGS) THEN
                dlog( Txt:='fbJobData: !! Bad data in loaded scheme!', Lvl:=1 );
                Cmd := 0; (* Abort further commands *)
            ELSE
                vnStepIndex := Scheme.CurStep;
                vnTotSteps := Scheme.TotSteps;
                dlog( Txt:='fbJobData: Loaded scheme %ld: %ldx%ld, %d steps', Lvl:=4, Val1:=TO_DINT(vnSchemeIndex), Val2:=vqSheetWidth/1E3, Val3:=vqSheetHeight/1E3, Val4:=TO_DINT(vnTotSteps) );
                (* Tipologia schema 'vnSchemeType' *)
                (* Indice passo oltre il quale il tavolo di carico si libera *)
                IF vnStep_NoMoreIns<1 THEN
                    (* Nah, non mi piace se è nullo o negativo, lo pongo oltre l'ultimo passo *)
                    dlog( Txt:='fbJobData: !! Feed will never be available!', Lvl:=2 );
                    vnStep_NoMoreIns := vnTotSteps + 1;
                END_IF;
            END_IF;
        ELSE
            (* Error loading scheme *)
            dlog( Txt:='fbJobData: !! Bad or missing UDF file', Lvl:=1 );
            SET_MSG(MSG_BAD_SCHEMEDATA,'MSG_BAD_SCHEMEDATA',0);
            (* SET_MSG(MSG_INVALIDPRJ,'MSG_INVALIDPRJ',0); *)
        END_IF;
        (* In ogni caso, mangia il comando *)
        Cmd := Cmd & NOT BIT_SETSCHEME; (* eat command *)
    END_IF;
ELSE
    (* Respond to commands *)
    (* --------------------------------------------------------------- *)
    IF (Cmd & BIT_RSTPRJ)<>0 THEN
        (* -- Servizio di reset di tutti gli argomenti del lavoro --
          Acts: .Invalido il passo corrente
                .Resetto i dati della sequenza passi *)
        dlog( Txt:='fbJobData: Resetting project', Lvl:=4 );

        (* Cancella i files in RAMDisk? No, fallo prima di spedire i files *)
        (* VN_SYS_RELOAD_PROG := 65; (* RPC_ERASE_ALL *)

        Scheme( Clear:=TRUE ); (* Ripulisco lo schema caricato *)
        MatPars( Reset:=TRUE ); (* Parametri materiale *)

        (* Dati progetto (auto) *)
        vnSchemesCount := 0;
        (* vaProjName := ''; *)

        (* Dati schema (auto) *)
        vaSchemeFile := '';
        vnSchemeIndex := 0;
        vnSheetsCount := 0;
        vnPiecesCount := 0;
        vnSchemeType := 0;
        vnStep_NoMoreIns := 0;
        vqSheetWidth := 0;
        vqSheetHeight := 0;
        vaSchemeInfo := '';
        vnTotSteps := 0;

        (* Argomenti del passo di lavorazione (auto/man) *)
        vnStepSettings := 0;
        vnStackedSheets := 0;
        vqSubSheet_Width := 0;
        vqSubSheet_Height := 0;
        vqSubSheet_MoveInfo := 0;
        vqProc_Algn := 0;
        vqProd_MoveInfo := 0;
        vqRemn_MoveInfo := 0;
        vqProc_Ybtm := 0;
        vqProc_Ytop := 0;

        (* Quantità derivate *)
        vbStepValid := FALSE;
        vbLastStep := FALSE;
        vbWillTiltOutPiece := FALSE;
        vbMustAlign := FALSE;
        vqCut_Height := 0;
        vqProd_Width := 0;
        vqRemn_Width := 0;
        vqSubSheet_ProcWidth := 0;
        vqSubSheet_ProcHeight := 0;
        vqProc_AlgnDelta := 0;
        vqProcArea_Xmax := 0;
        vqProcArea_Xmin := 0;
        vdSubSheet_Mass := 0.0;
        vdSubSheet_Jm := 0.0;
        vdRemn_Mass := 0.0;
        vdProd_Mass := 0.0;
        (* Dati movimentazione *)
        vnSubSheet_Id := 0;
        vnSubSheet_From := 0;
        vnSubSheet_Rot := 0;
        vnSubSheet_To := 0;
        vnProd_Id := 0;
        vnProd_From := 0;
        vnProd_Rot := 0;
        vnProd_To := 0;
        vnRemn_Id := 0;
        vnRemn_From := 0;
        vnRemn_Rot := 0;
        vnRemn_To := 0;

        (* Misure *)
        vqGlass_ActualThckn := 0; (* Può variare da una lastra all'altra? *)

        (* Stato lavorazione dello step corrente *)
        vbExtractDone := FALSE;
        vbEdgeTrimmed := FALSE;
        vbPreRotDone := FALSE;
        vbProcDone := FALSE;
        vbDetachDone := FALSE;
        vnPieceDelivering := 0;
        vnPieceTaken := 0;
        vqRemn_X := NO_POS_UM; (* Resetting project *)
        vqY_BtmEdge := NO_POS_UM; (* Invalido bordi vetro: Resetting project *)
        vqY_TopEdge := NO_POS_UM;
        vqCut_Length := 0;
        (* Eredità dal passo precedente *)
        vbZprescored_Done := FALSE;
        vqSubSheet_X := NO_POS_UM; (* Resetting project *)
        vqSubSheet_Y := NO_POS_UM;
        vqInsSheet_Y := NO_POS_UM;
        (* Valori sbirciati del passo successivo *)
        vbNextStep_Valid := FALSE;
        vqNextStep_FirstAlgn := 0;
        vqNextProcArea_Xmin := 0;
        vqNextProcArea_Xmax := 0;
        vbNextStep_Zprescore := FALSE;
        (* Monitors *)
        vnStepIndex := 0;
        vbSchemeDone := FALSE;
        vbSchemeAlmostDone := FALSE;

        Cmd := Cmd & NOT BIT_RSTPRJ; (* eat command *)


    (* --------------------------------------------------------------- *)
    ELSIF (Cmd & BIT_SETPRJ)<>0 THEN
        (* -- Servizio di set del progetto (auto) --
            In: vnBuf_SchemesCount, vaProjName (da comunicazione); trasmissione *.udf
           Out: vnSchemesCount
          Cond: passo non in esecuzione
          Acts: .Check 'vaProjName' and 'vnSchemesCount' *)
        dlog( Txt:='fbJobData: Setting project', Lvl:=4 );
        vnSchemeIndex := 0;
        (* Probabilmente potrei caricare un progetto pur continuando a lavorare,
           per invalidare il lavoro caricato dai anche 'BIT_RSTPRJ' *)
        vnSchemesCount := vnBuf_SchemesCount;
        (* Checks *)
        IF LEN(vaProjName)>0 AND vnSchemesCount>0 THEN
            dlog( Txt:=CONCAT('fbJobData: Ok, %ld schemes in project ',vaProjName), Lvl:=4, Val1:=TO_DINT(vnSchemesCount) );
            vqProjectsCount := vqProjectsCount + 1; (* Nota: se qui i files mac sono Ok *)
        ELSIF vnSchemesCount>0 THEN
            dlog( Txt:='fbJobData: !! %ld schemes but empty project name!', Lvl:=2, Val1:=TO_DINT(vnSchemesCount) );
            (* SET_MSG(MSG_BAD_JOBARGS,'No project name!',0); *)
        ELSE
            dlog( Txt:='fbJobData: !! No schemes and empty project name!', Lvl:=2 );
            SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',0);
        END_IF;
        (* TODO 1: sarebbe il caso di controllare i file UDF trasmessi *)
        Cmd := Cmd & NOT BIT_SETPRJ; (* eat command *)


    (* --------------------------------------------------------------- *)
    ELSIF (Cmd & BIT_SETSCHEME)<>0 THEN

        (* -- Servizio di caricamento dello schema (auto) --
            In: vaSchemeFile (file di dati da caricare)
           Out: vnSchemeIndex,vnSheetsCount,vnPiecesCount,...vqSheetWidth,...,vaSchemeInfo
         Other: 'vnSheetIndex', ossia la ripetizione, può essere valorizzato da Hmi, ma non lo uso
          Cond: passo non in esecuzione
          Acts: .Invalido il passo corrente
                .Carico il file dello schema e valorizzo il primo passo *)
        dlog( Txt:=CONCAT('fbJobData: Loading scheme ',vaSchemeFile), Lvl:=3 );
        (* Resetto i dati dello schema *)
        vnSchemeIndex := 0;
        vnSheetsCount := 0;
        vnPiecesCount := 0;
        vnSchemeType := 0;
        vnStep_NoMoreIns := 0;
        vqSheetWidth := 0;
        vqSheetHeight := 0;
        vaSchemeInfo := '';
        vnTotSteps := 0;
        (* Resetto i dati derivati *)
        vbStepValid := FALSE;
        (* Stato lavorazione step corrente *)
        vbExtractDone := FALSE;
        vbEdgeTrimmed := FALSE;
        vbPreRotDone := FALSE;
        vbProcDone := FALSE;
        vbDetachDone := FALSE;
        vnPieceDelivering := 0;
        vnPieceTaken := 0;
        vqRemn_X := NO_POS_UM; (* Setting new scheme *)
        vqY_BtmEdge := NO_POS_UM; (* Invalido bordi vetro: Setting new scheme *)
        vqY_TopEdge := NO_POS_UM;
        vqCut_Length := 0;
        (* Misure *)
        vqGlass_ActualThckn := 0; (* Può variare da una lastra all'altra? *)
        (* Eredità dal passo precedente *)
        vbZprescored_Done := FALSE;
        vqSubSheet_X := NO_POS_UM; (* Setting new scheme *)
        vqSubSheet_Y := NO_POS_UM;
        vqInsSheet_Y := NO_POS_UM;
        (* Valori sbirciati del passo successivo *)
        vbNextStep_Valid := FALSE;
        vqNextStep_FirstAlgn := 0;
        vqNextProcArea_Xmin := 0;
        vqNextProcArea_Xmax := 0;
        vbNextStep_Zprescore := FALSE;
        (* Monitors *)
        vnStepIndex := 0;
        vbSchemeDone := FALSE;
        vbSchemeAlmostDone := FALSE;

        RST_MSG_IF_ON(MSG_BAD_SCHEMEDATA);
        RST_MSG_IF_ON(MSG_BAD_JOBARGS);

        (* Caricamento del file di dati *)
        Scheme( Chn:=1, UdfPth:=vaSchemeFile, MtxPth:='StratoScheme.mtx', Load:=TRUE );
        (* Note: .Scheme.Load è usato sopra per caricare
                 .'vnSchemeIndex' è valorizzato da UDF *)


    (* --------------------------------------------------------------- *)
    ELSIF (Cmd & BIT_RSTMAT)<>0 THEN
        (* --- Servizio di reset dei parametri materiale ---
               Cond: passo non in esecuzione *)
        MatPars( Reset:=TRUE ); (* Resetta parametri materiale *)
        (* Meglio invalidare il passo corrente *)
        vbStepValid := FALSE;
        Cmd := Cmd & NOT BIT_RSTMAT; (* eat command *)


    (* --------------------------------------------------------------- *)
    ELSIF (Cmd & BIT_SETMAT)<>0 THEN
        (* --- Servizio di caricamento dei parametri materiale ---
              Cond: passo non in esecuzione? *)
        MatPars( Set:=TRUE ); (* Valorizza parametri materiale *)
        (* Aggiorno i dati derivati *)
        vbStepValid := vbStepValid AND MatPars.Valid;
        Cmd := Cmd & NOT BIT_SETMAT; (* eat command *)


    (* --------------------------------------------------------------- *)
    ELSIF (Cmd & BIT_SETSTEP)<>0 OR (Cmd & BIT_NXTSTEP)<>0 THEN
        (* --- Servizio di caricamento del passo di lavorazione ---
              Cond: passo non in esecuzione
              Acts: Invalido il passo corrente
              Out: vbStepValid *)

        (* Resetto i dati derivati *)
        vbStepValid := FALSE;
        EmptyStep := FALSE;
        (* Valori sbirciati del passo successivo *)
        vbNextStep_Valid := FALSE;
        vqNextStep_FirstAlgn := 0;
        vqNextProcArea_Xmin := 0;
        vqNextProcArea_Xmax := 0;
        vbNextStep_Zprescore := FALSE;

        (* Reset messaggi *)
        RST_MSG_IF_ON(MSG_BAD_JOBARGS);
        (* Reset messaggi di selezione ciclica *)
        RST_MSG_IF_ON(MSG_SKIPSCORE);
        RST_MSG_IF_ON(MSG_SKIPOPEN);
        RST_MSG_IF_ON(MSG_WONTOPEN);
        RST_MSG_IF_ON(MSG_WONTDETACH);
        RST_MSG_IF_ON(MSG_TRIMCUT);
        RST_MSG_IF_ON(MSG_CANNOTOPEN);
        RST_MSG_IF_ON(MSG_CANNOTDETACH);

        IF vbAutoMode THEN
            (* --- Preparazione caricamento passo (automatico) --- *)
            IF (Cmd & BIT_NXTSTEP)<>0 THEN
                (* É una prosecuzione in automatico, voglio i dati in eredità del passo precedente! *)
                dlog( Txt:='fbJobData: Next step (auto)', Lvl:=1 );
                Cmd := Cmd & NOT BIT_NXTSTEP; (* eat command *)

                (* Flag temporanei legati al flusso di lavoro *)

                (* Controllo se lo schema è finito *)
                IF Scheme.CurStep<Scheme.TotSteps THEN
                    (* Esiste un passo successivo *)
                    vbSchemeDone := FALSE;
                    (* Increase step *)
                    vnBuf_StepIndex := Scheme.CurStep + 1;
                    dlog( Txt:='Step %d inherits vqSubSheet_X=%ld mm', Lvl:=5, Val1:=TO_DINT(vnBuf_StepIndex), Val2:=vqSubSheet_X/1E3 );
                ELSE (* Schema terminato *)
                    (* Avanza schema *)
                    IF NOT vbSchemeDone THEN
                        vqSchemesCount := vqSchemesCount + 1;
                        vbSchemeDone := TRUE;
                    END_IF;
                    (* Invalidating step index *)
                    vnBuf_StepIndex := Scheme.CurStep + 1;
                    dlog( Txt:='No more steps (scheme %ld reached %ld)', Lvl:=1, Val1:=TO_DINT(vnSchemeIndex), Val2:=TO_DINT(Scheme.TotSteps) );
                END_IF;
            ELSE
                (* É una navigazione, resetto i dati in eredità dal passo precedente... *)
                vqSubSheet_X := NO_POS_UM; (* Selecting a step *)
                vqSubSheet_Y := NO_POS_UM;
                vqInsSheet_Y := NO_POS_UM;
                vbZprescored_Done := FALSE;
                (* ...Ed eventuali stati legati al flusso di lavoro
                vqAlgnEvac_Xbck := NO_POS_UM;
                vbAlgnEvac_Scheduled := FALSE; *)
            END_IF;

            (* --- Lettura dati del passo automatico ---
               Valorizzazione degli argomenti del passo di lavorazione
                In: vnBuf_StepIndex (Indice del passo nello schema)
               Out: vnBuf_StepSettings, vqBuf_SubSheet_Width, ...
              Acts: Carica da UDF il passo indicato *)
            dlog( Txt:='fbJobData: Selecting step %d', Lvl:=4, Val1:=TO_DINT(vnBuf_StepIndex) );
            IF Scheme.Loaded THEN
                vbLastStep := (vnBuf_StepIndex = Scheme.TotSteps);
                (* vbSchemeAlmostDone := vnBuf_StepIndex >= (Scheme.TotSteps-1); (* Nah, non molto intelligente *)
                (* Viene valorizzato in 'StepSeq.Status=STSEQ_PRE' *)
                IF vnBuf_StepIndex>0 AND vnBuf_StepIndex<=Scheme.TotSteps THEN
                    Scheme( SelStep:=vnBuf_StepIndex ); (* è un comando immediato *)
                    IF NOT Scheme.ValidStep THEN
                        dlog( Txt:='!! Cannot load step %d', Lvl:=1, Val1:=TO_DINT(vnBuf_StepIndex) );
                        EmptyStep := TRUE; (* Request to load an empty step *)
                    END_IF;
                    vnStepIndex := Scheme.CurStep;
                ELSE
                    dlog( Txt:='! Invalid step index %d (<1 or >%d)', Lvl:=1, Val1:=TO_DINT(vnBuf_StepIndex), Val2:=TO_DINT(Scheme.TotSteps) );
                    EmptyStep := TRUE; (* Request to load an empty step *)
                END_IF;
            ELSE
                (* There is not a loaded scheme *)
                vbSchemeDone := FALSE;
                dlog( Txt:='!! No scheme data loaded', Lvl:=1 );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',0);
                EmptyStep := TRUE; (* Request to load an empty step *)
            END_IF;

            (* Load an empty step if requested *)
            IF EmptyStep THEN
                (* Load an empty step *)
                vnBuf_StepSettings := 0;
                vqBuf_SubSheet_Width := 0;
                vqBuf_SubSheet_Height := 0;
                vqBuf_SubSheet_MoveInfo := 0;
                vqBuf_Proc_Algn := 0;
                vqBuf_Prod_MoveInfo := 0;
                vqBuf_Remn_MoveInfo := 0;
                vqBuf_Proc_Ybtm := 0;
                vqBuf_Proc_Ytop := 0;

                Cmd:=0; (* Abort further commands *)
            END_IF;
        ELSE
            (* --- Preparazione caricamento passo (manuale) --- *)
            (* Dati derivati inerenti il lavoro automatico *)
            vbLastStep := FALSE;
            vbSchemeAlmostDone := FALSE;

            (* Resetto stati del flusso di lavoro: resetta evacuazione *)
            vqAlgnEvac_Xbck := NO_POS_UM;
            vbAlgnEvac_Scheduled := FALSE;

            (* Niente eredità dal passo precedente *)
            vbZprescored_Done := FALSE;
            vqY_BtmEdge := NO_POS_UM; (* Invalido bordi vetro: Loading a manual step *)
            vqY_TopEdge := NO_POS_UM;
            vqCut_Length := 0;
            vqSubSheet_X := NO_POS_UM; (* Manual step *)
            vqSubSheet_Y := NO_POS_UM;
            vqInsSheet_Y := NO_POS_UM;

            (* --- Servizio di selezione passo successivo (man) --- *)
            IF (Cmd & BIT_NXTSTEP)<>0 THEN
                dlog( Txt:='fbJobData: ! Next step in manual mode?', Lvl:=1 );
                (* A livello macchina non memorizzo dei passi manuali,
                   la cosa è gestita a livello interfaccia, quindi questo
                   comando non ha senso *)
                Cmd := Cmd & NOT BIT_NXTSTEP; (* eat command *)
            END_IF;

            (* --- Servizio di set degli argomenti del passo (man) ---
                In: vnBuf_StepSettings, vqBuf_SubSheet_Width, ... *)
            (* Se in manuale non vengono date le dimensioni lastra, imposto io un default
               vedi anche: 'fbGuessSheetSize' *)
            IF vnBuf_StepSettings<>0 THEN (* Se non sto caricando un passo invalido *)
                IF vqBuf_SubSheet_Height<=0 THEN (* vbSloppyManual *)
                    (* Assicura qualche ventilatore *)
                    vqBuf_SubSheet_Height := 2000E3;
                    dlog( Txt:='fbJobData: ! Assuming Height=%ld mm for manual cut', Lvl:=3, Val1:=vqBuf_SubSheet_Height/1E3 );
                END_IF;
                IF vqBuf_SubSheet_Width<=0 THEN (* vbSloppyManual *)
                    (* Forzo ciclica rifilo, non vorrei mai farne una standard su un rifilo *)
                    vqBuf_SubSheet_Width := vqBuf_Proc_Algn + vqRemn_DtchMinWidth;
                    dlog( Txt:='fbJobData: ! Assuming Width=%ld mm for manual cut', Lvl:=5, Val1:=vqBuf_SubSheet_Width/1E3 );
                END_IF;
                dlog( Txt:='fbJobData: Manual cut %ld mm on sheet %ldx%ld', Lvl:=4, Val1:=vqBuf_Proc_Algn/1E3, Val2:=vqBuf_SubSheet_Width/1E3, Val3:=vqBuf_SubSheet_Height/1E3 );
            END_IF; (* Dimensioni lastra di default se passo non vuoto *)

        END_IF; (* -- Auto/Manual mode *)

        (* ---- Step loading (common part) ---- *)
        (* Take incoming data *)
        vnStepSettings := vnBuf_StepSettings;
        vnStackedSheets := vnBuf_StackedSheets;
        vqSubSheet_Width := vqBuf_SubSheet_Width;
        vqSubSheet_Height := vqBuf_SubSheet_Height;
        vqSubSheet_MoveInfo := vqBuf_SubSheet_MoveInfo;
        vqProc_Algn := vqBuf_Proc_Algn;
        vqProd_MoveInfo := vqBuf_Prod_MoveInfo;
        vqRemn_MoveInfo := vqBuf_Remn_MoveInfo;
        vqProc_Ybtm := vqBuf_Proc_Ybtm;
        vqProc_Ytop := vqBuf_Proc_Ytop;

        (* Misure *)
        (* vqGlass_ActualThckn := 0; (* Va rimisurato ogni volta? *)

        (* Resetto i buffer che potrebbero non essere parte dei dati del passo
           (per retrocompatibilità con Hmi che non valorizza questi buffer) *)
        vqBuf_Proc_Ybtm := 0;
        vqBuf_Proc_Ytop := 0;

        (* Intercetto caricamento di un passo vuoto
           (si fa per prevenire lo start alla de-sincronizzazione) *)
        EmptyStep := vnStepSettings=0 AND vqSubSheet_Width=0 AND vqSubSheet_Height=0;
        IF EmptyStep THEN
            dlog( Txt:='fbJobData: -> Empty step', Lvl:=4 );
            (* Resetto i dati derivati *)
            vbLastStep := FALSE;
            vbWillTiltOutPiece := FALSE;
            vbMustAlign := FALSE;
            vqCut_Height := 0;
            vqProd_Width := 0;
            vqRemn_Width := 0;
            vqSubSheet_ProcWidth := 0;
            vqSubSheet_ProcHeight := 0;
            vqProc_AlgnDelta := 0;
            vqProcArea_Xmax := 0;
            vqProcArea_Xmin := 0;
            vdSubSheet_Mass := 0.0;
            vdSubSheet_Jm := 0.0;
            vdRemn_Mass := 0.0;
            vdProd_Mass := 0.0;
            (* Dati movimentazione *)
            vnSubSheet_Id := 0;
            vnSubSheet_From := 0;
            vnSubSheet_Rot := 0;
            vnSubSheet_To := 0;
            vnProd_Id := 0;
            vnProd_From := 0;
            vnProd_Rot := 0;
            vnProd_To := 0;
            vnRemn_Id := 0;
            vnRemn_From := 0;
            vnRemn_Rot := 0;
            vnRemn_To := 0;
            (* Eredità dal passo precedente *)
            vbZprescored_Done := FALSE;
            vqY_BtmEdge := NO_POS_UM; (* Invalido bordi vetro: Empty step *)
            vqY_TopEdge := NO_POS_UM;
            vqCut_Length := 0;
            vqSubSheet_X := NO_POS_UM; (* Empty step *)
            vqSubSheet_Y := NO_POS_UM;
            vqInsSheet_Y := NO_POS_UM;
            (* Monitors *)
            vnStepIndex := 0;
            (* vbSchemeDone := FALSE; (* No! Potrei essere qua proprio perché lo schema è finito! *)
            vbSchemeAlmostDone := FALSE;
        ELSE
            (* --- Calcolo i dati del passo di lavorazione ---
                In: vqSubSheet_Width,vqSubSheet_Height, vqProc_Algn
                    vqSubSheet_MoveInfo, vqProd_MoveInfo, vqRemn_MoveInfo,
                    <material data>
               Out: vqProd_Width,vqRemn_Width,vqCut_Height
                    vnSubSheetId, vnProdId, vnRemnId, ...
                    vdSubSheet_Mass, vdProd_Mass, vdRemn_Mass, ... *)

            (* Voglio che i parametri materiale siano già stati mandati *)
            IF NOT MatPars.Valid THEN
                dlog( Txt:='fbJobData: !! Material not valid', Lvl:=1 );
                SET_MSG(MSG_INVALIDMAT,'MSG_INVALIDMAT',0);
            END_IF;

            (* -- Assicuro di mascherare i bit della ricetta -- *)
            vnCutRecipe := vnCutRecipe & vnEnabledRecipes;

            (* -- Dati movimentazione -- *)
            (* Identificativi pezzi finiti e scarti (<0:has-cuts 0:scrap >0:piece) *)
            vnSubSheet_Id := TO_INT( SHR(vqSubSheet_MoveInfo, 16) );
            vnProd_Id := TO_INT( SHR(vqProd_MoveInfo, 16) );
            vnRemn_Id := TO_INT( SHR(vqRemn_MoveInfo, 16) );

            (* Sagome contenute *)
            vbSubSheet_HasShape := (vqSubSheet_MoveInfo & MSK_MV_SHAPE)<>0;
            vbProd_HasShape := (vqProd_MoveInfo & MSK_MV_SHAPE)<>0;
            vbRemn_HasShape := (vqRemn_MoveInfo & MSK_MV_SHAPE)<>0;

            (* Contiene preincisioni? *)
            vbSubSheet_Prescored := (vqSubSheet_MoveInfo & MSK_MV_SCORED)<>0;
            vbProd_Prescored := (vqProd_MoveInfo & MSK_MV_SCORED)<>0;
            vbRemn_Prescored := (vqRemn_MoveInfo & MSK_MV_SCORED)<>0;
            (* IF vbSubSheet_Prescored THEN
                dlog( Txt:='! SubSheet was prescored', Lvl:=4 );
            END_IF; *)

            (* -Provenienza- *)
            vnSubSheet_From := TO_INT( vqSubSheet_MoveInfo & MSK_MV_FROM );
            vnProd_From := TO_INT( vqProd_MoveInfo & MSK_MV_FROM );
            vnRemn_From := TO_INT( vqRemn_MoveInfo & MSK_MV_FROM );
            (* Controllo provenienza sottolastra in arrivo *)
            CASE vnSubSheet_From OF
                0 :
                    ; (* dlog( Txt:='fbJobData: SubSheet is in proc zone', Lvl:=6 ); *)
                ZONE_FEED :
                    dlog( Txt:='! SubSheet from Feed', Lvl:=6 );
                ZONE_OUT :
                    dlog( Txt:='! SubSheet from downstream', Lvl:=6 );
                ZONE_LOAD :
                    dlog( Txt:='! SubSheet from upstream', Lvl:=6 );
            ELSE
                    dlog( Txt:='!! Invalid vnSubSheet_From=%d', Lvl:=1, Val1:=TO_DINT(vnSubSheet_From) );
                    SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',TO_DINT(vnSubSheet_From));
            END_CASE;
            (* Controllo provenienza prodotto *)
            IF vnProd_From<>0 THEN
                dlog( Txt:='!! Unexpected vnProd_From=%d', Lvl:=1, Val1:=TO_DINT(vnProd_From) );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',TO_DINT(vnProd_From));
            END_IF;
            (* Controllo provenienza rimanenza *)
            IF vnRemn_From<>0 THEN
                dlog( Txt:='!! Unexpected vnRemn_From=%d', Lvl:=1, Val1:=TO_DINT(vnRemn_From) );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',TO_DINT(vnRemn_From));
            END_IF;

            (* -Rotazione- *)
            vnSubSheet_Rot := TO_INT( SHR(vqSubSheet_MoveInfo & MSK_MV_ROT, 3) );
            vnProd_Rot := TO_INT( SHR(vqProd_MoveInfo & MSK_MV_ROT, 3) );
            vnRemn_Rot := TO_INT( SHR(vqRemn_MoveInfo & MSK_MV_ROT, 3) );
            (* Converto 3 in -1, corrispondente a -90° (rotazioni riscontri) *)
            IF vnSubSheet_Rot>2 THEN vnSubSheet_Rot:=vnSubSheet_Rot-4; END_IF;
            IF vnProd_Rot>2 THEN vnProd_Rot:=vnProd_Rot-4; END_IF;
            (* IF vnRemn_Rot>2 THEN vnRemn_Rot:=vnRemn_Rot-4; END_IF; La rotazione rimanenza non è prevista*)
            (* Controllo rotazioni supportate *)
            IF vnSubSheet_Rot<>0 AND vnSubSheet_Rot<>1 AND vnSubSheet_Rot<>-1 THEN
                dlog( Txt:='!! Invalid vnSubSheet_Rot (a=%d deg)', Lvl:=1, Val1:=TO_DINT(90*vnSubSheet_Rot) );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',TO_DINT(vnSubSheet_Rot));
            END_IF;
            IF vnProd_Rot<>0 AND vnProd_Rot<>-1 THEN
                dlog( Txt:='!! Invalid vnProd_Rot (a=%d deg)', Lvl:=1, Val1:=TO_DINT(90*vnProd_Rot) );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',TO_DINT(vnProd_Rot));
            END_IF;
            IF vnRemn_Rot<>0 THEN
                dlog( Txt:='!! Unexpected vnRemn_Rot (a=%d deg)', Lvl:=1, Val1:=TO_DINT(90*vnRemn_Rot) );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',TO_DINT(vnRemn_Rot));
            END_IF;

            (* -Destinazione- *)
            vnSubSheet_To := TO_INT( SHR(vqSubSheet_MoveInfo & MSK_MV_TO, 5) );
            vnProd_To := TO_INT( SHR(vqProd_MoveInfo & MSK_MV_TO, 5) );
            vnRemn_To := TO_INT( SHR(vqRemn_MoveInfo & MSK_MV_TO, 5) );

            (* Controllo destinazione sottolastra in arrivo *)
            CASE vnSubSheet_To OF
                0 :
                    ; (* dlog( Txt:='fbJobData: SubSheet has no dest', Lvl:=6 ); *)
                ZONE_FEED :
                    dlog( Txt:='! SubSheet to Feed', Lvl:=4 );
                ZONE_OUT :
                    dlog( Txt:='! SubSheet to downstream', Lvl:=4 );
                ZONE_LOAD :
                    dlog( Txt:='! SubSheet to upstream', Lvl:=4 );
            ELSE
                    dlog( Txt:='!! Invalid vnSubSheet_To=%d', Lvl:=1, Val1:=TO_DINT(vnSubSheet_To) );
                    SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',TO_DINT(vnSubSheet_To));
            END_CASE;

            (* Se la sottolastra va portata da qualche parte non ha senso dichiarare una processazione
            IF vnSubSheet_To<>0 AND vnStepSettings<>0 THEN
                dlog( Txt:='fbJobData: !! vnSubSheet_To=%d with vnStepSettings=0x%X', Lvl:=1, Val1:=TO_DINT(vnSubSheet_To), Val1:=TO_DINT(vnStepSettings) );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',TO_DINT(vnProd_To));
            END_IF; *)

            (* Controllo destinazione prodotto: normalmente la determino io in base a vnProd_Id *)
            IF vnProd_To<>0 AND vnProd_To<>ZONE_OUT THEN
                dlog( Txt:='!! Unsupported vnProd_To=%d', Lvl:=1, Val1:=TO_DINT(vnProd_To) );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',TO_DINT(vnProd_To));
            END_IF;

            (* Controllo destinazione rimanenza: normalmente la determino io,
               in base a 'vnRemn_Id', comunque potrei sempre considerare anche
               queste indicazioni esterne.
               Tipicamente vnRemn_To=[0|ZONE_FEED] se vnRemn_Id<0
               Le altre ZONE_OUT, ZONE_LOAD non sono ancora usate *)
            IF vnRemn_To<>0 AND vnRemn_To<>ZONE_FEED THEN (* ZONE_FEED, ZONE_OUT, ZONE_LOAD *)
                dlog( Txt:='! Specified vnRemn_To=%d', Lvl:=4, Val1:=TO_DINT(vnRemn_To) );
            END_IF;


            (* -- Dimensioni e riscontro -- *)
            (* Controlli coerenza dimensioni sottolastra in arrivo *)
            IF vqSubSheet_Width<1E3 THEN
                dlog( Txt:='!! Invalid vqSubSheet_Width=%ld mm', Lvl:=1, Val1:=vqSubSheet_Width/1E3 );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',vqSubSheet_Width);
            END_IF;

            IF vqSubSheet_Height<1E3 THEN
                (* Per l'altezza sono più tollerante se essa non viene usata (niente rotazioni) *)
                IF vbAutoMode OR fnRotated90(vnSubSheet_Rot) OR fnRotated90(vnProd_Rot) THEN
                    dlog( Txt:='!! Invalid vqSubSheet_Height=%ld mm', Lvl:=1, Val1:=vqSubSheet_Height/1E3 );
                    SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',vqSubSheet_Height);
                ELSE (* vbSloppyManual *)
                    vqSubSheet_Height := 1000E3; (* Imposto un valore di default *)
                    dlog( Txt:='! Assuming vqSubSheet_Height=%ld mm', Lvl:=3, Val1:=vqSubSheet_Height/1E3 );
                END_IF;
            END_IF;
            (* A proposito della verifica della misura dell'altezza effettiva, meglio assicurarla se devo ruotare *)
            IF vbAutoMode AND fnRotated90(vnProd_Rot) THEN
                vqWorkSettings := vqWorkSettings & NOT BIT_NOCHECKCUTLEN;
            END_IF;

            (* - Riconosci situazioni particolari - *)
            (* Troncaggio traversi monolitico *)
            vbFloatStripesBreak := (vnSchemeType & BIT_STRIPES)<>0 AND (vnStepSettings & BIT_SCORE)=0 AND (vnSheetType & BIT_STRATO)=0;
            (* Rifilo di testa di lastre squadrate con rotelle (non va riscontrato) *)
            vbFrontTrim := vbSheet_WasUpRight AND vnStepIndex=1 AND vqProc_Algn<=vqProd_TrimWidth;
            (* Passo per preincidere un taglio annidato: gestisco dopo *)
            (* vbZprescore := vqProc_Ybtm<>vqProc_Ytop AND (vnStepSettings & (BIT_OPEN OR BIT_DETACH))=0; *)

            (* -- Ordinate di processazione (normalmente si usano i bordi rilevati del vetro) -- *)
            vbZprescore := FALSE;
            IF vqProc_Ybtm<>vqProc_Ytop THEN
                dlog( Txt:='! Specified Ybtm=%ld Ytop=%ld', Lvl:=5, Val1:=vqProc_Ybtm/1E3, Val2:=vqProc_Ytop/1E3 );
                IF (vnStepSettings & (BIT_OPEN OR BIT_DETACH))=0 THEN
                    (* Preincisione tagli annidati *)
                    vbZprescore := TRUE;
                ELSE
                    (* Non ha senso specificare ordinate di lavoro all'interno del vetro se apro/separo *)
                    dlog( Txt:='!! Not prescoring', Lvl:=1 );
                    SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',0);
                END_IF;
            END_IF;

            (* Devo ereditare la posizione dei bordi vetro per non cercare la lastra?
               Normalmente no, a meno che: *)
            IF (vbZprescored_Done AND vbZprescore) THEN (* ...Sono una preincisione successiva *)
                dlog( Txt:='! Inheriting edges %ld|%ld', Lvl:=3, Val1:=vqY_BtmEdge/1E3, Val2:=vqY_TopEdge/1E3 );
            ELSE
                (* Invalido bordi vetro per assicurare la ricerca lastra *)
                vqY_BtmEdge := NO_POS_UM; (* Invalido bordi vetro: Loading a step *)
                vqY_TopEdge := NO_POS_UM;
                vqCut_Length := 0;
            END_IF;
            vbZprescored_Done := FALSE; (* Reset inherited signal *)


            (* Devo riscontrare la sottolastra da processare?
               Essa potrebbe essere portata in 'vqProc_Algn' direttamente
               con le cinghie, senza doverla riscontrare *)
            IF vbAutoMode AND vbFrontTrim THEN
                (* Non riscontrare il rifilo di testa di lastre squadrate con rotelle *)
                dlog( Txt:='! Wont align sheet front trim %ld <= %ld', Lvl:=2, Val1:=vqProc_Algn/1E3, Val1:=vqProd_TrimWidth/1E3 );
                vbMustAlign := FALSE;
            ELSIF vbAutoMode AND vbFloatStripesBreak THEN
                (* Non riscontrare durante il troncaggio traversi monolitico,
                   se i tagli arrivano già aperti può sbeccare? *)
                vbMustAlign := vbAlgn_FloatStripesBreak;
                dlog( Txt:='! Align of float stripe: %d', Lvl:=3, Val1:=TO_DINT(vbMustAlign) );
            ELSIF vnSubSheet_To<>0 AND vnStepSettings=0 THEN
                (* La sottolastra è solo da movimentare *)
                vbMustAlign := FALSE;
                vqProc_Algn := 0; (* Comporterà prodotto nullo e rimanenza uguale alla sottolastra *)
            ELSE
                (* Normalmente devo riscontrare la sottolastra da processare *)
                vbMustAlign := TRUE;
            END_IF;


            (* Controlli quota X di processazione *)
            (* Anche se non c'è processazione, determina dimensioni prodotto e rimanenza, quindi deve avere senso: *)
            IF vqProc_Algn<0 OR vqProc_Algn>vqX_OutTableEnd THEN
                dlog( Txt:='!! Invalid vqProc_Algn=%ld mm', Lvl:=1, Val1:=vqProc_Algn/1E3 );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',vqProc_Algn);
            (* Se devo riscontrare, deve essere riscontrabile: *)
            ELSIF vbMustAlign AND vqProc_Algn>vqAlgnMax THEN
                dlog( Txt:='!! Cannot align vqProc_Algn=%ld>%ld mm', Lvl:=1, Val1:=vqProc_Algn/1E3, Val2:=vqAlgnMax/1E3 );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',vqProc_Algn);
                SET_MSG(MSG_BAD_ALGNARGS,'MSG_BAD_ALGNARGS',vqProc_Algn);
            END_IF;


            (* Determino le dimensioni delle sottolastre tagliate, tengo conto di eventuali pre-rotazioni *)
            vqProd_Width := vqProc_Algn;
            IF fnRotated90(vnSubSheet_Rot) THEN
                (* Lastra in arrivo sarà ruotata *)
                vqSubSheet_ProcWidth  := vqSubSheet_Height;
                vqSubSheet_ProcHeight := vqSubSheet_Width;
            ELSE
                (* Lastra in arrivo non ruotata *)
                vqSubSheet_ProcWidth  := vqSubSheet_Width;
                vqSubSheet_ProcHeight := vqSubSheet_Height;
            END_IF;
            vqCut_Height := vqSubSheet_ProcHeight;
            vqRemn_Width := vqSubSheet_ProcWidth - vqProd_Width;

            (* Controlli coerenza dimensioni rimanenza e prodotto *)
            IF vqRemn_Width<0 THEN
                dlog( Txt:='!! Cannot align to %ld a sheet w=%ld mm', Lvl:=1, Val1:=vqProc_Algn/1E3, Val2:=(vqProd_Width+vqRemn_Width)/1E3 );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',vqRemn_Width);
            END_IF;
            IF (2*(vqProd_Width+vqRemn_Width))<=(vqX_CutZoneP-vqCarrInf_CurrXroomM) AND vnStepSettings<>0 THEN
                dlog( Txt:='! Narrow sheet w=%ld may fall', Lvl:=2, Val1:=(vqProd_Width+vqRemn_Width)/1E3 );
                (* SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',vqProd_Width+vqRemn_Width); *)
            END_IF;

            (* Precalcolo quanto spazio mi serve per il riscontro della processazione *)
            (* Nota: Si usa solo se 'vbMustAlign' è vero *)
            IF vbMustAlign THEN
                CalcAlgnDelta( Width:=vqProd_Width+vqRemn_Width, Height:=vqCut_Height, Align:=vqProc_Algn );
                vqProc_AlgnDelta := CalcAlgnDelta.Delta;
            ELSE
                vqProc_AlgnDelta := 0;
            END_IF;


            (* -- Controlli fattibilità sequenza di taglio -- *)
            IF vqCut_Height<vqCut_MinLength THEN
                dlog( Txt:='!! Sheet too short vqCut_Height=%ld < %ld mm', Lvl:=1, Val1:=vqCut_Height/1E3, Val2:=vqCut_MinLength/1E3 );
                SET_MSG(MSG_BAD_JOBARGS,'MSG_BAD_JOBARGS',vqCut_Height);
            END_IF;


            (* -- Valutazione rischio caduta vetro alla quota di processazione -- *)
            IF vqSubSheet_ProcWidth < vqFallWidth THEN (* AND vbMustAlign? *)
                (* Questo vetro è stretto e può potenzialmente cadere.
                   La dimensione minima di appoggio per cui non cade è: *)
                D := vqSubSheet_ProcWidth/2 + vqFall_MaxMargin;
                (* Se non appoggia nè allo stacco nè ai riscontri: *)
                IF (vq[ivqAx_HomePos+AX_XS-1] - vqProc_Algn + vqSubSheet_ProcWidth) < D AND (* Non appoggia allo stacco *)
                   (vqProc_Algn - vqX_CutZoneP) < D THEN (* Non appoggia ai riscontri *)
                    (* Cade dallo stacco o dai riscontri:
                           ▄▄▄▄▄▄▄▄▄▄▄▄╠════                     ▄▄▄▄▄▄▄▄▄▄▄▄╠════
                       ▒▒▒▒▒▒▒▒       ↓ ▒▒▒▒▒▒▒▒        ▒▒▒▒▒▒▒▒ ↓       ▒▒▒▒▒▒▒▒ *)
                    dlog( Txt:='! W=%ld will fall', Lvl:=2, Val1:=vqSubSheet_ProcWidth/1E3 );
                    (* SET_MSG(MSG_FALLINCUTZONE,'MSG_FALLINCUTZONE',vqSubSheet_ProcWidth); *)
                    (* TODO 1: Se questa fosse una processazione finale (pezzi finiti/scarti) o una preincisione avrebbe senso saltarla!
                    IF vbAutoMode AND vbSkipUndoableStep THEN
                        vbSkipProc := TRUE;
                    END_IF;
                    *)
                END_IF;
            END_IF; (* -- A rischio caduta *)


            (* -- Condizioni di sola incisione rifilo--
                Se pezzo finito e dimensioni sotto certe soglie,
                incido e basta, consegnando l'insieme di prodotto
                e rimanenza *)
            IF vnProd_Id>0 AND vnRemn_Id=0 AND
               (vnStepSettings & (BIT_OPEN OR BIT_DETACH))<>0 AND
               vqRemn_Width<=vqJustScore_RemnMaxWidth AND
               vqSubSheet_ProcHeight<=vqJustScore_MaxHeight THEN
                dlog( Txt:='! Just score piece %d (%ld+%ld)x%ld', Lvl:=4, Val1:=TO_DINT(vnProd_Id), Val2:=vqProd_Width/1E3, Val3:=vqRemn_Width/1E3, Val4:=vqSubSheet_ProcHeight/1E3 );
                (* Forzo sola incisione *)
                vnStepSettings := vnStepSettings & NOT (BIT_OPEN OR BIT_DETACH);
                (* Notifico che c'è un'incisione da aprire *)
                vbProd_Prescored := TRUE;
                (* Forzo evacuazione a fine linea? Non serve, vnProd_Id>0
                vnProd_To := ZONE_OUT; *)
            (* ELSE
                dlog( Txt:='fbJobData: Normal cut %d|%d Remn %ldx%ld', Lvl:=4, Val1:=TO_DINT(vnProd_Id), Val2:=TO_DINT(vnRemn_Id), Val3:=vqRemn_Width/1E3, Val4:=vqSubSheet_ProcHeight/1E3 ); *)
            END_IF; (* Sola incisione rifilo *)


            (* - Asportazione basso emissivo - *)
            (* Gestisci indicatore globale di esclusione nello schema *)
            IF (vnSheetType & BIT_LOWE)<>0 AND (vnSchemeType & BIT_NOLOWE)<>0 THEN
                (* Forzo materiale non basso emissivo per escludere molature
                   Nota: Il caricamento del materiale precede sempre
                         il caricamento del passo *)
                dlog( Txt:='! Excluding Low-E (no-lowe)', Lvl:=3 );
                vnSheetType := vnSheetType & NOT BIT_LOWE;
            END_IF;

            IF (vnStepSettings & BIT_LOWE)<>0 AND (vnSheetType & BIT_LOWE)=0 THEN
                (* Se il materiale non è basso emissivo, togli automaticamente la molatura *)
                vnStepSettings := vnStepSettings & NOT BIT_LOWE;
            END_IF;
            (* Attivo automaticamente il bit di molatura se bisogna incidere
               un materiale basso emissivo su macchine con mola
               Mah, non mi sembra una grande idea! Tra l'altro i flag di lavoro
               possono essere cambiati dinamicamente senza ricaricare il passo
            IF (vnStepSettings & BIT_LOWE)=0 AND (vnStepSettings & BIT_SCORE)<>0 AND (vnSheetType & BIT_LOWE)<>0 AND vnGrLe_Type>0 THEN
                dlog( Txt:='! Activating grinding for Low-E material', Lvl:=2 );
                vnStepSettings := vnStepSettings OR BIT_LOWE
            END_IF; *)


            (* - Incisibilità -
            IF (vnStepSettings & BIT_SCORE)<>0 THEN
            END_IF; *)

            (* - Apribilità - *)
            IF (vnStepSettings & BIT_OPEN)<>0 THEN
                IF vqRemn_Width<vqRemn_OpenMinWidth THEN
                    dlog( Txt:='Remn w=%ld < %ld mm wont be opened', Lvl:=2, Val1:=vqRemn_Width/1E3, Val2:=vqRemn_OpenMinWidth/1E3 );
                    (* MAI togliere operazioni ciclica: il programma di taglio DEVE fallire affinché richieda intervento operatore! *)
                    (* vnStepSettings := vnStepSettings & NOT (BIT_OPEN OR BIT_DETACH); *)
                    SET_MSG(MSG_WONTOPEN,'Cannot open Remn',vqRemn_Width);
                END_IF;
                IF vqProd_Width<vqProd_OpenMinWidth THEN
                    dlog( Txt:='Prod w=%ld < %ld mm wont be opened', Lvl:=2, Val1:=vqProd_Width/1E3, Val2:=vqProd_OpenMinWidth/1E3 );
                    (* MAI togliere operazioni ciclica: il programma di taglio DEVE fallire affinché richieda intervento operatore! *)
                    (* vnStepSettings := vnStepSettings & NOT (BIT_OPEN OR BIT_DETACH); *)
                    SET_MSG(MSG_WONTOPEN,'Cannot open Prod',vqProd_Width);
                END_IF;
            END_IF;

            (* - Separabilità - *)
            IF (vnStepSettings & BIT_DETACH)<>0 THEN
                IF vqRemn_Width<vqRemn_DtchMinWidth THEN
                    dlog( Txt:='Remn w=%ld < %ld mm wont be detached', Lvl:=2, Val1:=vqRemn_Width/1E3, Val2:=vqRemn_DtchMinWidth/1E3 );
                    (* MAI togliere operazioni ciclica: il programma di taglio DEVE fallire affinché richieda intervento operatore! *)
                    (* vnStepSettings := vnStepSettings & NOT BIT_DETACH; *)
                    SET_MSG(MSG_WONTDETACH,'Cannot detach Remn',vqRemn_Width);
                END_IF;
                IF vqProd_Width<vqProd_DtchMinWidth THEN
                    dlog( Txt:='Prod w=%ld < %ld mm wont be detached', Lvl:=2, Val1:=vqProd_Width/1E3, Val2:=vqProd_DtchMinWidth/1E3 );
                    (* MAI togliere operazioni ciclica: il programma di taglio DEVE fallire affinché richieda intervento operatore! *)
                    (* vnStepSettings := vnStepSettings & NOT BIT_DETACH; *)
                    SET_MSG(MSG_WONTDETACH,'Cannot detach Prod',vqProd_Width);
                END_IF;
            END_IF;


            (* Determino area processazione di questo step
               Xmax: usato per capire dove è possibile lasciare una lastra in evacuazione
               Xmin: metto un valore qui, ma in realtà è usato durante le post-movimentazioni *)
            (* vqProcArea_Xmax := vqProd_Width + vqProc_AlgnDelta + vqProcArea_XmaxMrg; *)
            (* Meglio tenere conto di una eventuale rotazione:
               ipotizzo rotazione lato riscontro e che lo spazio di riscontro vari di poco *)
            vqProcArea_Xmax := vqProcArea_XmaxMrg + vqProc_AlgnDelta +
                               SEL(fnRotated90(vnSubSheet_Rot), vqProd_Width, MAX(vqProd_Width,vqSubSheet_Width));

            (* Per l'area indietro considero la dimensione rimanenza più il movimento di riscontro più il
               movimento indietro di separazione; in ogni caso mi assicuro sempre di liberare lo stacco *)
            vqProcArea_Xmin := MIN(vq[ivqAx_HomePos+AX_XS-1] - vqProc_AlgnDelta - vqRemn_Width, vqDtch_Xbegin);


            (* Calcolo delle masse *)
            vdSubSheet_Mass := fnGlassMass(vqSubSheet_Width,vqSubSheet_Height,vqGlass_Thckn); (* vqSupThckn+vqInfThckn *)
            vdProd_Mass := fnGlassMass(vqProd_Width,vqCut_Height,vqGlass_Thckn);
            vdRemn_Mass := vdSubSheet_Mass - vdProd_Mass;

            (* Calcolo dei momenti di inerzia rispetto il centro di massa [Kg m²] *)
            (* Nota: il momento d'inerzia su un'asse parallelo è J' = J + M·d²
                     sullo spigolo del rettangolo è Jmax = M·(w²+h²)/3   *)
            vdSubSheet_Jm := vdSubSheet_Mass * (POW(TO_LREAL(vqSubSheet_Width)/1.0E6,2.0)+POW(TO_LREAL(vqSubSheet_Height)/1.0E6,2.0)) / 12.0; (* M·(w²+h²)/12 *)
            vdProd_Jm := vdProd_Mass * (POW(TO_LREAL(vqProd_Width)/1.0E6,2.0)+POW(TO_LREAL(vqCut_Height)/1.0E6,2.0)) / 12.0; (* M·(w²+h²)/12 *)
            vdRemn_Jm := vdRemn_Mass * (POW(TO_LREAL(vqRemn_Width)/1.0E6,2.0)+POW(TO_LREAL(vqCut_Height)/1.0E6,2.0)) / 12.0; (* M·(w²+h²)/12 *)

            (* Se servono dati di lavoro aggiuntivi, li richiedo qui? *)
            IF vbSubSheet_HasShape THEN
                (* Mi servono i dati del traverso-sagoma: richiedo il loro invio *)
                vnHmi_SendData := vnStepIndex;
                (* L'effetto su interfaccia PC è impostare
                   mach->Status.comm_status().requesting_data() a cui segue mach->write_shape() *)
            END_IF;

            (* Consegna *)
            vbWillTiltOutPiece := vnTiltOut_Type>0 AND (vqWorkSettings & BIT_AUTOTILTOUT)<>0
                                  AND vnProd_Id>0 AND NOT vbProd_Prescored;
            (* Nota: vnRemn_Id>0 non conta, se il prodotto non è un pezzo è probabilmente preso a mano *)

            (* -- Finally -- *)
            (* Giudico la validità del passo in caricamento *)
            vbStepValid := MatPars.Valid AND NOT IS_MSG(MSG_BAD_JOBARGS);
            IF vbStepValid THEN
                dlog( Txt:='[[Loaded step: %ldx%ld %ldKg, algn:%ld]]', Lvl:=4, Val1:=vqSubSheet_Width/1E3, Val2:=vqSubSheet_Height/1E3, Val3:=TO_DINT(vdSubSheet_Mass), Val4:=vqProc_Algn/1E3 );

                RST_MSG_IF_ON(MSG_NOJOB);

                (* Se sono in automatico sbircio alcuni valori del passo successivo *)
                IF vbAutoMode THEN
                    (* Appena caricato un passo valido in modalità automatica *)
                    (* Sbircio il passo successivo *)
                    (* dlog( Txt:='fbJobData: Peeking step %d', Lvl:=4, Val1:=TO_DINT(vnStepIndex+1) ); *)
                    Scheme( SelStep:=vnStepIndex+1, Peek:=TRUE ); (* È un comando immediato *)
                    IF Scheme.ValidStep THEN
                        (* Ok, peeked values in: v[bnq]Buf_* *)
                        vbNextStep_Valid := TRUE;

                        (* Qui valuto:
                            .La quota di riscontro successiva
                             (per eventuale preposizionamento riscontri)
                            .La zona che serve per la processazione del taglio successivo
                             (eventualmente usata usata per calcolare quanto spostare la rimanenza)
                             In particolare mi interessa la zona X lato stacco, data dal minimo tra
                             quanto mi serve per separare la prossima rimanenza e l'eventuale area
                             di rotazione del prossimo prodotto.
                             L'area di rotazione la calcolerò al momento opportuno, qui considero
                             solo lo spazio necessario alla separazione, dato dalla larghezza della
                             prossima rimanenza e il movimento necessario dello stacco,
                             che non può essere maggiore della rispettiva quota di parcheggio *)

                        IF fnRotated90( TO_INT(SHR(vqBuf_SubSheet_MoveInfo & MSK_MV_ROT,3)) ) THEN
                            (* Lastra in arrivo sarà ruotata di 90° *)
                            (* Se la ruoto con la pinza, ci sarà un riscontro per la rotazione;
                               se lato riscontro allineo la larghezza lastra, altrimenti a zero
                               Nota: dovrei tenere conto qualora fosse fattibile la rotazioni con altri sistemi,
                                     ad es. ventosa su polmone ID_BUFROT, vnBufRot_Type, BIT_ENABBUFROT
                                     in tal caso si riscontra il taglio/processazione *)
                            vqNextStep_FirstAlgn := SEL( vbStep_RotSheetOnAlgn, 0, vqBuf_SubSheet_Width );

                            (* Ascissa bordo indietro rimanenza del taglio successivo *)
                            vqNextProcArea_Xmin := vqBuf_Proc_Algn - vqBuf_SubSheet_Height;

                            (* Spazio preso dal riscontro per rotazione (lato riscontro) *)
                            CalcAlgnDelta( Width:=vqBuf_SubSheet_Width, Height:=vqBuf_SubSheet_Height, Align:=vqBuf_SubSheet_Width );
                            vqNextProcArea_Xmax := CalcAlgnDelta.Align + CalcAlgnDelta.Delta;
                            (* Spazio di riscontro necessario alla processazione *)
                            CalcAlgnDelta( Width:=vqBuf_SubSheet_Height, Height:=vqBuf_SubSheet_Width, Align:=vqBuf_Proc_Algn );
                            (* Prendo il massimo tra i due *)
                            vqNextProcArea_Xmax := MAX(vqNextProcArea_Xmax, CalcAlgnDelta.Align + CalcAlgnDelta.Delta);
                        ELSE
                            (* Lastra in arrivo non ruotata *)
                            (* Si riscontrerà direttamente per il taglio/processazione *)
                            vqNextStep_FirstAlgn := vqBuf_Proc_Algn;

                            (* Ascissa bordo indietro rimanenza del taglio successivo *)
                            vqNextProcArea_Xmin := vqBuf_Proc_Algn - vqBuf_SubSheet_Width;

                            (* Spazio di riscontro necessario alla processazione *)
                            CalcAlgnDelta( Width:=vqBuf_SubSheet_Width, Height:=vqBuf_SubSheet_Height, Align:=vqBuf_Proc_Algn );
                            vqNextProcArea_Xmax := CalcAlgnDelta.Align + CalcAlgnDelta.Delta;
                        END_IF;

                        (* Zona che serve per la processazione del taglio successivo:
                           Al bordo indietro rimanenza aggiungo il movimento necessario al riscontro
                           e allo stacco; in ogni caso mi assicuro sempre di liberare lo stacco *)
                        (* Anzichè usare un valore pessimistico fisso dovrei calcolare quello effettivo:
                           CalcAlgnDelta( Width:=vqBuf_SubSheet_Width, Height:=vqBuf_SubSheet_Height, Align:=vqBuf_Proc_Algn );
                           Ma questo valore in fondo non lo uso nemmeno... *)
                        vqNextProcArea_Xmin := MIN(vqNextProcArea_Xmin + vq[ivqAx_HomePos+AX_XS-1] - 300E3, vqDtch_Xbegin);

                        (* Il valore massimo mi serve per considerazioni su dove posso
                           lasciare il bordo indietro dei pezzi in consegna *)
                        vqNextProcArea_Xmax := vqNextProcArea_Xmax + vqProcArea_XmaxMrg;

                        (* Il taglio successivo è una preincisione? *)
                        vbNextStep_Zprescore := vqBuf_Proc_Ybtm<>vqBuf_Proc_Ytop AND (vnBuf_StepSettings & (BIT_OPEN OR BIT_DETACH))=0;

                        dlog( Txt:='fbJobData: -> Peeked step %d: algn=%ld area=%ld|%ld', Lvl:=5, Val1:=TO_DINT(vnStepIndex+1), Val2:=vqNextStep_FirstAlgn/1E3, Val3:=vqNextProcArea_Xmin/1E3, Val4:=vqNextProcArea_Xmax/1E3 );
                    ELSE
                        (* Probabilmente i passi sono finiti *)
                        dlog( Txt:='fbJobData: -> No valid step after %d', Lvl:=5, Val1:=TO_DINT(vnStepIndex) );
                        (* Nota: Ho già resettato i valori sbirciati sopra al caricamento del passo *)
                    END_IF;
                ELSE (* Manual mode *)
                    (* Appena caricato un passo valido in modalità manuale *)
                    vnTotSteps := 1; (* C'è un passo caricato *)
                END_IF; (* auto/manual mode *)

                (* Opzione per far vedere all'operatore dove posizionare il vetro *)
                IF vbAlgn_AutoInd AND vnAlgnBlocks_Sts=TS_OFF (* Piedini bassi *)
                   (* AND vn[ivnStatus+ID_ALGN]=STS_IDLE (* Nah, al massimo avrò un errore *)
                   AND NOT (vbAutoMode AND vbFeat_FullAuto) THEN (* No macchine W in automatico *)
                    dlog( Txt:='fbJobData: ! Indicating align %d mm', Lvl:=5, Val1:=vqProc_Algn/1E3 );
                    vbSelAlgnInd := TRUE;
                    vbBtnStartAlgn := TRUE; (* Will be eat in 'Services' *)
                END_IF;
            END_IF; (* Step valid *)
        END_IF; (* Step not empty *)

        (* Resetto stato lavorazione step corrente *)
        vbExtractDone := vnSubSheet_From<>ZONE_FEED;
        vbEdgeTrimmed := FALSE;
        vbPreRotDone := NOT fnRotated90(vnSubSheet_Rot);
        vbProcDone := FALSE;
        vbDetachDone := FALSE;
        vqRemn_X := NO_POS_UM; (* Loading new step *)

        Cmd := Cmd & NOT BIT_SETSTEP; (* eat command *)


    (* --------------------------------------------------------------- *)
    ELSIF (Cmd & BIT_PEEKSTEP)<>0 THEN
        (* --- Sbircia il passo successivo ---
              In: Scheme.CurStep
              Out: vnBuf_StepSettings, vqBuf_SubSheet_Width, ...
              Acts: Invalido il passo corrente *)
        dlog( Txt:='fbJobData: -> Peeking step %d', Lvl:=4, Val1:=TO_DINT(Scheme.CurStep+1) );
        IF vbAutoMode THEN
            Scheme( SelStep:=Scheme.CurStep+1, Peek:=TRUE ); (* è un comando immediato *)
            (* IF JobData.Scheme.ValidStep THEN ... *)
        ELSE
            dlog( Txt:='!! No step to peek in manual mode', Lvl:=1 );
        END_IF;
        Cmd := 0; (* eat all commands *)

    (* --------------------------------------------------------------- *)
    ELSIF (Cmd & BIT_SETCUTFLAGS)<>0 THEN
        (* --- Setta i selettori di processazione --- *)
        vnStepSettings := vnBuf_StepSettings;
        dlog( Txt:='fbJobData: -> vnStepSettings set to 0x%X', Lvl:=4, Val1:=TO_DINT(vnStepSettings) );
        Cmd := Cmd & NOT BIT_SETCUTFLAGS; (* eat command *)

    (* --------------------------------------------------------------- *)
    ELSIF (Cmd & BIT_SETRECIPE)<>0 THEN
        (* --- Setta la ricetta di processazione --- *)
        vnCutRecipe := vnBuf_CutRecipe & vnEnabledRecipes;
        dlog( Txt:='fbJobData: -> vnCutRecipe set to 0x%X', Lvl:=4, Val1:=TO_DINT(vnCutRecipe) );
        Cmd := Cmd & NOT BIT_SETRECIPE; (* eat command *)

    (* --------------------------------------------------------------- *)
    ELSIF Cmd<>0 THEN
        dlog( Txt:='fbJobData: !! Ignoring command 0x%X, unknown bit', Lvl:=3, Val1:=TO_DINT(Cmd) );
        Cmd := 0; (* Abort further commands *)
    END_IF;
END_IF; (* -- Not busy *)


(* -- Monitors -- *)

(* Segnali passo valido caricato *)
JustValid := vbStepValid AND NOT Valid;
JustInvalid := NOT vbStepValid AND Valid;
Valid := vbStepValid;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbHmi

{ DE:"Interaction with external interface" }

	VAR_OUTPUT
	Status : INT; { DE:"Status" }
	WorkMode : INT; { DE:"Modalità di lavorazione" }
	ID : INT := ID_HMI; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vnHmiRequest : INT; { DE:"Richiesta da Hmi" }
	JobData : fbJobData; { DE:"Dati e argomenti della lavorazione" }
	vnSelWorkMode : INT; { DE:"Selettore modalità lavorazione [bit0:auto bit1:shape]" }
	vnEnabledModes : INT; { DE:"Modalità lavorazione abilitate" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vbShapeMode : BOOL; { DE:"Macchina in modalità sagomato curvilineo" }
	vbSlantMode : BOOL; { DE:"Modalità tagli obliqui attivata" }
	END_VAR

	{ CODE:ST }(*    fbHmi (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Gestisce l'interazione con programmi esterni,
      in particolare gli argomenti del lavoro.
         .Comanda il caricamento dei dati in arrivo
         .Commutazione modalità manuale/automatica

      DETAILS
      ----------------------------------------------
      Non fa altro che passare i comandi al gestore
      dei dati di lavoro, controllando le condizioni
      di applicazione, fornendo poi una risposta al
      richiedente.
      Qui ci sono eventuali accorgimenti nella
      commutazione tra le modalità di lavorazione.

      EXAMPLE OF USAGE
      ----------------------------------------------
      Hmi : fbHmi; { DE:"Iterazione con interfaccia utente" }
*)

(* -- State machine -- *)
CASE Status OF

    COM_JOBDATA : (* Loading job data in progress *)
        JobData();
        IF JobData.Cmd=0 THEN
            (* Qualunque cosa abbia fatto, ora ha finito; mi sta bene solo step vuoto o valido *)
            IF (vnHmiRequest & (BIT_SETSTEP OR BIT_NXTSTEP))<>0 AND NOT (JobData.EmptyStep OR JobData.Valid) THEN
                dlog( Txt:='fbHmi: !! No valid step after job data load', Lvl:=1 );
                Status := COM_ERROR;
            ELSE
                vnHmiRequest := 0; (* Eat command *)
                Status := STS_IDLE;
            END_IF;
        END_IF;

    STS_IDLE : (* Free, respond to requests *)
        (* Dispatch Hmi requests *)
        IF vnHmiRequest<>0 THEN
            (* A seconda del tipo di richiesta *)
            IF (vnHmiRequest & MSK_JOBCHANGECMD)<>0 THEN
                (* È un comando di cambio/sincronizzazione dei dati di lavoro: solo se non sto lavorando *)
                IF vn[ivnStatus+ID_STEPSEQ]=STS_IDLE OR vn[ivnStatus+ID_STEPSEQ]=STSEQ_DONE THEN
                    dlog( Txt:='fbHmi: -> Job command 0x%X', Lvl:=4, Val1:=TO_DINT(vnHmiRequest) );
                    JobData( Cmd:=vnHmiRequest );
                    Status := COM_JOBDATA;
                ELSE
                    dlog( Txt:='fbHmi: !! Rejecting vnHmiRequest=0x%X as StepSeq.Status=%d', Lvl:=1, Val1:=TO_DINT(vnHmiRequest), Val2:=TO_DINT(vn[ivnStatus+ID_STEPSEQ]) );
                    vnHmiRequest := 0; (* Eat rejected command *)
                    Status := COM_REJECTED;
                END_IF;
            ELSE
                (* È un comando immediato: non notifico nulla *)
                (* dlog( Txt:='fbHmi: -> Hmi command 0x%X', Lvl:=4, Val1:=TO_DINT(vnHmiRequest) ); *)
                JobData( Cmd:=vnHmiRequest );
                vnHmiRequest := 0; (* Eat command *)
            END_IF;
        END_IF;


    ELSE (* COM_REJECTED, COM_ERROR: wait acknowledge *)
        IF vnHmiRequest=0 THEN
            dlog( Txt:='fbHmi: Error acknowledged', Lvl:=1 );
            Status := STS_IDLE;
        END_IF;
END_CASE; (* -- state machine *)


(* -- Selettore modalità di lavoro -- *)
IF WorkMode<>vnSelWorkMode THEN
    (* vnEnabledModes *)
    WorkMode := vnEnabledModes & vnSelWorkMode;
    IF WorkMode<>vnSelWorkMode THEN
        dlog( Txt:='fbHmi: !! Disabled mode: 0x%X', Lvl:=1, Val1:=TO_DINT(WorkMode XOR vnSelWorkMode) );
        vnSelWorkMode := WorkMode;
    END_IF;

    dlog( Txt:='fbHmi: -> WorkMode=0x%X', Lvl:=3, Val1:=TO_DINT(WorkMode) );
    vbAutoMode := (WorkMode & BIT_AUTOMODE)<>0; (* v. anche 'vbFeat_FullAuto' *)
    vbShapeMode := (WorkMode & BIT_SHAPEMODE)<>0;
    vbSlantMode := (WorkMode & BIT_SLANTMODE)<>0;

    (* Qui posso intercettare la commutazione tra automatico e manuale:
    IF vbAutoMode THEN
        (* Passato in automatico!
    ELSE
        (* Passato in manuale!
    END_IF; *)

END_IF;


(* -- Monitors -- *)
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := Status=TS_OFF;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbMoveSeq

{ DE:"Gestore esecuzione sequenza movimentazione vetro" }

	VAR_IN_OUT
	Execute : BOOL; { DE:"Comando esecuzione" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato dell'esecuzione" }
	AtRest : BOOL; { DE:"Nessuna sequenza in corso" }
	Done : BOOL; { DE:"Sequenza terminata correttamente" }
	END_VAR

	VAR_EXTERNAL
	Cnc : fbCncM32; { DE:"Cnc device" }
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	vnCh1Ret : INT; { DE:"Valore di ritorno ultima subroutine (vedi 'RET_*')" }
	END_VAR

	{ CODE:ST }(*    fbMoveSeq (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Astrae il servizio di esecuzione di una
      sequenza di movimentazione vetro, ottenuta
      tramite un programma Cnc.

      DETAILS
      ----------------------------------------------
      Esegue il programma Cnc 'Move.src' sul canale
      principale (Chn1), il valore di ritorno è
      scritto in 'vnCh1Ret'.
*)

CASE Status OF

    TS_ON : (* Executing *)
        IF NOT Execute THEN (* Abort *)
            Cnc.Chn1.AbortPrg := TRUE;
            dlog( Txt:='fbMoveSeq: !! Aborted', Lvl:=2 );
            Status := TS_GOINGOFF;
        ELSIF Cnc.Chn1.Status=CS_RUN THEN
            (* Qui potrei monitorare l'esecuzione: file programma, linea *)
        ELSIF Cnc.Chn1.Status=CS_HOLD THEN
            (* Programma in pausa! *)
            Status := TS_WAITON;
        ELSE
            (* Programma terminato *)
            Done := vnCh1Ret=RET_OK;
            Status := TS_GOINGOFF;
        END_IF;


    TS_WAITON : (* Programma in pausa *)
        IF NOT Execute THEN (* Abort *)
            Cnc.Chn1.AbortPrg := TRUE; (* Ensure a stop/reset *)
            Status := TS_GOINGOFF;
        ELSIF Cnc.Chn1.Status<CS_HOLD THEN
            Cnc.Chn1.AbortPrg := TRUE; (* Ensure a stop/reset *)
            Status := TS_GOINGOFF;
        ELSIF Cnc.Chn1.Status=CS_RUN THEN
            Status := TS_ON;
        END_IF;


    TS_GOINGON : (* Starting program *)
        IF Cnc.Chn1.Ret<0 THEN (* Program not launched *)
            dlog( Txt:='fbMoveSeq: !! Cannot launch', Lvl:=0 );
            Status := TS_GOINGOFF;
        ELSIF Cnc.Chn1.Status=CS_RUN THEN
            Status := TS_ON;
        END_IF;


    TS_GOINGOFF : (* Stopping program *)
        IF Cnc.Chn1.Status>=CS_HOLD THEN
            Cnc.Chn1.AbortPrg := TRUE; (* Ensure a stop/reset *)
        ELSIF Cnc.Chn1.Status<=CS_READY THEN
            Execute := FALSE;
            Status := TS_OFF;
        END_IF;


    TS_OFF : (* Doing nothing *)
        IF Execute THEN
            Done := FALSE;
            (* dlog( Txt:='fbMoveSeq: [Starting]', Lvl:=2 ); *)
            (* Potrei selezionare il programma mediante argomento *)
            Cnc.Chn1.PrgPth := 'Move-Rotate-Prod.obj'; (* Lo chiamo in vnProd_PostSts=POST_ROTATING *)
            Cnc.Chn1.StartPrg := TRUE; (* Cnc.Chn1.Status=CS_READY *)
            Status := TS_GOINGON;
        END_IF;
END_CASE;

(* -- Monitors -- *)
AtRest := Status=TS_OFF;
(* vn[ivnStatus+ID] := Status; *)
(* vb[ivbAtRest+ID] := AtRest; *)

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbProcSeq

{ DE:"Gestore esecuzione sequenza processazione vetro" }

	VAR_IN_OUT
	Execute : BOOL; { DE:"Comando esecuzione" }
	END_VAR

	VAR_INPUT
	idx : INT; { DE:"Identificativo della processazione all'interno dello schema [1..N]" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato dell'esecuzione" }
	AtRest : BOOL; { DE:"Nessuna sequenza in corso" }
	Done : BOOL; { DE:"Sequenza terminata correttamente" }
	ID : INT := ID_PROCSEQ; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	Cnc : fbCncM32; { DE:"Cnc device" }
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vnProcPhase : INT; { DE:"Fase corrente della sequenza di processazione/taglio" }
	vbStepValid : BOOL; { DE:"Passo di lavorazione valido e caricato" }
	vnCh1Ret : INT; { DE:"Valore di ritorno ultima subroutine (vedi 'RET_*')" }
	Watch : fbWatch; { DE:"Orologio di sistema" }
	vdCutDate : LREAL; { DE:"Timestamp of last cut start" }
	vnCarriages_Cmd : INT; { DE:"Comando carrelli coordinati" }
	vnCarrSup_Cmd : INT; { DE:"Comando carrello superiore 'ID_CARR_SUP'" }
	vnCarrInf_Cmd : INT; { DE:"Comando carrello inferiore 'ID_CARR_INF'" }
	vnDtch_Cmd : INT; { DE:"Comando stacco" }
	vnAlgn_Cmd : INT; { DE:"Comando generale riscontri 'ID_ALGN' (vedi ALCMD_ALIGN, ...)" }
	vnBrkBar_Cmd : INT; { DE:"Aziona barra di troncaggio del ponte di taglio (0:riposo 1:esci 2:esci+sali)" }
	vbLampOut_Cmd : BOOL; { DE:"Aziona uscita lampada riscaldamento PVB (0:dentro 1:fuori)" }
	vbLampOn_Cmd : BOOL; { DE:"Accendi lampada riscaldamento PVB" }
	vnHoldPads_Cmd : INT; { DE:"Comando discesa tamponi fermavetro" }
	vnClampAlgn_Cmd : INT; { DE:"Comando discesa premilastra lato riscontri" }
	vnClampDtch_Cmd : INT; { DE:"Comando discesa premilastra lato stacco" }
	END_VAR

	{ CODE:ST }(*    fbProcSeq (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Astrae il servizio di esecuzione di una
      sequenza di processazione vetro, data
      tipicamente da:
        .Ricerca
        .Asportazione basso emissivo
        .Incisione
        .Apertura
        .Separazione
      Non bisogna però fare assunzioni in merito:
      il vetro potrebbe non essere separato, per
      questo vedere 'vbDetachDone'.

      DETAILS
      ----------------------------------------------
      Esegue sul canale principale (Chn1) il programma
      'Proc.src', il cui valore di ritorno è scritto
      in 'vnCh1Ret'.
*)

CASE Status OF

    TS_ON : (* Executing *)
        IF NOT Execute THEN (* Abort program *)
            Cnc.Chn1.AbortPrg := TRUE;
            dlog( Txt:='fbProcSeq: !! Cut %ld aborted', Lvl:=2, Val1:=TO_DINT(idx) );

            (* Ferma servizi chiamati dai programmi della sequenza di taglio,
               escludendo eventuali parcheggi in corso *)
            IF vnCarriages_Cmd>CARCMD_TRAIL_LOCK THEN vnCarriages_Cmd := CMD_STOP; END_IF;
            IF vnCarrSup_Cmd>CARCMD_TRAIL_LOCK THEN vnCarrSup_Cmd := CMD_STOP; END_IF;
            IF vnCarrInf_Cmd>CARCMD_TRAIL_LOCK THEN vnCarrInf_Cmd := CMD_STOP; END_IF;
            IF vnDtch_Cmd<>CMD_PARK THEN vnDtch_Cmd := CMD_STOP; END_IF;
            IF vn[ivnStatus+ID_ALGN]<>ALSTS_RESETTING THEN vnAlgn_Cmd := CMD_STOP; END_IF;

            vnBrkBar_Cmd := 0;
            vbLampOut_Cmd := FALSE;
            vbLampOn_Cmd := FALSE;
            vnHoldPads_Cmd := 0;
            vnClampAlgn_Cmd := CMD_STOP;
            vnClampDtch_Cmd := CMD_STOP;

            Status := TS_GOINGOFF;
        ELSIF Cnc.Chn1.Status=CS_RUN THEN
            (* Qui potrei monitorare l'esecuzione: file programma, linea *)
            (* vnProcPhase è gestito nei programmi *)
        ELSIF Cnc.Chn1.Status=CS_HOLD THEN
            (* Programma di taglio in pausa! *)
        ELSE
            (* Programma terminato *)
            Done := vnCh1Ret=RET_OK;
            IF Done THEN
                (* Programma concluso correttamente *)
                dlog( Txt:='fbProcSeq: [Cut %ld done]', Lvl:=3, Val1:=TO_DINT(idx) );
                (* I dati di taglio sono eventualmente resettati altrove *)
            END_IF;
            Status := TS_GOINGOFF;
        END_IF;


    TS_GOINGON : (* Starting program *)
        IF Cnc.Chn1.Ret<0 THEN (* Program not launched *)
            dlog( Txt:='fbProcSeq: !! Cannot run cut %ld', Lvl:=0, Val1:=TO_DINT(idx) );
            Status := TS_GOINGOFF;
        ELSIF Cnc.Chn1.Status=CS_RUN THEN
            Status := TS_ON;
        END_IF;


    TS_GOINGOFF : (* Stopping program *)
        IF Cnc.Chn1.Status>=CS_HOLD THEN
            Cnc.Chn1.AbortPrg := TRUE; (* Ensure a stop/reset *)
        ELSIF Cnc.Chn1.Status<=CS_READY THEN
            vnProcPhase := 0;
            Execute := FALSE;
            Status := TS_OFF;
        END_IF;


    TS_OFF : (* Doing nothing *)
        IF Execute THEN
            (* Inizializza *)
            vnProcPhase := 0;
            Done := FALSE;
            (* Dati lavoro correttamente caricati? *)
            IF vbStepValid THEN
                (* Timestamp of the cut start *)
                Watch( Act:=1 );
                vdCutDate := Watch.DateTime;
                (* dlog( Txt:='fbProcSeq: [Starting cut %ld]', Lvl:=2, Val1:=TO_DINT(idx) ); *)
                Cnc.Chn1.PrgPth := 'Proc.obj';
                Cnc.Chn1.StartPrg := TRUE; (* Cnc.Chn1.Status=CS_READY *)
                Status := TS_GOINGON;
            ELSE
                SET_MSG(MSG_NOJOB,'MSG_NOJOB',0);
                Execute := FALSE;
            END_IF;
        END_IF;
END_CASE;

(* -- Monitors -- *)
AtRest := Status=TS_OFF;
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




FUNCTION_BLOCK fbStepSeq

{ DE:"Gestore esecuzione sequenza del singolo passo di lavorazione" }

	VAR_IN_OUT
	Cmd : INT; { DE:"Comando start sequenza (0:none 1:all 2:cut 3:evac)" }
	ProcSeq : fbProcSeq; { DE:"Sequenza di taglio" }
	MoveSeq : fbMoveSeq; { DE:"Sequenza di movimentazione" }
	END_VAR

	VAR_INPUT
	Abort : BOOL; { DE:"Segnale di stop/annullamento sequenza" }
	END_VAR

	VAR_OUTPUT
	Status : INT; { DE:"Stato del sistema" }
	AtRest : BOOL; { DE:"Sistema a riposo" }
	ID : INT := ID_STEPSEQ; { DE:"Identificativo componente" }
	END_VAR

	VAR_EXTERNAL
	Cnc : fbCncM32; { DE:"Cnc device" }
	dlog : fbLog; { DE:"Logging facility" }
	Msgs : fbMessages; { DE:"Message services" }
	vbMsgs : ARRAY[ 0..999 ] OF BOOL; { DE:"Array messaggi attivati !MAX_MESSAGES!" }
	vqRequestActive : DINT; { DE:"Una o più richieste attive" }
	ThrowEmg : fbThrowEmg; { DE:"Facility to raise an emergency" }
	vb : ARRAY[ 0..8191 ] OF BOOL; { DE:"VB[]" }
	vn : ARRAY[ 0..4095 ] OF INT; { DE:"VN[]" }
	vq : ARRAY[ 0..8191 ] OF DINT; { DE:"VQ[]" }
	Watch : fbWatch; { DE:"Orologio di sistema" }
	JobData : fbJobData; { DE:"Dati e argomenti della lavorazione" }
	vqWorkSettings : DINT; { DE:"Selettori ritentivi di lavorazione" }
	vbAutoMode : BOOL; { DE:"Macchina in modalità automatica" }
	vbCutAutoStart : BOOL; { DE:"Fai partire automaticamente il taglio anche in manuale/sagomato" }
	vbFeat_FullAuto : BOOL; { DE:"Macchina con movimentazione completamente automatica del vetro" }
	vnCh1Ret : INT; { DE:"Valore di ritorno ultima subroutine" }
	vnBelts_Act : INT; { DE:"Maschera attivazione cinghie" }
	vnBuf_Type : INT; { DE:"Tipo modulo/zona polmone 'ID_BUF' (0:feed 1:belts)" }
	vnSchemeIndex : INT; { DE:"Indice schema di taglio corrente" }
	vnStepIndex : INT; { DE:"Indice passo dello schema corrente [1-TotSteps]" }
	vbSchemeDone : BOOL; { DE:"Schema completamente eseguito" }
	vbLastStep : BOOL; { DE:"Ultimo passo dello schema" }
	vbMustAlign : BOOL; { DE:"È necessario riscontrare la sottolastra da processare" }
	vbFloatStripesBreak : BOOL; { DE:"Troncaggio traversi monolitico (vedi BIT_STRIPES)" }
	vbZprescore : BOOL; { DE:"Il passo corrente è una preincisione di un taglio annidato" }
	vnSheetType : INT; { DE:"Tipologia materiale 'sheet-type'" }
	vqSubSheet_Width : DINT; { DE:"Dimensione longitudinale lastra in arrivo [um]" }
	vqSubSheet_Height : DINT; { DE:"Dimensione trasversale lastra in arrivo [um]" }
	vqSubSheet_ProcWidth : DINT; { DE:"Dimensione longitudinale lastra in arrivo (dopo la rotazione) [um]" }
	vqSubSheet_ProcHeight : DINT; { DE:"Dimensione trasversale lastra in arrivo (dopo la rotazione) [um]" }
	vdSubSheet_Mass : LREAL; { DE:"Massa della sottolastra corrente [Kg]" }
	vqProc_Algn : DINT; { DE:"Quota riscontro per taglio/processazione [um]" }
	vqNextStep_FirstAlgn : DINT; { DE:"Prossima quota riscontri (per rotazione o processazione) [um]" }
	vqCut_Height : DINT; { DE:"Lunghezza taglio/altezza pezzi dichiarata [um]" }
	vqProd_Width : DINT; { DE:"Dimensione longitudinale prodotto del taglio [um]" }
	vqRemn_Width : DINT; { DE:"Dimensione longitudinale rimanenza del taglio [um]" }
	vdProd_Mass : LREAL; { DE:"Massa del prodotto del passo corrente [Kg]" }
	vdRemn_Mass : LREAL; { DE:"Massa della rimanenza del passo corrente [Kg]" }
	vqProc_AlgnDelta : DINT; { DE:"Spostamento di riscontro lastra [um]" }
	vnSubSheet_Id : INT; { DE:"Identificativo sottolastra" }
	vnSubSheet_From : INT; { DE:"Provenienza sottolastra" }
	vnSubSheet_Rot : INT; { DE:"Rotazione sottolastra (multipli di 90°)" }
	vnSubSheet_To : INT; { DE:"Destinazione sottolastra (see 'PLACE_*')" }
	vnProd_Id : INT; { DE:"Identificativo prodotto" }
	vnProd_From : INT; { DE:"Provenienza prodotto (see 'PLACE_*')" }
	vnProd_Rot : INT; { DE:"Rotazione prodotto (multipli di 90°)" }
	vnProd_To : INT; { DE:"Destinazione prodotto (see 'PLACE_*')" }
	vnRemn_Id : INT; { DE:"Identificativo rimanenza" }
	vnRemn_From : INT; { DE:"Provenienza rimanenza (see 'PLACE_*')" }
	vnRemn_To : INT; { DE:"Destinazione rimanenza  (see 'PLACE_*')" }
	vbProd_HasShape : BOOL; { DE:"Il prodotto contiene sagome" }
	vbRemn_HasShape : BOOL; { DE:"La rimanenza contiene sagome" }
	vbProd_Prescored : BOOL; { DE:"Il prodotto contiene preincisioni" }
	vbRemn_Prescored : BOOL; { DE:"La rimanenza contiene preincisioni" }
	vbWillTiltOutPiece : BOOL; { DE:"Almeno un pezzo sarà mandato alla ribaltina" }
	vnStackedSheets : INT; { DE:"Numero sottolastre accumulate sul carico dichiarate" }
	vnTmpStackedSize : INT; { DE:"Monitor i_TmpStacked.Size" }
	vqY_BtmEdge : DINT; { DE:"Quota misurata bordo vetro basso [um]" }
	vqY_TopEdge : DINT; { DE:"Quota misurata bordo vetro alto [um]" }
	vqCut_Length : DINT; { DE:"Lunghezza taglio misurata effettiva [um]" }
	vbEdgeDet_OnTheFly : BOOL; { DE:"Abilita la ricerca al volo del vetro durante il taglio" }
	vnSubSheet_PreSts : INT; { DE:"Stato pre-movimentazioni lastra" }
	vnProd_PostSts : INT; { DE:"Stato post-movimentazioni prodotto" }
	vnRemn_PostSts : INT; { DE:"Stato post-movimentazioni rimanenza" }
	vbExtractDone : BOOL; { DE:"Sottolastra in arrivo estratta da carico" }
	vbEdgeTrimmed : BOOL; { DE:"Bava plastico rimossa" }
	vbPreRotDone : BOOL; { DE:"Sottolastra in arrivo già ruotata" }
	vbProcDone : BOOL; { DE:"Taglio processato" }
	vbDetachDone : BOOL; { DE:"Sottolastra separata" }
	vbZprescored_Done : BOOL; { DE:"Il passo precedente è stato una preincisione eseguita con successo" }
	vnPieceDelivering : INT; { DE:"Identificativo pezzo in consegna" }
	vnPieceTaken : INT; { DE:"Identificativo ultimo pezzo prelevato" }
	vqRemn_X : DINT; { DE:"Posizione bordo avanti della rimanenza [um]" }
	vqProd_X : DINT; { DE:"Posizione bordo avanti del prodotto [um]" }
	vqSubSheet_X : DINT; { DE:"Posizione X bordo avanti della lastra in arrivo [um]" }
	vqSubSheet_Y : DINT; { DE:"Posizione Y bordo basso della lastra in arrivo [um]" }
	vqInsSheet_Y : DINT; { DE:"Posizione Y bordo basso dell'ultima lastra inserita nel carico [um]" }
	GuessSheetPos : fbGuessSheetPos; { DE:"Indovina posizione lastra da fotocellule" }
	vqNextProcArea_Xmax : DINT; { DE:"Prossima area processazione vetro: X massimo [um]" }
	vqNextProcArea_Xmin : DINT; { DE:"Prossima area processazione vetro: X minimo [um]" }
	vqProcArea_Xmin : DINT; { DE:"Area processazione vetro: X minimo (lato stacco) [um]" }
	vqRot_Xmin : DINT; { DE:"Ingombro rotazione: X minimo [um]" }
	vbVents_MotorsOn : BOOL; { DE:"Avvia i motori dei ventilatori" }
	vnEdgeTrim_Type : INT; { DE:"Tipo utensile intestatura plastico" }
	vqShift_GlassWidth : DINT; { DE:"Larghezza lastra movimentata [um]" }
	vqShift_GlassYbtm : DINT; { DE:"Ordinata bordo basso lastra movimentata [um]" }
	vqShift_GlassYtop : DINT; { DE:"Ordinata bordo alto lastra movimentata [um]" }
	vqShift_GlassX : DINT; { DE:"Posizione bordo avanti iniziale/corrente lastra movimentata [um]" }
	vqShift_TargetX : DINT; { DE:"Posizione finale lastra movimentata (bordo avanti) [um]" }
	vqShift_TargetTol : DINT; { DE:"Tolleranza sulla posizione finale della lastra movimentata [um]" }
	vbShift_NoRolls : BOOL; { DE:"Modificatore temporaneo: inibisci rulli riscontro" }
	vbShift_KeepAirOn : BOOL; { DE:"Modificatore temporaneo: non spegnere aria riscontri" }
	vnShift_Cmd : INT; { DE:"Comando a sistema di trasporto vetro" }
	vnShift_Seq : INT; { DE:"Stato/risultato sequenza di movimentazione cinghie" }
	vbShift_AlmostThere : BOOL; { DE:"Chiamata Lastra: quasi arrivata per riscontro" }
	vbShift_DumpRemn : BOOL; { DE:"Consegna/espulsione rimanenza lato stacco" }
	vnShift_DumpSeq : INT; { DE:"Stato/risultato sequenza di espulsione rifilo" }
	vbRemn_Dumpable : BOOL; { DE:"Si deve espellere automaticamente la rimanenza nel cassone" }
	vqShift_MovePosTol : DINT; { DE:"Tolleranza sui posizionamenti generici [um]" }
	vqShift_AlgnPosTol : DINT; { DE:"Tolleranza sul posizionamento per riscontro [um]" }
	vqShift_DragPosTol : DINT; { DE:"Tolleranza sul posizionamento per aggancio [um]" }
	vqShift_ProcPosTol : DINT; { DE:"Tolleranza sul posizionamento lastra per processazione [um]" }
	vqShift_ProcPosFix : DINT; { DE:"Correzione sul posizionamento lastra per processazione [um]" }
	vnShiftFeed_Cmd : INT; { DE:"Comando a cinghie carico" }
	fcDtchLast : fbPhotoCell; { DE:"Ultima fotocellula su modulo stacco (IFC_DTCH_LAST)" }
	fcFeedNearEnd : fbPhotoCell; { DE:"Fotocellula prossimità fine modulo di carico (IFC_FEED_NEAREND)" }
	vqShift_GoodWidth : DINT; { DE:"Larghezza minima passabile a riscontri senza avvicinam stacco [um]" }
	vqGlass_BigWidth : DINT; { DE:"Soglia larghezza vetro considerato ingombrante [um]" }
	vqGlass_BigHeight : DINT; { DE:"Soglia altezza vetro considerato ingombrante [um]" }
	vqGlass_Heavy : DINT; { DE:"Soglia massa vetro considerato pesante [g]" }
	vqTiltOut_MinWidth : DINT; { DE:"Minima larghezza da ribaltare [um]" }
	vqTiltOut_MaxWidth : DINT; { DE:"Massima larghezza ribaltabile automaticamente [um]" }
	vnAlgn_Cmd : INT; { DE:"Comando riscontri" }
	vnAlgn_Seq : INT; { DE:"Stato/risultato sequenze riscontri" }
	vnAlgnBlocks_Sel : INT; { DE:"Selezione piedini di riscontro" }
	vnAlgnBlocks_Sts : INT; { DE:"Stato dei piedini di riscontro" }
	vqAlgn_Tgt : DINT; { DE:"Quota di riscontro [um]" }
	vqAlgnSheet_X : DINT; { DE:"Posizione bordo avanti lastra riscontranda [um]" }
	vqAlgnSheet_Width : DINT; { DE:"Larghezza lastra riscontranda [um]" }
	vqAlgnSheet_Height : DINT; { DE:"Altezza lastra riscontranda [um]" }
	vbAlgn_UserAlign : BOOL; { DE:"Sequenza di riscontro con operatore" }
	vqAlgn_CurrX : DINT; { DE:"Posizione attuale dei piedini riscontri selezionati [um]" }
	vqAlgn_DragForeMargin : DINT; { DE:"Margine di aggancio con piedini anteriori [um]" }
	vqAlgn_AlmostDelta : DINT; { DE:"Soglia riscontro quasi terminato per inizio ricerca lastra [um]" }
	vqX_ClampAlgnP : DINT; { DE:"Ascissa fine premilastra riscontri [um]" }
	vnAlgn_DeliverCmd : INT; { DE:"Servizio generico estrazione/consegna pezzo" }
	vnAlgn_DeliverSeq : INT; { DE:"Stato/risultato sequenza di estrazione/consegna pezzo a valle" }
	vbAlgnDlvr_Prescored : BOOL; { DE:"Il pezzo da consegnare contiene preincisioni" }
	vnAlgnDlvr_Id : INT; { DE:"Identificativo vetro da portare a fine linea" }
	vqAlgnDlvr_Xbck : DINT; { DE:"Posizione bordo indietro vetro da consegnare [um]" }
	vqAlgnDlvr_Tgt : DINT; { DE:"Posizione bordo avanti dove consegnare [um]" }
	vqAlgnDlvr_Width : DINT; { DE:"Larghezza vetro da consegnare [um]" }
	vqAlgnDlvr_Ybtm : DINT; { DE:"Posizione Y basso vetro da consegnare [um]" }
	vqAlgnDlvr_Ytop : DINT; { DE:"Posizione Y alto vetro da consegnare [um]" }
	vbAlgnDlvr_AlmostDone : BOOL; { DE:"Sequenza di consegna a buon punto" }
	vqDeliver_DefaultXbck : DINT; { DE:"Posizione rilascio bordo indietro se non si porta a fine linea [um]" }
	vnDtch_Type : INT; { DE:"Tipologia stacco (0:none, 1:pneum, 2:mot)" }
	vqDtch_CurrX : DINT; { DE:"Posizione attuale del modulo di stacco [um]" }
	vnDtch_Cmd : INT; { DE:"Comando stacco" }
	vnDtch_Seq : INT; { DE:"Risultato sequenza stacco" }
	vqDtch_Tgt : DINT; { DE:"Posizione obiettivo stacco [um]" }
	vqDtch_GlassWidth : DINT; { DE:"Larghezza lastra da trascinare con lo stacco [um]" }
	vqDtch_GlassXbck : DINT; { DE:"Ascissa bordo indietro lastra da trascinare con lo stacco [um]" }
	vqDtch_GrabMinWidth : DINT; { DE:"Minimo vetro pinzabile [um]" }
	vnCarriages_Cmd : INT; { DE:"Comando carrelli coordinati" }
	vnCarriages_Sts : INT; { DE:"Stato funzionamento combinato carrelli" }
	vnCarriages_Seq : INT; { DE:"Risultato sequenza combinata carrelli" }
	vnCarrSup_Cmd : INT; { DE:"Comando carrello superiore" }
	vnCarrInf_Cmd : INT; { DE:"Comando carrello inferiore" }
	vbCarrSup_ParkOnEnd : BOOL; { DE:"Parcheggia il carrello alla fine dell'operazione" }
	vbCarriages_Prepos : BOOL; { DE:"Preposiziona i carrelli all'inizio del lavoro" }
	vbFeat_CarrHomeOnTop : BOOL; { DE:"Macchina con parcheggio carrelli opposto ad operatore" }
	vbFeat_FixedCarriages : BOOL; { DE:"Macchina con carrelli vincolati" }
	vqCarrInf_Tgt : DINT; { DE:"Posizione obiettivo carrello inferiore [um]" }
	vqCarrSup_Tgt : DINT; { DE:"Posizione obiettivo carrello superiore [um]" }
	vqYsup_TopParkPos : DINT; { DE:"Posizione di parcheggio alto carrello superiore [um]" }
	vqProc_Ybtm : DINT; { DE:"Quota Y basso processazione [um]" }
	vbGrabber_NotLocked : BOOL; { DE:"Pinza su traino e non agganciata a carrello inferiore" }
	vbGrabber_CanBeUnlocked : BOOL; { DE:"Pinza su traino e agganciata a carrello inferiore" }
	vbGrLe_NotLocked : BOOL; { DE:"Mola su traino e non agganciata a carrello superiore" }
	vbGrLe_CanBeUnlocked : BOOL; { DE:"Mola su traino e agganciata a carrello superiore" }
	vbCarr_ParkOnRotErr : BOOL; { DE:"Parcheggia automaticamente pinza in caso di rotazione fallita" }
	vnGrabber_Type : INT; { DE:"Tipo girapezzi (0:none 1:ventosa 2:pinza)" }
	vqGrab_GlassWidth : DINT; { DE:"Larghezza iniziale lastra da ruotare [um]" }
	vqGrab_GlassYbtm : DINT; { DE:"Ordinata bordo passo iniziale lastra da ruotare [um]" }
	vqGrab_GlassYtop : DINT; { DE:"Ordinata bordo alto iniziale lastra da ruotare [um]" }
	vqGrab_Ygrab : DINT; { DE:"Quota di presa [um]" }
	vqGrab_Agrab : DINT; { DE:"Angolo di presa [mdeg]" }
	vqGrab_Arot : DINT; { DE:"Angolo relativo di rotazione [mdeg]" }
	vqGrabber_DY : DINT; { DE:"Offset asse pinza girapezzi [um]" }
	vbGrab_DontSearchInc : BOOL; { DE:"Non misurare la lastra in arrivo" }
	CalcRotAlgn : fbCalcRotAlgn; { DE:"Calcoli per rotazione prodotto con pinza" }
	CalcAlgnDelta : fbCalcAlgnDelta; { DE:"Calcola delta riscontro" }
	vqAlgn_MinDelta : DINT; { DE:"Spostamento di riscontro minimo garantito [um]" }
	vnGrab_RotType : INT; { DE:"Tipo ultima rotazione con pinza" }
	vqDtch_Xbegin : DINT; { DE:"Ascissa inizio zona stacco [um]" }
	CalcRotBuf : fbCalcRotBuf; { DE:"Calcoli per rotazione su polmone" }
	vqBufRot_GlassWidth : DINT; { DE:"Larghezza lastra da ruotare [um]" }
	vqBufRot_GlassHeight : DINT; { DE:"Altezza lastra da ruotare [um]" }
	vqBufRot_GlassXfwd : DINT; { DE:"Ascissa bordo avanti lastra da ruotare [um]" }
	vqBufRot_GlassYbtm : DINT; { DE:"Ordinata bordo basso lastra da ruotare [um]" }
	vnBufRot_Cmd : INT; { DE:"Comando rotazione su polmone [90deg]" }
	vnBufRot_Seq : INT; { DE:"Risultato sequenza rotazione su polmone 'ID_BUFROT'" }
	vbBufRot_ExtrP90 : BOOL; { DE:"Rotazione preferita all'estrazione (0:-90 1:+90)" }
	vbBufRot_RemnP90 : BOOL; { DE:"Rotazione preferita della rimanenza (0:-90 1:+90)" }
	vbBufRot_TryInv : BOOL; { DE:"Prova ad invertire il senso di rotazione se collisioni" }
	vqBufRot_Yc : DINT; { DE:"Posizione Y centro rotazione [um]" }
	vqYo_SheetFeed : DINT; { DE:"Ordinata tipica della lastra in arrivo dal carico [um]" }
	vqDtchBelts_Size : DINT; { DE:"Larghezza banda gommmata cinghie a monte [um]" }
	vqBelts_MinGripDY : DINT; { DE:"Minima banda Y contatto gomma-vetro per trasportabilità [um]" }
	vqDtchBelts_Dx : DINT; { DE:"Offset X delle cinghie rispetto bordo stacco [um]" }
	vqXph_FeedBegin : DINT; { DE:"Ascissa fotocellula inizio carico [um]" }
	vqXph_FeedNearEnd : DINT; { DE:"Ascissa fotocellula prossimità fine carico [um]" }
	vqXph_FeedEnd : DINT; { DE:"Ascissa fotocellula fine carico [um]" }
	vqBelts_StackDist : DINT; { DE:"Distanza lastre accodate sul carico [um]" }
	vqDXph_DtchLast : DINT; { DE:"Offset ultima fotocellula su stacco [um]" }
	vqRemn_DXdtch : DINT; { DE:"Posizione bordo avanti della rimanenza separata rispetto lo stacco [um]" }
	vqOutZone_Xbusy : DINT; { DE:"Limite indietro zona occupata a fine linea [um]" }
	vbStep_EarlyStart : BOOL; { DE:"Anticipa start automatico del passo successivo" }
	vbStep_AlwaysNext : BOOL; { DE:"Seleziona step successivo anche al fallimento di una rotazione" }
	vbStep_RotSheetOnAlgn : BOOL; { DE:"Ruota sempre la lastra in arrivo portandola sui riscontri" }
	vbStep_StartAlgnOnCall : BOOL; { DE:"Fai partire la sequenza riscontro alla chiamata lastra" }
	vqX_BeltsEnd : DINT; { DE:"Estremo cinghie per controlli trasportabilità [um]" }
	vbFeat_AlgnHasBelts : BOOL; { DE:"Riscontri provvisti di cinghie (non i rulli)" }
	vqX_AlgnBeltsBegin : DINT; { DE:"Ascissa inizio rulli/cinghie sui riscontri [um]" }
	vqX_AlgnBeltsEnd : DINT; { DE:"Ascissa fine rulli/cinghie sui riscontri [um]" }
	vqBelts_MinGripDX : DINT; { DE:"Minimo contatto X cinghie-vetro per trasportabilità [um]" }
	Shiftable : fbShiftable; { DE:"Controllo trasportabilità con cinghie" }
	vqBeltsAlgn_MinGripDX : DINT; { DE:"Minimo contatto X cinghie riscontro-vetro [um]" }
	vnBeltsAlgn_N : INT; { DE:"Numero delle cinghie riscontro" }
	vqBeltsAlgn_Size : DINT; { DE:"Larghezza banda gommmata cinghie riscontro [um]" }
	vqX_OutZoneBegin : DINT; { DE:"Ascissa inizio zona fine linea [um]" }
	vqX_OutZoneEnd : DINT; { DE:"Quota X piedini ribaltina/fine linea [um]" }
	vqXph_OutZoneEnd : DINT; { DE:"Ascissa fotocellula fine zona fine linea [um]" }
	vqTiltOut_Xo : DINT; { DE:"Ascissa dei piedini automatici della ribaltina [um]" }
	vqPiecesCount : DINT; { DE:"Contatore pezzi in uscita" }
	vbSchemeAlmostDone : BOOL; { DE:"Schema quasi terminato (tavolo di carico libero)" }
	vnStep_NoMoreIns : INT; { DE:"Indice passo oltre il quale non ci sono più inserzioni nel carico" }
	vqRemn_XfreeDtch : DINT; { DE:"Posizione tipica bordo avanti rimanenza dopo liberazione fotocellula di stacco con le cinghie [um]" }
	vqFeed_Xend : DINT; { DE:"Posizione bordo avanti del tavolo di carico [um]" }
	END_VAR

	VAR
	ExtractDone : fbEdges; { DE:"Fronti per estrazione lastra" }
	i_TmpStacked : fbSheetStack; { DE:"Inserzioni di scarti/pezzi temporanei, v. vnStackedSheets" }
	Prod_MustReor : BOOL; { DE:"Il prodotto va riorientato prima di essere evacuato (post-movimentazione)" }
	Remn_MustReor : BOOL; { DE:"La rimanenza va riorientata prima di essere evacuato (post-movimentazione)" }
	Prod_Reoriented : BOOL; { DE:"Il prodotto è stato riorientato (post-movimentazione)" }
	Remn_Reoriented : BOOL; { DE:"La rimanenza è stata riorientata (post-movimentazione)" }
	JustAborting : BOOL; { DE:"Flag interno per notifica stop" }
	delta : DINT; { DE:"Temporaneo per calcoli" }
	x : DINT; { DE:"Temporaneo per calcoli" }
	END_VAR

	{ CODE:ST }(*    fbStepSeq (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Incorpora l'esecuzione della sequenza di
      lavorazione di un singolo passo di lavorazione.

      DETAILS
      ----------------------------------------------
      Un passo è composto da:
         .Movimentazione iniziale e riscontro
         .Processazione (taglio)
         .Movimentazione rimanenza e prodotto

      EXAMPLE OF USAGE
      ----------------------------------------------
      StepSeq : fbStepSeq; { DE:"Sequenza del passo di lavorazione" }
*)

(* -- State machine -- *)
CASE Status OF

    (* ------------------------------------------------------------------- *)
    STSEQ_POST : (* Last operations before next step *)
        (* Qua devo attendere che le sequenze di movimentazione prodotto e rimanenza
           giungano in uno stato accettabile per partire col passo successivo *)

        (* -- Monitor stato movimentazione prodotto -- *)
        CASE vnProd_PostSts OF

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_EDGE_ATZERO : (* Ensure prod back edge aligned to cut axis *)
                (* Nel caso abbia riorientazioni, appoggio dimensioni effettive
                   agli argomenti della traslazione *)
                IF Prod_Reoriented THEN
                    (* Prodotto riorientato: le dimensioni sono scambiate *)
                    vqShift_GlassWidth := vqCut_Length; (* vqCut_Height *)
                    vqShift_GlassYbtm := vqYo_SheetFeed; (* Assumo che la pinza l'abbia portato qui *)
                    vqShift_GlassYtop := vqShift_GlassYbtm + vqProd_Width;
                ELSE
                    (* Prodotto non riorientato *)
                    vqShift_GlassWidth := vqProd_Width;
                    vqShift_GlassYbtm := vqY_BtmEdge;
                    vqShift_GlassYtop := vqY_TopEdge;
                END_IF;
                vqShift_GlassX := vqProd_X; (* Posizione presunta *)

                (* Voglio assicurare bordo indietro a zero o comunque sui riscontri *)
                IF (vqShift_GlassX - vqShift_GlassWidth) > -2E3 THEN
                    (* Il bordo va già bene: Emissione a fine linea *)
                    (* Nota: Se bordo più avanti dello zero non è un problema,
                             i riscontri possono agganciarlo più avanti *)
                    vnProd_PostSts := POST_PREP_DELIVER;
                (* Se possibile prediligo il trascinamento con stacco perché
                   più veloce e funziona bene con larghezze piccole *)
                ELSIF vqShift_GlassX>0 AND (* Bordo avanti su riscontro *)
                      vqShift_GlassWidth<vqShift_GoodWidth AND (* Solo se lastra stretta? *)
                      fnInRange_DINT(vqShift_GlassX-vqShift_GlassWidth, vqDtch_CurrX - vq[ivqAx_PosLim+AX_XS-1] + 1E3, 0) AND (* Bordo indietro trascinabile a zero con stacco *)
                      vnDtch_Type=2 THEN (* Stacco motorizzato *)
                    (* Porto avanti il prodotto con lo stacco *)
                    vqDtch_GlassWidth := vqShift_GlassWidth;
                    vqDtch_GlassXbck := vqShift_GlassX - vqShift_GlassWidth; (* Il bordo indietro del vetro (se siamo qui è negativo) *)
                    vqDtch_Tgt := 0; (* Posizione di arrivo desiderata del bordo indietro del vetro *)
                    vnDtch_Cmd := DTCMD_MOVEGLASS;
                    vnProd_PostSts := POST_DRAG_TOALGN;
                ELSE
                    (* Porto avanti il prodotto col sistema di traslazione *)
                    dlog( Txt:='fbStepSeq: Prod in %ld to Algn', Lvl:=2, Val1:=vqShift_GlassX/1E3 );

                    (* Posiziono bordo indietro a zero, più un certo margine per essere sicuro di agganciarlo *)
                    vqShift_TargetX := vqShift_GlassWidth + vqShift_DragPosTol + vqAlgn_DragForeMargin;
                    vqShift_TargetTol := vqShift_DragPosTol;
                    vnShift_Cmd := SHFCMD_FORW_ONALGN;

                    vnProd_PostSts := POST_SHIFT_TOALGN;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_DRAG_TOALGN : (* Shifting prod to align side (vnDtch_Seq) *)
                (* Questo è il movimento avanti per poi agganciarlo e portarlo a fine linea *)
                IF vnDtch_Cmd=CMD_STOP THEN
                    (* Sequenza terminata, vedi risultato *)
                    IF vnDtch_Seq=SEQ_DONE THEN
                        vqProd_X := vqDtch_GlassXbck + vqDtch_GlassWidth; (* Aggiorno posizione della lastra in arrivo *)
                        dlog( Txt:='fbStepSeq: Prod dragged fwd (%ld)', Lvl:=4, Val1:=vqProd_X/1E3 );
                        (* Emissione a fine linea *)
                        vnProd_PostSts := POST_PREP_DELIVER;
                    ELSE
                        (* Non è riuscito a trascinare il prodotto! *)
                        dlog( Txt:='fbStepSeq: !! Prod: Cannot pass to align', Lvl:=1 );
                        IF vnProd_Id=0 THEN SET_MSG(REQ_DUMP_PROD,'REQ_DUMP_PROD',0);
                                       ELSE SET_MSG(REQ_TAKE_PROD,'REQ_TAKE_PROD',0); END_IF;
                        vnPieceDelivering := vnProd_Id; (* see: vnPieceTaken *)
                        vnProd_PostSts := POST_REMOVE_REQ;
                    END_IF;
                ELSE
                    vqProd_X := vqDtch_GlassXbck + vqDtch_GlassWidth; (* Monitora movimento *)
                END_IF;


            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_SHIFT_TOALGN : (* Shifting prod to align side (vnShift_Seq) *)
                (* Questo è il movimento avanti per poi agganciarlo e portarlo a fine linea *)
                IF vnShift_Cmd=CMD_STOP THEN
                (* Sequenza terminata, vedi risultato *)
                    IF vnShift_Seq=SEQ_DONE THEN
                        vqProd_X := vqShift_TargetX;
                        dlog( Txt:='fbStepSeq: Prod passed (%ld)', Lvl:=4, Val1:=vqProd_X/1E3 );
                        (* Emissione a fine linea *)
                        vnProd_PostSts := POST_PREP_DELIVER;
                    ELSE
                        (* Non è riuscito a portare il prodotto di là! *)
                        dlog( Txt:='fbStepSeq: !! Prod: Cannot pass to align', Lvl:=1 );
                        IF vnProd_Id=0 THEN SET_MSG(REQ_DUMP_PROD,'REQ_DUMP_PROD',0);
                                       ELSE SET_MSG(REQ_TAKE_PROD,'REQ_TAKE_PROD',0); END_IF;
                        vnPieceDelivering := vnProd_Id; (* see: vnPieceTaken *)
                        vnProd_PostSts := POST_REMOVE_REQ;
                    END_IF;
                ELSE
                    vqProd_X := vqShift_GlassX; (* Monitora movimento *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_PREP_DELIVER : (* Prepare to bring prod to line end *)
                (* Procedo a portarlo a valle.
                   Nota: Se devo ruotarlo o agganciarlo coi riscontri
                         il bordo indietro deve essere a zero! *)
                (* Vedo se devo riorientarlo
                   per massimizzare la ribaltabilità se basso e largo *)
                IF Prod_MustReor AND NOT Prod_Reoriented THEN
                    (* Lo ruoto prima di portarlo a fine linea *)
                    dlog( Txt:='fbStepSeq: Prod: Reorienting', Lvl:=4 );
                    (* Assicuro cinghie riscontri basse? In Detach-Trim le alzo... *)
                    vnBelts_Act := vnBelts_Act & NOT BIT_ROLLS_ALGN;
                    (* Valuto la rotazione *)
                    vqGrab_GlassWidth := vqProd_Width; (* Nota: piuttosto largo *)
                    vqGrab_GlassYbtm := vqY_BtmEdge; (* Nota: piuttosto basso *)
                    vqGrab_GlassYtop := vqY_TopEdge;
                    vqGrab_Agrab := 0; (* [mdeg] *)
                    vqGrab_Arot := 90E3; (* [mdeg] *)
                    vqGrab_Ygrab := NO_POS_UM; (* Il punto di presa sarà scelto opportunamente *)
                    (* vqGrab_Ygrab := vqGrab_GlassYbtm + (vqGrab_GlassYtop-vqGrab_GlassYbtm)/2; *)
                    CalcRotAlgn( What:=ROTARG_REOR );  (* Riorientazione prodotto *)
                    IF CalcRotAlgn.Ok THEN
                        (* Procediamo con la rotazione *)
                        (* Nota: La rimanenza se non da prelevare/espellere, deve
                                 indietreggiare opportunamente: vedi 'SHFCMD_BACK_REMN' *)
                        (* Nota: Questa sequenza attenderà 'vqRemn_X<vqRot_Xmin' e richieste *)
                        vnCarriages_Cmd := CARCMD_GRAB;
                        vnProd_PostSts := POST_REORIENTING;
                    END_IF;
                END_IF;
                (* Vediamo se è da portare subito a fine linea *)
                IF vnProd_PostSts<>POST_REORIENTING THEN
                    (* Niente riorientamento, procediamo a trascinarlo a fine linea *)
                    vnProd_PostSts := POST_WAIT_DELIVER;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_WAIT_DELIVER : (* Waiting possible previous operation *)
                (* Voglio portarlo a fine linea: attendo servizio pronto *)
                IF vnAlgn_DeliverCmd=CMD_STOP AND vnAlgn_DeliverSeq<=SEQ_DONE THEN
                    (* AND vn[ivnStatus+ID_CLAMP_ALGN]<=CL_RISING AND vb[ivbAtRest+ID_DTCH] *)
                    dlog( Txt:='fbStepSeq: Prod: Delivering', Lvl:=4 );
                    (* Sequenza emissione a fine linea mediante trascinamento con i piedini
                       di riscontro, in caso di errore alza 'REQ_TAKE_PROD', 'REQ_DUMP_PROD' *)
                    IF Prod_Reoriented THEN
                        (* Prodotto riorientato: le dimensioni sono scambiate *)
                        vqAlgnDlvr_Width := vqCut_Length; (* vqCut_Height *)
                        vqAlgnDlvr_Ybtm := vqYo_SheetFeed; (* Assumo che la pinza l'abbia portato qui *)
                        vqAlgnDlvr_Ytop := vqYo_SheetFeed + vqProd_Width;
                    ELSE
                        (* Prodotto non riorientato *)
                        vqAlgnDlvr_Width := vqProd_Width;
                        vqAlgnDlvr_Ybtm := vqY_BtmEdge;
                        vqAlgnDlvr_Ytop := vqY_TopEdge;
                    END_IF;
                    vnAlgnDlvr_Id := vnProd_Id;
                    vbAlgnDlvr_Prescored := vbProd_Prescored;
                    vqAlgnDlvr_Xbck := vqProd_X - vqAlgnDlvr_Width;
                    vqAlgnDlvr_Tgt := vqX_OutZoneEnd; (* TODO 4: La quota di arrivo dipende da cosa c'è a valle *)
                    (* La condizione di pezzo a fine linea è data dalla fotocellula IFC_OUTZONE_END, vqXph_OutZoneEnd *)
                    vnAlgn_DeliverCmd := DLVCMD_END;

                    vnProd_PostSts := POST_DELIVERING;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_DELIVERING : (* Moving prod to line end *)
                (* Sequenza emissione prodotto a fine linea
                   .Allo start attende la liberazione della fotocellula di stacco
                   .Poi attende la liberazione della zona a fine linea
                   .In caso di errore alza 'REQ_TAKE_PROD', 'REQ_DUMP_PROD' *)
                (* Per proseguire basta essere a buon punto con l'evacuazione *)
                IF vbStep_EarlyStart AND vbAlgnDlvr_AlmostDone AND vqAlgnDlvr_Xbck>vqNextStep_FirstAlgn THEN
                    (* La zona per riscontrare è libera, trascinamento in corso *)
                    (* Se non libererà i trasportatori riscontro mi assicuro di non far partire lo step successivo *)
                    IF vqAlgnDlvr_Width >= (vqX_OutZoneEnd-vqX_AlgnBeltsEnd) THEN
                        dlog( Txt:='fbStepSeq: Prod: ! Will be on Rolls', Lvl:=4 );
                        vnPieceDelivering := vnProd_Id; (* see: vnPieceTaken *)
                        vnProd_PostSts := POST_REMOVE_REQ;
                    ELSE
                        dlog( Txt:='fbStepSeq: Prod: Next (bck=%ld mm)', Lvl:=4, Val1:=vqAlgnDlvr_Xbck/1E3 );
                        vnProd_PostSts := 0;
                    END_IF;
                ELSIF vnAlgn_DeliverCmd=CMD_STOP THEN
                    (* Sequenza terminata, vediamo il risultato *)
                    IF vnAlgn_DeliverSeq=SEQ_DONE THEN
                        (* Prodotto consegnato *)
                        dlog( Txt:='fbStepSeq: Prod: Delivered', Lvl:=4 );
                        vnProd_PostSts := 0;
                        (* Se non ha liberato i trasportatori riscontro... *)
                        IF vqAlgnDlvr_Xbck <= vqX_AlgnBeltsEnd THEN (* OR fcOutzoneBegin.q *)
                            dlog( Txt:='fbStepSeq: Prod: ! On Rolls', Lvl:=4 );
                            (* vqOutZone_Xbusy<=vqX_AlgnBeltsEnd *)
                        END_IF;
                    ELSE
                        (* Consegna fallita, va prelevato a mano dai riscontri *)
                        dlog( Txt:='fbStepSeq: Prod: Must be removed', Lvl:=4 );
                        (* Nota: 'REQ_TAKE_PROD', 'REQ_DUMP_PROD' già alzati *)
                        vnProd_PostSts := POST_REMOVE_REQ;
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_REORIENTING : (* Reorienting prod with grabber (vnCarriages_Sts) *)
                (* Riorientazione del prodotto prima di portarlo a fine linea *)
                IF vnCarriages_Cmd=CMD_STOP THEN
                    IF vnCarriages_Seq=SEQ_DONE THEN
                        (* Prodotto riorientato con successo *)
                        (* Ora le dimensioni sono scambiate *)
                        (* La posizione: *)
                        vqProd_X := vqGrab_Ygrab - vqGrab_GlassYbtm; (* Il bordo avanti è dato dalla distanza del punto di presa dal bordo sotto *)
                        (* La Y del bordo basso è alla posizione pinza
                        vq[ivqAx_CurrPos+AX_YINF-1] + vqGrabber_DY;
                        Oppure possiamo pensarla anche a vqYo_SheetFeed *)
                        dlog( Txt:='fbStepSeq: Prod: Reoriented Xfwd=%ld Xbck=%ld=%ld-%ld', Lvl:=4, Val1:=vqProd_X/1E3, Val2:=(vqGrab_Ygrab-vqGrab_GlassYtop)/1E3, Val3:=vqGrab_Ygrab/1E3, Val4:=vqGrab_GlassYtop/1E3 );
                        Prod_Reoriented := TRUE; (* Done *)
                        (* Ora vado a chiudere la pinza.
                           Nota: se la posiz di chiusura è sotto, il carrello inferiore rimane lì *)
                        vnCarriages_Cmd := CMD_PARK;
                        vnProd_PostSts := POST_PARK;
                    ELSE
                        dlog( Txt:='fbStepSeq: !! Prod: Reorientation failed', Lvl:=1 );
                        (* Signal the fail *)
                        IF vnProd_Id=0 THEN SET_MSG(REQ_DUMP_PROD,'REQ_DUMP_PROD',0);
                                       ELSE SET_MSG(REQ_TAKE_PROD,'REQ_TAKE_PROD',0); END_IF;
                        (* Abortisco solo i movimenti del prodotto, per non fermare la rimanenza *)
                        vnPieceDelivering := vnProd_Id; (* see: vnPieceTaken *)
                        vnProd_PostSts := POST_REMOVE_REQ;
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_ROTATING : (* Rotating prod with carriages sequence *)
                IF vnCarriages_Cmd=CMD_STOP THEN
                    IF vnCarriages_Seq=SEQ_DONE THEN
                        (* Prodotto ruotato con successo, aggiorno posizione lastra da tagliare *)
                        vqSubSheet_X := vqGrab_Ygrab - vqGrab_GlassYbtm; (* + vqGrabber_DX *) (* Bordo avanti *)
                        vqSubSheet_Y := vq[ivqAx_CurrPos+AX_YINF-1] + vqGrabber_DY; (* Bordo sotto *)
                        dlog( Txt:='fbStepSeq: Prod: Rotated Xfwd=%ld=%ld-%ld Ybtm=%ld', Lvl:=4, Val1:=vqSubSheet_X/1E3, Val2:=vqGrab_Ygrab/1E3, Val3:=vqGrab_GlassYbtm/1E3, Val4:=vqSubSheet_Y/1E3 );
                        (* Ora vado a chiudere la pinza.
                           Nota: se la posiz di chiusura è sotto, il carrello inferiore rimane lì *)
                        vnCarriages_Cmd := CMD_PARK;
                        vnProd_PostSts := POST_PARK;

                        (* Se la lastra (stretta) deve andare avanti, il riposizionamento
                           può essere problematico, soprattutto se il riscontro ha solo dei rulli.
                           Invalido la posizione per assicurare lastra sullo stacco? *)
                        (* TODO 5: Ci vorrebbe una manovra di avvicinamento stacco? *)
                        IF (vqGrab_GlassYtop-vqGrab_GlassYbtm)<vqShift_GoodWidth AND (* Lastra stretta... *)
                           fcDtchLast.q AND (* ...Letta da ultima fotocellula per manovra liberazione... *)
                           (* NOT vbFeat_AlgnHasBelts (* Ci sono solo dei rulli *)
                           vqNextStep_FirstAlgn>vqSubSheet_X THEN (* ...Deve andare avanti... *)
                            dlog( Txt:='fbStepSeq: ! Prod: Invalidating narrow sheet pos', Lvl:=3 );
                            vqSubSheet_X := NO_POS_UM; (* Ensure narrow sheet on detach *)
                            (* vqSubSheet_Y := NO_POS_UM; *)
                            (* Assicuro di liberare l'area taglio per avvicinamento stacco *)
                            vnCarriages_Cmd := CARCMD_FREEAREA;
                        END_IF;
                    ELSE
                        dlog( Txt:='fbStepSeq: !! Prod: Rotation failed', Lvl:=1 );
                        SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                        IF vbCarr_ParkOnRotErr THEN
                            vnCarriages_Cmd := CMD_PARK;
                        END_IF;
                        (* Mi assicuro di invalidare la posizione in eredità al passo successivo *)
                        vqSubSheet_X := NO_POS_UM; (* Rotate by hand *)
                        vqSubSheet_Y := NO_POS_UM;
                        (* Non abortisco, altrimenti blocco le operazioni sulla rimanenza *)
                        vnProd_PostSts := POST_ROTATE_REQ;
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_ROTATING_PRG : (* Rotating prod with CNC program *)
                MoveSeq( Execute:=NOT Abort );
                IF NOT Abort AND NOT MoveSeq.Execute THEN
                    (* Sequenza terminata, vedi risultato *)
                    IF MoveSeq.Done THEN
                        (* Prodotto ruotato con successo, aggiorno posizione lastra da tagliare:
                           Assumo già fatto nel programma *)
                        (* dlog( Txt:='fbStepSeq: Prod: Rotated Xfwd=%ld Ybtm=%ld', Lvl:=4, Val1:=vqSubSheet_X/1E3, Val2:=vqSubSheet_Y/1E3 ); *)
                        (* Fatto, attendo eventuale sequenza di parcheggio *)
                        vnProd_PostSts := POST_PARK;
                    ELSE
                        SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                        (* Mi assicuro di invalidare la posizione in eredità al passo successivo *)
                        vqSubSheet_X := NO_POS_UM; (* Rotate by hand *)
                        vqSubSheet_Y := NO_POS_UM;
                        (* Non abortisco, altrimenti blocco le operazioni sulla rimanenza *)
                        vnProd_PostSts := POST_ROTATE_REQ;
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_PARK : (* Waiting a park command (vnCarriages_Sts) *)
                (* Sequenza di chiusura pinza dopo rotazione *)
                IF vnCarriages_Cmd=CMD_STOP OR
                   (vbStep_EarlyStart AND
                    (vnCarriages_Cmd>=CMD_PARK AND vnCarriages_Cmd<=CARCMD_FULLPARK) AND (* Parking carriages sequence *)
                    vnCarriages_Sts>CARSTS_PARK_GOTODWN) THEN (* Closing grabber *)
                    IF vnCarriages_Seq=SEQ_DONE OR vbStep_EarlyStart THEN
                        dlog( Txt:='fbStepSeq: Prod: Grabber handled (%d)', Lvl:=4, Val1:=TO_DINT(vnCarriages_Sts) );
                        IF vnProd_Id<0 THEN
                            (* Ho ruotato per tagliare: fatto *)
                            vnProd_PostSts := 0;
                        ELSIF vnShift_Cmd=CMD_STOP THEN
                            (* Proceed to see what to do *)
                            vnProd_PostSts := POST_SEE_GENERIC;
                        END_IF;
                    ELSE
                        dlog( Txt:='fbStepSeq: !! Prod: Cannot close grabber', Lvl:=1 );
                        SET_MSG(MSG_NOTPARKED,'MSG_NOTPARKED: Grabber',0);
                        IF vnProd_Id<0 THEN
                            (* Ho ruotato per tagliare *)
                            (* Richiedo intervento operatore per procedere al riscontro *)
                            SET_MSG(REQ_DOALIGN,'REQ_DOALIGN',0);
                        ELSE
                            (* Ho ruotato per riorientare *)
                        END_IF;
                        Status := STSEQ_STOP; (* Mah, per sicurezza abortisco *)
                    END_IF;
                END_IF; (* Command terminated *)

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_ROTATE_REQ : (* Requesting operator to rotate prod manually (REQ_ROTATEBYHAND) *)
                IF vnAlgn_DeliverCmd=CMD_STOP AND NOT IS_MSG(REQ_ROTATEBYHAND) THEN
                    (* Prodotto ruotato *)
                    vnCarriages_Seq := SEQ_START; (* Evito di forzare un parcheggio allo start *)
                    dlog( Txt:='fbStepSeq: Prod: Rotated by hand', Lvl:=4 );
                    vnProd_PostSts := 0;
                    Status := STSEQ_STOP; (* Meglio abortire, non so dove è la lastra *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_REMOVE_REQ : (* Requesting operator to remove prod manually *)
                IF NOT IS_MSG(REQ_TAKE_PROD) AND NOT IS_MSG(REQ_DUMP_PROD) THEN
                    (* Prodotto prelevato *)
                    dlog( Txt:='fbStepSeq: Prod: Removed by hand', Lvl:=4 );
                    vnPieceTaken := SEL( vnProd_Id>0, 0, vnProd_Id );
                    vnProd_PostSts := 0;
                    (* Status := STSEQ_STOP; (* TODO 1: meglio abortire? *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_SEE_GENERIC : (* What to do with a product in a generic position ex. undetached *)
                (* Devo riallineare il bordo indietro a zero?
                   Se il riscontro ha le cinghie (e non devo riorientare) può darsi
                   che non sia necessario portare il bordo indietro a zero *)
                IF vbFeat_AlgnHasBelts AND (NOT Prod_MustReor OR Prod_Reoriented) THEN
                    (* Pezzi quasi trasportabili con le cinghie a parte una piccola spintarella con lo stacco.
                       Di quanto posso portarlo avanti dipende dalla situazione:
                       .Se posso pinzare il vetro subito dove sono: D=Xs.PosLim - Xs.CurrPos
                       .Se devo spostarmi per pinzarlo: D=Xs.PosLim - (Xbck+grab-margin)
                       .Se lo spingo senza pinzarlo: D=Xs.PosLim - Xbck *)

                    IF Prod_Reoriented THEN
                        (* Prodotto riorientato: le dimensioni sono scambiate *)
                        vqShift_GlassWidth := vqCut_Length; (* vqCut_Height *)
                        vqShift_GlassYbtm := vqYo_SheetFeed; (* Assumo che la pinza l'abbia portato qui *)
                        vqShift_GlassYtop := vqShift_GlassYbtm + vqProd_Width;
                    ELSE
                        (* Prodotto non riorientato *)
                        vqShift_GlassWidth := vqProd_Width;
                        vqShift_GlassYbtm := vqY_BtmEdge;
                        vqShift_GlassYtop := vqY_TopEdge;
                    END_IF;

                    (* Massimo spostamento avanti con stacco: *)
                    x := vqProd_X - vqShift_GlassWidth; (* Posizione bordo indietro *)
                    IF x<(vqDtch_CurrX-vqDtch_GrabMinWidth) THEN
                        (* Il vetro è direttamente pinzabile dove sono *)
                        delta := vq[ivqAx_PosLim+AX_XS-1]-1E3 - vqDtch_CurrX;
                    ELSIF x<vqDtch_CurrX THEN
                        (* È sotto il premilastra ma non immediatamente pinzabile, pinzerò al doppio del margine minimo *)
                        delta := vq[ivqAx_PosLim+AX_XS-1]-1E3 - x - 2*vqDtch_GrabMinWidth;
                    ELSE
                        (* Lo spingerò in avanti *)
                        delta := vq[ivqAx_PosLim+AX_XS-1]-1E3 - x;
                    END_IF;

                    IF (vqShift_GlassWidth/2)>vqBeltsAlgn_MinGripDX AND (* Abbastanza largo per essere preso dalle cinghie riscontro *)
                       (* (vqShift_GlassWidth/2)>(vqProd_X-vqX_AlgnBeltsBegin) AND (* Il baricentro è fuori dalle cinghie riscontro *)
                       fnInRange_DINT(vqShift_GlassWidth/2 - (vqProd_X-vqX_AlgnBeltsBegin),0,delta) AND (* Il baricentro è fuori dalle cinghie riscontro ma non di tanto *)
                       x>(vqDtch_CurrX+vqDtchBelts_Dx) AND (* Non appoggio alle cinghie stacco *)
                       vnDtch_Type=2 THEN (* Stacco motorizzato *)
                        (* Porto avanti il prodotto con lo stacco *)
                        vqDtch_GlassWidth := vqShift_GlassWidth;
                        vqDtch_GlassXbck := x; (* Il bordo indietro del vetro *)
                        vqDtch_Tgt := vqDtch_GlassXbck + delta; (* Bordo indietro più avanti possibile *)
                        vnDtch_Cmd := DTCMD_MOVEGLASS;
                        vnProd_PostSts := POST_DRAG_TOALGN;
                    ELSIF (vqProd_X-vqX_AlgnBeltsBegin)>=MAX(vqBeltsAlgn_MinGripDX,vqShift_GlassWidth/2) THEN (* C'è grip e il peso è sulle cinghie riscontro *)
                        (* Se fosse abbastanza alto potrebbe essere consegnato a fine linea
                           direttamente con le cinghie, altrimenti dovrò usare i riscontri *)
                        Shiftable( iY:=ivqBeltsAlgn_Y, N:=vnBeltsAlgn_N, W:=vqBeltsAlgn_Size,
                                   ybtm:=vqShift_GlassYbtm, ytop:=vqShift_GlassYtop );
                        vnProd_PostSts := SEL(Shiftable.q, POST_EDGE_ATZERO, POST_PREP_DELIVER);
                    ELSE
                        (* Prima di consegnare assicuro bordo indietro a zero (probabilmente aggancerò coi riscontri) *)
                        vnProd_PostSts := POST_EDGE_ATZERO;
                    END_IF;
                ELSE
                    (* Non ci sono le cinghie riscontro oppure devo riorientare *)
                    (* Prima di proseguire assicuro bordo indietro a zero *)
                    vnProd_PostSts := POST_EDGE_ATZERO;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_WAIT_TOABORT : (* Wait other to finish before give a stop *)
                IF (vnRemn_PostSts=0 OR vnRemn_PostSts=POST_WAIT_TOABORT)
                   AND NOT IS_MSG(REQ_WORK_SHAPE) THEN (* Attendi reset richieste prima di proseguire *)
                    dlog( Txt:='fbStepSeq: !! Prod: Aborting', Lvl:=1 );
                    Status := STSEQ_STOP;
                END_IF;

        END_CASE; (* -- Post-movimentazione prodotto *)

        (* -- Monitor stato movimentazione rimanenza -- *)
        CASE vnRemn_PostSts OF
            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_DUMPING : (* Dumping/giving the remnant (vnShift_DumpSeq) *)
                (* Sequenza di espulsione rimanenza (cassone o prelievo da stacco)
                   .Gestisce stato 'vqRemn_X'
                   .Alla fine porta sempre lo stacco in parcheggio
                   .Se non è buttabile, sposta un po' indietro e basta
                   .In caso di errore lancia 'REQ_TAKE_REMN','REQ_DUMP_REMN' *)
                IF NOT vbShift_DumpRemn THEN
                    (* Sequenza eseguita *)
                    IF vnShift_DumpSeq=SEQ_DONE THEN
                        vnRemn_PostSts := 0;
                    ELSE
                        vnRemn_PostSts := POST_REMOVE_REQ;
                        (* Anticipo il segnale di schema eseguito *)
                        IF vbAutoMode AND vbLastStep THEN vbSchemeDone := TRUE; END_IF;
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_BACK_LITTLE : (* Shifting back remn to free the cut zone (vnShift_Seq) *)
                IF vnShift_Cmd=0 THEN
                    IF vnShift_Seq=SEQ_DONE THEN
                        vqRemn_X := SEL(vqShift_GlassX<0, vqRemn_XfreeDtch, vqShift_GlassX);
                        dlog( Txt:='fbStepSeq: Remn: Placed in %ld (vqRemn_XfreeDtch=%ld)', Lvl:=4, Val1:=vqRemn_X/1E3, Val2:=vqRemn_XfreeDtch/1E3 );

                        IF vnRemn_Id<0 THEN
                            (* La rimanenza è la sottolastra che sarà processata nel passo successivo: *)
                            vqSubSheet_X := vqRemn_X;
                            vqSubSheet_Y := vqY_BtmEdge;
                            vnRemn_PostSts := 0; (* Fatto *)
                        ELSE
                            (* È un pezzo o uno scarto *)
                            (* Una possibilità è richiedere che venga prelevata a mano
                            IF vnRemn_Id=0 THEN SET_MSG(REQ_DUMP_REMN,'REQ_DUMP_REMN',0);
                                           ELSE SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0); END_IF;
                            vnRemn_PostSts := POST_REMOVE_REQ; *)

                            (* Manderò la rimanenza a fine linea,
                               la voglio posizionare sui riscontri in modo che sia agganciabile/riorientabile *)
                            vnRemn_PostSts := POST_WAIT_TOPASS;
                        END_IF;
                    ELSE
                        (* Non sono riuscito a liberare la fotocellula di stacco? *)
                        dlog( Txt:='fbStepSeq: !! Remn: Cannot free cut zone', Lvl:=1 );

                        (* Se lo stacco è avanti, lo parcheggio *)
                        IF NOT vb[ivbAtRest+ID_DTCH] THEN
                            dlog( Txt:='! Parking Dtch (%d)', Lvl:=5, Val1:=TO_DINT(vnDtch_Cmd) );
                            vnDtch_Cmd := CMD_PARK;
                        END_IF;

                        IF vnRemn_Id<0 THEN
                            (* La rimanenza deve essere ancora processata *)
                            SET_MSG(REQ_BACK_REMN,'REQ_BACK_REMN',0);
                            vnRemn_PostSts := POST_BACK_REQ;
                            (* Status := STSEQ_STOP; (* Abortisco tutto? Nah *)
                        ELSE
                            (* La rimanenza è un pezzo o uno scarto non movimentabile, quindi va tolta *)
                            IF vnRemn_Id=0 THEN SET_MSG(REQ_DUMP_REMN,'REQ_DUMP_REMN',0);
                                           ELSE SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0); END_IF;
                            vnRemn_PostSts := POST_REMOVE_REQ;
                        END_IF;
                    END_IF;
                ELSIF vnShift_Cmd=SHFCMD_BACK_REMN THEN
                    vqRemn_X := vqShift_GlassX; (* Monitora movimento rimanenza *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_BACK_INS : (* Inserting remn in feed table (vnShift_Seq) *)
                IF vnShift_Cmd=CMD_STOP THEN
                    (* Sequenza di accumulo/parcheggio rimanenza completata *)
                    IF vnShift_Seq=SEQ_DONE THEN
                        (* Un piccolo controllo *)
                        IF vnBuf_Type<>0 AND vqRemn_X>(vqXph_FeedEnd-vqBelts_StackDist) THEN
                            dlog( Txt:='fbStepSeq: Remn: ! Not fully inserted? (%ld mm)', Lvl:=3, Val1:=vqRemn_X/1E3 );
                        ELSE
                            dlog( Txt:='fbStepSeq: Remn: Inserted back (%ld mm)', Lvl:=3, Val1:=vqRemn_X/1E3 );
                        END_IF;

                        vqRemn_X := NO_POS_UM; (* Rimanenza inserita *)
                    ELSE (* vnShift_Seq=SEQ_ERROR *)
                        (* Fallita inserzione rimanenza! *)
                        dlog( Txt:='fbStepSeq: Remn: !! Remn: Ins error (%ld mm)', Lvl:=1, Val1:=vqRemn_X/1E3 );
                        SET_MSG(REQ_STACK_REMN,'REQ_STACK_REMN',0);
                        (* Le ragioni: IS_MSG(REQ_STACKFULL) OR IS_MSG(REQ_STACKBACK) OR IS_MSG(REQ_STACK_REMN) *)
                        (* Vedo se abortire o meno (siamo a fine passo, quindi non è un problemone)
                           Meglio abortire se:
                             -Non ho liberato la zona processazione
                             -C'è il polmone e non ho liberato il polmone *)
                        IF vqRemn_X>vqProcArea_Xmin OR (vnBuf_Type<>0 AND vqRemn_X>vqXph_FeedEnd) THEN
                            (* Meglio abortire *)
                            (* Devo abortire subito o posso far terminare le post-movimentazioni al prodotto? *)
                            (* Fermo subito solo se c'è una rotazione in corso con pericolo di collisione *)
                            IF vnCarriages_Cmd=CARCMD_GRAB AND (* vnProd_PostSts=POST_ROTATE_REQ *)
                               vqRemn_X>vqProcArea_Xmin THEN
                                Status := STSEQ_STOP; (* Abortisco il passo *)
                                vnCarriages_Cmd := CMD_STOP; (* Redundant *)
                                SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                            ELSE
                                (* Abortisco il passo dopo le post-movimentazioni prodotto *)
                                vnRemn_PostSts := POST_WAIT_TOABORT;
                            END_IF;
                        ELSE
                            (* Mah, la prossima inserzione potrebbe avere problemi... *)
                            dlog( Txt:='fbStepSeq: Remn: !! Not fully inserted (%ld mm)', Lvl:=3, Val1:=vqRemn_X/1E3 );
                            (* ...Però vado avanti *)
                            vnRemn_PostSts := 0;
                        END_IF;
                    END_IF;
                (* Monitora movimento rimanenza *)
                ELSIF vnShift_Cmd=SHFCMD_INS_REMN THEN
                    vqRemn_X := vqShift_GlassX;
                END_IF;

                (* -Rileva rimanenza inserita- *)
                IF vqRemn_X=NO_POS_UM OR vqRemn_X<vqProcArea_Xmin THEN
                    (* Considero rimanenza parcheggiata del tutto *)
                    vnRemn_PostSts := 0;

                    (* Se è un pezzo o uno scarto, lo sto accumulando
                       temporaneamente per poi evacuarlo a fine linea al
                       completamento della processazione del prodotto *)
                    IF vnRemn_Id>=0 THEN
                        (* Tengo traccia che è stato accumulato temporaneamente un pezzo/scarto *)
                        i_TmpStacked.Sheet.Width := vqShift_GlassWidth;
                        i_TmpStacked.Sheet.Height := vqShift_GlassYtop - vqShift_GlassYbtm;
                        i_TmpStacked.Sheet.Id := vnRemn_Id;
                        i_TmpStacked( Push:=TRUE );
                        dlog( Txt:='fbStepSeq: << Inserted tmp %ldx%ld Id=%d', Lvl:=2, Val1:=i_TmpStacked.Sheet.Width/1E3, Val2:=i_TmpStacked.Sheet.Height/1E3, Val3:=TO_DINT(i_TmpStacked.Sheet.Id) );
                    ELSE
                        (* Mi ricordo della posizione Y dell'ultima lastra inserita *)
                        vqInsSheet_Y := vqShift_GlassYbtm;
                    END_IF; (* Pezzo o scarto *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_BACK_REQ : (* Requesting operator to move back the remnant *)
                IF NOT IS_MSG(REQ_BACK_REMN) THEN
                    (* Una ridondante sicurezza *)
                    IF fcDtchLast.q THEN
                        SET_MSG(REQ_BACK_REMN,'REQ_BACK_REMN',0);
                    ELSE
                        (* Rimanenza indietreggiata a mano *)
                        dlog( Txt:='fbStepSeq: Remn: Backed by hand (%ld)', Lvl:=4, Val1:=vqRemn_X/1E3 );
                        IF vnRemn_Id<0 THEN
                            (* La rimanenza è la sottolastra che sarà processata nel passo successivo: *)
                            vqSubSheet_X := vqRemn_X;
                            vqSubSheet_Y := vqY_BtmEdge;
                        END_IF;
                        vnRemn_PostSts := 0; (* Fatto *)
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_WAIT_TOPASS : (* Waiting conditions to pass the remnant to align module *)
                IF vnProd_PostSts=POST_WAIT_TOABORT THEN
                    vnRemn_PostSts := POST_REMOVE_REQ;
                ELSIF vnShift_Cmd=CMD_STOP AND vqOutZone_Xbusy>vqX_AlgnBeltsEnd AND
                   (vnProd_PostSts=0 OR (vnProd_PostSts=POST_DELIVERING AND vbAlgnDlvr_AlmostDone)) THEN
                    (* Preparo per mandare la rimanenza a fine linea,
                       la voglio posizionare sui riscontri in modo che sia agganciabile *)
                    (* Nota: Questo fa partire una sequenza di traslazione, nel frattempo su riscontro il
                             prodotto è tipicamente in fase di evacuazione a fine linea o in riorientazione *)
                    dlog( Txt:='fbStepSeq: Remn: Pass to Algn', Lvl:=5 );
                    vqShift_GlassWidth := vqRemn_Width;
                    vqShift_GlassYbtm := vqY_BtmEdge;
                    vqShift_GlassYtop := vqY_TopEdge; (* dichiarata: vqY_BtmEdge + vqCut_Height *)
                    vqShift_GlassX := vqRemn_X; (* L'ho mandata dietro la fotocellula di stacco *)
                    (* Posiziono bordo indietro a zero, più un certo margine per essere sicuro di agganciarlo *)
                    vqShift_TargetX := vqRemn_Width + vqShift_DragPosTol + vqAlgn_DragForeMargin;
                    vqShift_TargetTol := vqShift_DragPosTol;
                    vnShift_Cmd := SHFCMD_FORW_ONALGN;

                    vnRemn_PostSts := POST_SHIFT_TOALGN;
                (* ELSE SET_MSG(MSG_OUTZONE_BUSY,'MSG_OUTZONE_BUSY',vqOutZone_Xbusy); *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_SHIFT_TOALGN : (* Shifting remn to align side (vnShift_Seq) *)
                (* Questo è il movimento per poi portarla a fine linea
                   Nota: in questa condizione il prodotto è sempre anch'esso da evacuare *)
                IF vnShift_Cmd=CMD_STOP THEN
                    (* Sequenza terminata, vedi risultato *)
                    IF vnShift_Seq=SEQ_DONE THEN
                        (* vnShift_Cmd=SHFCMD_FORW_ONALGN, vnShift_Cmd<>CMD_STOP, vn[ivnStatus+ID_SHIFT]=SHF_IDLE *)
                        (* vqRemn_X := vqShift_TargetX; *)
                        dlog( Txt:='fbStepSeq: Remn passed (%ld)', Lvl:=4, Val1:=vqShift_TargetX/1E3 );
                        (* Adesso saremmo pronti per agganciarla, lancierò la sequenza
                           di trascinamento solo quando il prodotto è stato evacuato *)
                        vnRemn_PostSts := POST_PREP_DELIVER;
                    ELSE
                        (* Non è riuscito a portare la rimanenza di là! *)
                        dlog( Txt:='fbStepSeq: !! Remn: Cannot pass to align', Lvl:=1 );
                        (* Potrei fallire subito: *)
                        (* IF vnRemn_Id=0 THEN SET_MSG(REQ_DUMP_REMN,'REQ_DUMP_REMN',0);
                                          ELSE SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0); END_IF;
                        vnRemn_PostSts := POST_REMOVE_REQ; *)
                        (* Oppure, meglio, sposto opportunamente la rimanenza: *)
                        vbShift_DumpRemn := TRUE; (* Nota: Alzerà 'REQ_TAKE_REMN','REQ_DUMP_REMN' *)
                        vnRemn_PostSts := POST_DUMPING;
                    END_IF;
                (* ELSE
                    vqRemn_X := vqShift_GlassX; (* Monitora movimento *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_PREP_DELIVER : (* Prepare to bring remn to line end *)
                (* Procedo a portarla a valle.
                   Nota: Se devo ruotarla o agganciarla coi riscontri
                         il bordo indietro deve essere a zero! *)
                (* IF Remn_MustReor THEN ... *)
                (* Se contiene una sagoma da lavorare, la lascio dov'è *)
                IF vbRemn_HasShape AND (vqWorkSettings & BIT_STOPONSHAPE)<>0 THEN
                    dlog( Txt:='fbStepSeq: ! Remn has shape', Lvl:=2 );
                    SET_MSG(REQ_WORK_SHAPE,'REQ_WORK_SHAPE',0);
                    vnRemn_PostSts := POST_WAIT_TOABORT;
                ELSE
                    vnRemn_PostSts := POST_WAIT_DELIVER;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_WAIT_DELIVER : (* Waiting product delivered *)
                (* Voglio portarla a fine linea agganciandola coi riscontri *)
                (* Attendo prodotto a "posto", ossia:
                     .Post-movimenti prodotto conclusi
                     .Eventuale precedente trascinamento avanti concluso
                     .Se tavolo a valle, voglio aver prima evacuato *)
                IF vnProd_PostSts=POST_WAIT_TOABORT THEN
                    vnRemn_PostSts := POST_REMOVE_REQ;
                ELSIF vnProd_PostSts=0 AND vnAlgn_DeliverCmd=CMD_STOP THEN
                    dlog( Txt:='fbStepSeq: Remn: Delivering', Lvl:=4 );

                    (* Sequenza emissione a fine linea mediante trascinamento con i piedini
                       di riscontro, in caso di errore alza 'REQ_TAKE_PROD', 'REQ_DUMP_PROD' *)
                    vnAlgnDlvr_Id := vnRemn_Id;
                    vbAlgnDlvr_Prescored := vbRemn_Prescored;
                    vqAlgnDlvr_Xbck := 0; (* vqRemn_X - vqRemn_Width *)
                    vqAlgnDlvr_Width := vqRemn_Width;
                    vqAlgnDlvr_Ybtm := vqY_BtmEdge;
                    vqAlgnDlvr_Ytop := vqY_TopEdge;
                    vqAlgnDlvr_Tgt := vqX_OutZoneEnd; (* TODO 4: La quota di arrivo dipende da cosa c'è a valle *)
                    vnAlgn_DeliverCmd := DLVCMD_END;

                    vnRemn_PostSts := POST_DELIVERING;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_DELIVERING : (* Moving remn to line end *)
                (* Sequenza emissione rimanenza a fine linea
                   .Attende la liberazione della zona a fine linea
                   .In caso di errore alza 'REQ_TAKE_PROD', 'REQ_DUMP_PROD' *)
                IF vbStep_EarlyStart AND vbAlgnDlvr_AlmostDone AND vqAlgnDlvr_Xbck>vqNextStep_FirstAlgn THEN
                    (* La zona per riscontrare è libera, trascinamento in corso *)
                    (* Se non libererà i trasportatori riscontro mi assicuro di non far partire lo step successivo *)
                    IF vqAlgnDlvr_Width >= (vqX_OutZoneEnd-vqX_AlgnBeltsEnd) THEN
                        dlog( Txt:='fbStepSeq: Remn: Will be on Rolls', Lvl:=4 );
                        vnPieceDelivering := vnRemn_Id; (* see: vnPieceTaken *)
                        vnRemn_PostSts := POST_REMOVE_REQ;
                    ELSE
                        dlog( Txt:='fbStepSeq: Remn: Next (bck=%ld mm)', Lvl:=4, Val1:=vqAlgnDlvr_Xbck/1E3);
                        vnRemn_PostSts := 0;
                    END_IF;
                ELSIF vnAlgn_DeliverCmd=CMD_STOP THEN
                    (* Sequenza terminata, vediamo il risultato *)
                    IF vnAlgn_DeliverSeq=SEQ_DONE THEN
                        (* Rimanenza consegnata *)
                        dlog( Txt:='fbStepSeq: Remn: Delivered', Lvl:=4 );
                        vnRemn_PostSts := 0;
                        (* Se non ha liberato i trasportatori riscontro... *)
                        IF vqAlgnDlvr_Xbck <= vqX_AlgnBeltsEnd THEN (* OR fcOutzoneBegin.q *)
                            dlog( Txt:='fbStepSeq: Remn: ! On Rolls', Lvl:=4 );
                        END_IF;
                    ELSE
                        (* Consegna fallita, va prelevato a mano dai riscontri *)
                        dlog( Txt:='fbStepSeq: Remn: Must be removed', Lvl:=4 );
                        (* Nota: 'REQ_TAKE_PROD', 'REQ_DUMP_PROD' già alzati *)
                        vnRemn_PostSts := POST_REMOVE_REQ;
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_REMOVE_REQ : (* Requesting operator to remove remn manually *)
                IF NOT IS_MSG(REQ_TAKE_REMN) AND NOT IS_MSG(REQ_DUMP_REMN) AND
                   NOT IS_MSG(REQ_TAKE_PROD) AND NOT IS_MSG(REQ_DUMP_PROD) THEN
                    (* Rimanenza tolta *)
                    dlog( Txt:='fbStepSeq: Remn: Removed by hand', Lvl:=4 );
                    vnPieceTaken := SEL( vnRemn_Id>0, 0, vnRemn_Id );
                    vnRemn_PostSts := 0;

                    (* Se lo stacco è avanti, lo parcheggio *)
                    IF NOT vb[ivbAtRest+ID_DTCH] THEN
                        (* dlog( Txt:='! Parking Dtch (%d)', Lvl:=5, Val1:=TO_DINT(vnDtch_Cmd) ); *)
                        vnDtch_Cmd := CMD_PARK;
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_WAIT_STRIPE : (* Waiting previous stripe out before shift remn to line-end *)
                IF vnProd_PostSts=POST_WAIT_TOABORT THEN
                    vnRemn_PostSts := POST_REMOVE_REQ;
                ELSIF vnProd_PostSts=0 THEN
                    (* Mando avanti la rimanenza *)
                    dlog( Txt:='fbStepSeq: Shifting Remn stripe to align', Lvl:=4 );
                    vqShift_GlassWidth := vqRemn_Width;
                    vqShift_GlassYbtm := vqY_BtmEdge;
                    vqShift_GlassYtop := vqY_TopEdge; (* dichiarata: vqShift_GlassYbtm + vqCut_Height *)
                    vqShift_GlassX := vqRemn_X;
                    vqShift_TargetX := vqRemn_Width;
                    (* Se non dovrò agganciarlo coi riscontri, come ad esempio
                       quando sto troncando un monolitico, posso evitare l'errore
                       di quota non raggiungibile e muovere quanto posso: *)
                    IF vqShift_TargetX>vqX_OutZoneEnd AND vbFloatStripesBreak THEN
                        dlog( Txt:='fbStepSeq: ! Sheet too wide (%ld) wont cross x=0', Lvl:=3, Val1:=vqShift_TargetX/1E3, Val2:=vqX_OutZoneEnd/1E3 );
                        vqShift_TargetX := vqX_OutZoneEnd;
                    END_IF;

                    vqShift_TargetTol := vqShift_DragPosTol;
                    vnShift_Cmd := SHFCMD_FORW_ONALGN;

                    vnRemn_PostSts := POST_MOVE_STRIPE;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_MOVE_STRIPE : (* Shifting big remn to align/line-end *)
                IF vnShift_Cmd=CMD_STOP THEN
                    IF vnShift_Seq=SEQ_DONE THEN
                        (* dlog( Txt:='fbStepSeq: Remn stripe shifted to align module', Lvl:=4 ); *)
                        SET_MSG(REQ_TAKE_PROD,'REQ_TAKE_PROD',0);
                        vnRemn_PostSts := POST_REMOVE_REQ;
                    ELSE
                        (* Non è riuscito a portare la rimanenza di là! *)
                        SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0);
                        vnRemn_PostSts := POST_REMOVE_REQ;
                    END_IF;
                (* ELSE *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            POST_WAIT_TOABORT : (* Wait other to finish before give a stop *)
                IF (vnProd_PostSts=0 OR vnProd_PostSts=POST_WAIT_TOABORT)
                   AND NOT IS_MSG(REQ_WORK_SHAPE) THEN (* Attendi reset richieste prima di proseguire *)
                    dlog( Txt:='fbStepSeq: !! Remn: Aborting', Lvl:=1 );
                    Status := STSEQ_STOP;
                END_IF;

        END_CASE; (* -- Post-movimentazione rimanenza *)

	    (* Forzo uscita se si preme lo stop *)
        IF Abort THEN
            dlog( Txt:='fbStepSeq: !! Abort post-ops', Lvl:=2 );
            Status := STSEQ_STOP;
	        (* Nota: lo stop alle sequenze è gestito direttamente nelle stesse *)
        END_IF;

        (* -- Intercetta abort per errore irreversibile -- *)
        IF Status=STSEQ_STOP THEN
            (* Post-operazioni non completate *)
            dlog( Txt:='fbStepSeq: !! Step %d post-ops aborted (sts=%d,%d)', Lvl:=2, Val1:=TO_DINT(vnStepIndex), Val2:=TO_DINT(vnProd_PostSts), Val3:=TO_DINT(vnRemn_PostSts) );
            vnProd_PostSts := 0;
            vnRemn_PostSts := 0;

            (* Decidiamo se rimanere nel passo di lavorazione corrente oppure caricare il successivo *)
            IF (vbProd_HasShape OR vbRemn_HasShape) OR (IS_MSG(REQ_ROTATEBYHAND) AND NOT vbStep_AlwaysNext) THEN
                (* Rimaniamo nello step attuale in modo da avere la
                   possibilità di riprendere le post-movimentazioni *)
                dlog( Txt:='Remaining', Lvl:=4 );
            ELSE
                (* Carico il passo successivo e lascio che l'operatore completi
                   a mano le post-movimentazioni *)
                IF vbAutoMode THEN
                    dlog( Txt:='Selecting next', Lvl:=4 );
                    (* Mi assicuro di invalidare la posizione in eredità al passo successivo *)
                    vqSubSheet_X := NO_POS_UM; (* Post-ops abort *)
                    vqSubSheet_Y := NO_POS_UM;
                    JobData( Cmd:=BIT_NXTSTEP ); (* Get next step (auto mode) *)
                END_IF;
            END_IF;
        (* -- Abbiamo finito? (possiamo partire col passo successivo?) -- *)
        ELSIF vnProd_PostSts=0 AND vnRemn_PostSts=0 THEN
            (* Post-taglio terminato, proseguo col passo successivo *)
            dlog( Txt:='fbStepSeq: Step %d post-ops done', Lvl:=4, Val1:=TO_DINT(vnStepIndex) );
            Status := STSEQ_DONE;
        END_IF;



    (* ------------------------------------------------------------------- *)
    STSEQ_STARTPOST : (* Preparing step post-cut movements *)
        dlog( Txt:='fbStepSeq: >> Step %d.%d post-ops', Lvl:=3, Val1:=TO_DINT(vnSchemeIndex), Val2:=TO_DINT(JobData.Scheme.CurStep) );
        (* IF NOT vbAutoMode THEN dlog( Txt:='!! Not in auto mode', Lvl:=3 ); END_IF; *)

        (* Ora si presentano i seguenti casi, in ordine di probabilità:
            .Rotaz prodotto e Park rimanenza (prodotto da tagliare e rimanenza da tagliare)
            .Rotaz prodotto e Dump rimanenza (prodotto da tagliare e rimanenza scarto)
            .Emissione prodotto (prodotto pezzo finito o grosso scarto e rimanenza da tagliare)
            .Emissione prodotto + rimanenza (prodotto e rimanenza pezzo finito o grosso scarto)
            .Emissione prodotto e Dump rimanenza (prodotto pezzo finito o grosso scarto e rimanenza scarto)
            .Park rimanenza (prodotto da tagliare e rimanenza da tagliare)

           Quindi sostanzialmente da qui partono le sequenze per:
             .Rimanenza
                1) Accumulo su carico
                2) Prelievo/espulsione lato stacco
                3) Prelievo/evacuazione fine linea
             .Prodotto
                1) Rotazione lato riscontro
                2) Prelievo/evacuazione fine linea      *)

        (* Default: non so dove sarà la prossima sottolastra da processare *)
        vqSubSheet_X := NO_POS_UM; (* Starting post-ops *)
        vqSubSheet_Y := NO_POS_UM;
        (* Inizializzo i miei stati interni, default: done/none *)
        vnProd_PostSts := 0;
        vnRemn_PostSts := 0;
        (* Riorientazione pezzi/sottolastre in uscita *)
        Prod_MustReor := FALSE;
        Remn_MustReor := FALSE;
        Prod_Reoriented := FALSE;
        Remn_Reoriented := FALSE;

        (* Visto che ormai ho tagliato, ora mi interessa l'area di
           processazione del prossimo taglio, occhio a non confonderti! *)
        vqProcArea_Xmin := vqNextProcArea_Xmin;

        (* Anzitutto vedo se ho prodotto e rimanenza (la lastra è stata separata?) *)
        IF vbDetachDone THEN

            (* Prodotto
                 vqProd_Width, vdProd_Mass, vdProd_Jm
                 vqProd_MoveInfo, vnProd_Id, vnProd_From, vnProd_To, vnProd_Rot

               Rimanenza
                 vqRemn_Width, vdRemn_Mass, vdRemn_Jm
                 vqRemn_MoveInfo, vnRemn_Id, vnRemn_From, vnRemn_To, vnRemn_Rot *)

            (* Posizione di prodotto e rimanenza 'vqProd_X', 'vqRemn_X'
            Non vanno assegnati qui perché potrebbero essere stati già
            aggiornati/movimentati in caso di ripresa dell'esecuzione
            del passo. Vedi 'Detach-*.src' e STSEQ_CUT *)

            (* Vediamo cosa devo fare *)
            (* Se troncaggio traversi monolitico mi fermo qui, le post-movimentazioni
               rischiano di aprirmi il vetro; potrei tenere accesi i ventilatori riscontro *)
            IF vbFloatStripesBreak THEN
                dlog( Txt:='! Float stripes brk: Take Prod by hand', Lvl:=3 );
                (* Richiedo comunque di rimuovere il prodotto *)
                SET_MSG(REQ_TAKE_PROD,'REQ_TAKE_PROD',0);
                vnProd_PostSts := POST_REMOVE_REQ;
                (* La rimanenza *)
                IF vnRemn_To=ZONE_OUT THEN
                    (* Se la rimanenza è da evacuare, lo facciamo appena tolto il prodotto *)
                    (* dlog( Txt:='fbStepSeq: Remn %ldx%ld out-fwd', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqRemn_Height/1E3 ); *)
                    (* Attendi che il prodotto sia stato preso, poi passa avanti anche la rimanenza *)
                    vnRemn_PostSts := POST_WAIT_STRIPE;
                ELSE
                    (* Se la rimanenza non deve essere evacuata probabilmente conterrà
                       dei traversi, essa è la prossima sottolastra da processare: *)
                    (* vnRemn_PostSts := 0; (* Già così *)
                    vqSubSheet_X := 0;
                    vqSubSheet_Y := vqY_BtmEdge;
                END_IF;

            (* Se il prodotto deve essere ulteriormente processato,
               la rimanenza va o accumulata o prelevata dallo stacco *)
            ELSIF vnProd_Id<0 AND vnProd_To=0 THEN
                (* -Il prodotto va processato-
                    Va ruotato o riposizionato
                    La rimanenza deve in ogni caso andare indietro (inserzione o espulsione) *)
                dlog( Txt:='Prod %ldx%ld in %ld must be processed', Lvl:=4, Val1:=vqProd_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqProd_X/1E3 );
                (* Quindi la prossima sottolastra da processare ora è qui: *)
                vqSubSheet_X := vqProd_Width;
                vqSubSheet_Y := vqY_BtmEdge;

                IF vnProd_Rot=-1 THEN
                    (* Il prodotto va ruotato di -90° *)
                    dlog( Txt:='Prod must rotate', Lvl:=3 );

                    vnProd_PostSts := POST_ROTATE_REQ; (* Default: richiedo rotazione manuale *)

                    IF (vqWorkSettings & BIT_ENABGRABBER)<>0 THEN
                        (* Faccio partire la sequenza di rotazione prodotto
                           (rotaz lato riscontro +90°) *)
                        vqGrab_GlassWidth := vqProd_Width;
                        vqGrab_GlassYbtm := vqY_BtmEdge; (* Assumo lastra già misurata in Y *)
                        vqGrab_GlassYtop := vqY_TopEdge;
                        vqGrab_Agrab := 0; (* [mdeg] *)
                        vqGrab_Arot := 90E3; (* [mdeg] *)
                        vqGrab_Ygrab := NO_POS_UM; (* Il punto di presa sarà scelto opportunamente *)
                        (* Calcolo rotazione e valuto fattibilità *)
                        CalcRotAlgn( What:=ROTARG_PROD );  (* Prodotto *)
                        IF CalcRotAlgn.Ok THEN
                            (* A seconda del tipo di girapezzi *)
                            IF vnGrabber_Type=1 THEN
                                (* Ventosa, probabilmente su ActiveF *)
                                (* La sequenza è implementata in un programma CNC *)
                                MoveSeq( Execute:=NOT Abort );
                                vnProd_PostSts := POST_ROTATING_PRG;
                            ELSE
                                (* Ruoteremo tramite sequenza PLC carrelli, probabilmente pinza se presente *)
                                (* Procediamo con la rotazione *)
                                (* Nota: Questa sequenza attenderà 'vqRemn_X=NO_POS_UM' e richieste *)
                                vnCarriages_Cmd := CARCMD_GRAB;
                                vnProd_PostSts := POST_ROTATING;

                                (* Mi premuro di aggiornare l'area che la rimanenza deve liberare
                                   tenendo conto dell'area necessaria alla rotazione del prodotto
                                   Non considero 'vqNextProcArea_Xmin' perché tanto le lastre
                                   vengono traslate insieme *)
                                (* vqProcArea_Xmin := MIN( vqNextProcArea_Xmin, vqRot_Xmin ); *)
                                (* TODO 1: Margine aggiuntivo, è molto attaccato! Per ora tolgo di nuovo vqBelts_StackDist *)
                                vqProcArea_Xmin := vqRot_Xmin - vqProc_AlgnDelta - vqBelts_StackDist;
                                (* Nota: È bene considerare anche lo spazio di riscontro,
                                         perché la lastra accumulata rimane ferma mentre
                                         quella avanti è spinta indietro *)
                            END_IF;
                        (* ELSE (* Prodotto non ruotabile *)
                        END_IF;
                    ELSE
                        dlog( Txt:='! Rot disabled', Lvl:=4 );
                    END_IF;

                    (* Se prodotto non ruotabile, lo porto fuori e alzo la richiesta *)
                    IF vnProd_PostSts=POST_ROTATE_REQ THEN
                        SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);

                        (* Se rotazione non fattibile aggancio il vetro coi riscontri e
                           lo sposto sul tavolo, questa operazione è utile anche in caso
                           di prodotto stretto che cade, per ora pinzato col premilastra *)
                        (* dlog( Txt:='fbStepSeq: Aggancio e porto fuori prodotto non ruotato', Lvl:=3 ); *)
                        IF vnAlgn_DeliverCmd=CMD_STOP THEN
                            vnAlgnDlvr_Id := vnProd_Id;
                            vbAlgnDlvr_Prescored := vbProd_Prescored;
                            vqAlgnDlvr_Xbck := 0;
                            vqAlgnDlvr_Tgt := MIN(vqDeliver_DefaultXbck + vqProd_Width, vqX_OutZoneEnd);
                            vqAlgnDlvr_Width := vqProd_Width;
                            vqAlgnDlvr_Ybtm := vqY_BtmEdge;
                            vqAlgnDlvr_Ytop := vqY_TopEdge;
                            vnAlgn_DeliverCmd := DLVCMD_MOVE;
                        END_IF;
                    END_IF;

                ELSIF vnProd_Rot=0 THEN
                    (* Il prodotto contiene tagli sul medesimo livello, stiamo tagliando
                       partendo dai tagli indietro, tipicamente per fettine strette.
                       Il prossimo step muoverà il prodotto indietro, forse coi riscontri *)
                    dlog( Txt:='! Prod contains cuts (%d)', Lvl:=4, Val1:=TO_DINT(-vnProd_Id) );
                    vnProd_PostSts := 0;
                (* ELSE
                    (* Unsupported product rotation - questa situazione è già intercettata in 'fbJobData' *)
                END_IF;

                (* -La rimanenza deve lasciare la zona di processazione-
                     Visto che la rotazione prodotto può essere ripresa,
                     eseguo operazioni su rimanenza solo se non sono già
                     state fatte, controllando lo stato 'vqRemn_X' *)
                IF vqRemn_X<>NO_POS_UM AND vqRemn_X>vqProcArea_Xmin THEN
                    (* Operazioni di allontanamento/rimozione rimanenza
                       Nota: sono a prescindere dalla destinazione rimanenza:
                         vnRemn_To=0 verrà inserita o espulsa, a seconda
                         vnRemn_To=ZONE_FEED verrà inserita
                         vnRemn_To=ZONE_LOAD verrà inserita
                         vnRemn_To=ZONE_OUT verrà inserita, in teoria evacuazione posticipata *)
                    IF vnRemn_Id<0 (* OR vnRemn_To<>0 *) THEN
                        (* La rimanenza va accumulata nel carico perché andrà tagliata *)
                        dlog( Txt:='Remn %ldx%ld in %ld will be inserted', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqRemn_X/1E3 );
                        vqShift_GlassWidth := vqRemn_Width;
                        vqShift_GlassYbtm := vqY_BtmEdge;
                        vqShift_GlassYtop := vqY_TopEdge; (* Dichiarata: vqShift_GlassYbtm + vqCut_Height *)
                        vqShift_GlassX := vqRemn_X;
                        (* vqShift_TargetX scelto opportunamente *)
                        vqShift_TargetTol := vqShift_MovePosTol;
                        vnShift_Cmd := SHFCMD_INS_REMN;
                        vnRemn_PostSts := POST_BACK_INS;
                    ELSIF vnRemn_Id=0 THEN
                        (* La rimanenza è uno scarto, vediamo cosa farne in base alla dimensione *)
                        (* Nota: Non farò partire la rotazione fino a che è attiva 'POST_REMOVE_REQ' *)

                        dlog( Txt:='Remn %ldx%ld in %ld is scrap', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqRemn_X/1E3 );
                        (* Vediamo cosa farne in base alla dimensione *)
                        IF vqRemn_Width>=vqGlass_BigWidth AND vqSubSheet_ProcHeight>=vqGlass_BigHeight THEN (* TO_DINT(1000.0 * vdRemn_Mass)>=vqGlass_Heavy *)
                            (* Scarto grossino lato stacco *)
                            (* TODO 4: Se ultimo scarto lastra lo inserisco nel carico se non
                                       si sta caricando e non c'è una lastra caricata *)
                            (* TODO 5: Andrebbe inserito nel carico (c'è il prodotto da ruotare)
                                       e se ribaltabile successivamente portato a fine linea *)
                            IF vnStackedSheets<=0 AND (* No inserzioni dichiarate nel carico *)
                               (* i_TmpStacked.Size<=0 AND (* No inserzioni complessive/effettive nel carico *)
                               vnStepIndex>=vnStep_NoMoreIns AND vnStep_NoMoreIns>0 AND (* Niente inserzioni pianificate *)
                               vnShiftFeed_Cmd=CMD_STOP AND NOT fcFeedNearEnd.q THEN (* No prossima lastra caricanda *)
                                (* Lo inserisco nel carico, tanto è l'ultimo *)
                                vqShift_GlassWidth := vqRemn_Width;
                                vqShift_GlassYbtm := vqY_BtmEdge;
                                vqShift_GlassYtop := vqY_TopEdge;
                                vqShift_GlassX := vqRemn_X;
                                (* vqShift_TargetX sarà scelto opportunamente *)
                                vqShift_TargetTol := vqShift_MovePosTol;
                                vnShift_Cmd := SHFCMD_INS_REMN;
                                vnRemn_PostSts := POST_BACK_INS;
                            ELSE
                                (* Lo sposto un po' indietro e ne chiedo il prelievo *)
                                vbShift_DumpRemn := TRUE; (* Nota: Alzerà 'REQ_TAKE_REMN','REQ_DUMP_REMN' *)
                                vnRemn_PostSts := POST_DUMPING;
                            END_IF;
                        (* Scarto piccolo lato stacco: lo si espelle o lo si preleva a mano *)
                        ELSE
                            vbShift_DumpRemn := TRUE; (* Nota: può alzare 'REQ_TAKE_REMN','REQ_DUMP_REMN' *)
                            vnRemn_PostSts := POST_DUMPING;
                        END_IF;
                    ELSE (* -La rimanenza è un pezzo finito- *)
                        (* Nota: non farò partire la rotazione fino a che è attiva 'POST_REMOVE_REQ' *)
                        dlog( Txt:='Remn %ldx%ld in %ld is piece %d', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqRemn_X/1E3, Val4:=TO_DINT(vnRemn_Id) );
                        vqPiecesCount := vqPiecesCount + 1;
                        (* Non posso mandarlo a fine linea perché il prodotto è da processare *)

                        (* TODO 5: Se pesante andrebbe parcheggiato e successivamente portato a fine linea *)
                        (*
                        IF TO_DINT(1000.0 * vdRemn_Mass)>=vqGlass_Heavy THEN
                        ELSE
                        END_IF;
                        *)

                        (* Lo sposto un po' indietro e ne chiedo il prelievo *)
                        (* Nota: assumo che 'Proc.src' finisca in uno stato già pronto per questa sequenza *)
                        vbShift_DumpRemn := TRUE; (* Nota: può alzare 'REQ_TAKE_REMN','REQ_DUMP_REMN' *)
                        vnRemn_PostSts := POST_DUMPING;
                        (* vnPieceDelivering := vnRemn_Id; (* see: vnPieceTaken *)
                        (*
                        dlog( Txt:='fbStepSeq: Take piece from detach side', Lvl:=3 );
                        SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0);
                        vnRemn_PostSts := POST_REMOVE_REQ;
                        *)
                    END_IF; (* Rimanenza *)
                ELSE
                    dlog( Txt:='Remn: Already moved out', Lvl:=3 );
                    vnRemn_PostSts := 0;
                END_IF; (* Operazioni su rimanenza *)
            ELSE
                (* -Il prodotto va evacuato a valle (portato a fine linea)-
                      .È un pezzo finito o uno scarto
                      .È indicata una destinazione (vnProd_To), tipicamente di evacuarlo a valle *)
                IF vnProd_To=ZONE_OUT THEN
                    dlog( Txt:='Prod %ldx%ld in %ld out-fwd', Lvl:=4, Val1:=vqProd_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqProd_X/1E3 );
                ELSIF vnProd_Id>0 THEN
                    dlog( Txt:='Prod %ldx%ld in %ld is piece %d', Lvl:=4, Val1:=vqProd_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqProd_X/1E3, Val4:=TO_DINT(vnProd_Id) );
                    vqPiecesCount := vqPiecesCount + 1;
                ELSE
                    (* Nota: entro qui anche in caso di destinazioni invalide *)
                    dlog( Txt:='Prod %ldx%ld in %ld is scrap', Lvl:=4, Val1:=vqProd_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqProd_X/1E3 );
                END_IF;

                (* Se contiene una sagoma da lavorare, lascio il prodotto dov'è *)
                IF vbProd_HasShape AND (vqWorkSettings & BIT_STOPONSHAPE)<>0 THEN
                    dlog( Txt:='! Prod has shape', Lvl:=2 );
                    SET_MSG(REQ_WORK_SHAPE,'REQ_WORK_SHAPE',0);
                    vnProd_PostSts := POST_WAIT_TOABORT;
                ELSE
                    (* Se prodotto è da ribaltare ma non è ribaltabile perchè basso e largo, riorientalo? *)
                    Prod_MustReor := vbWillTiltOutPiece AND (* vbProd_Prescored *)
                                     (vqWorkSettings & BIT_REORPIECES)<>0 AND
                                     (vqWorkSettings & BIT_ENABGRABBER)<>0 AND (* Chiaramente devo avere un sistema di rotazione *)
                                     vqProd_Width>vqTiltOut_MaxWidth AND (* Non ribaltabile perché troppo largo *)
                                     (* vqCut_Height/2<vqDtch_Width AND (* Affinchè basti liberare lo stacco per la rotazione? *)
                                     vqCut_Height>=vqShift_GoodWidth AND (* Affinchè non abbia problemi a portarlo avanti *)
                                     vqCut_Height>vqTiltOut_MinWidth AND (* Ribaltabile dopo la rotazione *)
                                     vqCut_Height<vqTiltOut_MaxWidth;

                    (* Emissione a fine linea *)
                    vnProd_PostSts := POST_PREP_DELIVER;
                END_IF;

                (* -La rimanenza- *)
                (* Poiché devo riorientare o portare a fine linea il prodotto, normalmente
                   devo spostare la rimanenza un po' indietro per liberare la zona taglio *)
                (* Sposta un po' indietro la rimanenza per liberare zona taglio/fotocellula fine stacco *)
                vqShift_GlassWidth := vqRemn_Width;
                vqShift_GlassYbtm := vqY_BtmEdge;
                vqShift_GlassYtop := vqY_TopEdge; (* Dichiarata: vqShift_GlassYbtm + vqCut_Height *)
                vqShift_GlassX := vqDtch_CurrX + vqRemn_DXdtch; (* Anziché vqRemn_X forzo io per poter essere più tollerante in caso di ripresa *)
                (* Normalmente mi basta liberare la fotocellula di stacco;
                   se devo riorientare il prodotto mi muovo indietro della
                   larghezza del prodotto ruotato più un margine per assicurare
                   che una volta passato il prodotto sui riscontri, la rimanenza
                   non sia troppo avanti *)
                vqShift_TargetX := SEL( Prod_MustReor, 0, MIN(vqDtch_Xbegin, -vqCut_Height-500E3) );
                (* Nota: vqShift_TargetX=0 significa liberazione della fotocellula fine stacco *)
                vqShift_TargetTol := vqShift_MovePosTol;
                vnShift_Cmd := SHFCMD_BACK_REMN;
                vnRemn_PostSts := POST_BACK_LITTLE;

                IF vnRemn_Id<0 THEN
                    dlog( Txt:='Remn %ldx%ld in %ld has cuts', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqRemn_X/1E3 );
                    (* La rimanenza contiene tagli, quindi è lei
                       la prossima sottolastra da processare: *)
                    vqSubSheet_X := vqDtch_CurrX + vqRemn_DXdtch;
                    vqSubSheet_Y := vqY_BtmEdge;

                ELSIF vnRemn_Id=0 THEN
                    dlog( Txt:='Remn %ldx%ld in %ld is scrap', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqRemn_X/1E3 );
                    (* La rimanenza è uno scarto, vediamo cosa farne *)
                    (* Lo porto a fine linea? *)
                    IF (vqWorkSettings & BIT_SCRAP_OUT)<>0
                       AND (vqRemn_Width<vqGlass_BigWidth OR vqCut_Length<vqGlass_BigHeight)
                       (* TO_DINT(1000.0 * vdRemn_Mass)>=vqGlass_Heavy *)
                       AND NOT vbRemn_Dumpable THEN (* Non può essere scaricato nel cassone *)
                        dlog( Txt:='! Remn scrap to out end', Lvl:=4 );
                        (* Se scarto basso e largo, non ribaltabile, riorientalo? *)
                        (* Remn_MustReor := ...; *)
                        (* Vedi 'POST_WAIT_TOPASS' *)
                    ELSE
                        (* Se possibile verrà buttato nel cassone, altrimenti
                           l'operatore se lo gestisce prelevandolo o inserendolo nel carico *)
                        (* Nota: assumo che 'Proc.src' finisca in uno stato già pronto per questa sequenza *)
                        vnShift_Cmd := CMD_STOP; (* Annullo eventuale comando *)
                        vbShift_DumpRemn := TRUE; (* Nota: può alzare 'REQ_TAKE_REMN','REQ_DUMP_REMN' *)
                        vnRemn_PostSts := POST_DUMPING;
                    END_IF;

                ELSE (* -La rimanenza è un pezzo finito- *)
                    dlog( Txt:='Remn %ldx%ld in %ld is piece %d', Lvl:=4, Val1:=vqRemn_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=vqRemn_X/1E3, Val4:=TO_DINT(vnRemn_Id) );
                    vqPiecesCount := vqPiecesCount + 1;

                    (* Mi annoto dove si trova?
                    vqRemn_X := vqDtch_CurrX + vqRemn_DXdtch;
                    vqRemn_Y := vqY_BtmEdge; *)

                    (* Se pezzo basso e largo, non ribaltabile, riorientalo? *)
                    (* Remn_MustReor := ...; *)
                    (* Vedi 'POST_WAIT_TOPASS' *)
                END_IF; (* Rimanenza da processare o meno *)
            END_IF; (* Prodotto da processare o meno *)

        ELSE (* La lastra non è stata separata *)

            (* Sottolastra (prima di eventuale rotazione)
                vqSubSheet_Width, vqSubSheet_Height, vdSubSheet_Mass, vdSubSheet_Jm
                vnSubSheet_Id, vnSubSheet_From, vnSubSheet_Rot, vnSubSheet_To

               Prodotto (==sottolastra dopo eventuale rotazione)
                 vqProd_Width, vdProd_Mass, vdProd_Jm
                 vqProd_MoveInfo, vnProd_Id, vnProd_From, vnProd_To, vnProd_Rot

               Rimanenza (nulla)
            *)
            dlog( Txt:='Sheet %ldx%ld in %ld processed (no detach)', Lvl:=4, Val1:=vqSubSheet_ProcWidth/1E3, Val2:=vqCut_Length/1E3, Val3:=vqProc_Algn/1E3 );
            (* Probabilmente siamo in uno di questi casi:
                 .Sola molatura (può essere molatura di testa)
                 .Sola incisione di striscette consecutive,in gergo "tagli differenziali" *)

            (* Per semplificarmi la vita considero questa lastra non separata
               come il prodotto di questa processazione, quindi forzo: *)
            (* Rimanenza nulla (e non presente) *)
            vqRemn_Width := 0;
            vqRemn_X := NO_POS_UM; (* La rimanenza non c'è *)
            (* Prodotto delle stesse dimensioni della lastra *)
            vqProd_Width := vqSubSheet_ProcWidth;
            (* Posizione del prodotto *)
            vqProd_X := vqProc_Algn; (* Ha il bordo avanti alla quota di processazione *)
            (* Nota: Attenzione ad assegnarlo qui, perdi lo stato in caso di ripresa dell'esecuzione del passo! *)

            (* Vediamo cosa fare: Guardo l'ID del prodotto, la rimanenza non esiste *)
            IF vnProd_Id<0 AND vnProd_To=0 THEN
                (* La sottolastra va ulteriormente processata *)
                (* Non ammetto rotazioni del prodotto visto che non c'è stata separazione,
                   una eventuale rotazione va fatta sulla lastra in arrivo dello step successivo.
                   Aggiungo una eccezione, quando il bordo indietro è già a zero
                   (situazione molatura del bordo indietro) *)
                IF vnProd_Rot=-1 AND vqProd_X=vqProd_Width THEN
                    (* Posso ruotarla subito lato riscontri di -90° *)
                    dlog( Txt:='! Rotating now sheet on Algn', Lvl:=3 );

                    vnProd_PostSts := POST_ROTATE_REQ; (* Default: richiedo rotazione manuale *)

                    IF (vqWorkSettings & BIT_ENABGRABBER)<>0 THEN
                        (* Faccio partire la sequenza di rotazione prodotto
                           (rotaz lato riscontro +90°) che qui realizzo tramite pinza: *)
                        vqGrab_GlassWidth := vqProd_Width;
                        vqGrab_GlassYbtm := vqY_BtmEdge; (* Assumo lastra già misurata in Y *)
                        vqGrab_GlassYtop := vqY_TopEdge;
                        vqGrab_Agrab := 0; (* [mdeg] *)
                        vqGrab_Arot := 90E3; (* [mdeg] *)
                        vqGrab_Ygrab := NO_POS_UM; (* Il punto di presa sarà scelto opportunamente *)

                        (* Valuto *)
                        CalcRotAlgn( What:=ROTARG_PROD );  (* Prodotto non separato *)
                        IF CalcRotAlgn.Ok THEN
                            (* Procediamo con la rotazione *)
                            (* Nota: Questa sequenza attenderà 'vqRemn_X=NO_POS_UM' e richieste *)
                            vnCarriages_Cmd := CARCMD_GRAB;
                            vnProd_PostSts := POST_ROTATING;
                        (* ELSE (* Prodotto non ruotabile con pinza *)
                        END_IF;
                    (* ELSE (* dlog( Txt:='fbStepSeq: Auto-rotation not enabled', Lvl:=4 ); *)
                    END_IF;

                    (* Se prodotto non ruotabile, avverto e lo porto fuori dal premilastra *)
                    IF vnProd_PostSts=POST_ROTATE_REQ THEN
                        SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                        (* Sposto il prodotto fuori da premilastra *)
                        IF vnAlgn_DeliverCmd=CMD_STOP THEN
                            vnAlgnDlvr_Id := vnProd_Id;
                            vbAlgnDlvr_Prescored := vbProd_Prescored;
                            vqAlgnDlvr_Xbck := 0;
                            vqAlgnDlvr_Tgt := MIN(vqDeliver_DefaultXbck + vqProd_Width, vqX_OutZoneEnd);
                            vqAlgnDlvr_Width := vqProd_Width;
                            vqAlgnDlvr_Ybtm := vqY_BtmEdge;
                            vqAlgnDlvr_Ytop := vqY_TopEdge;
                            vnAlgn_DeliverCmd := DLVCMD_MOVE;
                        END_IF;
                    END_IF;
                ELSIF vnProd_Rot<>0 THEN
                    dlog( Txt:='!! Wont rotate subsheet at %ld', Lvl:=1, Val1:=vqProd_X/1E3 );
                    Status := STSEQ_STOP;
                ELSE
                    (* La considero misurata e riscontrata: *)
                    vqSubSheet_X := vqProc_Algn;
                    vqSubSheet_Y := vqY_BtmEdge;
                    dlog( Txt:='! Undetached subsheet at %ld,%ld', Lvl:=1, Val1:=vqSubSheet_X/1E3, Val2:=vqSubSheet_Y/1E3 );
                    (* Per me ho finito, procediamo al passo successivo *)
                    (* vnProd_PostSts := 0; *)
                    Status := STSEQ_DONE;
                END_IF; (* Requisiti prosecuzione lavoro *)
            (*ELSIF vnProd_To<>0 THEN (* TODO 5: Ignoro 'vnProd_To'? *)
            (* Se contiene una sagoma da lavorare,la lascio lì dov'è *)
            ELSIF (vbProd_HasShape OR vbRemn_HasShape) AND (vqWorkSettings & BIT_STOPONSHAPE)<>0 THEN
                dlog( Txt:='! SubSheet has shape', Lvl:=2 );
                (* Bisogna prima separare il taglio e poi eventualmente lavorare la sagoma *)
                SET_MSG(REQ_WORK_PRESCORED,'REQ_WORK_PRESCORED',0);
                SET_MSG(REQ_WORK_SHAPE,'REQ_WORK_SHAPE',0);
                vnProd_PostSts := POST_WAIT_TOABORT;
            ELSE
                (* La lastra va evacuata a fine linea, la tratto come prodotto della processazione *)
                IF vnProd_Id>0 THEN
                    dlog( Txt:='SubSheet %ldx%ld is piece %d', Lvl:=4, Val1:=vqProd_Width/1E3, Val2:=vqCut_Length/1E3, Val3:=TO_DINT(vnProd_Id) );
                    vqPiecesCount := vqPiecesCount + 1;
                ELSIF vnProd_To=ZONE_OUT THEN
                    dlog( Txt:='SubSheet %ldx%ld out-fwd', Lvl:=4, Val1:=vqProd_Width/1E3, Val2:=vqCut_Length/1E3 );
                ELSE
                    (* Nota: Entro qui anche in caso di destinazioni invalide *)
                    dlog( Txt:='SubSheet %ldx%ld is scrap', Lvl:=4, Val1:=vqProd_Width/1E3, Val2:=vqCut_Length/1E3 );
                END_IF;

                (* Vediamo cosa fare con un prodotto in posizione generica *)
                vnProd_PostSts := POST_SEE_GENERIC;
            END_IF; (* Ulteriori processazioni o pezzo finito *)

        END_IF; (* Vetro separato o meno *)

        (* Se non mi devo fermare, procediamo *)
        IF Status<>STSEQ_STOP AND Status<>STSEQ_DONE THEN
            vbVents_MotorsOn := TRUE; (* Assicuro ventilatori pronti *)
            Status := STSEQ_POST;
        END_IF;



    (* ------------------------------------------------------------------- *)
    STSEQ_CUT : (* Cutting sheet *)
        ProcSeq( Execute:=NOT Abort ); (* Sequenza di taglio *)
        IF NOT Abort AND NOT ProcSeq.Execute THEN
            (* Sequenza terminata, vedi risultato *)
            IF ProcSeq.Done THEN
                (* Ok, qui il vetro è processato, da qui in poi in caso
                   di errori non avrebbe senso ripetere questo taglio... *)
                vbProcDone := TRUE;

                (* Posizione di prodotto e rimanenza *)
                IF vbDetachDone THEN
                    (* Settati nei programmi 'Detach-*.src' *)
                    (* vqProd_X := vqProd_Width; (* Il prodotto ha il bordo indietro a zero? Non è detto *)
                    vqRemn_X := vqDtch_CurrX + vqRemn_DXdtch; (* La rimanenza è in vqRemn_DXdtch rispetto lo stacco:

                                                 vqRemn_Width  vqRemn_DXdtch
                                     vqShift_RemnTakePos│ │←→│→│
                                                     ┌──┼─┼──┬─┐
                                                     │▒▒¦  ▒▒¦ │ vqDtch_CurrX
                                                     │▒▒¦  ▒▒¦ │
                                                     └──┼────┼─┘ ‒‒→ x
                                                        │←‒‒‒│
                                                     │←‒‒‒‒‒‒‒→│
                                                     vqDtch_Width      *)
                    (* IF (vqShift_RemnTakePos - vqRemn_Width) >= (vqDtch_CurrX - vqDtch_Width) THEN *)


                ELSE
                    (* Vetro non separato *)
                    vqProd_X := vqProc_Algn; (* Il prodotto avrà il bordo avanti alla quota di processazione? *)
                    vqRemn_X := NO_POS_UM; (* La rimanenza non c'è *)

                    (* Avrei dovuto separarlo? Faccio questo controllo in 'Proc.src'
                    IF (vnStepSettings & BIT_DETACH)<>0 THEN
                        dlog( Txt:='fbStepSeq: !! Glass not detached', Lvl:=2 );
                        SET_MSG(MSG_CUTERROR,'MSG_CUTERROR',0);
                        Status := STSEQ_STOP;
                    END_IF; *)
                END_IF;

                (* In automatico andiamo avanti con le post-movimentazioni *)
                IF vbAutoMode THEN
                    (* Ok, il vetro è stato processato e il passo è quasi eseguito,
                       prima di caricare il successivo faccio partire le post-movimentazioni *)
                    (* dlog( Txt:='fbStepSeq: Cut done, post-ops (auto)', Lvl:=3 ); *)
                    Status := STSEQ_STARTPOST;
                    (*
                    IF (vqWorkSettings & BIT_STOPONSHAPE)<>0 AND (vbProd_HasShape OR vbRemn_HasShape) THEN
                        dlog( Txt:='fbStepSeq: ! Stop for shape', Lvl:=2 );
                        SET_MSG(REQ_WORK_SHAPE,'REQ_WORK_SHAPE',0);
                        Status := STSEQ_STOP;
                    END_IF;
                    *)
                    (* Anticipo il segnale di schema eseguito?
                    Mah, tenterebbe di caricare lo schema dopo...
                    IF vbLastStep THEN vbSchemeDone := TRUE; END_IF; *)
                ELSE
                    (* Se sono in manuale, ho finito *)
                    (* Nota: lo stato finale del rifilo/rimanenza è deciso in 'Detach-*.src' *)
                    Status := STSEQ_DONE;
                END_IF;
            ELSE
                (* La sequenza di taglio non è terminata correttamente *)
                dlog( Txt:='fbStepSeq: !! Cut: Not finished', Lvl:=2 );
                IF vbAutoMode THEN
                    SET_MSG(REQ_FINISHCUT,'REQ_FINISHCUT',0);
                END_IF;
                Status := STSEQ_STOP;
            END_IF;
        END_IF;



    (* ------------------------------------------------------------------- *)
    STSEQ_STARTCUT : (* Prepare glass processing/cut *)
        dlog( Txt:='fbStepSeq: [Starting cut]', Lvl:=3 );
        vbProcDone := FALSE; (* Ridondante, l'ho già fatto al caricamento dello step *)
        (* Controllo requisiti per lo start taglio *)
        (* Niente richieste in sospeso per lo start di un nuovo lavoro *)
        IF (vqRequestActive & REQMSK_NOSTART)<>0 THEN
            dlog( Txt:='!! Requests 0x%lX', Lvl:=2, Val1:=vqRequestActive );
            Status := STSEQ_STOP;
        (* Nota: Vedi altri controlli in 'Proc.src' *)
        ELSE
            vbVents_MotorsOn := TRUE; (* Assicuro ventilatori pronti *)
            ProcSeq( idx:=vnStepIndex, Execute:=NOT Abort );
            Status := STSEQ_CUT;
        END_IF;




    (* ------------------------------------------------------------------- *)
    STSEQ_PRE : (* Sheet placement before processing *)

        (* Rileva estrazione dal carico (PRE_PLACE_PROC, PRE_SHIFT_GRAB) *)
        ExtractDone( in:=vbExtractDone AND vn[ivnStatus+ID_SHIFT]=SHF_PLACE_FWD );
        IF ExtractDone.rise THEN

            (* - Segnale di lastra quasi terminata -
               Usato per far partire le operazioni di carico della lastra successiva
               Criterio: se il tavolo di carico è libero da qui in poi *)
            vbSchemeAlmostDone := vbAutoMode AND (* Devo essere in modalità automatica *)
                                  (vqRemn_XfreeDtch - vqRemn_Width) > vqFeed_Xend AND (* La rimanenza può liberare la fotocellula stacco senza invadere il carico *)
                                  (* i_TmpStacked.Size<=0 AND (* No inserzioni complessive/effettive nel carico *)
                                  vnStackedSheets<=0 AND (* No inserzioni dichiarate nel carico *)
                                  vnStepIndex>=vnStep_NoMoreIns AND vnStep_NoMoreIns>0; (* Niente inserzioni pianificate *)
            (* Qualcosa è stato estratto *)
            (* i_TmpStacked( Pop:=TRUE ); (* No, è già stato fatto comunque *)

        END_IF; (* Lastra estratta *)

        (* - Sottostati - *)
        CASE vnSubSheet_PreSts OF

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_DRAG_GRAB : (* Dragging sheet with detach for grab rotation *)
                IF vnDtch_Cmd=CMD_STOP THEN
                    (* Sequenza terminata, vedi risultato *)
                    IF vnDtch_Seq=SEQ_DONE THEN
                        (* Lastra posizionata per poter essere agguantata dalla pinza *)
                        vqSubSheet_X := vqDtch_GlassXbck + vqDtch_GlassWidth; (* Aggiorno posizione della lastra in arrivo *)
                        vnSubSheet_PreSts := PRE_START_GRAB; (* Procediamo con la rotazione *)
                    ELSE
                        (* Errore nella movimentazione lastra *)
                        dlog( Txt:='fbStepSeq: !! PRE_DRAG_GRAB: Error', Lvl:=1 );
                        SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                        vbPreRotDone := TRUE; (* Considero già da subito fatto *)
                        Status := STSEQ_STOP;
                    END_IF;
                ELSE
                    vqSubSheet_X := vqDtch_GlassXbck + vqDtch_GlassWidth; (* Monitora movimento lastra in arrivo *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_SHIFT_GRAB : (* Placing sheet for align+grab rotation *)
                (* Sono partite le sequenze di posizionamento lastra e forse anche riscontro *)
                IF vnShift_Cmd=CMD_STOP THEN (* vn[ivnStatus+ID_SHIFT]=SHF_IDLE *)
                    (* Sequenza terminata, vedi risultato *)
                    IF vnShift_Seq=SEQ_DONE THEN
                        (* Se sono qui è perchè la lastra va ruotata *)
                        (* ASSERT(fnRotated90(vnSubSheet_Rot) AND NOT vbPreRotDone, '??') *)

                        dlog( Txt:='fbStepSeq: Sheet placed at %ld mm, now align to grab', Lvl:=3, Val1:=vqShift_TargetX/1E3 );
                        (* Se non è già partita, lancio la sequenza di riscontro per allineare il bordo lastra alla pinza *)
                        IF vn[ivnStatus+ID_ALGN]<>ALSTS_ALIGNING THEN
                            vnAlgnBlocks_Sel := 16#FFFF;
                            vqAlgn_Tgt := SEL( vbStep_RotSheetOnAlgn, 0, vqSubSheet_Width );
                            vqAlgnSheet_X := vqShift_TargetX;
                            vqAlgnSheet_Width := vqSubSheet_Width;
                            vqAlgnSheet_Height := vqSubSheet_Height;
                            vbAlgn_UserAlign := FALSE;
                            vnAlgn_Cmd := ALCMD_ALIGN; (* for grab *)
                        END_IF;
                        (* Ora attendo la sequenza di riscontro per allineare il bordo lastra alla pinza *)
                        vnSubSheet_PreSts := PRE_ALIGN_GRAB;
                    ELSE
                        (* Errore nella movimentazione lastra *)
                        (* dlog( Txt:='fbStepSeq: !! PRE_SHIFT_GRAB: Error', Lvl:=1 ); *)
                        SET_MSG(REQ_GET_SHEET,'REQ_GET_SHEET',0);
                        Status := STSEQ_STOP; (* Questo fa abortire il riscontro *)
                    END_IF;
                ELSE
                    vqSubSheet_X := vqShift_GlassX; (* Monitora movimento lastra in arrivo *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_ALIGN_GRAB : (* Aligning sheet for rotation with grabber *)
                IF vnAlgn_Cmd=CMD_STOP THEN
                    (* Sequenza terminata, vedi risultato *)
                    IF vnAlgn_Seq=SEQ_DONE THEN
                        (* Lastra posizionata per poter essere agguantata dalla pinza *)
                        vqSubSheet_X := vqAlgn_Tgt; (* Aggiorno posizione della lastra in arrivo *)
                        vnSubSheet_PreSts := PRE_START_GRAB; (* Procediamo con la rotazione *)
                    ELSE (* vnAlgn_Seq=ALSEQ_ALGN_NOCONTACT, SEQ_ERROR *)
                        (* Riscontro non completato *)
                        (* dlog( Txt:='fbStepSeq: !! Align error for rotation', Lvl:=2 ); *)
                        SET_MSG(REQ_GET_SHEET,'REQ_GET_SHEET',0);
                        Status := STSEQ_STOP;
                        (* Togliendo il commento seguente non si può ritentare la chiamata *)
                        (* SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                        vbPreRotDone := TRUE; (* Considero già da subito fatto *)
                    END_IF;
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_START_GRAB : (* Starting sheet rotation with grabber *)
                (* Faccio partire la sequenza di rotazione con pinza
                   Nota: L'invasione della zona a fine linea
                         'OutZone.Xbusy' è già gestita nella sequenza
                   Se ho allineato il bordo indietro a zero è una rotazione lato riscontro
                   Se ho allineato il bordo avanti a zero è una rotazione lato stacco *)
                IF vqSubSheet_X>0 THEN
                    (* ASSERT(vqSubSheet_X=vqSubSheet_Width, 'Not an align rotation') *)
                    (* Default: intendo ruotarla lato riscontro *)
                    dlog( Txt:='fbStepSeq: Rotating on align', Lvl:=4 );
                    vqGrab_Agrab := 0; (* [mdeg] *)
                    vqGrab_Arot := 90E3; (* [mdeg] *)
                ELSE
                    (* Intendo ruotarla lato stacco *)
                    dlog( Txt:='fbStepSeq: Rotating on dtch', Lvl:=4 );
                    vqGrab_Agrab := 180E3; (* [mdeg] *)
                    vqGrab_Arot := -90E3; (* [mdeg] *)
                END_IF;
                vqGrab_GlassWidth := vqSubSheet_Width;
                IF vbGrab_DontSearchInc THEN
                    (* Assumo posizione lastra senza cercare.
                       Rischio di collisione sotto se alzo troppo la stima, sopra se la abbasso troppo *)
                    vqGrab_GlassYbtm := SEL(vqSubSheet_Y<>NO_POS_UM, vqYo_SheetFeed, vqSubSheet_Y);
                    vqGrab_GlassYtop := vqGrab_GlassYbtm + vqSubSheet_Height;
                ELSE
                    (* Forzo misurazione nella sequenza pinza *)
                    vqGrab_GlassYbtm := NO_POS_UM;
                    vqGrab_GlassYtop := NO_POS_UM;
                    (* Meglio assicurarsi di verificare l'altezza misurata *)
                    vqWorkSettings := vqWorkSettings & NOT BIT_NOCHECKCUTLEN;
                END_IF;
                (* vqGrab_Agrab, vqGrab_Arot (* Valorizzati sopra *)
                vqGrab_Ygrab := NO_POS_UM; (* Il punto di presa sarà scelto opportunamente *)

                vnCarriages_Cmd := CARCMD_GRAB;
                vnSubSheet_PreSts := PRE_ROTAT_GRAB;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_ROTAT_GRAB : (* Rotating sheet with grabber *)
                (* Sequenza di rotazione automatica lastra in arrivo
                   .Se rotazione fallita alza REQ_ROTATEBYHAND *)
                IF vnCarriages_Cmd=CMD_STOP THEN
                    IF vnCarriages_Seq=SEQ_DONE THEN
                        (* Lastra in arrivo ruotata con successo *)
                        vbPreRotDone := TRUE;
                        (* Aggiorno posizione lastra da tagliare *)
                        vqSubSheet_Y := vq[ivqAx_CurrPos+AX_YINF-1] + vqGrabber_DY; (* Posizione Y pinza *)
                        (* La posizione X dipende da come è stata ruotata, uso le posiz Y precedenti: *)
                        IF vnGrab_RotType=2 THEN
                            (* Se rotazione lato stacco vnGrab_RotType=2 (vbStep_RotSheetOnAlgn=FALSE) *)
                            vqSubSheet_X := vqGrab_GlassYtop - vqGrab_Ygrab; (* Distanza punto di presa - bordo sopra *)
                        ELSE
                            (* Se rotazione lato riscontro vnGrab_RotType=1 (vbStep_RotSheetOnAlgn=TRUE) *)
                            vqSubSheet_X := vqGrab_Ygrab - vqGrab_GlassYbtm; (* Distanza punto di presa - bordo sotto *)
                        END_IF;
                        dlog( Txt:='fbStepSeq: Subsheet rotated Xfwd=%ld Ybtm=%ld mm', Lvl:=4, Val1:=vqSubSheet_X/1E3, Val2:=vqSubSheet_Y/1E3 );

                        (* Ora vado a chiudere la pinza.
                           Nota: Se la posiz di chiusura è sotto, il carrello inferiore rimane lì
                           Nota: Questa sequenza è sempre attesa in 'STSEQ_STARTPRE' *)
                        vnCarriages_Cmd := CMD_PARK;
                        Status := STSEQ_STARTPRE; (* Ripartiamo *)
                    ELSE
                        dlog( Txt:='fbStepSeq: !! PRE_ROTAT_GRAB: Failed', Lvl:=1 );
                        SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                        vbPreRotDone := TRUE; (* Considero già da subito fatto *)
                        vnCarriages_Seq := SEQ_START; (* Resetto il risultato per evitare di forzare un parcheggio allo start *)
                        (* Mi assicuro di invalidare la posizione in eredità *)
                        vqSubSheet_X := NO_POS_UM; (* Rotate by hand *)
                        vqSubSheet_Y := NO_POS_UM;

                        Status := STSEQ_STOP;
                    END_IF;
                    vqY_BtmEdge := NO_POS_UM; (* Invalido bordi vetro: Rotazione lastra in arrivo con pinza *)
                    vqY_TopEdge := NO_POS_UM;
                    vqCut_Length := 0;
                END_IF; (* vnCarriages_Cmd=CMD_STOP *)

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_SHIFT_BUF : (* Placing sheet for buffer rotation *)
                IF vnShift_Cmd=CMD_STOP AND
                   vb[ivbAtRest+ID_BELTS_BUF] AND vb[ivbAtRest+ID_BELTS_FEED] THEN
                    (* Sequenza terminata, vedi risultato *)
                    IF vnShift_Seq=SEQ_DONE THEN
                        dlog( Txt:='fbStepSeq: Rotating on buf', Lvl:=4 );
                        vnBufRot_Cmd := CalcRotBuf.k;
                        vnSubSheet_PreSts := PRE_ROTAT_BUF;
                    ELSE
                        (* Errore nella chiamata lastra *)
                        (* dlog( Txt:='fbStepSeq: !! PRE_SHIFT_BUF: Error', Lvl:=1 ); *)
                        SET_MSG(REQ_GET_SHEET,'REQ_GET_SHEET',0);
                        Status := STSEQ_STOP; (* Questo fa abortire il riscontro *)
                    END_IF;
                ELSE
                    vqSubSheet_X := vqShift_GlassX; (* Monitora movimento lastra in arrivo *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_ROTAT_BUF : (* Rotating sheet with buffer *)
                (* Sequenza di rotazione automatica lastra in arrivo
                   .Se rotazione fallita alza REQ_ROTATEBYHAND *)
                IF vnBufRot_Cmd=0 THEN
                    (* Se la lastra risulta ancora da estrarre dal carico
                       se sono sopra le fotocellule dello stacco avrei errore:
                       'Cannot pop sheet, glass on dtch'
                       Lo evito ponendo: *)
                    (* vbExtractDone := TRUE; *)
                    vnSubSheet_From := 0;
                    IF vnBufRot_Seq=SEQ_DONE THEN
                        (* Lastra in arrivo ruotata con successo *)
                        vbPreRotDone := TRUE;
                        (* Aggiorno posizione lastra da tagliare, che dipende da come è stata ruotata *)
                        vqSubSheet_X := CalcRotBuf.Xfwd_rot;
                        vqSubSheet_Y := CalcRotBuf.Ybtm_rot;
                        dlog( Txt:='fbStepSeq: Subsheet rotated Xfwd=%ld Ybtm=%ld mm', Lvl:=4, Val1:=vqSubSheet_X/1E3, Val2:=vqSubSheet_Y/1E3 );

                        (* A questo punto ripartiamo con la chiamata lastra *)
                        Status := STSEQ_STARTPRE;
                    ELSE
                        dlog( Txt:='fbStepSeq: !! Subsheet: rotation failed', Lvl:=1 );
                        SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                        vbPreRotDone := TRUE; (* Considero già da subito fatto *)
                        (* Mi assicuro di invalidare la posizione in eredità *)
                        vqSubSheet_X := NO_POS_UM; (* Rotate by hand *)
                        vqSubSheet_Y := NO_POS_UM;

                        Status := STSEQ_STOP;
                    END_IF;
                    vqY_BtmEdge := NO_POS_UM; (* Invalido bordi vetro: Rotazione lastra in arrivo su polmone *)
                    vqY_TopEdge := NO_POS_UM;
                    vqCut_Length := 0;
                END_IF; (* vnCarriages_Cmd=CMD_STOP *)

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_PLACE_PROC : (* Placing sheet for align+processing *)
                (* Sono partite le sequenze di posizionamento lastra e forse anche riscontro *)
                IF vnShift_Cmd=CMD_STOP THEN (* vn[ivnStatus+ID_SHIFT]=SHF_IDLE *)
                    (* Sequenza terminata, vedi risultato *)
                    IF vnShift_Seq=SEQ_DONE THEN
                        (* Devo processare/tagliare, lastra alla quota di processazione *)
                        (* ASSERT(vnSubSheet_To=0, 'Subsheet has destination!') *)
                        dlog( Txt:='fbStepSeq: Sheet placed at %ld mm (proc at %ld)', Lvl:=3, Val1:=vqShift_TargetX/1E3, Val2:=vqProc_Algn/1E3 );
                        (* Bisogna riscontrare? *)
                        IF vbMustAlign THEN
                            (* La lastra deve essere riscontrata prima della processazione
                               Se non è già partita, lancio la sequenza di riscontro del taglio *)
                            IF vn[ivnStatus+ID_ALGN]<>ALSTS_ALIGNING THEN
                                vnAlgnBlocks_Sel := 16#FFFF; (* All blocks, zero would be also ok *)
                                vqAlgn_Tgt := vqProc_Algn;
                                vqAlgnSheet_X := vqShift_TargetX;
                                vqAlgnSheet_Width := vqProd_Width + vqRemn_Width;
                                vqAlgnSheet_Height := vqCut_Height;
                                vbAlgn_UserAlign := FALSE;
                                vnAlgn_Cmd := ALCMD_ALIGN; (* for proc *)
                            END_IF;
                            (* Ora attendo la sequenza di riscontro del taglio *)
                            vnSubSheet_PreSts := PRE_ALIGN_PROC;
                        ELSE
                            (* Lastra già pronta per essere processata *)
                            vnSubSheet_PreSts := 0;
                            (* La lastra deve essere in vqProc_Algn! *)
                            IF ABS(vqSubSheet_X-vqProc_Algn)<(vqShift_ProcPosTol+ABS(vqShift_ProcPosFix)) THEN (* Tolleranza *)
                                (* Ok, vedi se far partire la processazione *)
                                Status := SEL( (vbAutoMode AND (vbFeat_FullAuto OR vbZprescore)) OR vbCutAutoStart, STSEQ_STOP, STSEQ_STARTCUT );
                            ELSE
                                dlog( Txt:='fbStepSeq: !! PRE_PLACE_PROC: Not in place: %ld-%ld=%ld > %ld um', Lvl:=2, Val1:=vqSubSheet_X/1E3, Val2:=vqProc_Algn/1E3, Val3:=(vqSubSheet_X-vqProc_Algn), Val4:=vqShift_ProcPosTol );
                                Status := STSEQ_STOP;
                            END_IF;
                        END_IF;
                    ELSE
                        (* Errore nella chiamata lastra *)
                        (* dlog( Txt:='fbStepSeq: !! Get sheet error', Lvl:=1 ); *)
                        SET_MSG(REQ_GET_SHEET,'REQ_GET_SHEET',0);
                        Status := STSEQ_STOP; (* Questo fa abortire il riscontro *)
                    END_IF;
                ELSE
                    vqSubSheet_X := vqShift_GlassX; (* Monitora movimento lastra in arrivo *)
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_ALIGN_PROC : (* Aligning sheet for cut/processing *)
                IF vnAlgn_Cmd=CMD_STOP THEN
                    (* Sequenza terminata, vedi risultato *)
                    IF vnAlgn_Seq=SEQ_DONE THEN
                        (* Riscontro completato con successo *)
                        vnSubSheet_PreSts := 0;
                        (* Dopo il riscontro la lastra è in: *)
                        vqSubSheet_X := vqProc_Algn;
                        (* Se la processazione è già stata lanciata passo ad attenderla,
                           altrimenti vedo se devo lanciarla o terminare *)
                        IF ProcSeq.Execute THEN
                            Status := STSEQ_CUT;
                        ELSE
                            Status := SEL( (vbAutoMode AND (vbFeat_FullAuto OR vbZprescore)) OR vbCutAutoStart, STSEQ_STOP, STSEQ_STARTCUT );
                        END_IF;
                    ELSE (* vnAlgn_Seq=ALSEQ_ALGN_NOCONTACT,SEQ_ERROR *)
                        (* Riscontro non completato *)
                        (* dlog( Txt:='fbStepSeq: !! Align error, aborting', Lvl:=2 ); *)
                        (* Non voglio sempre alzare il messaggio: in manuale è normale avere un ALSEQ_ALGN_NOCONTACT *)
                        IF vbAutoMode OR vnAlgn_Seq<>ALSEQ_ALGN_NOCONTACT THEN
                            SET_MSG(REQ_DOALIGN,'REQ_DOALIGN',0);
                        END_IF;
                        Status := STSEQ_STOP;
                    END_IF;
                (* Lancio anticipato della sequenza di taglio in automatico: *)
                ELSIF vbAutoMode
                      AND vnAlgn_Seq>=ALSEQ_ALGN_PUSHING  (* Ho già incontrato il vetro *)
                      AND (vqAlgn_CurrX-vqAlgn_Tgt)<=vqAlgn_AlmostDelta  (* Quasi completato *)
                      AND (vqAlgn_CurrX-vqAlgnSheet_Width)<1E3  (* Il bordo indietro ha oltrepassato o quasi lo zero *)
                      AND NOT vbEdgeDet_OnTheFly (* Non è prevista la ricerca al volo *)
                      AND NOT ProcSeq.Execute THEN (* Sequenza taglio non ancora lanciata *)
                    (* dlog( Txt:='fbStepSeq: Starting cut on aligning (D=%ld mm)', Lvl:=4, Val1:=(vqAlgn_Tgt-vqAlgn_CurrX)/1E3 ); *)
                    ProcSeq( idx:=vnStepIndex, Execute:=NOT Abort );
                END_IF;

            (* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)
            PRE_EXE_EDGTRIM : (* Edge trimming in progress *)
                IF Cnc.Chn1.Status<=CS_READY THEN
                    RST_MSG_IF_ON(MSG_EDGTRIMMING); (* Notifica operazione in corso *)
                    (* Programma terminato, vedo risultato *)
                    IF vnCh1Ret=RET_OK THEN
                        vbEdgeTrimmed := TRUE;
                        (* Aggiorno posizione lastra da tagliare? Già fatto! *)
                        (* vqSubSheet_X := 0; *)
                        Status := STSEQ_STARTPRE; (* Prosecute with the job *)
                    ELSE
                        Status := STSEQ_STOP;
                    END_IF;
                END_IF;

        END_CASE; (* -- vnSubSheet_PreSts *)



    (* ------------------------------------------------------------------- *)
    STSEQ_STARTPRE : (* Start getting sheet *)

        vnSubSheet_PreSts := 0; (* Assicuro di resettare il sottostato *)

        IF vbAutoMode THEN
            dlog( Txt:='fbStepSeq: >> Step %d.%d started', Lvl:=3, Val1:=TO_DINT(vnSchemeIndex), Val2:=TO_DINT(vnStepIndex) );
            (* Note: vnStepIndex === JobData.Scheme.CurStep *)
            IF vnStepIndex=1 THEN
                i_TmpStacked( Clear:=TRUE );
            END_IF;
        ELSE
            dlog( Txt:='fbStepSeq: >> Step started', Lvl:=3 );
            i_TmpStacked( Clear:=TRUE );
        END_IF;

        (* Controllo requisiti per lo start passo *)
        (* Niente richieste in sospeso per lo start di un nuovo lavoro *)
        IF (vqRequestActive & REQMSK_NOSTART)<>0 THEN
            dlog( Txt:='!! Requests 0x%lX', Lvl:=2, Val1:=vqRequestActive );
            Status := STSEQ_STOP;
        (* Intercetta errori sulla sequenza carrelli *)
        ELSIF vnCarriages_Seq=SEQ_ERROR THEN
            SET_MSG(MSG_NOTPARKED,'MSG_NOTPARKED: Carriages',0);
            dlog( Txt:='!! Carriages seq failed', Lvl:=2 );
            Status := STSEQ_STOP;
        (* Vorrei prevenire situazione con pinza alta in mezzo al taglio,
           es. rotazione manuale non effettuata: preposizionando il
           carrello superiore potrebbe andare a collidere *)
        ELSIF vnGrabber_Type>0 AND vn[ivnStatus+ID_GRABBER]<>GSTS_CLOSED AND vq[ivqAx_CurrPos+AX_YINF-1]>200E3 THEN
            SET_MSG(MSG_NOTPARKED,'MSG_NOTPARKED: Grabber',0);
            dlog( Txt:='!! Grabber (%d)', Lvl:=2, Val1:=TO_DINT(vn[ivnStatus+ID_GRABBER]) );
            Status := STSEQ_STOP;
        ELSE
            (* Requisiti ok, vediamo cosa devo fare *)
            RST_MSG_IF_ON(MSG_NOTPARKED);

            (* Qualche informazione aggiuntiva sul passo *)
            IF fnRotated90(vnSubSheet_Rot) THEN
                IF vbPreRotDone THEN
                    (* La rotazione è già stata fatta, visualizzo le dimensioni già scambiate *)
                    dlog( Txt:='SubSheet %ldx%ld (rotated) algn:%ld', Lvl:=3, Val1:=vqSubSheet_Height/1E3, Val2:=vqSubSheet_Width/1E3, Val3:=vqProc_Algn/1E3 ); (* vdSubSheet_Mass *)
                ELSE
                    (* La rotazione è da fare, visualizzo la massa *)
                    dlog( Txt:='SubSheet %ldx%ld rot:%d %ld Kg', Lvl:=3, Val1:=vqSubSheet_Width/1E3, Val2:=vqSubSheet_Height/1E3, Val3:=TO_DINT(90*vnSubSheet_Rot), Val4:=TO_DINT(vdSubSheet_Mass) );
                END_IF;
            ELSE
                (* La lastra in arrivo non è da ruotare *)
                dlog( Txt:='SubSheet %ldx%ld algn:%ld', Lvl:=3, Val1:=vqSubSheet_Width/1E3, Val2:=vqSubSheet_Height/1E3, Val3:=vqProc_Algn/1E3 ); (* vdSubSheet_Mass *)
            END_IF;

            IF vqOutZone_Xbusy < vqX_OutZoneEnd THEN
                dlog( Txt:='! OutZone.Xbusy=%ld mm', Lvl:=3, Val1:=vqOutZone_Xbusy/1E3 );
            END_IF;
            (* Debug: Stato lastre accumulate *)
            IF vnStackedSheets>0 THEN
                dlog( Txt:='Stacked subsheets:%d', Lvl:=4, Val1:=TO_DINT(vnStackedSheets) );
            END_IF;
            IF i_TmpStacked.Size>0 THEN
                dlog( Txt:='Stacked:%d Top:%ldx%ld,Id=%d', Lvl:=4, Val1:=TO_DINT(i_TmpStacked.Size), Val2:=i_TmpStacked.Sheet.Width/1E3, Val3:=i_TmpStacked.Sheet.Height/1E3, Val4:=TO_DINT(i_TmpStacked.Sheet.Id) );
            END_IF;

            (* Init *)
            (* vbVents_MotorsOn := TRUE; (* Assicuro ventilatori pronti *)
            vnAlgn_Seq := SEQ_ERROR; (* Inizializzo per sicurezza riscontro fallito *)
            vqRemn_X := NO_POS_UM; (* La posizione rimanenza non ha senso ora *)

            (* Gli argomenti del passo di lavorazione sono:
            vnStepSettings, vqCut_Height, vbStepValid, vbNextStep_Valid, vqNextStep_FirstAlgn, vnStackedSheets
            vqSubSheet_Width, vqSubSheet_Height, vqProc_Algn, vdSubSheet_Mass, vdSubSheet_Jm
            vqSubSheet_MoveInfo, vnSubSheet_Id, vnSubSheet_From, vnSubSheet_To, vnSubSheet_Rot
            vqProd_Width, vdProd_Mass, vdProd_Jm
            vqProd_MoveInfo, vnProd_Id, vnProd_From, vnProd_To, vnProd_Rot
            vqRemn_Width, vdRemn_Mass, vdRemn_Jm
            vqRemn_MoveInfo, vnRemn_Id, vnRemn_From, vnRemn_To, vnRemn_Rot *)

            (* Dati in eredità dal passo precedente:
               Posizione presunta lastra: vqSubSheet_X,vqSubSheet_Y
               Posizione ultima inserzione nel carico: vqInsSheet_Y *)

            (* -Posizione presunta lastra- *)
            (* Se la lastra è da estrarre e lo stato del passo è vergine, ignoro l'eredità *)
            IF vnSubSheet_From=ZONE_FEED AND NOT vbExtractDone AND vqSubSheet_X<>NO_POS_UM THEN
                dlog( Txt:='! Ignoring vqSubSheet_X=%ld mm', Lvl:=3, Val1:=vqSubSheet_X/1E3 );
                vqSubSheet_X := NO_POS_UM;
                vqSubSheet_Y := NO_POS_UM; (* vqInsSheet_Y *)
            END_IF;

            (* - Stimo posizione X se non ereditata - *)
            IF vqSubSheet_X=NO_POS_UM THEN
                (* In base agli argomenti del passo (provenienza sottolastra in arrivo) *)
                CASE vnSubSheet_From OF
                    ZONE_OUT  :
                        (* Proviene da valle *)
                        vqSubSheet_X := vqX_OutZoneEnd + vqSubSheet_Width;
                        dlog( Txt:='! Sheet from downstream', Lvl:=2 );
                        (* TODO 5: cosa fare?? *)
                    ZONE_LOAD :
                        (* Proviene da monte *)
                        vqSubSheet_X := vqXph_FeedBegin - vqSubSheet_Width;
                        dlog( Txt:='! Sheet from upstream', Lvl:=2 );
                        (* TODO 5: cosa fare?? *)
                    ZONE_FEED :
                        (* Deve essere estratta dal carico *)
                        vqSubSheet_X := vqXph_FeedNearEnd;
                        vqSubSheet_Y := vqInsSheet_Y; (* Da ultima inserzione *)
                        vqInsSheet_Y := NO_POS_UM; (* Valore usato *)
                        (* IF vbExtractDone THEN dlog( Txt:='fbStepSeq: Sheet already extracted from feed', Lvl:=4 ); END_IF; *)

                        (* Mantengo il mio conteggio interno delle inserzioni e
                           controllo se devo evacuare uno scarto/pezzo accumulato precedentemente *)
                        IF i_TmpStacked.Size>vnStackedSheets AND NOT vbExtractDone THEN
                            (* Considero subito estratta anche in caso di errore*)
                            i_TmpStacked( Pop:=TRUE );

                            IF i_TmpStacked.Sheet.Id >= 0 THEN
                                (* É stato temporaneamente inserito un pezzo o uno scarto!! *)
                                dlog( Txt:='-> out-fwd tmp %ldx%ld Id=%d', Lvl:=2, Val1:=i_TmpStacked.Sheet.Width/1E3, Val2:=i_TmpStacked.Sheet.Height/1E3, Val3:=TO_DINT(i_TmpStacked.Sheet.Id) );
                                (*
                                vqShift_GlassWidth := i_TmpStacked.Sheet.Width;
                                vqShift_GlassYbtm := vqYo_SheetFeed;
                                vqShift_GlassYtop := vqShift_GlassYbtm + i_TmpStacked.Sheet.Height;
                                vqShift_GlassX := vqXph_FeedNearEnd;
                                vqShift_TargetX := vqShift_GlassWidth;
                                vqShift_TargetTol := vqShift_MovePosTol;
                                vnShift_Cmd := SHFCMD_PLACE_SHEET;
                                Status := STSEQ_OUTFWD;
                                (* Intanto potrei avvicinare i riscontri per agganciarla
                                IF vnAlgn_Cmd=CMD_STOP THEN
                                    vqAlgn_Tgt := vqAlgn_XrMinSafe + 10E3;
                                    vnAlgn_Cmd := CMD_MOVETO;
                                END_IF;
                                RETURN; *)
                            END_IF;
                        END_IF;
                    ELSE
                        (* Già in zona, la penso posta prima dell'ultima fotocellula (o nel carico se non estratta) *)
                        (* vqSubSheet_X := SEL(vbExtractDone, vqXph_FeedNearEnd, (vqDtch_CurrX+vqDXph_DtchLast)-500E3); *)

                        (* Valutazione in base a fotocellule *)
                        GuessSheetPos( W:=vqSubSheet_Width );
                        vqSubSheet_X := GuessSheetPos.Xfwd;

                        (* TODO 1: Occhio che però potrebbe dare problemi nel caso di posizionamenti
                           con target minore di zero, ad esempio per rotazioni con ventosa!
                           In questi casi dovrebbe arrivare dal passo precedente... *)
                END_CASE;
                dlog( Txt:='! Assuming vqSubSheet_X=%ld mm', Lvl:=3, Val1:=vqSubSheet_X/1E3 );
            ELSE
                dlog( Txt:='! Inheriting sheet in %ld,%ld mm', Lvl:=3, Val1:=vqSubSheet_X/1E3, Val2:=vqSubSheet_Y/1E3 );
            END_IF;

            (* - Stimo posizione Y se non ereditata - *)
            IF vqSubSheet_Y=NO_POS_UM THEN
                (* Se lastra bassa la assumo trasportabile, posizionata opportunamente in Y *)
                IF vqSubSheet_Height<(vq[ivqDtchBelts_Y+2]-vqYo_SheetFeed) AND
                   vqSubSheet_Height >= (vq[ivqDtchBelts_DY+2] - vqDtchBelts_Size + 2*vqBelts_MinGripDY) THEN
                    (* Potrebbe essere trasportabile se la centrassi sulle cinghie 1 e 2 *)
                    vqSubSheet_Y := vq[ivqDtchBelts_Y+1] - (vqSubSheet_Height - vq[ivqDtchBelts_DY+2])/2;
                ELSE
                    vqSubSheet_Y := vqYo_SheetFeed;
                END_IF;
                dlog( Txt:='! Assuming vqSubSheet_Y=%ld mm', Lvl:=3, Val1:=vqSubSheet_Y/1E3 );
            END_IF;

            (* Da qui in poi ho la posizione presunta *)
            (* ASSERT(vqSubSheet_X<>NO_POS_UM AND vqSubSheet_Y<>NO_POS_UM, 'Sheet pos not valorized') *)

            (* Devo posizionare opportunamente la lastra, valutiamo la
               situazione per capire dove devo traslarla. Tipicamente:
                 -Lastra da intestare?
                 -Lastra da ruotare?
                 -Altro (evacuazione, processazione) *)
            (* La lastra in arrivo va intestata? *)
            IF vnEdgeTrim_Type>0 AND (vqWorkSettings & BIT_EDGETRIM)<>0 AND NOT vbEdgeTrimmed THEN
                dlog( Txt:='-> Trim edge', Lvl:=3 );
                (* Porto il bordo avanti a zero in modo che possa
                   essere lavorato dal programma 'Edge-Trimming.src' *)
                (* Traslazione con cinghie + riscontro *)
                vqShift_GlassWidth := vqSubSheet_Width;
                vqShift_GlassYbtm := vqSubSheet_Y;
                vqShift_GlassYtop := vqShift_GlassYbtm + vqSubSheet_Height;
                vqShift_GlassX := vqSubSheet_X;
                CalcAlgnDelta( Width:=vqSubSheet_Width, Height:=vqSubSheet_Height, Align:=0 );
                vqShift_TargetX := vqSubSheet_Width + CalcAlgnDelta.Delta;
                vqShift_TargetTol := vqShift_AlgnPosTol;
                vnShift_Cmd := SHFCMD_PLACE_SHEET;
                (* Anticipo il riscontro *)
                vnAlgnBlocks_Sel := 16#FFFF;
                vqAlgn_Tgt := 0;
                vqAlgnSheet_X := vqShift_TargetX;
                vqAlgnSheet_Width := vqSubSheet_Width;
                vqAlgnSheet_Height := vqSubSheet_Height;
                vbAlgn_UserAlign := FALSE;
                vnAlgn_Cmd := ALCMD_ALIGN; (* for edge trim *)
                (* Lancio il programma *)
                Cnc.Chn1.PrgPth := 'Edge-Trimming.obj'; (* Programma di intestatura che toglie la bava di plastico *)
                Cnc.Chn1.StartPrg := TRUE; (* Cnc.Chn1.Status=CS_READY *)
                (* Next status *)
                vnSubSheet_PreSts := PRE_EXE_EDGTRIM;
                Status := STSEQ_PRE;

            (* La lastra in arrivo va ruotata? *)
            ELSIF fnRotated90(vnSubSheet_Rot) AND NOT vbPreRotDone THEN
                (* Lastra in arrivo deve essere ruotata *)

                (* Valorizzo subito gli argomenti del servizio di traslazione
                   (anche se non è detto che lo userò) *)
                vqShift_GlassWidth := vqSubSheet_Width;
                vqShift_GlassYbtm := vqSubSheet_Y;
                vqShift_GlassYtop := vqShift_GlassYbtm + vqSubSheet_Height;
                vqShift_GlassX := vqSubSheet_X;

                (* Vediamo con quale sistema posso ruotare la lastra *)
                Status := STSEQ_STOP; (* Default: rotazione manuale *)

                (* Controllo requisiti per rotazione automatica *)
                IF NOT vbAutoMode THEN
                    (* Mah, strano che la ciclica in manuale abbia una rotazione *)
                    dlog( Txt:='! Wont rotate in manual mode', Lvl:=4 );
                    SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                    RETURN;
                END_IF;

                (* -- Ventosa su polmone --
                   Se è presente e abilitato il sistema di rotazione su polmone,
                   provo a vedere se è possibile ruotare con esso, ma solo se
                   la lastra in arrivo non è già sui riscontri *)
                IF (vqWorkSettings & BIT_ENABBUFROT)<>0 AND (* Questo bit comporta un adeguato 'vnBufRot_Type' *)
                   (vqSubSheet_X - vqSubSheet_Width)<vqDtch_CurrX AND (* Non troppo avanti o addirittura sui riscontri *)
                   Status=STSEQ_STOP THEN (* Ancora niente rotazione automatica *)

                    (* Sistema rotazione su polmone disponibile, valutiamo se fattibile *)
                    vqBufRot_GlassWidth := vqSubSheet_Width;
                    vqBufRot_GlassHeight := vqSubSheet_Height;
                    vqBufRot_GlassXfwd := NO_POS_UM; (* La faccio calcolare a 'CalcRotBuf' *)
                    vqBufRot_GlassYbtm := vqSubSheet_Y;

                    (* Decido il senso di rotazione richiesto, a seconda che
                       abbia una lastra da estrarre dal carico o una rimanenza *)
                    IF vnSubSheet_From=ZONE_FEED THEN
                        CalcRotBuf.k_des := SEL(vbBufRot_ExtrP90, TO_INT(-1), INT#1);
                    ELSE
                        CalcRotBuf.k_des := SEL(vbBufRot_RemnP90, TO_INT(-1), INT#1);
                    END_IF;
                    (* Se ci sono lastre accumulate... *)
                    IF vnStackedSheets>0 OR i_TmpStacked.Size>0 THEN
                        (* ...Considera il carico pieno *)
                        CalcRotBuf.Xmin := vqXph_FeedEnd - vqBelts_StackDist;
                    ELSE
                        (* ...Considera il carico vuoto *)
                        CalcRotBuf.Xmin := vqXph_FeedBegin;
                    END_IF;
                    (* Valuto la fattibilità della rotazione desiderata *)
                    CalcRotBuf(); (* Lastra in arrivo *)

                    (* Se non riesco a ruotare in quel senso potrei provare nel senso opposto *)
                    IF CalcRotBuf.k=0 THEN
                        (* La rotazione desiderata non è fattibile, vedo se devo riprovare nell'altro senso *)
                        IF vbBufRot_TryInv THEN
                            dlog( Txt:='! Trying inv BufRot', Lvl:=3 );
                            vqBufRot_GlassXfwd := NO_POS_UM; (* Devo farlo ricalcolare! *)
                            CalcRotBuf.k_des := -CalcRotBuf.k_des; (* Inverso il senso *)
                            CalcRotBuf(); (* Lastra in arrivo *)
                        END_IF;
                    END_IF;

                    IF CalcRotBuf.k<>0 THEN
                        (* Rotazione fattibile, procediamo *)
                        dlog( Txt:='Will rotate on BufRot k=%d', Lvl:=3, Val1:=TO_DINT(CalcRotBuf.k) );
                        (* La porto sopra la ventosa *)
                        (* TODO 1: In caso di rimanenza, la posizione iniziale potrebbe
                                 essere cannata, dovrei usare fotocellule per misura
                        IF vq[3550]<>0 AND vqSubSheet_X>vqBufRot_Xc THEN
                            dlog( Txt:='fbStepSeq: ! Fixing vqSubSheet_X=%ld+%ld', Lvl:=3, Val1:=vqSubSheet_X/1E3, Val2:=vq[3550]/1E3 );
                            vqSubSheet_X := vqSubSheet_X + vq[3550];
                            vqShift_GlassX := vqSubSheet_X;
                        END_IF;
                        *)

                        (* Per posizionare la lastra sulla ventosa uso sempre le cinghie *)
                        vqShift_TargetX := vqBufRot_GlassXfwd; (* Calcolata da 'CalcRotBuf' *)
                        vqShift_TargetTol := vqShift_MovePosTol;
                        vnShift_Cmd := SHFCMD_PLACE_SHEET;
                        Status := STSEQ_PRE;
                        vnSubSheet_PreSts := PRE_SHIFT_BUF;
                        RETURN;
                    (* ELSE (* Rotazione non fattibile *)
                        (* Se per colpa di vqRot_Xmin<CalcRotBuf.Xmin, potrei richiedere REQ_STACKBACK *)
                    END_IF;
                END_IF; (* --- Rotazione lastra in arrivo con ventosa su pomone *)


                (* -- Pinza girapezzi su carrello --
                   Se è presente e abilitato il sistema di rotazione con pinza,
                   provo a vedere se è possibile ruotare la lastra in arrivo *)
                IF (vqWorkSettings & BIT_ENABGRABBER)<>0 AND (* Questo bit comporta un adeguato 'vnGrabber_Type' *)
                   Status=STSEQ_STOP THEN (* Ancora niente rotazione automatica *)
                    (* Sistema rotazione su carrello (pinza) disponibile, valutiamo se fattibile *)
                    (* Scegliamo il lato/senso di rotazione *)
                    IF vbStep_RotSheetOnAlgn THEN
                        (* Intendo ruotarla lato riscontro *)
                        (* Voglio vedere subito qui se è fattibile o no, in
                           modo da richiedere subito la rotazione manuale qui
                           sul carico senza portarla avanti *)
                        (* Argomenti della valutazione *)
                        vqGrab_GlassWidth := vqSubSheet_Width;
                        vqGrab_GlassYbtm := vqYo_SheetFeed;
                        vqGrab_GlassYtop := vqYo_SheetFeed + vqSubSheet_Height;
                        vqGrab_Agrab := 0;
                        vqGrab_Arot := 90E3;
                        vqGrab_Ygrab := NO_POS_UM;
                        (* Valuto *)
                        CalcRotAlgn( What:=ROTARG_INCOMING );  (* Lastra in arrivo *)
                        (* Calcolo il margine di riscontro per ruotare *)
                        CalcAlgnDelta( Width:=vqSubSheet_Width, Height:=vqSubSheet_Height, Align:=vqSubSheet_Width );
                        IF CalcAlgnDelta.Delta<vqAlgn_MinDelta THEN
                            (* Se non fattibile la lascio sul carico e richiedo rotazione manuale *)
                            dlog( Txt:='!! Manually rotate on feed, cannot align %ld', Lvl:=2, Val1:=CalcAlgnDelta.Align/1E3 );
                            SET_MSG(REQ_ROTATEONFEED,'REQ_ROTATEONFEED',0);
                            vbPreRotDone := TRUE; (* Considero già da subito fatto *)
                        ELSIF NOT CalcRotAlgn.Ok THEN
                            (* Se non fattibile la lascio sul carico e richiedo rotazione manuale *)
                            dlog( Txt:='!! Manually rotate on feed', Lvl:=2 );
                            SET_MSG(REQ_ROTATEONFEED,'REQ_ROTATEONFEED',0);
                            vbPreRotDone := TRUE; (* Considero già da subito fatto *)
                        ELSE
                            (* Ok, rotazione fattibile *)
                            dlog( Txt:='Will rotate on Algn', Lvl:=3 );

                            (* Ora devo assicurare a zero il bordo indietro della
                               lastra in modo che possa essere agguantato dalla pinza *)

                            (* Se il bordo indietro è già a zero procedo direttamente alla rotazione *)
                            IF vqSubSheet_X=vqSubSheet_Width THEN
                                vnSubSheet_PreSts := PRE_START_GRAB;
                            (* Se possibile prediligo il trascinamento con stacco perché
                               più veloce e funziona bene con larghezze piccole *)
                            ELSIF vqSubSheet_X>0 AND (* Posizione nota/Bordo avanti su riscontro *)
                                  vqSubSheet_Width<vqShift_GoodWidth AND (* Solo se lastra stretta? *)
                                  fnInRange_DINT(vqSubSheet_X-vqSubSheet_Width, vqDtch_CurrX - vq[ivqAx_PosLim+AX_XS-1] + 1E3, 0) AND (* Bordo indietro trascinabile a zero con stacco *)
                                  vnDtch_Type=2 THEN (* Stacco motorizzato *)
                                (* Uso servizio stacco per spostare il vetro *)
                                vqDtch_GlassWidth := vqSubSheet_Width;
                                vqDtch_GlassXbck := vqSubSheet_X - vqSubSheet_Width; (* Il bordo indietro del vetro (se siamo qui è negativo) *)
                                vqDtch_Tgt := 0; (* Posizione di arrivo desiderata del bordo indietro del vetro *)
                                vnDtch_Cmd := DTCMD_MOVEGLASS;
                                vnSubSheet_PreSts := PRE_DRAG_GRAB;
                                Status := STSEQ_PRE;
                            (* Traslazione con cinghie + riscontro *)
                            ELSE
                                (* Traslazione con cinghie + riscontro *)
                                vqShift_TargetX := vqSubSheet_Width + CalcAlgnDelta.Delta;
                                vqShift_TargetTol := vqShift_AlgnPosTol;
                                vnShift_Cmd := SHFCMD_PLACE_SHEET;
                                vnSubSheet_PreSts := PRE_SHIFT_GRAB;
                                Status := STSEQ_PRE;

                                (* Anticipo il riscontro della rotazione lato riscontri *)
                                vnAlgnBlocks_Sel := 16#FFFF;
                                vqAlgn_Tgt := vqSubSheet_Width;
                                vqAlgnSheet_X := vqShift_TargetX;
                                vqAlgnSheet_Width := vqSubSheet_Width;
                                vqAlgnSheet_Height := vqSubSheet_Height;
                                vbAlgn_UserAlign := FALSE;
                                vnAlgn_Cmd := ALCMD_ALIGN; (* for grab *)
                            END_IF; (* Posizionamento lastra in arrivo per rotazione con pinza *)
                        END_IF; (* Rotazione fattibile *)
                    ELSE
                        (* Intendo ruotarla lato stacco *)
                        (* Valuto... *)
                        (* Calcolo il margine di riscontro per ruotare *)
                        CalcAlgnDelta( Width:=vqSubSheet_Width, Height:=vqSubSheet_Height, Align:=0 );
                        (* La porto un poco oltre lo zero per allineare il bordo avanti a zero *)
                        vqShift_TargetX := CalcAlgnDelta.Delta;
                        vqShift_TargetTol := vqShift_AlgnPosTol;
                        vnShift_Cmd := SHFCMD_PLACE_SHEET;
                        Status := STSEQ_PRE;
                        vnSubSheet_PreSts := PRE_SHIFT_GRAB;

                        (* Potrei anticipare il riscontro, ma forse è meglio di no
                        vnAlgnBlocks_Sel := 16#FFFF;
                        vqAlgn_Tgt := 0;
                        vqAlgnSheet_X := vqShift_TargetX;
                        vqAlgnSheet_Width := vqSubSheet_Width;
                        vqAlgnSheet_Height := vqSubSheet_Height;
                        vbAlgn_UserAlign := FALSE;
                        vnAlgn_Cmd := ALCMD_ALIGN;  (* for grab *)
                    END_IF; (* Tipo di rotazione automatica lastra in arrivo *)

                    (* Preparo carrello inferiore per rotazione lastra in arrivo con pinza *)
                    IF vnCarrInf_Cmd=CMD_STOP AND vnCarriages_Cmd=CMD_STOP AND Status<>STSEQ_STOP THEN (* Rotazione fattibile con pinza *)
                        dlog( Txt:='Preparing to Grab', Lvl:=4 );
                        IF vbGrabber_NotLocked THEN
                            (* Pinza su traino non agganciata (In posizione di aggancio non blocca lo stacco) *)
                            vnCarrInf_Cmd := CARCMD_TRAIL_LOCK;
                        ELSIF NOT vb[ivbAtRest+ID_CARR_INF] THEN
                            (* Carrello in posizione strana? Con la pinza preferisco sempre arrivare dall'alto *)
                            vnCarrInf_Cmd := CARCMD_TOPPARK;
                        END_IF;
                    END_IF;
                END_IF; (* --- Rotazione lastra in arrivo con pinza *)

                (* -- Intercetta se non si procede a ruotare automaticamente -- *)
                IF Status=STSEQ_STOP THEN
                    (* La lastra sarà ruotata a mano *)
                    (* dlog( Txt:='fbStepSeq: ! Cant rotate automatically', Lvl:=4 ); *)
                    (* Segnala che è necessario ruotare manualmente *)
                    IF vnSubSheet_From=ZONE_FEED THEN
                        SET_MSG(REQ_ROTATEONFEED,'REQ_ROTATEONFEED',0);
                    ELSE
                        SET_MSG(REQ_ROTATEBYHAND,'REQ_ROTATEBYHAND',0);
                    END_IF;
                    vbPreRotDone := TRUE; (* Considero già da subito fatto *)
                END_IF;

                (* Assicuro piedini riscontro bassi *)
                IF vnAlgnBlocks_Sts>=TS_GOINGON AND vnAlgn_Cmd=CMD_STOP THEN
                    dlog( Txt:='Resetting AlgnBlocks', Lvl:=4 );
                    vnAlgn_Cmd := CMD_PARK;
                END_IF;

                (* Assicuro carrello superiore in parcheggio *)
                IF NOT vb[ivbAtRest+ID_CARR_SUP] AND vnCarrSup_Cmd=CMD_STOP THEN
                    dlog( Txt:='Parking CarrSup', Lvl:=4 );
                    vnCarrSup_Cmd := CMD_PARK;
                END_IF;

            ELSE (* Non devo nè intestare nè ruotare la lastra *)

                (* Valorizzo subito gli argomenti del servizio di traslazione
                   (anche se non è detto che lo userò) *)
                vqShift_GlassWidth := vqSubSheet_ProcWidth;
                vqShift_GlassYbtm := vqSubSheet_Y;
                vqShift_GlassYtop := vqShift_GlassYbtm + vqSubSheet_ProcHeight;
                vqShift_GlassX := vqSubSheet_X;

                (* In base a destinazione sottolastra *)
                CASE vnSubSheet_To OF
                    ZONE_OUT :
                        (* Non devo processare, devo solo evacuare a valle *)
                        vqShift_TargetX := vqX_OutZoneEnd;
                        vqShift_TargetTol := vqShift_MovePosTol;
                        vnShift_Cmd := SHFCMD_PLACE_SHEET;
                        Status := STSEQ_OUTFWD;
                        dlog( Txt:='Shifting downstream to %ld mm', Lvl:=4, Val1:=vqShift_TargetX/1E3 );
                    ZONE_LOAD :
                        (* Non devo processare, devo solo restituire a monte *)
                        vqShift_TargetX := vqXph_FeedBegin;
                        vqShift_TargetTol := vqShift_MovePosTol;
                        vnShift_Cmd := SHFCMD_PLACE_SHEET;
                        Status := STSEQ_OUTBCK;
                        dlog( Txt:='Shifting upstream to %ld mm', Lvl:=4, Val1:=vqShift_TargetX/1E3 );
                    ZONE_FEED :
                        (* Non devo processare, devo solo inserire nel carico *)
                        vqShift_TargetX := vqXph_FeedNearEnd;
                        vqShift_TargetTol := vqShift_MovePosTol;
                        vnShift_Cmd := SHFCMD_PLACE_SHEET;
                        Status := STSEQ_INS_FEED;
                        dlog( Txt:='Inserting to %ld mm', Lvl:=4, Val1:=vqShift_TargetX/1E3 );
                    ELSE
                        (* Situazione tipica, posiziono per processare
                           Tipicamente la lastra è movimentata dal sistema di traslazione (cinghie),
                           ad eccezione di alcune situazioni particolari:
                             -Lastra già in posizione per essere tagliata
                             -Lastra non movimentabile con cinghie ma arretrabile dai riscontri *)

                        (* Eventuali movimentazioni dei carrelli
                           Nota: I comandi potrebbero essere sovrascritti più sotto *)
                        IF vnCarrInf_Cmd=CMD_STOP AND vnCarriages_Cmd=CMD_STOP THEN
                            (* Parcheggia la pinza se agganciata *)
                            IF vbGrabber_CanBeUnlocked THEN (* Comporta vnGrabber_Type=2 su traino *)
                                dlog( Txt:='Grabber park (%d)', Lvl:=4, Val1:=TO_DINT(vn[ivnStatus+ID_GRABBER]) );
                                IF vn[ivnStatus+ID_GRABBER]<>GSTS_CLOSED THEN
                                    (* Devo gestire pinza non chiusa *)
                                    vnCarriages_Cmd := CARCMD_FULLPARK;
                                ELSE
                                    (* Se ci sarà l'avvicinamento stacco rimango su *)
                                    vnCarrInf_Cmd := SEL(vqSubSheet_ProcWidth>=vqShift_GoodWidth, CARCMD_TRAIL_UNLOCK, CARCMD_FULLPARK);
                                END_IF;
                            END_IF;
                        END_IF;
                        IF vnCarrSup_Cmd=CMD_STOP THEN
                            (* Se schema non basso emissivo e traino mola agganciato, vai a sganciarlo *)
                            IF vbGrLe_CanBeUnlocked AND (vnSheetType & BIT_LOWE)=0 THEN
                                vnCarrSup_Cmd := CARCMD_FULLPARK; (* CARCMD_TRAIL_UNLOCK *)
                            (* Se schema basso emissivo e traino mola non agganciato, vai a prenderlo *)
                            ELSIF vbGrLe_NotLocked AND (vnSheetType & BIT_LOWE)<>0 THEN
                                vnCarrSup_Cmd := CARCMD_TRAIL_LOCK; (* Nella posizione di lock l'area taglio è libera *)
                                vbCarrSup_ParkOnEnd := vqSubSheet_ProcWidth>=vqShift_GoodWidth;
                            (* Se servirà avvicinare lo stacco per far passare la lastra, assicura zona taglio libera *)
                            ELSIF vqSubSheet_X<0 AND vqSubSheet_ProcWidth<vqShift_GoodWidth THEN
                                (* dlog( Txt:='fbStepSeq: Carrs free area', Lvl:=4 ); *)
                                vnCarrSup_Cmd := CARCMD_FREEAREA;
                                IF vnCarrInf_Cmd=CMD_STOP AND vnCarriages_Cmd=CMD_STOP THEN
                                    vnCarrInf_Cmd := CARCMD_FREEAREA;
                                END_IF;
                            (* Preposizionamento dei carrelli *)
                            ELSIF vbCarriages_Prepos AND vbAutoMode THEN
                                (* In base a se dovrò ricercare i bordi Y della lastra *)
                                IF vqY_BtmEdge>=vqY_TopEdge OR vqY_BtmEdge=NO_POS_UM OR vqY_TopEdge=NO_POS_UM THEN
                                    (* Posizione Y non completamente nota *)
                                    (* Preposizionamento carrelli per la ricerca lastra indietro con carrello superiore (ActiveW) *)
                                    IF vbFeat_CarrHomeOnTop AND NOT vbFeat_FixedCarriages THEN
                                        dlog( Txt:='Carr prepos (bcksrch Ytop=%ld)', Lvl:=4, Val1:=(vqSubSheet_Y+vqSubSheet_ProcHeight)/1E3 );
                                        vqCarrSup_Tgt := vqSubSheet_Y + vqSubSheet_ProcHeight - vq[ivqProbe_DY+IRQ_PROBESUP] + 150E3;
                                        IF vqCarrSup_Tgt < vqYsup_TopParkPos THEN
                                            vnCarrSup_Cmd := CMD_MOVETO;
                                        END_IF;
                                        IF vnCarrInf_Cmd=CMD_STOP AND vnCarriages_Cmd=CMD_STOP THEN
                                            vnCarrInf_Cmd := CARCMD_BTMPARK;
                                        END_IF;
                                    (* Preposizionamento carrelli per possibile ricerca lastra al volo (ActiveHP) *)
                                    ELSIF vbEdgeDet_OnTheFly THEN
                                        dlog( Txt:='Carr prepos (park)', Lvl:=4 );
                                        vnCarrSup_Cmd := CMD_PARK;
                                        IF vnCarrInf_Cmd=CMD_STOP AND vnCarriages_Cmd=CMD_STOP AND NOT vb[ivbAtRest+ID_CARR_INF] THEN
                                            vnCarrInf_Cmd := CMD_PARK;
                                        END_IF;
                                    END_IF;
                                ELSE
                                    (* Posizione Y completamente nota (no ricerca) *)

                                    (* Preposizionamento dei carrelli per preincisione senza ricerca vetro *)
                                    IF vbZprescore AND vb[ivbAtRest+ID_DTCH] AND
                                       vnCarrInf_Cmd=CMD_STOP AND vnCarriages_Cmd=CMD_STOP THEN
                                        (* vqY_BtmEdge + vqProc_Ytop === vqY_TopEdge - (vqSubSheet_ProcHeight - vqProc_Ytop) *)
                                        vqCarrSup_Tgt := vqY_BtmEdge + vqProc_Ybtm;
                                        vqCarrInf_Tgt := vqCarrSup_Tgt;
                                        dlog( Txt:='Carr prepos (Zpresc Y=%ld)', Lvl:=4, Val1:=vqCarrSup_Tgt/1E3 );
                                        vnCarrSup_Cmd := CMD_MOVETO;
                                        vnCarrInf_Cmd := CMD_MOVETO;
                                    END_IF;
                                END_IF;
                            (* Assicuro carrello superiore in parcheggio se taglio normale *)
                            ELSIF NOT vb[ivbAtRest+ID_CARR_SUP] AND NOT vbZprescore THEN
                                dlog( Txt:='Parking CarrSup', Lvl:=4 );
                                vnCarrSup_Cmd := CMD_PARK;
                            END_IF;
                        END_IF;

                        (* Intercetto situazione di lastra già posizionata:
                           L'unico caso in cui mi fido è durante le preincisioni, se la posizione
                           ereditata coincide con la quota di riscontro *)
                        IF vbZprescore AND vqSubSheet_X=vqProc_Algn THEN
                            dlog( Txt:='! Already at %ld mm', Lvl:=4, Val1:=vqSubSheet_X/1E3 );
                            Status := SEL( (vbAutoMode AND (vbFeat_FullAuto OR vbZprescore)) OR vbCutAutoStart, STSEQ_STOP, STSEQ_STARTCUT );

                        (* -- Arretramento lastra con i riscontri --
                                   Quando la lastra da tagliare è    vqSubSheet_ProcWidth
                                   prevalentemente sui riscontri      │←‒‒‒‒‒‒‒‒‒‒‒→│
                                   e non riuscirei ad arretrarla      ┌───┼─────────┐
                                   con le cinghie, meglio usare i     │   │         │●
                                   riscontri passando direttamente    │   │         │●
                                   alla fase di riscontro per la      └───┼─────────┘
                                   processazione                      │‒‒→│‒‒‒‒‒‒‒‒→│
                                                                          0    vqSubSheet_X *)
                        ELSIF vqSubSheet_X>vqProc_Algn AND (* Lastra da indietreggiare *)
                              (vbZprescore OR
                                ( (vqX_BeltsEnd-(vqSubSheet_X-vqSubSheet_ProcWidth))<vqBelts_MinGripDX (* Nessun grip sui trasportatori *)
                                  AND (vqSubSheet_X-vqProc_Algn)<500E3 ) ) THEN (* ...Non troppo movimento *)
                            (* Allineo direttamente il taglio, non uso rulli/cinghie *)
                            dlog( Txt:='! Direct align from %ld to %ld mm (Xbck=%ld)', Lvl:=4, Val1:=vqSubSheet_X/1E3, Val2:=vqProc_Algn/1E3, Val3:=(vqSubSheet_X-vqSubSheet_ProcWidth)/1E3 );
                            vnAlgnBlocks_Sel := 16#FFFF; (* All blocks, zero would be also ok *)
                            vqAlgn_Tgt := vqProc_Algn;
                            vqAlgnSheet_X := vqSubSheet_X;
                            vqAlgnSheet_Width := vqSubSheet_ProcWidth;
                            vqAlgnSheet_Height := vqSubSheet_ProcHeight;
                            vbAlgn_UserAlign := FALSE;
                            vnAlgn_Cmd := ALCMD_ALIGN; (* for proc *)
                            (* Procedo direttamente al riscontro del taglio *)
                            Status := STSEQ_PRE;
                            vnSubSheet_PreSts := PRE_ALIGN_PROC;
                        ELSE
                            (* Altrimenti dò mandato al sistema di trasporto vetro *)
                            vqShift_GlassX := vqSubSheet_X;
                            IF vbMustAlign THEN
                                (* Ricalcolo lo spazio di riscontro per supportare eventuale cambio parametri dopo sincronizzazione *)
                                CalcAlgnDelta( Width:=vqSubSheet_ProcWidth, Height:=vqSubSheet_ProcHeight, Align:=vqProc_Algn );
                                vqProc_AlgnDelta := CalcAlgnDelta.Delta;
                                (* Posiziono per riscontrare, porto un po' più avanti... *)
                                vqShift_TargetX := vqProc_Algn + vqProc_AlgnDelta;
                                vqShift_TargetTol := vqShift_AlgnPosTol; (* ...con una certa tolleranza *)
                            ELSE
                                (* Posiziono per processare direttamente, porto nella posizione finale... *)
                                vqShift_TargetX := vqProc_Algn + vqShift_ProcPosFix;
                                vqShift_TargetTol := vqShift_ProcPosTol; (* ...con pocatolleranza *)
                            END_IF;

                            (* Se sto troncando un monolitico: *)
                            IF vbFloatStripesBreak THEN
                                (* Escludi rulli su riscontro *)
                                vbShift_NoRolls := TRUE;
                            END_IF;

                            vnShift_Cmd := SHFCMD_PLACE_SHEET;
                            Status := STSEQ_PRE;
                            vnSubSheet_PreSts := PRE_PLACE_PROC;

                            (* Piedini di riscontro *)
                            (* Start anticipato del riscontro lastra
                               se non bloccheranno le manovre di posizionamento *)

                            IF vbMustAlign AND vbStep_StartAlgnOnCall AND
                               (vqProc_Algn>vqX_ClampAlgnP OR vqSubSheet_Width>vqShift_GoodWidth) THEN
                                dlog( Txt:='Early align', Lvl:=4 );
                                (* Faccio partire la sequenza di riscontro del taglio *)
                                vnAlgnBlocks_Sel := 16#FFFF; (* All blocks, zero would be also ok *)
                                vqAlgn_Tgt := vqProc_Algn;
                                vqAlgnSheet_X := vqShift_TargetX;
                                vqAlgnSheet_Width := vqSubSheet_ProcWidth;
                                vqAlgnSheet_Height := vqSubSheet_ProcHeight;
                                vbAlgn_UserAlign := FALSE;
                                vnAlgn_Cmd := ALCMD_ALIGN; (* for proc *)
                                (* Vedere le condizioni attese in 'ALSEQ_ALGN_GOUP' *)
                            (* Assicuro piedini riscontro bassi *)
                            ELSIF vnAlgnBlocks_Sts>=TS_GOINGON AND vnAlgn_Cmd=CMD_STOP THEN
                                dlog( Txt:='Resetting AlgnBlocks', Lvl:=4 );
                                vnAlgn_Cmd := CMD_PARK;
                            END_IF;

                        END_IF; (* Posiziono per processare *)

                END_CASE; (* In base a destinazione sottolastra *)
            END_IF; (* Devo o non devo ruotare la lastra *)

            (* !Niente comandi qui, il blocco contiene dei RETURN! *)
        END_IF; (* -- Controllo requisiti start passo *)


    (* ------------------------------------------------------------------- *)
    STSEQ_INS_FEED : (* Insert in feed *)
        IF vnShift_Cmd=CMD_STOP THEN
            (* Sequenza terminata, vedi risultato *)
            IF vnShift_Seq=SEQ_DONE THEN
                (* Lastra posizionata correttamente *)
                dlog( Txt:='fbStepSeq: INS_FEED: Done', Lvl:=4 );

                (* Eredità allo step successivo *)
                vqSubSheet_X := NO_POS_UM; (* Inserting in feed *)
                vqSubSheet_Y := NO_POS_UM;

                Status := STSEQ_DONE;

                (* TODO 3: dovrei passarla alla caricatrice con la restituzione sfrido? *)
                (* Status := STSEQ_OUTBCK_LDR; *)
            ELSE
                (* Lastra non ben posizionata *)
                dlog( Txt:='fbStepSeq: !! INS_FEED: Error', Lvl:=1 );
                SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0);
                Status := STSEQ_STOP;
            END_IF;
        ELSE
            vqSubSheet_X := vqShift_GlassX; (* Monitora movimento lastra in arrivo *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    STSEQ_OUTFWD : (* Move downstream (shift to align module) *)
        IF vnShift_Cmd=CMD_STOP THEN (* vn[ivnStatus+ID_SHIFT]=SHF_IDLE *)
            (* Sequenza terminata, vedi risultato
               Ho comandato il bordo avanti a vqShift_TargetX := vqX_OutZoneEnd;
               non è detto che riesca a raggiungerla, mi aspetto che fallisca
               se vqShift_GlassWidth<vqX_OutZoneEnd *)
            IF vnShift_Seq=SEQ_DONE THEN
                (* Lastra posizionata correttamente *)
                (* Eventualmente ora potrebbe mancare una espulsione
                   fuori dal modulo riscontro con cinghiette uscita o
                   spingendo coi riscontri stessi; questo ha senso se
                   c'è qualcosa a valle *)
                dlog( Txt:='fbStepSeq: OUTFWD: Done?', Lvl:=4 );
                (* Eredità allo step successivo *)
                vqSubSheet_X := NO_POS_UM; (* Shifted forward *)
                vqSubSheet_Y := NO_POS_UM;
                Status := STSEQ_DONE;
            ELSIF vqSubSheet_X>=vqShift_GlassWidth AND vqSubSheet_X<vqShift_TargetX AND vnAlgn_DeliverCmd=CMD_STOP THEN
                (* Sono tutto sul modulo riscontri ma non sono arrivato, forse perché le
                   cinghie non possono portare il vetro fino a 'vqShift_TargetX'?
                   Provo ad usare servizio di estrazione pezzo *)
                vnAlgnDlvr_Id := vnSubSheet_Id;
                vbAlgnDlvr_Prescored := FALSE;
                vqAlgnDlvr_Xbck := vqSubSheet_X - vqShift_GlassWidth;
                vqAlgnDlvr_Tgt := vqX_OutZoneEnd;
                vqAlgnDlvr_Width := vqShift_GlassWidth;
                vqAlgnDlvr_Ybtm := vqShift_GlassYbtm;
                vqAlgnDlvr_Ytop := vqShift_GlassYtop;
                vnAlgn_DeliverCmd := DLVCMD_END;
                vnPieceDelivering := vnSubSheet_Id; (* see: vnPieceTaken *)
                Status := STSEQ_OUTFWD_END; (* Procedi ad evacuare a fine linea coi riscontri *)
            ELSE
                (* Lastra non ben posizionata *)
                dlog( Txt:='fbStepSeq: !! OUTFWD: Error', Lvl:=1 );
                SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0);
                Status := STSEQ_STOP;
            END_IF;
        ELSE
            vqSubSheet_X := vqShift_GlassX; (* Monitora movimento lastra in arrivo *)
        END_IF;


    (* ------------------------------------------------------------------- *)
    STSEQ_OUTFWD_END : (* Move downstream (second movement) *)
        (* Sequenza emissione a fine linea *)
        IF vnAlgn_DeliverCmd=CMD_STOP THEN
            (* Sequenza terminata, vediamo il risultato *)
            IF vnAlgn_DeliverSeq=SEQ_DONE THEN
                (* Lastra consegnata *)
                (* Eredità allo step successivo *)
                vqSubSheet_X := NO_POS_UM; (* Delivered forward *)
                vqSubSheet_Y := NO_POS_UM;
                Status := STSEQ_DONE;
            ELSE
                (* La lastra va prelevata a mano dai riscontri *)
                (* dlog( Txt:='fbStepSeq: !! OUTFWD_END: Error', Lvl:=4 ); *)
                vnPieceTaken := SEL( vnSubSheet_Id>0, 0, vnSubSheet_Id );
                Status := STSEQ_STOP;
            END_IF;
        END_IF;


    (* ------------------------------------------------------------------- *)
    STSEQ_OUTBCK : (* Move upstream (shift approach) *)
        IF vnShift_Cmd=CMD_STOP THEN (* vn[ivnStatus+ID_SHIFT]=SHF_IDLE *)
            (* Sequenza terminata, vedi risultato *)
            IF vnShift_Seq=SEQ_DONE THEN
                (* Lastra posizionata correttamente *)
                dlog( Txt:='fbStepSeq: OUTBCK: Done', Lvl:=4 );

                (* Eredità allo step successivo *)
                vqSubSheet_X := NO_POS_UM; (* Shifted backward *)
                vqSubSheet_Y := NO_POS_UM;

                Status := STSEQ_DONE;

                (* TODO 3: dovrei passarla alla caricatrice con la restituzione sfrido? *)
                (* Status := STSEQ_OUTBCK_LDR; *)
            ELSE
                (* Lastra non ben posizionata *)
                dlog( Txt:='fbStepSeq: !! OUTBCK: Error', Lvl:=1 );
                SET_MSG(REQ_TAKE_REMN,'REQ_TAKE_REMN',0);
                Status := STSEQ_STOP;
            END_IF;
        ELSE
            vqSubSheet_X := vqShift_GlassX; (* Monitora movimento lastra in arrivo *)
        END_IF;


    (* -------------------------------------------------------------------
    STSEQ_OUTBCK_LDR : (* Move upstream (to loader) *)


    (* ------------------------------------------------------------------- *)
    STS_IDLE : (* Doing nothing *)

        (* Se non c'è lavoro caricato, reset richieste inutili *)
        IF JobData.JustInvalid THEN
            RST_MSG_IF_ON(REQ_FINISHCUT);
            RST_MSG_IF_ON(REQ_GET_SHEET);
            RST_MSG_IF_ON(REQ_STACK_REMN);
            RST_MSG_IF_ON(REQ_ROTATEBYHAND);
            RST_MSG_IF_ON(REQ_ROTATEONFEED);
            RST_MSG_IF_ON(REQ_DOALIGN);
            (* Non le richieste funzionali alla consegna dell'ultimo pezzo! *)
            (* RST_MSG_IF_ON(REQ_BACK_REMN); *)
        END_IF;

        (* Rispondi ai comandi *)
        IF Cmd<>0 THEN
            (* Rispondo ai comandi se c'è un lavoro correttamente caricato *)
            IF JobData.Valid THEN
                (* TODO 3: Timestamp of the start step *)
                (* Watch( Act:=1 ); *)
                (* vdStartStepDate := Watch.DateTime; *)

                (* Comando di movimentazione lastra *)
                IF Cmd=STSEQ_STARTPRE THEN
                    (* Condizioni per avvio esecuzione di un nuovo step
                         .Scarto sullo stacco prelevato
                         .La liberazione della zona a fine linea è gestita all'interno delle sequenze *)
                    IF IS_MSG(REQ_TAKE_REMN) OR IS_MSG(REQ_DUMP_REMN) THEN
                        dlog( Txt:='fbStepSeq: !! Remn on Dtch', Lvl:=1 );
                        Cmd := 0;
                    ELSE
                        Status := STSEQ_STARTPRE;
                    END_IF;

                (* Comando di start processazione vetro/taglio *)
                ELSIF Cmd=STSEQ_STARTCUT THEN
                    RST_MSG_IF_ON(REQ_FINISHCUT);
                    Status := STSEQ_STARTCUT;

                (* Comando di post-movimentazione *)
                ELSIF Cmd=STSEQ_STARTPOST THEN
                    (* Product rotation, park remnant, piece out *)
                    Status := STSEQ_STARTPOST;

                ELSE
                    dlog( Txt:='fbStepSeq: !! Unknown cmd=%d', Lvl:=1, Val1:=TO_DINT(Cmd));
                    Cmd := 0;
                END_IF;
            ELSE
                dlog( Txt:='fbStepSeq: ! No valid job loaded', Lvl:=1 );
                SET_MSG(MSG_NOJOB,'MSG_NOJOB',0);
                Cmd := 0;
            END_IF;
        ELSIF ProcSeq.Status>TS_GOINGOFF THEN
            dlog( Txt:='fbStepSeq: ! ProcSeq running', Lvl:=1 );
            ProcSeq( Execute:=FALSE );
            Status := STSEQ_STOP;
        END_IF;



    (* ------------------------------------------------------------------- *)
    STSEQ_DONE : (* Step done *)
        (* A seconda della modalità automatica o manuale *)
        IF vbAutoMode THEN
            (* In automatico proseguo col passo successivo *)
            dlog( Txt:='fbStepSeq: >> Step done (auto)', Lvl:=3 );
            (* Prima di caricare un nuovo passo... *)
            vbZprescored_Done := vbZprescore;
            (* Devo rilevare se nel frattempo qualcuno ha cambiato lo schema?
               Nota: Se sto lavorando non permetto di cambiare schema (v. BIT_SETSCHEME) *)
            (* Carico il passo successivo *)
            JobData( Cmd:=BIT_NXTSTEP ); (* Get next step (auto mode) *)
            (* Nota: ricorda che ci sono dei dati in eredità allo step successivo
                     (flusso automatico) vqSubSheet_X, vqSubSheet_Y, ... *)
            (* Rilevo completamento schema ed errori di caricamento passo *)
            IF vbSchemeDone THEN
                dlog( Txt:='>> Scheme done', Lvl:=3 );
                Status := STSEQ_STOP;
            ELSIF NOT JobData.Valid THEN
                dlog( Txt:='!! Invalid next step', Lvl:=2 );
                Status := STSEQ_STOP;
            ELSE
                (* Ok, got a new valid step, prosecute to work *)
                Status := STSEQ_STARTPRE;
            END_IF;
        ELSE
            (* In manuale mi fermo *)
            dlog( Txt:='fbStepSeq: >> Step done (man)', Lvl:=4 );
            Status := STSEQ_STOP;
        END_IF;



    (* ------------------------------------------------------------------- *)
    ELSE (* STSEQ_STOP *)
        IF NOT JustAborting THEN
            JustAborting := TRUE;
            dlog( Txt:='fbStepSeq: Aborting (%d)', Lvl:=4, Val1:=TO_DINT(ProcSeq.Status) );
        END_IF;

        Cmd := 0; (* Eat command *)

        (* Ferma eventuali movimentazioni eccetto l'inserzione nel carico *)
        IF( vn[ivnStatus+ID_SHIFT]<>SHF_INS_FEED ) THEN vnShift_Cmd:=CMD_STOP; END_IF;
        vbShift_DumpRemn := FALSE;
        IF vnAlgn_Cmd<>CMD_PARK THEN vnAlgn_Cmd := CMD_STOP; END_IF;

        (* Stop sequenze processazione *)
        IF NOT (vnCarriages_Cmd>=CMD_PARK AND vnCarriages_Cmd<=CARCMD_FULLPARK) THEN
            (* Parcheggio carrelli non in corso *)
            vnCarriages_Cmd := CMD_STOP;
            IF NOT (vnCarrSup_Cmd>=CMD_PARK AND vnCarrSup_Cmd<=CARCMD_FULLPARK) THEN vnCarrSup_Cmd:=CMD_STOP; END_IF;
            IF NOT (vnCarrInf_Cmd>=CMD_PARK AND vnCarrInf_Cmd<=CARCMD_FULLPARK) THEN vnCarrInf_Cmd:=CMD_STOP; END_IF;
        END_IF;
        IF vnDtch_Cmd<>CMD_MOVETO THEN vnDtch_Cmd:=CMD_STOP; END_IF; (* Nota: CMD_PARK si trasforma in un CMD_MOVETO *)

        (* Permetti l'evoluzione dello stop della sequenza taglio *)
        IF ProcSeq.Status>TS_OFF THEN
            ProcSeq( Execute:=FALSE );
        ELSIF NOT Abort THEN
            JustAborting := FALSE;
            Status := STS_IDLE;
        END_IF;

END_CASE; (* -- state machine *)

(* -- Manage stop signal -- *)
IF Abort AND Status>STSEQ_DONE AND Status<>STSEQ_POST THEN
    IF Status=STSEQ_PRE THEN
        dlog( Txt:='fbStepSeq: !! Abort pre-ops (%d) step %d', Lvl:=2, Val1:=TO_DINT(vnSubSheet_PreSts), Val2:=TO_DINT(vnStepIndex) );
    ELSIF Status=STSEQ_CUT THEN
        dlog( Txt:='fbStepSeq: !! Abort cut step %d', Lvl:=2, Val1:=TO_DINT(vnStepIndex) );
    (* ELSIF Status=STSEQ_POST THEN
        dlog( Txt:='fbStepSeq: !! Abort post-ops (%d,%d) step %d', Lvl:=2, Val1:=TO_DINT(vnProd_PostSts), Val2:=TO_DINT(vnRemn_PostSts), Val3:=TO_DINT(vnStepIndex) ); *)
    END_IF;
    Status := STSEQ_STOP;
END_IF;


(* -- Monitors -- *)
vnTmpStackedSize := i_TmpStacked.Size;
AtRest := Status=STS_IDLE;
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_FUNCTION_BLOCK




	(********************)
	(*                  *)
	(*     PROGRAMS     *)
	(*                  *)
	(********************)



PROGRAM Signals

{ DE:"Segnali comuni alle macchine laminato" }

	VAR
	NotifyPulse : fbPulseTrain; { DE:"User notification pulses" }
	ErrorPulse : Tmono; { DE:"Error notification pulse" }
	END_VAR

	{ CODE:ST }(*    Signals (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Gestione dei segnali e utilità di monitoraggio
      comuni alle macchine laminato.
*)

IF Mach.Status>MS_INIT THEN

    (* - Luci semaforo -
         .Durante boot lampeggiano tutte insieme a 4Hz
         .Durante macchina in test lampeggiano tutte insieme a 1Hz
         .Altrimenti vedi sotto *)
    IF Mach.Status=MS_TEST THEN
        (* In modalità di test faccio lampeggiare tutto a 1Hz *)
        O_RED_LIGHT := vbBlink1Hz;
        O_YELLOW_LIGHT := vbBlink1Hz;
        O_GREEN_LIGHT := vbBlink1Hz;
    ELSE
        (* La luce rossa riguarda l'esecuzione del lavoro, se è accesa
           c'è qualche sequenza in corso *)
        IF Cnc.Chn1.Status>CS_READY THEN
            O_RED_LIGHT := vbBlink2Hz; (* Programma in corso *)
        ELSIF Mach.Busy OR FeedTilt.Operating THEN
            O_RED_LIGHT := vbBlink1Hz; (* Sequenza in corso *)
        (*ELSIF Mach.Freeze THEN
            O_RED_LIGHT := TRUE; (* Sequenza in pausa *)
        ELSE
            O_RED_LIGHT := FALSE;
        END_IF;
        (* ┌──────────────────┬───────────────────────────────────┐
           │ Red light        │ Meaning                           │
           ├──────────────────┼───────────────────────────────────┤
           │ Off              │ Machine idle, can go inside       │
           │ Slow blink (1Hz) │ Other function in progress        │
           │ Mid blink (2Hz)  │ Executing a program (channel1)    │
           │ Fast blink (4Hz) │ Machine booting                   │
           │ On (fixed)       │ Sequence paused                   │
           └──────────────────┴───────────────────────────────────┘ *)

        (* La luce gialla riguarda allarmi e messaggi *)
        O_YELLOW_LIGHT := (Mach.Status<>MS_ERROR AND vqRequestActive<>0 AND vbBlink1Hz) OR
                          (Mach.Status=MS_ERROR AND vbBlink4Hz);
        (* ┌──────────────────┬───────────────────────────────────┐
           │ Yellow light     │ Meaning                           │
           ├──────────────────┼───────────────────────────────────┤
           │ Off              │ No emergency or requests          │
           │ Slow blink (1Hz) │ Requesting something to operator  │
           │ Mid blink (2Hz)  │                                   │
           │ Fast blink (4Hz) │ Emergency status or booting       │
           │ On (fixed)       │                                   │
           └──────────────────┴───────────────────────────────────┘ *)

        (* La luce verde riguarda le attuazioni (assi e pneumatica) *)
        O_GREEN_LIGHT := Mach.ActReady AND ( (NOT Scu.PreAlarm AND (vbHomingDone OR vbBlink1Hz))
                                              OR (Scu.PreAlarm AND vbBlink4Hz) );
        (* ┌──────────────────┬───────────────────────────────────┐
           │ Green light      │ Meaning                           │
           ├──────────────────┼───────────────────────────────────┤
           │ Off              │ Actuations not ready              │
           │ Slow blink (1Hz) │ Actuations ready, homing not done │
           │ Mid blink (2Hz)  │                                   │
           │ Fast blink (4Hz) │ Safety in prealarm or booting     │
           │ On (fixed)       │ Actuations ready, homing done     │
           └──────────────────┴───────────────────────────────────┘ *)
    END_IF; (* -- Luci semaforo *)


    (* Notifiche sicurezze *)
    O_SAFETY_LIGHT := (I_SCU_SAFETY_MACH OR I_SCU_SAFETY_IN) AND vbBlink1Hz;
    (* Nota: Nelle macchine combinate la sicurezza da monolitico è in 'I_SCU_POW_CA' *)
    (* O_SAFETY_LIGHT_PROC := (NOT I_SCU_POW_Y OR NOT I_SCU_POW_X) AND vbBlink1Hz; *)
    (* O_SAFETY_LIGHT_FEED := NOT I_SCU_POW_C AND vbBlink1Hz; *)


    (* Strisce LED
       Modulabili in RGB: R+G=Yellow, G+B=Cyan, R+B=Magenta, R+G+B=White *)
    (* Striscia LED zona riscontri *)
    O_ALGN_LIGHT_R := ( StepSeq.Status<>STS_IDLE AND NOT O_SCU_OUTZONE_BUSY ) OR (* Mach.Busy *)
                      vnAlgn_DeliverCmd<>CMD_STOP OR (* vnAlgn_DeliverSeq>SEQ_DONE *)
                      BeltsOutZone.Status>=BLT_ENABLING OR
                      TiltOut.Status=TL_GOINGDOWN;
    O_ALGN_LIGHT_G := O_SCU_OUTZONE_BUSY;
    O_ALGN_LIGHT_B := O_SAFETY_LIGHT AND NOT (O_ALGN_LIGHT_R OR O_ALGN_LIGHT_G);


    (* Striscia LED zona premilastra riscontro *)
    O_CLAMP_ALGN_LIGHT_R := Mach.Busy OR vnProcPhase<>0 OR vnClampAlgn_Cmd<>CMD_STOP OR vnClampDtch_Cmd<>CMD_STOP;
    O_CLAMP_ALGN_LIGHT_G := Mach.ActReady AND ClampAlgn.AtRest AND NOT O_CLAMP_ALGN_LIGHT_R;
    O_CLAMP_ALGN_LIGHT_B := O_SAFETY_LIGHT AND NOT (O_CLAMP_ALGN_LIGHT_R OR O_CLAMP_ALGN_LIGHT_G);
    (* Striscia LED zona premilastra stacco *)
    O_CLAMP_DTCH_LIGHT_R := O_CLAMP_ALGN_LIGHT_R;
    O_CLAMP_DTCH_LIGHT_G := Mach.ActReady AND ClampDtch.AtRest AND NOT O_CLAMP_DTCH_LIGHT_R;
    O_CLAMP_DTCH_LIGHT_B := O_CLAMP_ALGN_LIGHT_B;


    (* Notifiche richiesta intervento operatore *)
    O_NOTIFY_REQ_BLINK := vqRequestActive<>0 AND vbBlink1Hz;
    (* Impulso notifica per segnalazione acustica, reiterata ogni T secondi *)
    NotifyPulse( in:=vqRequestActive<>0, T:=TO_UDINT(3 * vqNotifyPulseTime), pt:=TO_UDINT(vqNotifyPulseTime) );
    O_NOTIFY_REQ_PULSE := NotifyPulse.pulse;

    (* Segnalazione errore critico, impulso singolo *)
    ErrorPulse( in:=Mach.Status=MS_ERROR, pt:=TO_UDINT(vqNotifyPulseTime) );
    O_NOTIFY_ERR_PULSE := ErrorPulse.q;


    (* -- Monitor risorse condivise -- *)
    vnLowerCutZone_Algn := LowerCutZone_Algn;
    vnLowerCutZone_Dtch := LowerCutZone_Dtch;
    vnUpperCutZone := UpperCutZone;
    vnPowerSource  := PowerSource;


    (* - Interazione con magazzino - *)
    (* Segnale di lastra quasi terminata per preparare il carico di quella
       successiva: se non ho più inserzioni da fare nel tavolo di carico *)
    O_LDR_ALMOSTDONE := vbSchemeAlmostDone AND vbAutoMode AND StepSeq.Status>STS_IDLE; (* vn[ivnStatus+ID_STEPSEQ] *)

    (* Richiesta di una nuova lastra:
       -quando richiedo un trasferimento con caricatrice non pronta *)
    IF vnShiftFeed_Cmd=SHFCMD_FEED_LOAD AND NOT Loader.SheetReady AND vnLoader_Type>0 THEN (* IS_MSG(MSG_LDR_CANT_FWD) *)
        (* Al comando di trasferimento lastra ma con rulliera non pronta *)
        IF NOT O_LDR_NEXTSHEET THEN
            dlog( Txt:='Signals: Machine wants next sheet ON', Lvl:=3 );
            O_LDR_NEXTSHEET := TRUE;
        END_IF;
    ELSIF vnShiftFeed_Sts=SHF_FEED_LDPASS THEN
        (* Durante il trasferimento *)
        IF O_LDR_NEXTSHEET THEN
            dlog( Txt:='Signals: Machine wants next sheet OFF', Lvl:=3 );
            O_LDR_NEXTSHEET := FALSE;
            O_LDR_HAVESCRAP := FALSE;
        END_IF;
    END_IF;
    (* O_LDR_NEXTSHEET := O_LDR_NEXTSHEET OR O_LDR_ALMOSTDONE; *)

    (* Segnalazione presenza sfrido da restituire:
       -quando richiedo la restituzione sfrido con caricatrice non pronta *)
    IF vnShiftFeed_Cmd=SHFCMD_FEED_UNLOAD AND NOT Loader.CanReceive AND vnLoader_Type>0 THEN (* IS_MSG(MSG_LDR_CANT_BCK) *)
        (* Al comando di restituzione ma con rulliera non pronta *)
        IF NOT O_LDR_HAVESCRAP THEN
            dlog( Txt:='Signals: Machine has scrap ON', Lvl:=3 );
            O_LDR_HAVESCRAP := TRUE;
        END_IF;
    ELSIF vnShiftFeed_Sts=SHF_FEED_UNLDPASS THEN
        (* Durante la restituzione *)
        IF O_LDR_HAVESCRAP THEN
            dlog( Txt:='Signals: Machine has scrap OFF', Lvl:=3 );
            O_LDR_HAVESCRAP := FALSE;
        END_IF;
    END_IF;

    (* Segnale abilitazione operazione di rimozione bava plastico *)
    O_LDR_EDGETRIM := (vqWorkSettings & BIT_EDGETRIM)<>0;

ELSE (* Starting *)
    O_RED_LIGHT := vbBlink4Hz;
    O_YELLOW_LIGHT := vbBlink4Hz;
    O_GREEN_LIGHT := vbBlink4Hz;
END_IF; (* --- Machine started *)

END_PROGRAM




PROGRAM Stats

{ DE:"Statistiche e manutenzione" }

	{ CODE:ST }(*    Stats (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Statistiche e manutenzione
*)

(*
IF Mach.Status>MS_INIT THEN
END_IF;
*)

(* Maintain tools statistics
IF Tinf.Output THEN
    vdTinf_Travel := vdTinf_Travel + 1.666667E-8 * TO_LREAL(Yinf.CurrSpd) * vdPlcScanTime;
END_IF;
*)

(* Servizio reset statistiche - Nota: solo se autorizzato *)
IF vbBtnResetStats AND (vbSelAuthorized OR vbSelTechnician) THEN
    vbBtnResetStats := FALSE; (* Eat *)
    vbSelAuthorized := FALSE; (* Revoke temporary auth *)

    (* Contatori *)
    vqBootsCount    := 0;
    vqLoadsCount    := 0;
    vqProjectsCount := 0;
    vqSchemesCount  := 0;
    vqProcCount     := 0;
    vqPiecesCount   := 0;
    vqUnloadsCount  := 0;

    (* Utensili
    vdKnife_TravelDist := 0.0;
    vdGrLe_TravelDist := 0.0;
    vdScraper_TravelDist := 0.0;
    vdMrk_TravelDist := 0.0;
    *)
END_IF;

(* TODO 1: Controllo usura parti da statistiche e notifiche manutenzione
Set statistiche risalenti all'ultima manutenzione
Blocco manutenzione
*)
END_PROGRAM




PROGRAM Services

{ DE:"Interfaccia comune a comandi e servizi delle macchine laminato" }

	VAR
	CmdStop : fbEdges; { DE:"Fronti del comando di stop" }
	CmdPark : RiseEdge; { DE:"Fronte del comando parcheggio" }
	CmdMoveAndAlign : RiseEdge; { DE:"Fronte del comando posizionamento e riscontro vetro" }
	CmdStartCut : RiseEdge; { DE:"Fronte del comando start taglio" }
	CmdStartAuto : RiseEdge; { DE:"Fronte del comando start movim automatico" }
	CmdCustom1 : RiseEdge; { DE:"Fronte del comando personalizzabile 1" }
	CmdCustom2 : RiseEdge; { DE:"Fronte del comando personalizzabile 2" }
	PrgTest : INT; { DE:"Last Prg test code" }
	StartShape_Cmd : INT; { DE:"Last start shape command" }
	AutoLoad : RiseEdge; { DE:"Fronte per carico automatico" }
	ParkAfterStop : BOOL; { DE:"Esegui parcheggio dopo richiesta di stop" }
	TDeferredExpiration : Ton; { DE:"Timeout azione deferita" }
	END_VAR

	{ CODE:ST }(*    Services (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Interfaccia comune ai comandi e servizi delle
      macchine laminato, gestione comandi e servizi
      comuni.
*)

(* -- Settaggi di lavoro -- *)
(* Assicura solo funzioni abilitate *)
vqWorkSettings := vqEnabledSettings & vqWorkSettings;
(* IF vnSpdOvd>100 THEN vnSpdOvd:=100; END_IF; *)



(* -- Reset comandi attuazioni --
      .Attuazioni e servizi da PLC *)
IF vbRstSvcs OR Mach.Status=MS_JUSTERROR THEN
    dlog( Txt:='[Services] vbRstSvcs', Lvl:=3 );

    (* EraseArray( Type:=TYP_VB, Idx:=ivbSvcs, Size:=100 ); *)
    (* EraseArray( Type:=TYP_VN, Idx:=ivnSvcs, Size:=100 ); *)
    (* EraseArray( Type:=TYP_VQ, Idx:=ivqSvcs, Size:=100 ); *)

    (* Servizi Sipro *)
    vb[iVB_AX_JOG_MENO+20*(AX_XS-1)] := FALSE; (* Jog stacco usato nell'azzeramento *)

    (* Proporzionali *)
    vqPV1_Yinf_P := 0;
    vqPV2_Yinf_P := 0;
    vqPV1_Ysup_P := 0;
    vqPV2_Ysup_P := 0;
    vqPV3_Ysup_P := 0;
    vqPV1_Dtch_P := 0;

    (* Riscontri *)
    vnAlgnBlocks_Cmd := 0; (* Leave blocks where are *)
    vnAlgnBlocks_Sel := 0; (* Reset blocks selection *)
    vnAlgn_Cmd := CMD_STOP;
    vnAlgn_DeliverCmd := CMD_STOP;
    vnAlgn_DragCmd := CMD_STOP;
    vbAlgnEvac_Scheduled := FALSE;
    (* vqAlgnEvac_Xbck := NO_POS_UM; (* Nah, meglio ricordarselo! *)
    vqAlgnDlvr_PausePos := 0;
    vbAlgnDlvr_AlmostDone := FALSE;
    (* Eat possible temporary selectors *)
    vbAlgn_UserAlign := FALSE;
    vbAlgn_FreezeToPlace := FALSE;
    vbAlgn_FastPush := FALSE;
    vbAlgn_IgnoreDragCmds := FALSE;

    (* Ribaltina *)
    vnTiltOut_Cmd := 0;

    (* Carrelli *)
    vnCarrSup_Cmd := 0;
    vnCarrInf_Cmd := 0;
    vbCarrSup_ParkOnEnd := FALSE;
    vbCarrInf_ParkOnEnd := FALSE;

    (* Stacco *)
    vnDtch_Cmd := 0;

    (* Attuazioni area taglio *)
    vnBrkBar_Cmd := 0;
    vbBrkBar_MidShift := FALSE;
    vbLampOut_Cmd := FALSE;
    vbLampOn_Cmd := FALSE;
    vnHoldPads_Cmd := 0;
    (* vbLubScore_Cmd := FALSE; *)
    vnClampAlgn_Cmd := CMD_STOP;
    vnClampDtch_Cmd := CMD_STOP;
    vqClampAlgn_P := 0;
    vqClampDtch_P := 0;

    (* Attuazioni area carico *)
    vbFeedWheels_Cmd := FALSE;

    (* Comandi utensili *)
    vbTinf_Cmd := FALSE;
    vbTsup_Cmd := FALSE;
    vqTinf_P := 0;
    vqTsup_P := 0;
    vbRinf_SelC := FALSE;
    vbRinf_Cmd := FALSE;
    vbRsup_SelC := FALSE;
    vbRsup_Cmd := FALSE;
    vqRinf_P := 0;
    vqRsup_P := 0;
    vnBladeSup_Cmd := CMD_STOP;
    vnBladeInf_Cmd := CMD_STOP;
    vnGrLe_Cmd := 0;
    vqGrLe_P := 0;
    vbDustBlow_Cmd := FALSE;
    vnGrabber_Cmd := 0; (* do nothing *)
    vqZgSetTorqueLim := NO_POS_UM;
    vnRollPreRot_Cmd := CMD_STOP;
    vbEdgeTrim_Cmd := FALSE;

    (* Utensili sagomato *)
    vnGrLe2_Cmd := CMD_STOP;
    vbTsup2_Cmd := FALSE;
    vbTinf2_Cmd := FALSE;
    vbRsup2_Cmd := FALSE;
    vbRinf2_Cmd := FALSE;

    (* Sistema rotazione su polmone *)
    vbBufGrabCup_Cmd := FALSE; (* Nota: mollerà solo con Zb fermo *)
    vnBufRot_Cmd := 0;

    (* Ventilatori cuscino aria *)
    vnVents_Cmd := 0;
    vnVents_CmdOvl := 0;
    vnVents_MotorOff := 0;
    vbVents_MotorsOn := FALSE;
	vnVentProd_Flux := 100; (* Ripristino massimo flusso *)
	vnVentRemn_Flux := 100;
	vnVentFeed_Flux := 100;

    (* Trasportatori *)
    vnBelts_Cmd := CMD_STOP;
    vnShift_Cmd := CMD_STOP;
    IF vnShiftFeed_Cmd<>SHFCMD_FEED_INSPLACE THEN vnShiftFeed_Cmd := CMD_STOP; END_IF;
    vnShiftAlgn_Cmd := CMD_STOP;
    vbShift_DumpRemn := FALSE;
    vbShift_NoRolls := FALSE;
    vbShift_KeepAirOn := FALSE;
    (* ShftOp *)
    (* vbBtnStartLabeling := FALSE; *)
    vqRollsAlgn_Target := 0;
    (* Normalmente meglio non disattivare le cinghie, a meno che non siano già ferme *)
    IF Belts.Status<=BLT_ENABLED THEN
        Belts( Cmd:=CMD_STOP );
        vnBelts_Act := 0;
    END_IF;

    (* Gantry: assicura assi gemelli agganciati *)
    vn[ivnAx_Cmd+AX_XR2-1] := 0; (* Aggancia *)
    vn[ivnAx_Cmd+AX_XS2-1] := 0; (* Aggancia *)
    vn[ivnAx_Cmd+AX_PR2-1] := 0; (* Aggancia *)
    vn[ivnAx_Cmd+AX_PS2-1] := 0; (* Aggancia *)

    (* Servizi etichettatore *)
    IF vnLabeler_Type>0 AND O_LBLAPPL_ASP THEN
        SET_MSG(REQ_TAKELABEL,'REQ_TAKELABEL',0);
    END_IF;
    vbBtnStartLabeling := FALSE;
    vnLblBrdg_Cmd := CMD_STOP;
    vbLblAppl_Out := FALSE;
    vbLblAppl_Put := FALSE;
    vnLblPrn_Cmd  := -1; (* -1:reset *)
    vnLbl_Print := 0;
    vnLbl_Put := 0;
    (* vbLblPrn_Emulated := FALSE; *)
    vnHmi_SendPrint := 0; (* vnLbl_NxtId := 0; *)
    vnHmi_SendData := 0;

    (* Servizi vari *)
    vbBtnCustom1 := FALSE;
    vbBtnCustom2 := FALSE;
    vbHeatLamp_ManCmd := FALSE;
    vnShapeProc_Cmd := 0;
    vnDeferredAction := CMD_STOP;

    (* Altri stati *)
    vnProcPhase := 0;
    vnGrab_RotStatus := 0;

    (* Modi di funzionamento *)
    IF vbAutoMode THEN
        (* Assicura di uscire dalla modalità sagoma *)
        vnSelWorkMode := vnSelWorkMode & NOT (BIT_SHAPEMODE OR BIT_SLANTMODE);
    END_IF;

    (* Test *)
    PrgTest := 0;
    vnPrgTest := PrgTest;
    vnPlcTest := 0;

    (* Finally *)
    vbRstSvcs := FALSE; (* Eat *)
END_IF; (* vbRstSvcs *)



(* -- Stop/abort command -- *)
CmdStop( in:=vbBtnStop );
IF CmdStop.rise THEN
    (* Devo rispondere alla richiesta di stop *)
    vbStopSignal := TRUE; (* Questo è il segnale propagato e gestito nei vari moduli *)

    (* Abort or pause Cnc programs -channel 1- *)
    IF Cnc.Chn1.Status>CS_READY THEN (* First channel *)
        dlog( Txt:='[Services] vbBtnStop (Chn1 run)', Lvl:=4 );
        (* Abortisco tutto: *)
        (* Cnc.Chn1.AbortPrg := TRUE; (* Stop just this channel *)
        Cnc.Reset := TRUE; (* Abort all channels *)
        vbBtnReset := TRUE; (* Reset alarms/messages, services *)
        (* Altrimenti, se volessi solo pausare: *)
        (* Cnc.Chn1.Hold := TRUE; (* Freeze program if was running *)
    (* Se non stavo facendo nulla, resetto emergenze/messaggi *)
    ELSIF Mach.Status=MS_BUSY THEN
        (* Il segnale di stop bloccherà ciò che stava facendo *)
        dlog( Txt:='[Services] vbBtnStop (MS_BUSY)', Lvl:=4 );
        vbBtnReset := TRUE; (* Reset alarms/messages, services *)
    ELSE
        dlog( Txt:='[Services] vbBtnStop (still)', Lvl:=4 );
        vbBtnReset := TRUE; (* Reset alarms/messages, services *)
    END_IF;
(* Azioni allo stop mantenuto *)
ELSIF vbStopHeldSignal THEN
    (* Assicuro cinghie disattivate *)
    Belts( Cmd:=CMD_STOP );
    vnBelts_Act := 0;
ELSIF CmdStop.fall THEN
    vbStopSignal := FALSE; (* Richiesta non più attiva, posso togliere segnale *)
    (* Se è richiesto un comando parcheggio dopo lo stop *)
    IF ParkAfterStop THEN
        ParkAfterStop := FALSE; (* eat *)
        vnDeferredAction := CMD_PARK;
    END_IF;
ELSIF vbBtnStop AND vbStopSignal THEN
    (* -Richiesta di stop acquisita ma ancora attiva-
       potrebbe essere che nessuno resetti vbBtnStop, provo a
       resettarlo io, tanto se qualcuno sta premendo il pulsante
       'vbBtnStop' verrà rimesso a TRUE, quindi non dovrei creare fronti *)
    vbBtnStop := FALSE;
END_IF; (* CmdStop *)



(* -- Stop/abort just the processing (cut) -- *)
IF vbBtnStopCut THEN
    IF StepSeq.Status=STSEQ_CUT THEN
        dlog( Txt:='[Services] vbBtnStopCut', Lvl:=4 );
        StepSeq( Abort:=TRUE );
    ELSIF StepSeq.Status=STS_IDLE THEN
        dlog( Txt:='[Services] vbBtnStopCut done', Lvl:=4 );
        vbBtnStopCut := FALSE;
    END_IF;
END_IF; (* vbBtnStopCut *)



(* -- Reset --
      .Reset CNC alarms/emergencies
      .Reset Cnc channels: this causes execution abort!
      .Reset user messages                              *)
IF vbBtnReset THEN
    vbBtnReset := FALSE; (* Eat *)
    dlog( Txt:='[Services] vbBtnReset', Lvl:=3 );
    vbRstSvcs := TRUE; (* Reset comandi/attuazioni ai sottosistemi *)
    Cnc.Reset := TRUE; (* Reset del controller: stop assi + reset emergenze *)
    Msgs(Act:=3, Idx:=MAX_MESSAGES); (* Reset dei messaggi, non le richieste! *)
    (* Non voglio resettare lo stato del passo di lavorazione!
    vbBtnResetStep := TRUE;  *)
END_IF; (* vbBtnReset *)



(* -- Acknowledge --
      .Prendi atto notifiche macchina
      .Conferma operazioni                      *)
IF vbBtnAckn THEN
    dlog( Txt:='[Services] vbBtnAckn', Lvl:=3 );
    vbBtnAckn := FALSE; (* Eat *)

    (* Ricorda stato richieste non resettabili col bottone *)
    vb[ivbReqsBuf+REQ_WORK_PRESCORED] := IS_MSG(REQ_WORK_PRESCORED);

    (* Reset delle sole richieste (non dei messaggi) *)
    Msgs(Act:=3, Idx:=REQMSG_SIZE);

    (* Ripristina richieste non resettabili col bottone *)
    IF vb[ivbReqsBuf+REQ_WORK_PRESCORED] AND vbOutZone_SafeConfirm THEN
        SET_MSG(REQ_WORK_PRESCORED,'REQ_WORK_PRESCORED',0);
    END_IF;
END_IF; (* vbBtnAckn *)



(* -- Reset stato di lavorazione corrente -- *)
IF vbBtnResetStep THEN (* Mach.Status=MS_JUSTERROR *)
    dlog( Txt:='[Services] vbBtnResetStep', Lvl:=4 );
    vbBtnResetStep := FALSE; (* Eat *)

    (* Resetto stato lavorazione del passo *)
    vbExtractDone := vnSubSheet_From<>ZONE_FEED;
    vbPreRotDone := NOT fnRotated90(vnSubSheet_Rot);
    vbProcDone := FALSE;
    vbDetachDone := FALSE;
    vqRemn_X := NO_POS_UM;
    (* Eredità dal passo precedente *)
    vqSubSheet_X := NO_POS_UM; (* Reset work *)
    vqSubSheet_Y := NO_POS_UM;

    (* Riscontri *)
    (* vnAlgn_Cmd := CMD_STOP; (* This should take care of vnAlgn_ResetSeq, vnAlgn_AlgnSeq *)
    (* vnAlgn_DragSeq := SEQ_START; (* Stato evacuazione *)
END_IF; (* vbBtnResetStep *)



(* -- Force completion of current step and move on to the next one --
      .Interruzione del passo corrente
      .Selezione del successivo        *)
IF vbBtnNextStep THEN
    vbBtnNextStep := FALSE; (* Eat *)
    (* dlog( Txt:='[Services] vbBtnNextStep', Lvl:=3 ); *)

    (* Reset richieste inutili *)
    RST_MSG_IF_ON(REQ_FINISHCUT);
    RST_MSG_IF_ON(REQ_GET_SHEET);

    (* Assicuro stop... *)
    IF vbNextStep_FullStop THEN
        vbBtnStop := TRUE; (* Questo ferma tutto, anche una eventuale inserzione lastra *)
    ELSE
        vbBtnStopCut := TRUE; (* Fermo solo il taglio *)
    END_IF;
    (* ...Seguito da un parcheggio *)
    ParkAfterStop := TRUE;

    (* Dipendentemente dalla modalità di lavoro *)
    IF vbAutoMode THEN (* (Hmi.WorkMode & BIT_AUTOMODE)<>0 *)
        dlog( Txt:='[Services] vbBtnNextStep (step %d)', Lvl:=3, Val1:=TO_DINT(vnStepIndex) );

        (* Resetto i dati in eredità dallo step precedente perché il flusso
           automatico si è fermato, e l'operatore potrebbe aver spostato il vetro *)
        vqSubSheet_X := NO_POS_UM; (* Btn Next step *)
        vqSubSheet_Y := NO_POS_UM;
        (* Invece lo stato di lavorazione del passo lo gestisce JobData *)

        (* Load next step (auto mode) *)
        JobData( Cmd:=BIT_NXTSTEP );
    ELSE
        dlog( Txt:='[Services] vbBtnNextStep (cut %ld mm)', Lvl:=3, Val1:=vqProc_Algn/1E3 );

        (* Dò taglio completato, l'interfaccia passerà al passo successivo *)
        vbProcDone := TRUE;
    END_IF;
END_IF; (* vbBtnNextStep *)



(* -- Force Emg --
      .Utilità per forzare una emergenza utente *)
IF vbSelEmergency THEN
    ThrowEmg(Idx:=EMG_USER, Txt:='User emergency (vbSelEmergency)');
END_IF;



(* -- Force Halt --
      .Utilità per simulare inibizione assi (sicurezze)
IF vbBtnHalt THEN
    Mach.Sys.MovAxLocks := Mach.Sys.MovAxLocks OR SYSBIT_HMI;
ELSE
    Mach.Sys.MovAxLocks := Mach.Sys.MovAxLocks & NOT SYSBIT_HMI;
END_IF; (* vbBtnHalt *)



(* -- Park --
      .Sequenza di parcheggio assi
      .Ripristino stato normale macchina  *)
CmdPark( in:=vbBtnPark );
IF CmdPark.q THEN
    dlog( Txt:='[Services] vbBtnPark (held=%d, sts=%d)', Lvl:=3, Val1:=TO_DINT(vbBtnParkHeld), Val2:=TO_DINT(Mach.Status) );
    (* Depending on machine status *)
    CASE Mach.Status OF

        MS_WAITHOMING :
            RST_MSG(MSG_CANTPARK);
            Cnc.Chn1.StartHoming := TRUE; (* Cnc.Chn1.Status=CS_READY *)

        MS_READY :
            Cnc.Chn1.PrgPth := 'Park.obj';
            Cnc.Chn1.StartPrg := TRUE; (* Cnc.Chn1.Status=CS_READY *)

        (* MS_PAUSED : *)

        ELSE
            (* Segnala errore se 'Park' non è già in esecuzione *)
            IF Cnc.Chn1.Status<>CS_RUN OR vaLaunchPrg<>'Park.obj' THEN
                SET_MSG(MSG_CANTPARK,'MSG_CANTPARK',TO_DINT(Mach.Status));
            END_IF;

    END_CASE; (* ---- CASE Mach.Status *)

ELSIF vbBtnPark AND Cnc.Chn1.Status<=CS_READY THEN
    (* Comando terminato *)
    vbBtnPark := FALSE; (* Eat *)
END_IF; (* CmdPark *)



(* -- Algn --
      .Sequenza di riscontro lastra alla quota programmata
      .Indicatore quota programmata dei riscontri *)
IF vbBtnStartAlgn THEN

    dlog( Txt:='[Services] vbBtnStartAlgn (sts=%d)', Lvl:=3, Val1:=TO_DINT(Mach.Status) );

    (* Reset messaggi alzati *)
    RST_MSG_IF_ON(MSG_NOJOB);
    (* Reset richieste inutili *)
    RST_MSG_IF_ON(REQ_DOALIGN);
    RST_MSG_IF_ON(REQ_FINISHCUT);
    RST_MSG_IF_ON(REQ_GET_SHEET);

    IF NOT vbHomingDone THEN
        (* Do nothing *)
    ELSIF Algn.Status=ALSTS_ALIGNING THEN
        (* Se sto già riscontrando, assicura di sbloccare *)
        vbAlgn_FreezeToPlace := FALSE;
    ELSIF Algn.Status<>STS_IDLE OR vnAlgn_Cmd<>CMD_STOP THEN
        dlog( Txt:='!! Algn.Status=%d vnAlgn_Cmd=%d', Lvl:=2, Val1:=TO_DINT(Algn.Status), Val2:=TO_DINT(vnAlgn_Cmd) );
    ELSIF NOT vbSelAlgnInd AND (IS_MSG(REQ_ROTATEBYHAND) OR IS_MSG(REQ_ROTATEONFEED)) THEN
        dlog( Txt:='!! Not during a request', Lvl:=2 );
    (* ELSIF Mach.Status<MS_READY THEN
        dlog( Txt:='!! Machine not ready (%d)', Lvl:=2, Val1:=TO_DINT(Mach.Status));
        SET_MSG(MSG_MACHNOTREADY,'MSG_MACHNOTREADY',TO_DINT(Mach.Status)); *)
    ELSIF NOT vbStepValid THEN
        dlog( Txt:='!! No valid step loaded', Lvl:=2 );
        SET_MSG(MSG_NOJOB,'MSG_NOJOB',0);
    ELSE
        (* Comando io direttamente i riscontri *)
        IF vbSelAlgnInd THEN
            (* Indicatore riscontri *)
            dlog( Txt:='vbBtnStartAlgn: Indicating %ld mm (d=%ld)', Lvl:=3, Val1:=vqProc_Algn/1E3, Val2:=vqAlgn_IndOffset/1E3 );
            (* Nota: Il comando di movimento libero provvederà ad assicurare piedini bassi! *)
            vqAlgn_Tgt := vqProc_Algn + vqAlgn_IndOffset;
            IF vqAlgn_Tgt > Xr.PosLim THEN
                (* Posizionerò i piedini posteriori, sempre con quell'offset *)
                vqAlgn_Tgt := vqAlgn_Tgt - vqAlgnBlk_RearDist;
            END_IF;
            (* Nota: Il range di movimento viene gestito dal comando, comunque
                     sicuramente non voglio entrare in zona taglio per indicare *)
            IF vqAlgn_Tgt<vqAlgn_XrMinSafe THEN vqAlgn_Tgt := vqAlgn_XrMinSafe + 1E3; END_IF;
            vnAlgn_Cmd := CMD_MOVETO;
        ELSE
            (* Argomenti della sequenza riscontro:
               è considerato un riscontro ai fini del taglio, sempre post-rotazione *)
            vnAlgnBlocks_Sel := 16#FFFF; (* All blocks, zero would be also ok *)
            vqAlgn_Tgt := vqProc_Algn; (* Dovrebbe essere minore di vqAlgnMax-vqAlgn_MinUpMargin *)
            (* Differenzio lo spazio di riscontro in base alla modalità *)
            IF vbSloppyManual AND NOT (vbAutoMode OR vbSlantMode OR vbShapeMode) THEN
                (* Modalità manuale "pigra" *)
                GuessSheetSize();
                (* Spazio di riscontro fissato *)
                vqAlgnSheet_X := vqAlgn_Tgt + vqAlgn_FixedDelta;
                (* Se sono al limite ci rinuncio *)
                IF vqAlgnSheet_X > vqAlgnMax THEN
                    vqAlgnSheet_X := vqAlgn_Tgt + MAX(vqAlgnMax - vqAlgnSheet_X, 0);
                END_IF;
            ELSE
                (* Spazio di riscontro normale *)
                vqAlgnSheet_X := vqAlgn_Tgt + vqProc_AlgnDelta;
            END_IF;
            (* In caso di vbSlantMode non è proprio vero... *)
            vqAlgnSheet_Width := vqProd_Width + vqRemn_Width;
            vqAlgnSheet_Height := vqCut_Height;
            vbAlgn_UserAlign := TRUE;
            vbAlgn_FreezeToPlace := vbAlgn_FreezeOnManual; (* Fermati con piedini alti prima di proseguire *)
            vnAlgn_Cmd := ALCMD_ALIGN;
        END_IF;
    END_IF;

    vbSelAlgnInd := FALSE; (* Eat *)
    vbBtnStartAlgn := FALSE; (* Eat *)
END_IF;


(* -- Comando posizionamento e riscontro vetro -- *)
CmdMoveAndAlign( in:=vbBtnMoveAndAlign AND vbHomingDone );
IF CmdMoveAndAlign.q THEN
    (* dlog( Txt:='[Services] vbBtnMoveAndAlign', Lvl:=3 ); *)
    Cnc.Chn1.PrgPth := 'MoveAndAlign.obj';
    Cnc.Chn1.StartPrg := TRUE; (* Cnc.Chn1.Status=CS_READY *)
    (* IF Cnc.Chn1.Ret<0 THEN dlog( Txt:='!! MoveAndAlign failed', Lvl:=3 ); END_IF; *)
(* Assicuro reset comando *)
ELSIF CmdMoveAndAlign.in AND Cnc.Chn1.Status<=CS_READY THEN
    vbBtnMoveAndAlign := FALSE; (* Eat *)
END_IF;



(* -- Start shape process --
      .Sequenza di processazione sagoma *)
IF vnShapeProc_Cmd<>StartShape_Cmd THEN
    StartShape_Cmd := vnShapeProc_Cmd; (* Eat *)
    IF vnShapeProc_Cmd<>0 AND vbHomingDone THEN
        dlog( Txt:='[Services] vnShapeProc_Cmd=%d (0x%X)', Lvl:=3, Val1:=TO_DINT(vnShapeProc_Cmd), Val2:=TO_DINT(vnSelWorkMode) );

        (* Reset messaggi alzati *)
        RST_MSG_IF_ON(MSG_CANTSTART);

        IF Cnc.Chn1.Status=CS_READY THEN
            IF vbSlantMode THEN
                Cnc.Chn1.PrgPth := 'Rotate-Slant.obj';
                Cnc.Chn1.StartPrg := TRUE;
            ELSIF vbShapeMode THEN
                IF vnShapeProc_Cmd=1 THEN
                    Cnc.Chn1.PrgPth := 'Shape-Proc.obj';
                ELSIF vnShapeProc_Cmd>=2 THEN
                    Cnc.Chn1.PrgPth := 'Shape-Detach.obj';
                ELSE
                    Cnc.Chn1.PrgPth := '';
                END_IF;
                Cnc.Chn1.StartPrg := TRUE;
            END_IF;
            (* IF Cnc.Chn1.Ret<0 THEN dlog( Txt:='!! CmdStartShape failed', Lvl:=3 ); END_IF; *)
        ELSE
            dlog( Txt:='!! Cannot process shape (sts=%d)', Lvl:=3, Val1:=TO_DINT(Mach.Status) );
            SET_MSG(MSG_CANTSTART,'MSG_CANTSTART',TO_DINT(Mach.Status));
        END_IF;
    END_IF;
(* Assicuro reset comando *)
ELSIF StartShape_Cmd<>0 AND Cnc.Chn1.Status<=CS_READY THEN
    vnShapeProc_Cmd := 0; (* Eat *)
END_IF;



(* -- Start cut --
      .Sequenza di taglio (incisione, apertura, separazione)
      .Azzera assi se non azzerati
      .Rilascia hold?                 *)
CmdStartCut( in:=vbBtnStartCut );
IF CmdStartCut.q THEN
    vbBtnStartCut := FALSE; (* Eat *)
    dlog( Txt:='[Services] vbBtnStartCut (sts=%d)', Lvl:=3, Val1:=TO_DINT(Mach.Status) );

    (* Reset messaggi alzati *)
    RST_MSG_IF_ON(MSG_CANTSTART);
    RST_MSG_IF_ON(MSG_ALGN_NOGLASS);
    RST_MSG_IF_ON(MSG_ALGN_UNDERGLASS);
    (* Reset richieste inutili *)
    RST_MSG_IF_ON(REQ_FINISHCUT);
    RST_MSG_IF_ON(REQ_DOALIGN);
    RST_MSG_IF_ON(REQ_GET_SHEET);

    IF Mach.Status=MS_WAITHOMING THEN
        (* Azzeramento macchina *)
        Cnc.Chn1.StartHoming := TRUE; (* Cnc.Chn1.Status=CS_READY *)
    ELSIF StepSeq.Status<>STS_IDLE OR Mach.Status<MS_READY THEN
        dlog( Txt:='!! Cannot start cut (Mach.Status=%d, StepSeq.Status=%d)', Lvl:=3, Val1:=TO_DINT(Mach.Status), Val2:=TO_DINT(StepSeq.Status) );
        SET_MSG(MSG_CANTSTART,'MSG_CANTSTART',TO_DINT(Mach.Status));
    ELSE
        (* Resetto i dati in eredità dallo step precedente perché l'operatore potrebbe aver spostato il vetro? *)
        vqY_BtmEdge := NO_POS_UM; (* Invalido bordi vetro per assicurare la ricerca lastra: Start taglio *)
        vqY_TopEdge := NO_POS_UM;
        vqCut_Length := 0;
        (* Faccio partire il taglio
           Nota: Mach.Status potrebbe essere MS_BUSY se sta riscontrando o caricando
        IF Mach.Status<>MS_READY AND (Mach.Status<>MS_BUSY OR Algn.Status<>ALSTS_ALIGNING) THEN
            dlog( Txt:='! Starting cut with Mach.Status=%d', Lvl:=3, Val1:=TO_DINT(Mach.Status) );
        END_IF; *)
        StepSeq.Cmd := STSEQ_STARTCUT;
    END_IF;

END_IF; (* 'CmdStartCut' *)



(* -- Start auto --
      .Lavorazione automatica del passo corrente *)
CmdStartAuto( in:=vbBtnStartStep );
IF CmdStartAuto.q THEN
    vbBtnStartStep := FALSE; (* Eat *)
    dlog( Txt:='[Services] vbBtnStartStep (sts=%d)', Lvl:=3, Val1:=TO_DINT(Mach.Status) );

    (* Reset messaggi alzati *)
    RST_MSG_IF_ON(MSG_CANTSTART);

    CASE Mach.Status OF

        MS_READY, MS_JUSTDONE :
            (* Dipendentemente dallo stato del passo... *)
            IF vbProcDone THEN
                (* ...Eseguo le post-movimentazioni dopo il taglio *)
                StepSeq.Cmd := STSEQ_STARTPOST;
            ELSE
                (* ...Eseguo il passo dall'inizio *)
                (* Nota: Mantengo lo stato corrente dello step:
                   vbExtractDone, vbEdgeTrimmed, vbPreRotDone, vbProcDone, vbDetachDone, vqRemn_X
                   Che si resetta solo nella navigazione
                   Però resetto i dati in eredità dallo step precedente perché il flusso
                   automatico si è fermato, e l'operatore potrebbe aver spostato il vetro *)
                vqSubSheet_X := NO_POS_UM; (* Btn Start auto *)
                vqSubSheet_Y := NO_POS_UM;
                vqY_BtmEdge := NO_POS_UM; (* Invalido bordi vetro per assicurare la ricerca lastra: Start auto *)
                vqY_TopEdge := NO_POS_UM;
                vqCut_Length := 0;
                StepSeq.Cmd := STSEQ_STARTPRE;
            END_IF;

        (* MS_PAUSED : *)

        MS_WAITHOMING :
            Cnc.Chn1.StartHoming := TRUE; (* Cnc.Chn1.Status=CS_READY *)

        ELSE
            SET_MSG(MSG_CANTSTART,'MSG_CANTSTART',TO_DINT(Mach.Status));
    END_CASE;

END_IF; (* 'CmdStartAuto' *)



(* -- Speciale: forza processazione eseguita --
      Questa è una utilità di collaudo per riprendere rotazioni *)
IF vbBtnForceProcDone THEN
    vbBtnForceProcDone := FALSE; (* Eat *)
    dlog( Txt:='[Services] vbBtnForceProcDone', Lvl:=2 );

    IF Cnc.Chn1.Status=CS_READY THEN
        Cnc.Chn1.PrgPth := 'Proc-Dummy.obj';
        Cnc.Chn1.StartPrg := TRUE;
    ELSE
        SET_MSG(MSG_CANTSTART,'MSG_CANTSTART',TO_DINT(Mach.Status));
    END_IF;

END_IF; (* 'vbBtnForceProcDone' *)



(* -- Comando personalizzabile 1 -- *)
CmdCustom1( in:=vbBtnCustom1 );
IF CmdCustom1.q THEN
    dlog( Txt:='[Services] vbBtnCustom1', Lvl:=3 );
    Cnc.Chn1.PrgPth := 'CmdCustom1.obj';
    Cnc.Chn1.StartPrg := TRUE; (* Cnc.Chn1.Status=CS_READY *)
    (* IF Cnc.Chn1.Ret<0 THEN dlog( Txt:='!! CmdCustom1 failed', Lvl:=3 ); END_IF; *)
(* Assicuro reset comando *)
ELSIF vbBtnCustom1 AND Cnc.Chn1.Status<=CS_READY THEN
    vbBtnCustom1 := FALSE; (* Eat *)
END_IF;



(* -- Comando personalizzabile 2 -- *)
CmdCustom2( in:=vbBtnCustom2 );
IF CmdCustom2.q THEN
    dlog( Txt:='[Services] vbBtnCustom2', Lvl:=3 );
    Cnc.Chn1.PrgPth := 'CmdCustom2.obj';
    Cnc.Chn1.StartPrg := TRUE; (* Cnc.Chn1.Status=CS_READY *)
    (* IF Cnc.Chn1.Ret<0 THEN dlog( Txt:='!! CmdCustom2 failed', Lvl:=3 ); END_IF; *)
(* Assicuro reset comando *)
ELSIF vbBtnCustom2 AND Cnc.Chn1.Status<=CS_READY THEN
    vbBtnCustom2 := FALSE; (* Eat *)
END_IF;



(* -- Comando inserzione lastra nel tavolo di carico -- *)
IF vbBtnInsSheet THEN
    dlog( Txt:='[Services] vbBtnInsSheet', Lvl:=3 );
    vbBtnInsSheet := FALSE; (* eat *)

    IF vnShift_Cmd<>0 THEN
        (* dlog( Txt:='vbBtnInsSheet: ! vnShift_Cmd=%d', Lvl:=3, Val1:=TO_DINT(vnShift_Cmd) ); *)
        vnShift_Cmd := CMD_STOP; (* Abort current command *)
        vbBtnInsSheet := TRUE; (* Resubmit request *)
    ELSE
        vqShift_GlassWidth := 6000E3; (* Assumo una certa larghezza *)
        vqShift_GlassX := NO_POS_UM; (* Posizione iniziale: Sconosciuta *)
        vqShift_GlassYbtm := vqYo_SheetFeed; (* Assumo lastra trasportabile in Y *)
        vqShift_GlassYtop := vqShift_GlassYbtm + 3210E3;
        (* vqShift_TargetX scelto opportunamente *)
        vqShift_TargetTol := vqShift_MovePosTol;
        vnShift_Cmd := SHFCMD_INS_REMN;
        (* Se fosse la lastra da tagliare dovrei: *)
        (* vbExtractDone := FALSE; (* Forza estrazione allo start successivo *)
    END_IF;
END_IF; (* vbBtnInsSheet *)



(* -- Comando estrazione lastra da tavolo di carico -- *)
IF vbBtnExtrSheet THEN
    dlog( Txt:='[Services] vbBtnExtrSheet', Lvl:=3 );
    vbBtnExtrSheet := FALSE; (* eat *)

    IF vnShift_Cmd<>0 THEN
        (* dlog( Txt:='vbBtnExtrSheet: ! vnShift_Cmd=%d', Lvl:=3, Val1:=TO_DINT(vnShift_Cmd) ); *)
        vnShift_Cmd := CMD_STOP; (* Abort current command *)
        vbBtnExtrSheet := TRUE; (* Resubmit request *)
    ELSE
        vbExtractDone := FALSE; (* Forza estrazione *)

        vqShift_GlassWidth := 6000E3; (* Assumo una certa larghezza *)
        vqShift_GlassX := vqXph_FeedNearEnd; (* La immagino sul carico, deve essere estratta *)
        vqShift_GlassYbtm := vqYo_SheetFeed; (* Assumo lastra trasportabile in Y *)
        vqShift_GlassYtop := vqShift_GlassYbtm + 3210E3;
        vqShift_TargetX := 0; (* Porto il bordo avanti a zero *)
        vqShift_TargetTol := vqShift_MovePosTol;
        (* Occhio che questo altera lo stato in eredità allo step: *)
        vqSubSheet_X := vqShift_GlassX;
        vqSubSheet_Y := vqShift_GlassYbtm;

        vnShift_Cmd := SHFCMD_PLACE_SHEET;
    END_IF;
END_IF; (* vbBtnExtrSheet *)


(* -- Comando evacuazione lastra a valle --
   Nota: questo non gestisce lastre piccole, per
         evacuazione con riscontri vedi 'STSEQ_OUTFWD'
*)
IF vbBtnOutFwdSheet THEN
    dlog( Txt:='[Services] vbBtnOutFwdSheet', Lvl:=3 );
    vbBtnOutFwdSheet := FALSE; (* eat *)

    IF vnShift_Cmd<>0 THEN
        (* dlog( Txt:='vbBtnOutFwdSheet: ! vnShift_Cmd=%d', Lvl:=3, Val1:=TO_DINT(vnShift_Cmd) ); *)
        vnShift_Cmd := CMD_STOP; (* Abort current command *)
        vbBtnOutFwdSheet := TRUE; (* Resubmit request *)
    ELSE
        vbExtractDone := FALSE; (* Forza estrazione *)

        vqShift_GlassWidth := 6000E3; (* Assumo una certa larghezza *)
        vqShift_GlassX := vqXph_FeedNearEnd; (* La immagino sul carico, deve essere estratta *)
        vqShift_GlassYbtm := vqYo_SheetFeed; (* Assumo lastra trasportabile in Y *)
        vqShift_GlassYtop := vqShift_GlassYbtm + 3210E3;
        vqShift_TargetX := vqX_OutZoneEnd; (* Porto il bordo avanti a fine linea *)
        vqShift_TargetTol := vqShift_MovePosTol;
        (* Nota: il chiamante può settare i modificatori temporanei: vbShift_NoRolls, vbShift_KeepAirOn *)
        vnShift_Cmd := SHFCMD_PLACE_SHEET;
        (* IF vnShift_Cmd=CMD_STOP THEN IF vnShift_Seq=SEQ_DONE THEN ... *)
    END_IF;
END_IF; (* vbBtnOutFwdSheet *)


(* -- Comando carico automatico --
      Se tavolo libero e sta finendo lo schema e c'è una lastra sulla caricatrice, chiamala *)
AutoLoad( in:= vbSchemeAlmostDone AND Loader.SheetReady AND
               vnShiftFeed_Sts=STS_IDLE AND NOT fcFeedNearEnd.q ); (* AND I_FEEDTILT_GATE *)
IF AutoLoad.q AND (vqWorkSettings & BIT_AUTOLOAD)<>0 AND NOT I_LDR_ONFEEDTILT THEN
    dlog( Txt:='fbShift: ! AutoLoad', Lvl:=2 );
    vbBtnLoadSheet := TRUE;
END_IF;


(* -- Comando carico lastra -- *)
IF vbBtnLoadSheet THEN
    dlog( Txt:='[Services] vbBtnLoadSheet', Lvl:=3 );
    vbBtnLoadSheet := FALSE; (* eat *)

    (* Se ponte di etichettatura a monte del carico, parte la sequenza di etichettatura *)
    (* Nota: Non supporto la ripresa della lavorazione, quindi se fcFeedBegin.q carico normale *)
    IF vnLabeler_Type=2 AND (vqWorkSettings & BIT_LABELING)<>0 AND NOT fcFeedBegin.q THEN
        (* Start sequenza di etichettatura *)
        vbBtnStartLabeling := TRUE;
    ELSE
        (* Carico normale *)
        vnShiftFeed_Cmd := SHFCMD_FEED_LOAD;
    END_IF;
END_IF; (* vbBtnLoadSheet *)


(* -- Comando restituzione sfrido -- *)
IF vbBtnUnloadSheet THEN
    dlog( Txt:='[Services] vbBtnUnloadSheet', Lvl:=3 );
    vbBtnUnloadSheet := FALSE; (* eat *)

    vnShiftFeed_Cmd := SHFCMD_FEED_UNLOAD;
END_IF; (* vbBtnUnloadSheet *)


(* -- MachSettings file operations -- *)
IF vbBtnLoadMachSets THEN
    IF MachSettings.Load THEN
        (* Sta caricando i dati dei settaggi macchina *)
        MachSettings();
        IF NOT MachSettings.Load THEN
            (* Ha finito! *)
            vbBtnLoadMachSets := FALSE; (* Eat, done *)
        END_IF;
    ELSE (* Dò il comando *)
        MachSettings.Load := TRUE;
    END_IF;
(* ELSIF vbBtnSaveMachSets THEN
    vbBtnSaveMachSets := FALSE; (* Eat
    MachSettings.Save := TRUE; *)
END_IF; (* vbBtnLoadMachSets *)



(* -- ParDefaults file operations -- *)
IF vbBtnLoadParDefs THEN
    IF ParDefaults.Load THEN
        (* Sta caricando i parametri utente di default *)
        ParDefaults();
        IF ParDefaults.Loaded THEN
            vbBtnLoadParDefs := FALSE; (* Eat, done *)
        ELSIF NOT ParDefaults.Load THEN
            vbBtnLoadParDefs := FALSE; (* Eat, done *)
            dlog( Txt:='!! Error on loading ParDefaults', Lvl:=1 );
        END_IF;
    ELSE (* Dò il comando *)
        ParDefaults.Load := TRUE;
    END_IF;
(* ELSIF vbBtnSaveParDefs THEN
    vbBtnSaveParDefs := FALSE; (* Eat
    ParDefaults.Save := TRUE; *)
END_IF; (* vbBtnLoadParDefs *)



(* -- Reinizializzazione a caldo -- *)
IF vbBtnRestart THEN
    dlog( Txt:='[Services] vbBtnRestart', Lvl:=3 );
    vbBtnRestart := FALSE; (* Eat *)

    (* Check preconditions for this command *)
    IF Mach.Status=MS_BUSY THEN
        (* Better stop the current job *)
        dlog( Txt:='!! Cannot restart while working', Lvl:=1 );
    ELSE
        dlog( Txt:='', Lvl:=0 );
        dlog( Txt:='>> Hot restart', Lvl:=0 );
        (* Hot reinitialization of the machine *)
        vbMachSettings := FALSE;
        vbHomingDone := FALSE;
        Cnc.Status := DS_INIT; (* TODO 3: Sarebbe VAR_OUTPUT !! *)
        Mach.Status := MS_BOOTING; (* TODO 3: Sarebbe VAR_OUTPUT !! *)
        (* Cnc.Reboot := TRUE; (* TODO 5: All'inizio funzionava, ma ora Sipro ha dei problemi con Ethercat *)
        InitTask(); (* Vedi anche: PROGRAM Init *)
    END_IF;
END_IF; (* vbBtnRestart *)



(* -- Timeout azione deferita --
      Per evitare sorprese dopo ore... *)
TDeferredExpiration( in:=vnDeferredAction<>CMD_STOP, pt:=5000 );
IF TDeferredExpiration.q THEN
    dlog( Txt:='! Deferred action %d expired', Lvl:=2, Val1:=TO_DINT(vnDeferredAction) );
    vnDeferredAction := CMD_STOP;
END_IF;



(* -- Start programma di test -- *)
IF vnPrgTest<>PrgTest THEN (* AND Mach.Status=MS_READY  *)
    PrgTest := vnPrgTest; (* Eat *)
    IF vnPrgTest<>0 THEN
        dlog( Txt:='[Services] vnPrgTest=%d', Lvl:=1, Val1:=TO_DINT(vnPrgTest) );
        Cnc.Chn1.PrgPth := 'Test.obj';
        Cnc.Chn1.StartPrg := TRUE; (* Cnc.Chn1.Status=CS_READY *)
    END_IF;
END_IF;



(* -- TODO 5: Gestione emulazione utensili -- *)
(* Tsup.Emulated := xxx; (* Non accostare testina superiore *)
(* Tinf.Emulated := xxx; (* Non accostare testina inferiore *)
(* Rsup.Emulated := xxx; (* Non accostare rotella superiore *)
(* Rinf.Emulated := xxx; (* Non accostare rotella inferiore *)
(* BladeSup.Emulated := xxx; (* Non accostare lametta superiore *)
(* BladeInf.Emulated := xxx; (* Non accostare lametta inferiore *)
(* GrLe.Emulated := xxx; (* Non accostare mola *)
(* HoldPads.Emulated := xxx; (* Non abbassare tamponi *)
(* ClampDtch.Emulated := xxx; (* Non abbassare premilastra stacco *)
(* ClampAlgn.Emulated := xxx; (* Non abbassare premilastra riscontri *)
(* BrkBar.Emulated := xxx; (* Non alzare barra *)
(* HeatLamp.Emulated := xxx; (* Non accendere lampada *)



(* -- Notifiche a bassa priorità -- *)
IF vbHeartBeat THEN

    (* Reset messaggio start ignorato *)
    IF IS_MSG(MSG_CANTSTART) AND StepSeq.Status>STS_IDLE THEN
        RST_MSG(MSG_CANTSTART);
    END_IF;

END_IF; (* vbHeartBeat *)

END_PROGRAM




PROGRAM Test

{ DE:"Test services" }

	VAR
	Ttrain : fbPulseTrain; { DE:"Pulses train" }
	AnalyzeAx : fbAnalyzeAxis; { DE:"Measure friction and mass" }
	END_VAR

	{ CODE:ST }(*    A test unit (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Contains services for machine tests
*)

(* ------------------------------------------------------
                  Machine test services                  *)
IF Mach.Status=MS_TEST THEN

    (* Abortisci test se segnale di stop *)
    IF vbStopSignal THEN
        vnPlcTest := 0;
        Ttrain( in:=FALSE );
    END_IF;

    (* Servizio di analisi asse *)
    AnalyzeAx();

    CASE vnPlcTest OF

        ID_CARR_INF :
            (* Movimento avanti e indietro *)
            IF vnCarrInf_Cmd=0 THEN
                (* Il risultato del comando precedente è
                IF vnCarrInf_Seq<>SEQ_DONE THEN
                    dlog( Txt:='fbCarriages: CarrInf did not complete its sequence!', Lvl:=1 );
                END_IF;
                *)
                (* Dò un comando di movimento *)
                IF vqCarrInf_Tgt<>(Yinf.PosLim - 500E3) THEN
                    vqCarrInf_Tgt := Yinf.PosLim - 500E3;
                ELSE
                    vqCarrInf_Tgt := Yinf.NegLim + 500E3;
                END_IF;
                vnCarrInf_Cmd := CMD_MOVETO;
            (* ELSE (* Attendo che termini il comando *)
            END_IF;


        ID_CARR_SUP :
            (* Movimento avanti e indietro *)
            IF vnCarrSup_Cmd=0 THEN
                (* Dò un comando di movimento *)
                IF vqCarrSup_Tgt<>(Ysup.PosLim - 500E3) THEN
                    vqCarrSup_Tgt := Ysup.PosLim - 500E3;
                ELSE
                    vqCarrSup_Tgt := Ysup.NegLim + 500E3;
                END_IF;
                vnCarrSup_Cmd := CMD_MOVETO;
            (* ELSE (* Attendo che termini il comando *)
            END_IF;


        ID_DTCH :
            (* Movimento avanti e indietro *)
            IF vnDtch_Cmd=0 THEN
                (* Dò un comando di movimento *)
                IF vqDtch_Tgt<>(Xs.PosLim - 10E3) THEN
                    vqDtch_Tgt := Xs.PosLim - 10E3;
                ELSE
                    vqDtch_Tgt := Xs.NegLim + 10E3;
                END_IF;
                vnDtch_Cmd := CMD_MOVETO;
            (* ELSE (* Attendo che termini il comando *)
            END_IF;


        ID_ALGN :
            IF vnAlgnBlocks_Sel<>0 THEN
                (* Piedini su e giù *)
                Ttrain( in:=TRUE, T:=2000 );
                IF Ttrain.train THEN
                    IF vnAlgnBlocks_Cmd=0 THEN
                       IF Algn.Blocks.AtRest THEN
                           IF (vnAlgnBlocks_Sel&16#8000)=0 THEN
                               vnAlgnBlocks_Cmd := 1; (* Set piedini anteriori *)
                           ELSE
                               vnAlgnBlocks_Cmd := 2; (* Set piedini posteriori *)
                           END_IF;
                       ELSE
                           vnAlgnBlocks_Cmd := 3; (* Reset piedini *)
                       END_IF;
                    END_IF; (* -- Comando precedente terminato *)
                END_IF;
            ELSE
                (* Movimento riscontri avanti e indietro *)
                IF Xr.Cmd=AXC_STOP_FREE THEN Xr.Cmd:=AXC_STOP_ENAB; END_IF;
                IF Xr.Status=AXS_READY THEN
                    Xr.TgtSpd := 0;
                    Xr.AccPerc := 100;
                    Xr.DecPerc := 100;
                    Xr.OutFrc := 0;
                    Xr.MaxPosErr := WTR_HITDET;
                    IF Xr.TgtPos<>1500E3 THEN Xr.TgtPos:=1500E3;
                    ELSE Xr.TgtPos:=500E3; END_IF;
                    Xr.Cmd := AXC_START_POS;
                END_IF;
            END_IF;


        ID_ROLLS_ALGN :
            (* Movimento avanti/indietro dei rulli *)
            IF Cr.Cmd=AXC_STOP_FREE THEN Cr.Cmd:=AXC_STOP_ENAB; END_IF; (* Assicura servo on *)
            IF Cr.Status=AXS_READY THEN
                Cr.TgtSpd := 0;
                Cr.AccPerc := 100;
                Cr.DecPerc := 100;
                Cr.OutFrc := 0;
                Cr.MaxPosErr := WTR_DEFAULT;
                IF Cr.TgtPos<>1000E3 THEN Cr.TgtPos:=1000E3;
                ELSE Cr.TgtPos:=-1000E3; END_IF;
                Cr.Cmd := AXC_START_POS;
            END_IF;
            (* Movimento contemporaneo di altre cinghie * )
            IF FALSE THEN
                IF Cb.Cmd=AXC_STOP_FREE THEN Cb.Cmd:=AXC_STOP_ENAB; END_IF;
                IF Cb.Status=AXS_READY THEN
                    Cb.MasterIdx := Cs.Idx;
                    Cb.MaxPosErr := WTR_DEFAULT;
                    Cb.Cmd := AXC_START_FOL;
                END_IF;
                IF Cs.Cmd=AXC_STOP_FREE THEN Cs.Cmd:=AXC_STOP_ENAB; END_IF;
                IF Cs.Status=AXS_READY THEN
                    Cs.TgtSpd := 0;
                    Cs.AccPerc := 100;
                    Cs.DecPerc := 100;
                    Cs.OutFrc := 0;
                    Cs.MaxPosErr := WTR_HITDET;
                    IF Cs.TgtPos<>1000E3 THEN Cs.TgtPos:=1000E3;
                    ELSE Cs.TgtPos:=-1000E3; END_IF;
                    Cs.Cmd := AXC_START_POS;
                END_IF;
                IF Ca.Cmd=AXC_STOP_FREE THEN Ca.Cmd:=AXC_STOP_ENAB; END_IF;
                IF Ca.Status=AXS_READY THEN
                    Ca.TgtSpd := 0;
                    Ca.AccPerc := 100;
                    Ca.DecPerc := 100;
                    Ca.OutFrc := 0;
                    Ca.MaxPosErr := WTR_HITDET;
                    IF Ca.TgtPos<>1000E3 THEN Ca.TgtPos:=1000E3;
                    ELSE Ca.TgtPos:=-1000E3; END_IF;
                    Ca.Cmd := AXC_START_POS;
                END_IF;
            END_IF; *)


        ID_BELTS_DTCH :
            (* Movimento avanti/indietro delle cinghie stacco *)
            IF Cs.Cmd=AXC_STOP_FREE THEN Cs.Cmd:=AXC_STOP_ENAB; END_IF; (* Assicura servo on *)
            IF Cs.Status=AXS_READY THEN
                Cs.TgtSpd := 0;
                Cs.AccPerc := 100;
                Cs.DecPerc := 100;
                Cs.OutFrc := 0;
                Cs.MaxPosErr := WTR_HITDET;
                IF Cs.TgtPos<>1000E3 THEN Cs.TgtPos:=1000E3;
                ELSE Cs.TgtPos:=-1000E3; END_IF;
                Cs.Cmd := AXC_START_POS;
            END_IF;


        ID_BELTS_BUF :
            (* Movimento avanti/indietro delle cinghie polmone *)
            IF Cb.Cmd=AXC_STOP_FREE THEN Cb.Cmd:=AXC_STOP_ENAB; END_IF; (* Assicura servo on *)
            IF Cb.Status=AXS_READY THEN
                Cb.TgtSpd := 0;
                Cb.AccPerc := 100;
                Cb.DecPerc := 100;
                Cb.OutFrc := 0;
                Cb.MaxPosErr := WTR_HITDET;
                IF Cb.TgtPos<>1000E3 THEN Cb.TgtPos:=1000E3;
                ELSE Cb.TgtPos:=-1000E3; END_IF;
                Cb.Cmd := AXC_START_POS;
            END_IF;


        ID_BELTS_FEED :
            (* Movimento avanti/indietro cinghie carico *)
            IF Ca.Cmd=AXC_STOP_FREE THEN Ca.Cmd:=AXC_STOP_ENAB; END_IF; (* Assicura servo on *)
            IF Ca.Status=AXS_READY THEN
                Ca.TgtSpd := 0;
                Ca.AccPerc := 100;
                Ca.DecPerc := 100;
                Ca.OutFrc := 0;
                Ca.MaxPosErr := WTR_HITDET;
                IF Ca.TgtPos<>1000E3 THEN Ca.TgtPos:=1000E3;
                ELSE Ca.TgtPos:=-1000E3; END_IF;
                Ca.Cmd := AXC_START_POS;
            END_IF;


        ID_GRABBER :
            (* Movimento avanti e indietro orientazione pinza *)
            IF Zg.Cmd=AXC_STOP_FREE THEN Zg.Cmd:=AXC_STOP_ENAB; END_IF; (* Assicura servo on *)
            IF Zg.Status=AXS_READY THEN
                Zg.TgtSpd := 0;
                Zg.AccPerc := 100;
                Zg.DecPerc := 100;
                Zg.OutFrc := 0;
                Zg.MaxPosErr := WTR_HITDET;
                IF Zg.TgtPos=0 THEN Zg.TgtPos:=720E3;
                ELSE Zg.TgtPos:=0; END_IF;
                Zg.Cmd := AXC_START_POS;
            END_IF;


        ID_BUFROT :
            (* Movimento avanti e indietro rotazione ventosa *)
            IF Zb.Cmd=AXC_STOP_FREE THEN Zb.Cmd:=AXC_STOP_ENAB; END_IF; (* Assicura servo on *)
            IF Zb.Status=AXS_READY THEN
                Zb.TgtSpd := 0;
                Zb.AccPerc := 100;
                Zb.DecPerc := 100;
                Zb.OutFrc := 0;
                Zb.MaxPosErr := WTR_HITDET;
                IF Zb.TgtPos=0 THEN Zb.TgtPos:=720E3;
                ELSE Zb.TgtPos:=0; END_IF;
                Zb.Cmd := AXC_START_POS;
            END_IF;


        ID_TINF, ID_TSUP :
            (* Testine incisione on-off *)
            vqTinf_P := 10E3; (* Pressione di incisione a 1Kg *)
            vqTsup_P := 10E3;
            Ttrain( in:=TRUE, T:=2000 );
            IF Ttrain.train THEN
                IF vbTinf_Cmd THEN
                    vbTinf_Cmd := FALSE;
                    vbTsup_Cmd := FALSE;
                ELSE
                    vbTinf_Cmd := TRUE;
                    vbTsup_Cmd := TRUE;
                END_IF;
            END_IF;


        ID_RINF, ID_RSUP :
            (* Testine incisione on-off *)
            vqRinf_P := 10E3; (* Pressione di apertura a 1Kg *)
            vqRsup_P := 10E3;
            Ttrain( in:=TRUE, T:=2500 );
            IF Ttrain.train THEN
                IF vbRinf_Cmd THEN
                    vbRinf_Cmd := FALSE;
                    vbRsup_Cmd := FALSE;
                ELSE
                    vbRinf_SelC := FALSE; (* wheel *)
                    vbRinf_Cmd := TRUE;
                    vbRsup_SelC := FALSE; (* c-wheel *)
                    vbRsup_Cmd := TRUE;
                END_IF;
            END_IF;


        ID_BLADE_SUP :
            (* Lametta superiore on-off *)
            Ttrain( in:=TRUE, T:=2000 );
            IF Ttrain.train THEN
                vnBladeSup_Cmd := SEL(vnBladeSup_Cmd=CMD_STOP, CMD_STOP, BLCMD_PROBE);
            END_IF;


        ID_BLADE_INF :
            (* Lametta inferiore on-off *)
            Ttrain( in:=TRUE, T:=2000 );
            IF Ttrain.train THEN
                vnBladeInf_Cmd := SEL(vnBladeInf_Cmd=CMD_STOP, CMD_STOP, BLCMD_PROBE);
            END_IF;


        ID_GRLE :
            (* Mola on-off *)
            vqGrLe_P := 10E3; (* Pressione di molatura 1Kg *)
            Ttrain( in:=TRUE, T:=3000 );
            IF Ttrain.train THEN
                vnGrLe_Cmd := SEL( vnGrLe_Cmd=CMD_STOP, CMD_STOP, INT#3 );
            END_IF;


        ID_BRKBAR :
            (* Barra di troncaggio on-off *)
            Ttrain( in:=TRUE, T:=3000 );
            IF Ttrain.train THEN
                vnBrkBar_Cmd := SEL( vnBrkBar_Cmd=CMD_STOP, CMD_STOP, INT#2 );
            END_IF;


        ID_HEATLAMP :
            (* Lampada fuori/dentro *)
            (* vbLampOn_Cmd := FALSE; *)
            Ttrain( in:=TRUE, T:=3000 );
            IF Ttrain.train THEN
                vbLampOut_Cmd := NOT vbLampOut_Cmd;
            END_IF;


        ID_CLAMP_ALGN :
            (* IF vnClampAlgn_Type=1 THEN
            ELSIF vnClampAlgn_Type=2 THEN
            END_IF; *)
            (* Premilastra riscontro su-giù *)
            vqClampAlgn_P := 2000E3; (* Pressione finale 200Kg *)
            Ttrain( in:=TRUE, T:=3000 );
            IF Ttrain.train THEN
                vnClampAlgn_Cmd := SEL( vnClampAlgn_Cmd=CMD_STOP, CMD_STOP, CLCMD_HOLD );
            END_IF;


        ID_CLAMP_DTCH :
            (* IF vnClampDtch_Type=1 THEN
            ELSIF vnClampDtch_Type=2 THEN
            END_IF; *)
            (* Premilastra stacco su-giù *)
            vqClampDtch_P := 2000E3; (* Pressione finale 200Kg *)
            Ttrain( in:=TRUE, T:=3000 );
            IF Ttrain.train THEN
                vnClampDtch_Cmd := SEL( vnClampDtch_Cmd=CMD_STOP, CMD_STOP, CLCMD_HOLD );
            END_IF;


        ID_HOLDPADS :
            (* Tamponi fermavetro on-off *)
            Ttrain( in:=TRUE, T:=3000 );
            IF Ttrain.train THEN
                (* vqHoldPads_P := vqHoldPads_Phold; *)
                vnHoldPads_Cmd := SEL( vnHoldPads_Cmd=CMD_STOP, CMD_STOP, (BIT_DTCH_SIDE OR BIT_ALGN_SIDE) );
            END_IF;

    END_CASE; (* -- Test services *)

END_IF; (* -- Test mode *)


(* ------------------------------------------------------
                     Develop test
CASE vqPlcTest OF

    1 : vqPlcTest := 0;

    2 : vqPlcTest := 0;

    3 : vqPlcTest := 0;


    9 :
        Cnc.Chn1.PrgPth := 'Test.obj';
        Cnc.Chn1.StartPrg := TRUE;
        vqPlcTest := 11;

   10 :
       Cnc.Reset := TRUE;
       vqPlcTest := 11;

   11 :
        dlog( Txt:='*** vqPlcTest=11 Chn1.Status=%d', Lvl:=2, Val1:=vqPlcTest, Val2:=TO_DINT(Cnc.Chn1.Status));
        IF Cnc.Chn1.Status<>CS_READY THEN
            vqPlcTest := 12;
        END_IF;

   12 :
        dlog( Txt:='*** vqPlcTest=12 Chn1.Status=%d', Lvl:=2, Val1:=vqPlcTest,Val2:=TO_DINT(Cnc.Chn1.Status));
        IF Cnc.Chn1.Status<=CS_READY THEN
            vqPlcTest := 12;
        ELSE
            dlog( Txt:='*** Ready!', Lvl:=2 );
            vqPlcTest := 0;
        END_IF;

END_CASE; (* -- Develop test services *)


(* -- PLC time burn test --
IF vqPlcTest > 0 THEN
    fnr := vqPlcTest;
    WHILE fnr > 0 DO
        fnr := fnr - 1;
    END_WHILE;
END_IF; *)

END_PROGRAM




PROGRAM AxRefs

{ DE:"Riferimenti camme elettroniche" }

	{ CODE:ST }(*    AxRefs (Strato M-series)
      ----------------------------------------------

      OVERVIEW
      ----------------------------------------------
      Calcola i riferimenti di posizione degli slave
      per moto in camma elettronica con profilo
      calcolato 'on the fly'

      NOTES
      ----------------------------------------------
      Questo modulo è eseguito ad ogni tick, deve
      essere snello, non deve contenere operazioni
      lunghe.

      DETAILS
      ----------------------------------------------
      L'aggancio in posizione si effettua con
      FUN105 Mode=11, A=5, VNAX_FOLL_MASTER_NUM=vd-index
      Prima di agganciare, assicurarsi di portare
      gli slave nella posizione iniziale!
      Con 'fbM32Axis':
      Yinf.TgtPos := TO_DINT( 1000.0 * vd[ivdYinf_PosRef] );
      Yinf.Cmd := AXC_START_POS;
      ...
      IF Yinf.Arrived THEN
          Yinf.MasterIdx := ivdYinf_PosRef;
          Yinf.Cmd := AXC_START_FOL;
      END_IF;

      USAGE
      ----------------------------------------------
      Associare il programma al task 'RtcAx':
      PROGRAM AxRefs WITH RtcAx;
      Il task 'RtcAx' è eseguito ad ogni tick:
      TASK RtcAx ( INTERVAL := t#0ms, PRIORITY := 2 );
      Bisogna abilitare questo task ponendo:
      "Parametri di sistema"/"Flags PLC"/"Abilitazione task PLC in RTC"=1
      (cncsys2k.txt/PlcRtcFlags = 1)
*)

(* Profili camme elettroniche:
     -Rotazione positiva lato riscontro con pinza
*)

(*  Test
    vd[12] := 100.0 * SIN( 1E-5 * TO_LREAL(Ysup.CurrPos) );
    vd[13] := 100.0 * COS( 1E-5 * TO_LREAL(Ysup.CurrPos) );
*)

(* ----------------------------------------------------------------------- *)
IF vnGrab_RotStatus=1 THEN

    (* ---- Rotazione lato riscontro con pinza ----
      Contratto: Richiede precedente esecuzione di 'fbCalcRotAlgn',
      che a sua volta calcola gli input di 'fbYo' e 'fbXp'

      Il master è l'angolo di orientazione pinza, che essendo agguantata
      al vetro è pari all'inclinazione della lastra.
      Vogliamo ruotare in modo che l'ordinata del vertice basso 'yo' abbia
      una certa relazione con l'angolo 'a', dipendente dalla posizione
      desiderata finale 'yof'.
      I profili dipendenti da 'a' sono l'ordinata di presa 'yg' e l'ascissa
      dell'eventuale piedino ausiliario 'Xp' *)

    (* L'angolo corrente è dato dall'angolo di orientazione pinza
       -Va letto qui perché questo è un task ad alta frequenza
       -Meglio usare la posizione teorica per avere un profilo più bello *)
    (* SEL(vbGrab_MasterRefPos, AXQ_ACTPOS_ABS, AXQ_REFPOS_ABS) *)
    vqExecPlcFunRet := SiproFun( FUN_READAX, (100*Zg.Idx)+AXQ_REFPOS_ABS, ivqFunRet );

    (* Calcolo riferimenti di posizione degli slaves Yinf e Xr *)
    (* Il profilo desiderato da imprimere all'ordinata del vertice basso *)
    Yo( a:=MDEG2RAD * TO_LREAL(vq[ivqFunRet]) );

    (* Profilo del carrello inferiore: ordinata di presa e offset pinza *)
    vd[ivdYinf_PosRef] := Yo.value + Xp.d * COS(Yo.a) - 1.0E-3 * TO_LREAL(vqGrabber_DY);

    (* Profilo dell'ascissa del piedino ausiliario *)
    Xp( a:=Yo.a, yo:=Yo.value );
    (* Per stare più indietro per agganciare al volo: Xp( a:=Yo.a - A_DELTA, yo:=Yo.value );  *)
    vd[ivdXr_PosRef] := Xp.value - 1.0E-3 * TO_LREAL(vqAlgnBlk_ForeOppDist);

(* -----------------------------------------------------------------------
ELSIF vnGrab_RotStatus=2 THEN
    (* Rotazione lato stacco con pinza: riferimenti a Yinf e Yb
    vd[ivdYinf_PosRef] := (...) - 1.0E-3 * TO_LREAL(vqGrabber_DY);
    (* Piedino aiuto rotazione lato stacco?  vd[ivdYb_PosRef] := ... *)

END_IF;

END_PROGRAM




	(********************)
	(*                  *)
	(*      MACROS      *)
	(*                  *)
	(********************)




MACRO BELT_SEQ
{ DE:"Belts sequence" }

	PAR_MACRO
	THIS; { DE:"Current function block" }
	AX; { DE:"Driven axis (fbM32Axis)" }
	CAN_GOUP; { DE:"Condition to wait to go up" }
	IS_DWN; { DE:"Is ready down (BOOL)" }
	IS_UP; { DE:"Is ready up (BOOL)" }
	O_GOUP; { DE:"Out actuation (BOOL)" }
	END_PAR

	{ CODE:ST }

TWaitUp( in:=Status=BLT_ENABLING, pt:=TO_UDINT(vqBelts_OutTime) );
TWaitDwn( in:=Status=BLT_DISABLING, pt:=TO_UDINT(vqBelts_InTime) );
TUpDwnTout( in:=(TWaitUp.q AND NOT IS_UP) OR (TWaitDwn.q AND NOT IS_DWN), pt:=3000 );
CASE Status OF

    BLT_OPERATING : (* Axis moving or following *)
        Arrived := AX.Arrived; (* Monitor this result *)
        IF Cmd.Activate AND Allow THEN (* OR Cmd.Target<>0 OR Cmd.Follow<>0 *)
            (* Rileva se il movimento è finito *)
            IF AX.Status<=AXS_READY THEN
                (* Asse arrivato o non pronto, resetto i comandi *)
                (* Nota: il chiamante può controllare Arrived == AX.Arrived *)
                Cmd.Target := 0;
                Cmd.Follow := 0;
                Status := BLT_ENABLED;
            ELSIF AX.Cmd=AXC_START_POS THEN
                (* Se azzero il comando 'TgtPos' mi fermo senza abbassare *)
                IF Cmd.Target=0 THEN
                    dlog( Txt:=CONCAT(THIS,': Stop move request'), Lvl:=6 );
                    AX.Cmd := AXC_STOP_ENAB; (* Stop axis *)
                    Status := BLT_STOPPING; (* Wait motion stop *)
                ELSE
                    (* Cambi al volo della quota e della velocità *)
                    AX.TgtPos := Cmd.Target; (* [um] *)
                    AX.TgtSpd := Cmd.MaxSpeed; (* [um/min] *)
                END_IF;
            ELSIF AX.Cmd=AXC_START_FOL THEN
                (* Se azzero il comando 'Cmd.Follow' mi fermo senza abbassare *)
                IF Cmd.Follow=0 THEN
                    dlog( Txt:=CONCAT(THIS,': Stop follow request'), Lvl:=6 );
                    AX.Cmd := AXC_STOP_ENAB; (* Stop axis *)
                    Status := BLT_STOPPING; (* Wait motion stop *)
                END_IF;
            END_IF;
        ELSE
            (* Tolta attivazione, resetto i comandi *)
            dlog( Txt:=CONCAT(THIS,': Deactivated (ax.Status=%d)'), Lvl:=6, Val1:=TO_DINT(AX.Status));
            Cmd.Target := 0;
            Cmd.Follow := 0;
            AX.Cmd := AXC_STOP_ENAB; (* Stop axis *)
            Status := BLT_STOPPING; (* Wait motion stop *)
        END_IF;


    BLT_STOPPING : (* Stopping motion *)
        Arrived := AX.Arrived; (* Monitor this result *)
        AX.Cmd := AXC_STOP_ENAB; (* Stop axis *)
        IF AX.Status<AXS_STOPPING THEN
            Status := BLT_ENABLED;
        END_IF;


    BLT_ENABLED : (* Up and enabled *)
        IF Cmd.Activate AND Allow THEN
            IF AX.Status=AXS_READY THEN
                (* Respond to movement commands *)
                IF Cmd.Follow>0 THEN
                    (* Aggancio a master *)
                    dlog( Txt:=CONCAT(THIS,': Lock master %d'), Lvl:=6, Val1:=TO_DINT(Cmd.Follow));
                    AX.MasterIdx := Cmd.Follow;
                    AX.MaxPosErr := WTR_DEFAULT;
                    AX.Cmd := AXC_START_FOL;
                ELSIF Cmd.Target<>0 AND NOT vbBelts_HoldStartPos THEN
                    Arrived := FALSE; (* New command: better reset this result *)
                    (* Movimento autonomo *)
                    (* Occhio: se il posizionamento è molto piccolo AX.Status va subito
                               in AXS_READY e c'è un blocco nelle attese di BLT_OPERATING *)
                    dlog( Txt:=CONCAT(THIS,': Move to %ld mm'), Lvl:=6, Val1:=Cmd.Target/1E3);
                    AX.TgtPos := Cmd.Target; (* [um] *)
                    AX.TgtSpd := Cmd.MaxSpeed; (* [um/min] *)
                    AX.AccPerc := Cmd.Accel; (* [%] *)
                    (* Parzializzo anche la decelerazione solo se vado in avanti *)
                    AX.DecPerc := SEL(AX.TgtPos>0, 100, Cmd.Accel); (* [%] *)
                    AX.OutFrc := -1; (* max *)
                    AX.MaxPosErr := WTR_DEFAULT;
                    AX.Cmd := AXC_START_POS;
                END_IF;
            ELSIF AX.Status<AXS_READY THEN
                Status := BLT_WAITDRIVE;
            ELSIF AX.Status>AXS_STOPPING THEN
                Status := BLT_OPERATING;
            END_IF;

            (* Check sensors
            IF NOT IS_UP THEN
                dlog( Txt:=CONCAT(THIS,': Not up!'), Lvl:=2 );
                Status := BLT_ENABLING;
            END_IF; *)
        ELSE
            Status := BLT_DISABLING; (* Disable and return inside *)
        END_IF;


    BLT_WAITDRIVE : (* Waiting servo enabled *)
        IF Cmd.Activate AND Allow THEN
            AX.Cmd := AXC_STOP_ENAB; (* Enable axis *)
            IF AX.Status=AXS_READY THEN
                Status := BLT_ENABLED;
            END_IF;
        ELSE
            Status := BLT_DISABLING;
        END_IF;


    BLT_ENABLING : (* Going outside and enabling *)
        IF Cmd.Activate AND Allow THEN
            AX.Cmd := AXC_STOP_ENAB; (* Enable axis *)
            IF TWaitUp.q AND IS_UP THEN
                IF AX.Status=AXS_READY THEN
                    (* Reset possible timeout message *)
                    IF vbMsgs[MSG_BELTS_UPTOUT] THEN
                        Msgs(Act:=2, Idx:=MSG_BELTS_UPTOUT);
                    END_IF;
                    Status := BLT_ENABLED;
                ELSE
                    dlog( Txt:=CONCAT(THIS,': Ax not ready (%ld ms)'), Lvl:=2, Val1:=TO_DINT(TWaitUp.pt));
                    Status := BLT_WAITDRIVE;
                END_IF;
            ELSIF TUpDwnTout.q AND NOT vbMsgs[MSG_BELTS_UPTOUT] THEN
                Msgs(Act:=1, Idx:=MSG_BELTS_UPTOUT, Txt:=CONCAT(THIS,'-MSG_BELTS_UPTOUT'), Par:=0);
            END_IF;
        ELSE
            Status := BLT_ENABLED; (* Will abort immediately *)
        END_IF;


    BLT_DISABLING : (* Going inside and disabling *)
        AX.Cmd := AXC_STOP_FREE; (* Disable axis *)
        IF TWaitDwn.q AND IS_DWN THEN
            (* Cmd.Target := 0; *)
            (* Cmd.Follow := 0; *)
            (* Reset possible timeout message *)
            IF vbMsgs[MSG_BELTS_DWNTOUT] THEN
                Msgs(Act:=2, Idx:=MSG_BELTS_DWNTOUT);
            END_IF;
            Status := BLT_DISABLED;
        ELSIF TUpDwnTout.q AND NOT vbMsgs[MSG_BELTS_DWNTOUT] THEN
            Msgs(Act:=1, Idx:=MSG_BELTS_DWNTOUT, Txt:=CONCAT(THIS,'-MSG_BELTS_DWNTOUT'), Par:=0);
        END_IF;


    BLT_DISABLED : (* Inside and resting *)
        IF Cmd.Activate AND Allow AND CAN_GOUP THEN
            Arrived := FALSE; (* New command: better reset this result *)
            Status := BLT_ENABLING; (* Go Out *)
        ELSIF NOT IS_DWN THEN
            (* dlog( Txt:=CONCAT(THIS,': ! Not down'), Lvl:=2 ); *)
            Status := BLT_DISABLING;
        END_IF;

END_CASE;

(* Attuazione salita *)
O_GOUP := Status>=BLT_ENABLING AND Allow;

(* -- Monitors -- *)
CurrPos := AX.CurrPos; (* Per la teorica: + AX.CurrPosErr; See also 'Arrived' up there *)
CurrSpd := AX.CurrSpd;
AtRest := Status=BLT_DISABLED AND AX.Status<=AXS_READY AND NOT O_GOUP AND IS_DWN;
vn[ivnStatus+ID] := Status;
vb[ivbAtRest+ID] := AtRest;

END_MACRO




MACRO BELTS_GROUP2
{ DE:"Gestione gruppo cinghie gemelle" }

	PAR_MACRO
	AX2; { DE:"Slave axis (fbM32Axis)" }
	O2_GOUP; { DE:"Slave out actuation (BOOL)" }
	FC2_ISUP; { DE:"Slave out sensor (BOOL)" }
	AX; { DE:"Master axis (fbM32Axis)" }
	O_GOUP; { DE:"Master out actuation (BOOL)" }
	END_PAR

	{ CODE:ST }

(* Il motore insegue il master *)
IF AX.Status>=AXS_ENABLING THEN
    (* Assicuro in inseguimento del master *)
    IF AX2.Cmd<>AXC_START_FOL THEN
        AX2.MasterIdx := AX.Idx;
        AX2.MaxPosErr := WTR_DEFAULT;
        AX2.Cmd := AXC_START_FOL;
    END_IF;
ELSE
    AX2.Cmd := AXC_STOP_FREE;
END_IF;
AX2();

(* Anche la salita segue il master *)
O2_GOUP := O_GOUP;

(* Controllo cinghie gemelle attive *)
TBelts2Fault( in:=vqBelts2_ToutCheck>0 AND Status=BLT_OPERATING AND (AX2.Status<>AXS_MOVING_FOL OR NOT FC2_ISUP), pt:=TO_UDINT(vqBelts2_ToutCheck) );
Belts2Fault := TBelts2Fault.q;
END_MACRO




MACRO CLAMPMOT_SEQ
{ DE:"Motorized clamp sequence" }

	PAR_MACRO
	THIS; { DE:"Current function block name" }
	CL_CMD; { DE:"Clamp command (INT)" }
	AX; { DE:"Main axis (fbM32Axis)" }
	AX2; { DE:"Gantry axis (fbM32Gantry)" }
	END_PAR

	{ CODE:ST }
(*
      OVERVIEW
      ----------------------------------------------
      Attuazione di un premilastra motorizzato.
      I premilastra fanno tre cose:
        .Press (devono premere tanto per tirare o trascinare il vetro)
        .Hold (devono premere poco per assicurare che il vetro non si sposti)
        .Oppose (devono contrastare la barra di troncaggio o altro utensile)

      DETAILS
      ----------------------------------------------
      Il movimento è dato da un'asse brushless comandato
      in posizione, lo zero è sul livello del tavolo.
      Particolarmente importante è il valore dello spessore
      corrente del vetro, che determina la posizione di
      contatto.             __▄▄▄▄██▄▄▄▄__
                      Hrest↑             _↑
                           │_▒▒▒▒▒▒▒▒▒▒▒▒_↑Hglass
                           ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
      GANTRY
      ----------------------------------------------
      Tipicamente sulla spalla opposta c'è un motore gemello
      in asse elettrico.
      La forza è modulata solo dal lato del master, che quindi
      deve essere montato nella posizione lato operatore.

      PUSH AND POSITION
      ----------------------------------------------
      I premilastra sono nati con una attuazione pneumatica,
      quindi storicamente sono controllati con una pressione
      di spinta.
      L'uso dei premilastra motorizzati non deve cambiare
      questa interfaccia e deve mantenere gli stessi valori
      di magazzino materiale.
      È necessario quindi tradurre la spinta desiderata in
      una posizione relativa al vetro; questa potrebbe essere
      svolta assumendo una parte del premilastra deformabile e
      usando 'fnHpress', ma questa strada risulta difficilmente
      caratterizzabile.
      La strada scelta è impostare un limite di coppia del
      master (<=100% per evitare overloads) e spingere sul
      vetro.
      L'operazione di apertura con barra, in cui non si deve
      spingere ma portarsi in una certa posizione, assicurando
      un certo gioco, è più artificiosa: bisogna discriminare
      questa operazione dal valore di spinta (minore di una
      certa soglia).
*)
CASE Status OF
    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_PRESS : (* Pressing down *)
        (* Rispondi a abort o cambio comando *)
        IF CL_CMD<>CLCMD_PRESS THEN
            (* Ci può essere un errore di posizione accumulato, meglio resettarlo *)
            IF ABS(AX.CurrPosErr)>AX.InPosDelta THEN AX.Cmd:=AXC_RESET; END_IF; (* Resetto errore di posizione *)
            IF CL_CMD=CMD_STOP OR CL_CMD=CMD_PARK THEN
                (* Abortisco del tutto *)
                Htgt := SEL(CL_CMD=CMD_PARK, Hrest, AX.PosLim);
                MoveTo := MV_FREEMOVE;
                Status := CL_RISING;
            ELSE
                Status := STS_IDLE; (* Vai a gestire il nuovo comando *)
            END_IF;

        ELSIF ClampPush>=0 THEN
            (* Sto spingendo in limite di coppia *)
            AX.OutFrc := ClampPush; (* Respond to force limit change *)
            (* AX.TorqueMaxLim := vqPx_PressMaxTrq; (* [0.1%] Assicura di non superare mai un certo limite *)
            AX.TorqueMaxLim := LIMIT( TO_DINT(AX.kT * TO_LREAL(AX.OutFrc)), vqPx_PressMinTrq, vqPx_PressMaxTrq );

            (* Detect shortage of actual produced force (with tolerance) *)
            (* ABS(AX.CurrFrc)>=(ABS(AX.OutFrc)-100E3) OR ABS(AX.CurrTorque)>=(ABS(AX.TorqueMaxLim)-100)) *)
            (* La forza/coppia per spingere verso il basso è negativa: *)
            F_lim_reached( in:=(-AX.CurrFrc>=(AX.OutFrc-100E3) OR -AX.CurrTorque>=(AX.TorqueMaxLim-100)),
                           N:=100 ); (* Se perde la condizione per più di N scansioni *)
            IF NOT F_lim_reached.q AND
               AX.CurrPos>(AX.NegLim+200) THEN (* AX.InPosDelta  A meno che non abbia raggiunto limite software *)
                dlog( Txt:=CONCAT(THIS,': ! Press: %ld<%ld N (%ld<%ld%%)'), Lvl:=3, Val1:=AX.CurrFrc/1E3, Val2:=AX.OutFrc/1E3, Val3:=AX.CurrTorque/10, Val4:=AX.TorqueMaxLim/10 );
                IF ABS(AX.CurrPosErr)<vqClamps_Htol THEN
                    Htgt := AX.CurrPos - vqClamps_Htol; (* Premi più in basso *)
                    MoveTo := MV_TOOLMOVE;
                    Status := CL_SETTLE;
                ELSE
                    dlog( Txt:='!! PosErr: %ld um (h=%ld)', Lvl:=3, Val1:=AX.CurrPosErr, Val2:=AX.CurrPos/1E3 );
                END_IF;
            END_IF;

        ELSE (* Non devo più premere? *)
            CL_CMD := CMD_STOP;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_DOWN : (* In some position down *)
        (* Rispondi a cambio comando *)
        IF CL_CMD<>CmdBuf THEN
            (* Abort *)
            IF CL_CMD=CMD_STOP OR CL_CMD=CMD_PARK THEN
                IF ABS(AX.CurrPosErr)>AX.InPosDelta THEN AX.Cmd:=AXC_RESET; END_IF; (* Resetto errore di posizione? *)
                Htgt := SEL(CL_CMD=CMD_PARK, Hrest, AX.PosLim);
                MoveTo := MV_FREEMOVE;
                Status := CL_RISING;
            (* Want to press *)
            ELSIF CL_CMD=CLCMD_PRESS THEN
                dlog( Txt:=CONCAT(THIS,': Press %ld N (%ld mm)'), Lvl:=4, Val1:=ClampPush/1E3, Val2:=Hglass/1E3 );
                (* Vai alla posizione di inizio spinta *)
                IF ABS(AX.CurrPosErr)>AX.InPosDelta THEN AX.Cmd:=AXC_RESET; END_IF; (* Resetto errore di posizione? *)
                Htgt := Hglass + vqClamps_Htol; (* Posizione di inizio spinta *)
                MoveTo := MV_FREEMOVE;
                Status := CL_PULSEDOWN;
            (* Another positioning command *)
            ELSE
                Status := STS_IDLE; (* Vai a gestire il nuovo comando *)
            END_IF;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_SETTLE : (* Stabilizing press force *)
        (* Qui voglio raggiungere il limite di forza impostato,
           in genere non devo arrivare alla quota obiettivo *)
        AX.OutFrc := ClampPush;
        (* AX.TorqueMaxLim := vqPx_PressMaxTrq; (* [0.1%] Assicura di non superare mai un certo limite *)
        AX.TorqueMaxLim := LIMIT( TO_DINT(AX.kT * TO_LREAL(AX.OutFrc)), vqPx_PressMinTrq, vqPx_PressMaxTrq );

        (* Detect when pressing with the desired force *)
        (* ABS(AX.CurrFrc)>=ABS(AX.OutFrc) OR ABS(AX.CurrTorque)>=ABS(AX.TorqueMaxLim) *)
        (* La forza/coppia per spingere verso il basso è negativa: *)
        F_lim_reached( in:=-AX.CurrFrc>=AX.OutFrc OR -AX.CurrTorque>=AX.TorqueMaxLim,
                       N:=TO_INT(vqClamps_SettleTime/4) ); (* scan=4ms *)

        IF CL_CMD<>CLCMD_PRESS OR ClampPush<0 THEN
            (* Ci può essere un errore di posizione accumulato, meglio resettarlo *)
            IF ABS(AX.CurrPosErr)>AX.InPosDelta THEN AX.Cmd:=AXC_RESET; END_IF; (* Resetto errore di posizione *)
            (* Abortisco del tutto *)
            Htgt := SEL(CL_CMD=CMD_PARK, Hrest, AX.PosLim);
            MoveTo := MV_FREEMOVE;
            Status := CL_RISING;
        ELSIF F_lim_reached.q THEN (* AX.PosPhase>=AFS_POS_VCOST AND NOT AX.MovingBck *)
            dlog( Txt:=CONCAT(THIS,': Press: %ld>%ld N (%ld>%ld%%)'), Lvl:=3, Val1:=AX.CurrFrc/1E3, Val2:=AX.OutFrc/1E3, Val3:=AX.CurrTorque/10, Val4:=AX.TorqueMaxLim/10 );
            Status := CL_PRESS;
        ELSIF AX.CurrPos<(AX.NegLim+200) THEN (* AX.InPosDelta Anche quando raggiunto limite software *)
            (* In caso di rifilini piccoli accade di non raggiungere la coppia al limite sw, non ideale *)
            dlog( Txt:=CONCAT(THIS,': Press: !NegLim %ld/%ld N (%ld/%ld%%)'), Lvl:=3, Val1:=AX.CurrFrc/1E3, Val2:=AX.OutFrc/1E3, Val3:=AX.CurrTorque/10, Val4:=AX.TorqueMaxLim/10 );
            Status := CL_PRESS;
        ELSIF MoveTo<MV_WAITSTOP AND ABS(AX.CurrPosErr)<vqClamps_Htol AND ABS(AX.CurrSpd)<AX.MinLimSpeed THEN
            (* Non ho ancora saturato limite di coppia, devo andare oltre *)
            dlog( Txt:=CONCAT(THIS,': Settle: %ld N (%ld%%) h=%ld mm (err=%ld um)'), Lvl:=5, Val1:=AX.CurrFrc/1E3, Val2:=AX.CurrTorque/10, Val3:=AX.CurrPos/1E3, Val4:=AX.CurrPosErr );
            (* Nota: Ci pensa il servizio di movimentazione ad assicurare i limiti SW *)
            Htgt := AX.CurrPos - vqClamps_Htol;
            MoveTo := MV_TOOLMOVE;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_PULSEDOWN : (* Approaching glass at full speed *)
        IF MoveTo=MV_DONE THEN
            dlog( Txt:=CONCAT(THIS,': Cmd %d (%ld mm)'), Lvl:=5, Val1:=TO_DINT(CL_CMD), Val2:=AX.CurrPos/1E3 );
            IF CL_CMD=CLCMD_PRESS THEN
                (* Sono arrivato in prossimità del vetro,
                   Ora mi abbasso piano per premere andando in limite di coppia *)
                Htgt := Hglass - vqClamps_Htol;
                MoveTo := MV_TOOLMOVE;
                F_lim_reached(in:=FALSE, N:=0); (* Assicura di resettare *)
                Status := CL_SETTLE;
            ELSE
                (* Sono arrivato dove dovevo *)
                Status := CL_DOWN;
            END_IF;
        ELSIF MoveTo=MV_ERROR THEN
            Status := STS_ERROR;
        (* ELSE (* Wait move *)
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    CL_RISING : (* Going up to idle position *)
        IF MoveTo=MV_DONE THEN
            IF CL_CMD=CMD_PARK THEN CL_CMD:=CMD_STOP; END_IF;
            dlog( Txt:=CONCAT(THIS,': Up (%ld mm)'), Lvl:=5, Val1:=AX.CurrPos/1E3 );
            Status := STS_IDLE;
        ELSIF MoveTo=MV_ERROR THEN
            Status := STS_ERROR;
        (* ELSE (* Wait move *)
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    STS_IDLE : (* Premilastra non richiesto *)
        IF (CL_CMD=CLCMD_PRESS AND ClampPush>0) AND NOT Wait THEN
            (* Devo andare a spingere sul vetro in limite di coppia *)
            dlog( Txt:=CONCAT(THIS,': Press %ld N (%ld mm)'), Lvl:=4, Val1:=ClampPush/1E3, Val2:=Hglass/1E3 );
            Htgt := Hglass + vqClamps_Htol; (* Posizione di inizio spinta *)
            (* fnHpress(f:=ClampPush, Hr:=vqClamp*_Hr, Fc:=vqClamp*_Fc, Hc:=vqClamp*_Hc, exp:=2.5); *)
            MoveTo := MV_FREEMOVE;
            Status := CL_PULSEDOWN;
        ELSIF (CL_CMD=CLCMD_HOLD OR CL_CMD=CLCMD_OPPOSE OR CL_CMD=CLCMD_CLOSE OR CL_CMD=CMD_MOVETO) AND NOT Wait THEN
            CmdBuf := CL_CMD; (* Ricorda comando impartito *)
            (* Devo andare in una certa posizione sul vetro,
               seleziona quota in base a comando *)
            IF CL_CMD=CLCMD_OPPOSE THEN
                Htgt := Hglass + SEL(NoGlassOnRubber, vqClamps_DHbrk, vqClamps_DHbrk_more);
            ELSIF CL_CMD=CLCMD_HOLD THEN
                (* TODO 5: Anche qui sulla posizione dovrei controllare NoGlassOnRubber *)
                Htgt := Hglass + vqClamps_DHhold;
            ELSIF CL_CMD=CLCMD_CLOSE THEN
                (* Voglio solo chiudere il premilastra, ad es. per spingere il vetro con lo stacco *)
                Htgt := vqClamps_Htol;
            ELSE (* CL_CMD=CMD_MOVETO *)
                (* Htgt := ???; *) (* Movimento generico non supportato *)
                Status := STS_ERROR;
            END_IF;
            dlog( Txt:=CONCAT(THIS,': Cmd %d to %ld mm (h=%ld)'), Lvl:=4, Val1:=TO_DINT(CL_CMD), Val2:=Htgt/1E3, Val3:=Hglass/1E3 );
            MoveTo := MV_FREEMOVE;
            Status := CL_PULSEDOWN;
        ELSIF CL_CMD=CMD_PARK THEN
            (* Voglio alzare completamente il premilastra (es. per manutenzione).
               Se sono già lì, voglio andare in home *)
            Htgt := SEL(AX.CurrPos>(AX.PosLim-5E3), AX.PosLim, AX.HomePos);
            MoveTo := MV_FREEMOVE;
            Status := CL_RISING;
        ELSE (* Assicuro di essere alla posizione di riposo (con tolleranza per evitare continui aggiustamenti) *)
            Htgt := MIN(AX.PosLim, Hrest);
            (* IF ABS(AX.CurrPos-Htgt)>AX.InPosDelta THEN *)
            IF  AX.CurrPos<(Htgt-AX.InPosDelta) OR (* Troppo basso, devo salire *)
               (AX.CurrPos>(Htgt+AX.InPosDelta) AND StrictHrest ) THEN (* Troppo alto, devo scendere *)
                (* dlog( Txt:=CONCAT(THIS,': Adjusting to %ld), Lvl:=3, Val1:=Htgt/1E3 ); *)
                MoveTo := MV_FREEMOVE;
                Status := CL_RISING;
            END_IF;
        END_IF;

    (* - - - - - - - - - - - - - - - - - - - - - - - - - *)
    STS_ERROR : (* Errore sequenza *)
        (* Mi assicuro di salire! *)
        IF AX.Status=AXS_READY AND AX.Cmd<>AXC_RESET AND
           AX2.Locked AND ABS(AX2.Diff)<vqPx_GantryMaxErr THEN
            CL_CMD := CMD_STOP; (* Abort previous command *)
            Status := STS_IDLE;
        END_IF;

END_CASE; (* --- Up/down sequences *)


(* - Servizio di movimentazione - *)
IF Status<>STS_IDLE THEN
    CASE MoveTo OF

        MV_WAITMOVE : (* Attendi movimento verso quota obiettivo *)
            IF AX.Arrived THEN
                (* Ok, arrivato a destinazione *)
                dlog( Txt:=CONCAT(THIS,': Arrived at %ld mm'), Lvl:=6, Val1:=AX.TgtPos/1E3 );
                MoveTo := MV_DONE;
            ELSIF AX.Status<=AXS_READY THEN
                (* Situazione normale se sto premendo per saturare il limite di coppia *)
                dlog( Txt:=CONCAT(THIS,': ! Move to %ld not arrived (%ld mm)'), Lvl:=2, Val1:=AX.TgtPos/1E3, Val2:=AX.CurrPos/1E3 );
                MoveTo := MV_ERROR;
            (* Assicuro che il gantry stia inseguendo! *)
            ELSIF NOT AX2.Locked OR ABS(AX2.Diff)>vqPx_GantryMaxErr THEN
                dlog( Txt:=CONCAT(THIS,': !! Gantry diff %ld mm'), Lvl:=2, Val1:=AX2.Diff/1E3 );
                AX.Cmd := AXC_STOP_ENAB;
                MoveTo := MV_WAITSTOP;
            (* Non abortire la salita o il riposizionamento *)
            ELSIF CL_CMD=CMD_STOP AND Status>CL_RISING THEN
                dlog( Txt:=CONCAT(THIS,': ! MoveTo aborted'), Lvl:=2 );
                AX.Cmd := AXC_STOP_ENAB;
                MoveTo := MV_WAITSTOP;
            END_IF;


        MV_WAITSTOP : (* Attendi stop asse *)
            IF AX.Status<=AXS_READY THEN
                MoveTo := MV_ERROR; (* Comunque non sono arrivato *)
            END_IF;


        MV_FREEMOVE,  (* Prepara spostamento libero *)
        MV_TOOLMOVE : (* Prepara movimentino per premere *)
            (* Detect null movement *)
            IF MoveTo=MV_FREEMOVE AND ABS(AX.CurrPos-Htgt)<=AX.InPosDelta THEN
                dlog( Txt:=CONCAT(THIS,': Already at %ld mm (inpos=%ld um)'), Lvl:=5, Val1:=AX.CurrPos/1E3, Val2:=AX.InPosDelta );
                MoveTo := MV_DONE;
            (* Detect move (descend) abort *)
            ELSIF CL_CMD=CMD_STOP AND AX.MovingBck THEN (* Solo la discesa può abortire *)
                dlog( Txt:=CONCAT(THIS,': !! Move aborted'), Lvl:=1 );
                MoveTo := MV_ERROR;
            (* Attesa precondizione: Asse master pronto *)
            ELSIF AX.Status<>AXS_READY OR AX.Cmd=AXC_RESET THEN
                ENSURE_MSG(MSG_CLAMPS_NOTREADY,'MSG_CLAMPS_NOTREADY (master)',0); (* Notifica attesa *)
            (* Attesa precondizione: Gantry pronto ed allineato *)
            ELSIF NOT AX2.Locked OR ABS(AX2.Diff)>vqPx_GantryMaxErr THEN
                ENSURE_MSG(MSG_CLAMPS_NOTREADY,'MSG_CLAMPS_NOTREADY (gantry)',0); (* Notifica attesa *)
            ELSE
                RST_MSG_IF_ON(MSG_CLAMPS_NOTREADY);
                dlog( Txt:=CONCAT(THIS,': Move from %ld to %ld mm'), Lvl:=5, Val1:=AX.CurrPos/1E3, Val2:=Htgt/1E3);

                (* Gli argomenti del posizionamento: *)
                IF MoveTo=MV_FREEMOVE THEN
                    (* Spostamento libero *)
                    AX.TgtSpd := 100; (* [%] *)
                    AX.AccPerc := 100; (* [%] *)
                    AX.DecPerc := 100; (* [%] *)
                    AX.OutFrc := SEL(Htgt>AX.CurrPos, 0, Weight); (* Asse verticale *)
                    AX.TorqueMinLim := 500; (* [0.1%] Limite coppia minimo - La gestione normale del limite ha dei problemi! *)
                    AX.TorqueMaxLim := AX.MaxTorque; (* [0.1%] Limite coppia massimo *)
                    VQ_AX(iVQ_AX_MONITOR_3,AX2.Idx) := AX2.MaxTorque; (* Lo slave deve seguirmi al massimo *)
                    AX.MaxPosErr := WTR_HITDET;
                ELSE
                    (* Movimentino per premere *)
                    AX.TgtSpd := 20; (* [%] *)
                    AX.AccPerc := 100; (* [%] *)
                    AX.DecPerc := 100; (* [%] *)
                    AX.OutFrc := ClampPush; (* [mN] -Weight? *)
                    AX.TorqueMinLim := vqPx_PressMinTrq; (* [0.1%] Limite coppia minimo *)
                    AX.TorqueMaxLim := vqPx_PressMaxTrq; (* [0.1%] Limite coppia massimo *)
                    VQ_AX(iVQ_AX_MONITOR_3,AX2.Idx) := 1000; (* [0.1%] Assicura che lo slave non vada in overload *)
                    AX.MaxPosErr := WTR_DISABLE;
                END_IF;

                (* Forzo silenziosamente la quota obiettivo entro i limiti sw *)
                Htgt := LIMIT(Htgt, AX.NegLim, AX.PosLim);
                AX.TgtPos := Htgt; (* [um] *)
                AX.Cmd := AXC_START_POS;
                MoveTo := MV_WAITMOVE;

            END_IF; (* Posso muovere *)
    END_CASE; (* -- Servizio movimentazione *)
END_IF; (* -- Sequenza in corso *)

AtRest := Status=STS_IDLE AND CL_CMD=CMD_STOP AND AX.CurrPos>=(Hrest-AX.InPosDelta); (* Tolleranza *)

END_MACRO




	(*******************)
	(*                 *)
	(*     STRUCTS     *)
	(*                 *)
	(*******************)


TYPE

	ST_BELTSCMD : STRUCT { DE:"Belts command" }
		Activate : BOOL; { DE:"Activation command" }
		Target : DINT; { DE:"Target position - incremental [um]" }
		MaxSpeed : DINT; { DE:"Movement max speed [um/min]" }
		Accel : INT; { DE:"Acceleration [%]" }
		Follow : INT; { DE:"Follow Master" }
	END_STRUCT;


END_TYPE



	(********************)
	(*                  *)
	(*     TYPEDEFS     *)
	(*                  *)
	(********************)


TYPE

	VASTR : STRING[ 80 ]; { DE:"Sipro string (va)" }

END_TYPE



	(*****************)
	(*               *)
	(*     ENUMS     *)
	(*               *)
	(*****************)


TYPE


	EN_AXIS_MV_CMD: (
		{ DE:"Enum for MoveTo axis movements local service" }
		MV_ERROR := -1, { DE:"Mov Svc: errore" }
		MV_DONE := 0, { DE:"Mov Svc: movim completato" }
		MV_WAITSTOP := 1, { DE:"Mov Svc: attendi stop asse" }
		MV_FREEMOVE := 2, { DE:"Mov Svc: prepara mov libero" }
		MV_TOOLMOVE := 3, { DE:"Mov Svc: prepara mov con utensile" }
		MV_LOCKMOVE := 4, { DE:"Mov Svc: prepara agganciamento" }
		MV_LOCKED := 5, { DE:"Mov Svc: stato agganciato" }
		MV_SUSPENDED := 6, { DE:"Mov Svc: movimento sospeso" }
		MV_WAITMOVE := 7 { DE:"Mov Svc: attendi movim" }
	);

	EN_OUTZONE_CMD: (
		{ DE:"Enum for fbOutZone.NewPiece commands" }
		OZ_NONE := 0, { DE:"No command" }
		OZ_NOTIFY := 1, { DE:"Just notify that a piece is going to be delivered" }
		OZ_UPDATE := 2, { DE:"A piece released somewhere, just update the busy zone" }
		OZ_TAKE := 3 { DE:"Take care of the delivered piece" }
	);

END_TYPE
